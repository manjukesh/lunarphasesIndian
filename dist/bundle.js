/*! For license information please see bundle.js.LICENSE.txt */
(() => {
    var t = {
            187: t => {
                "use strict";

                function e(t, e, o) {
                    o = o || 2;
                    var s, a, l, c, d, f, m, g = e && e.length,
                        v = g ? e[0] * o : t.length,
                        _ = n(t, 0, v, o, !0),
                        y = [];
                    if (!_ || _.next === _.prev) return y;
                    if (g && (_ = function(t, e, i, o) {
                            var s, a, l, c = [];
                            for (s = 0, a = e.length; s < a; s++)(l = n(t, e[s] * o, s < a - 1 ? e[s + 1] * o : t.length, o, !1)) === l.next && (l.steiner = !0), c.push(p(l));
                            for (c.sort(u), s = 0; s < c.length; s++) i = r(i = h(c[s], i), i.next);
                            return i
                        }(t, e, _, o)), t.length > 80 * o) {
                        s = l = t[0], a = c = t[1];
                        for (var x = o; x < v; x += o)(d = t[x]) < s && (s = d), (f = t[x + 1]) < a && (a = f), d > l && (l = d), f > c && (c = f);
                        m = 0 !== (m = Math.max(l - s, c - a)) ? 1 / m : 0
                    }
                    return i(_, y, o, s, a, m), y
                }

                function n(t, e, n, r, i) {
                    var o, s;
                    if (i === M(t, e, n, r) > 0)
                        for (o = e; o < n; o += r) s = T(o, t[o], t[o + 1], s);
                    else
                        for (o = n - r; o >= e; o -= r) s = T(o, t[o], t[o + 1], s);
                    return s && v(s, s.next) && (S(s), s = s.next), s
                }

                function r(t, e) {
                    if (!t) return t;
                    e || (e = t);
                    var n, r = t;
                    do {
                        if (n = !1, r.steiner || !v(r, r.next) && 0 !== g(r.prev, r, r.next)) r = r.next;
                        else {
                            if (S(r), (r = e = r.prev) === r.next) break;
                            n = !0
                        }
                    } while (n || r !== e);
                    return e
                }

                function i(t, e, n, u, h, c, p) {
                    if (t) {
                        !p && c && function(t, e, n, r) {
                            var i = t;
                            do {
                                null === i.z && (i.z = d(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next
                            } while (i !== t);
                            i.prevZ.nextZ = null, i.prevZ = null,
                                function(t) {
                                    var e, n, r, i, o, s, a, l, u = 1;
                                    do {
                                        for (n = t, t = null, o = null, s = 0; n;) {
                                            for (s++, r = n, a = 0, e = 0; e < u && (a++, r = r.nextZ); e++);
                                            for (l = u; a > 0 || l > 0 && r;) 0 !== a && (0 === l || !r || n.z <= r.z) ? (i = n, n = n.nextZ, a--) : (i = r, r = r.nextZ, l--), o ? o.nextZ = i : t = i, i.prevZ = o, o = i;
                                            n = r
                                        }
                                        o.nextZ = null, u *= 2
                                    } while (s > 1)
                                }(i)
                        }(t, u, h, c);
                        for (var f, m, g = t; t.prev !== t.next;)
                            if (f = t.prev, m = t.next, c ? s(t, u, h, c) : o(t)) e.push(f.i / n), e.push(t.i / n), e.push(m.i / n), S(t), t = m.next, g = m.next;
                            else if ((t = m) === g) {
                            p ? 1 === p ? i(t = a(r(t), e, n), e, n, u, h, c, 2) : 2 === p && l(t, e, n, u, h, c) : i(r(t), e, n, u, h, c, 1);
                            break
                        }
                    }
                }

                function o(t) {
                    var e = t.prev,
                        n = t,
                        r = t.next;
                    if (g(e, n, r) >= 0) return !1;
                    for (var i = t.next.next; i !== t.prev;) {
                        if (f(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) && g(i.prev, i, i.next) >= 0) return !1;
                        i = i.next
                    }
                    return !0
                }

                function s(t, e, n, r) {
                    var i = t.prev,
                        o = t,
                        s = t.next;
                    if (g(i, o, s) >= 0) return !1;
                    for (var a = i.x < o.x ? i.x < s.x ? i.x : s.x : o.x < s.x ? o.x : s.x, l = i.y < o.y ? i.y < s.y ? i.y : s.y : o.y < s.y ? o.y : s.y, u = i.x > o.x ? i.x > s.x ? i.x : s.x : o.x > s.x ? o.x : s.x, h = i.y > o.y ? i.y > s.y ? i.y : s.y : o.y > s.y ? o.y : s.y, c = d(a, l, e, n, r), p = d(u, h, e, n, r), m = t.prevZ, v = t.nextZ; m && m.z >= c && v && v.z <= p;) {
                        if (m !== t.prev && m !== t.next && f(i.x, i.y, o.x, o.y, s.x, s.y, m.x, m.y) && g(m.prev, m, m.next) >= 0) return !1;
                        if (m = m.prevZ, v !== t.prev && v !== t.next && f(i.x, i.y, o.x, o.y, s.x, s.y, v.x, v.y) && g(v.prev, v, v.next) >= 0) return !1;
                        v = v.nextZ
                    }
                    for (; m && m.z >= c;) {
                        if (m !== t.prev && m !== t.next && f(i.x, i.y, o.x, o.y, s.x, s.y, m.x, m.y) && g(m.prev, m, m.next) >= 0) return !1;
                        m = m.prevZ
                    }
                    for (; v && v.z <= p;) {
                        if (v !== t.prev && v !== t.next && f(i.x, i.y, o.x, o.y, s.x, s.y, v.x, v.y) && g(v.prev, v, v.next) >= 0) return !1;
                        v = v.nextZ
                    }
                    return !0
                }

                function a(t, e, n) {
                    var i = t;
                    do {
                        var o = i.prev,
                            s = i.next.next;
                        !v(o, s) && _(o, i, i.next, s) && b(o, s) && b(s, o) && (e.push(o.i / n), e.push(i.i / n), e.push(s.i / n), S(i), S(i.next), i = t = s), i = i.next
                    } while (i !== t);
                    return r(i)
                }

                function l(t, e, n, o, s, a) {
                    var l = t;
                    do {
                        for (var u = l.next.next; u !== l.prev;) {
                            if (l.i !== u.i && m(l, u)) {
                                var h = E(l, u);
                                return l = r(l, l.next), h = r(h, h.next), i(l, e, n, o, s, a), void i(h, e, n, o, s, a)
                            }
                            u = u.next
                        }
                        l = l.next
                    } while (l !== t)
                }

                function u(t, e) {
                    return t.x - e.x
                }

                function h(t, e) {
                    var n = function(t, e) {
                        var n, r = e,
                            i = t.x,
                            o = t.y,
                            s = -1 / 0;
                        do {
                            if (o <= r.y && o >= r.next.y && r.next.y !== r.y) {
                                var a = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                                if (a <= i && a > s) {
                                    if (s = a, a === i) {
                                        if (o === r.y) return r;
                                        if (o === r.next.y) return r.next
                                    }
                                    n = r.x < r.next.x ? r : r.next
                                }
                            }
                            r = r.next
                        } while (r !== e);
                        if (!n) return null;
                        if (i === s) return n;
                        var l, u = n,
                            h = n.x,
                            d = n.y,
                            p = 1 / 0;
                        r = n;
                        do {
                            i >= r.x && r.x >= h && i !== r.x && f(o < d ? i : s, o, h, d, o < d ? s : i, o, r.x, r.y) && (l = Math.abs(o - r.y) / (i - r.x), b(r, t) && (l < p || l === p && (r.x > n.x || r.x === n.x && c(n, r))) && (n = r, p = l)), r = r.next
                        } while (r !== u);
                        return n
                    }(t, e);
                    if (!n) return e;
                    var i = E(n, t),
                        o = r(n, n.next);
                    return r(i, i.next), e === n ? o : e
                }

                function c(t, e) {
                    return g(t.prev, t, e.prev) < 0 && g(e.next, t, t.next) < 0
                }

                function d(t, e, n, r, i) {
                    return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
                }

                function p(t) {
                    var e = t,
                        n = t;
                    do {
                        (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
                    } while (e !== t);
                    return n
                }

                function f(t, e, n, r, i, o, s, a) {
                    return (i - s) * (e - a) - (t - s) * (o - a) >= 0 && (t - s) * (r - a) - (n - s) * (e - a) >= 0 && (n - s) * (o - a) - (i - s) * (r - a) >= 0
                }

                function m(t, e) {
                    return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                        var n = t;
                        do {
                            if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && _(n, n.next, t, e)) return !0;
                            n = n.next
                        } while (n !== t);
                        return !1
                    }(t, e) && (b(t, e) && b(e, t) && function(t, e) {
                        var n = t,
                            r = !1,
                            i = (t.x + e.x) / 2,
                            o = (t.y + e.y) / 2;
                        do {
                            n.y > o != n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next
                        } while (n !== t);
                        return r
                    }(t, e) && (g(t.prev, t, e.prev) || g(t, e.prev, e)) || v(t, e) && g(t.prev, t, t.next) > 0 && g(e.prev, e, e.next) > 0)
                }

                function g(t, e, n) {
                    return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
                }

                function v(t, e) {
                    return t.x === e.x && t.y === e.y
                }

                function _(t, e, n, r) {
                    var i = x(g(t, e, n)),
                        o = x(g(t, e, r)),
                        s = x(g(n, r, t)),
                        a = x(g(n, r, e));
                    return i !== o && s !== a || !(0 !== i || !y(t, n, e)) || !(0 !== o || !y(t, r, e)) || !(0 !== s || !y(n, t, r)) || !(0 !== a || !y(n, e, r))
                }

                function y(t, e, n) {
                    return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
                }

                function x(t) {
                    return t > 0 ? 1 : t < 0 ? -1 : 0
                }

                function b(t, e) {
                    return g(t.prev, t, t.next) < 0 ? g(t, e, t.next) >= 0 && g(t, t.prev, e) >= 0 : g(t, e, t.prev) < 0 || g(t, t.next, e) < 0
                }

                function E(t, e) {
                    var n = new w(t.i, t.x, t.y),
                        r = new w(e.i, e.x, e.y),
                        i = t.next,
                        o = e.prev;
                    return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r
                }

                function T(t, e, n, r) {
                    var i = new w(t, e, n);
                    return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
                }

                function S(t) {
                    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
                }

                function w(t, e, n) {
                    this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
                }

                function M(t, e, n, r) {
                    for (var i = 0, o = e, s = n - r; o < n; o += r) i += (t[s] - t[o]) * (t[o + 1] + t[s + 1]), s = o;
                    return i
                }
                t.exports = e, t.exports.default = e, e.deviation = function(t, e, n, r) {
                    var i = e && e.length,
                        o = i ? e[0] * n : t.length,
                        s = Math.abs(M(t, 0, o, n));
                    if (i)
                        for (var a = 0, l = e.length; a < l; a++) {
                            var u = e[a] * n,
                                h = a < l - 1 ? e[a + 1] * n : t.length;
                            s -= Math.abs(M(t, u, h, n))
                        }
                    var c = 0;
                    for (a = 0; a < r.length; a += 3) {
                        var d = r[a] * n,
                            p = r[a + 1] * n,
                            f = r[a + 2] * n;
                        c += Math.abs((t[d] - t[f]) * (t[p + 1] - t[d + 1]) - (t[d] - t[p]) * (t[f + 1] - t[d + 1]))
                    }
                    return 0 === s && 0 === c ? 0 : Math.abs((c - s) / s)
                }, e.flatten = function(t) {
                    for (var e = t[0][0].length, n = {
                            vertices: [],
                            holes: [],
                            dimensions: e
                        }, r = 0, i = 0; i < t.length; i++) {
                        for (var o = 0; o < t[i].length; o++)
                            for (var s = 0; s < e; s++) n.vertices.push(t[i][o][s]);
                        i > 0 && (r += t[i - 1].length, n.holes.push(r))
                    }
                    return n
                }
            },
            729: t => {
                "use strict";
                var e = Object.prototype.hasOwnProperty,
                    n = "~";

                function r() {}

                function i(t, e, n) {
                    this.fn = t, this.context = e, this.once = n || !1
                }

                function o(t, e, r, o, s) {
                    if ("function" != typeof r) throw new TypeError("The listener must be a function");
                    var a = new i(r, o || t, s),
                        l = n ? n + e : e;
                    return t._events[l] ? t._events[l].fn ? t._events[l] = [t._events[l], a] : t._events[l].push(a) : (t._events[l] = a, t._eventsCount++), t
                }

                function s(t, e) {
                    0 == --t._eventsCount ? t._events = new r : delete t._events[e]
                }

                function a() {
                    this._events = new r, this._eventsCount = 0
                }
                Object.create && (r.prototype = Object.create(null), (new r).__proto__ || (n = !1)), a.prototype.eventNames = function() {
                    var t, r, i = [];
                    if (0 === this._eventsCount) return i;
                    for (r in t = this._events) e.call(t, r) && i.push(n ? r.slice(1) : r);
                    return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(t)) : i
                }, a.prototype.listeners = function(t) {
                    var e = n ? n + t : t,
                        r = this._events[e];
                    if (!r) return [];
                    if (r.fn) return [r.fn];
                    for (var i = 0, o = r.length, s = new Array(o); i < o; i++) s[i] = r[i].fn;
                    return s
                }, a.prototype.listenerCount = function(t) {
                    var e = n ? n + t : t,
                        r = this._events[e];
                    return r ? r.fn ? 1 : r.length : 0
                }, a.prototype.emit = function(t, e, r, i, o, s) {
                    var a = n ? n + t : t;
                    if (!this._events[a]) return !1;
                    var l, u, h = this._events[a],
                        c = arguments.length;
                    if (h.fn) {
                        switch (h.once && this.removeListener(t, h.fn, void 0, !0), c) {
                            case 1:
                                return h.fn.call(h.context), !0;
                            case 2:
                                return h.fn.call(h.context, e), !0;
                            case 3:
                                return h.fn.call(h.context, e, r), !0;
                            case 4:
                                return h.fn.call(h.context, e, r, i), !0;
                            case 5:
                                return h.fn.call(h.context, e, r, i, o), !0;
                            case 6:
                                return h.fn.call(h.context, e, r, i, o, s), !0
                        }
                        for (u = 1, l = new Array(c - 1); u < c; u++) l[u - 1] = arguments[u];
                        h.fn.apply(h.context, l)
                    } else {
                        var d, p = h.length;
                        for (u = 0; u < p; u++) switch (h[u].once && this.removeListener(t, h[u].fn, void 0, !0), c) {
                            case 1:
                                h[u].fn.call(h[u].context);
                                break;
                            case 2:
                                h[u].fn.call(h[u].context, e);
                                break;
                            case 3:
                                h[u].fn.call(h[u].context, e, r);
                                break;
                            case 4:
                                h[u].fn.call(h[u].context, e, r, i);
                                break;
                            default:
                                if (!l)
                                    for (d = 1, l = new Array(c - 1); d < c; d++) l[d - 1] = arguments[d];
                                h[u].fn.apply(h[u].context, l)
                        }
                    }
                    return !0
                }, a.prototype.on = function(t, e, n) {
                    return o(this, t, e, n, !1)
                }, a.prototype.once = function(t, e, n) {
                    return o(this, t, e, n, !0)
                }, a.prototype.removeListener = function(t, e, r, i) {
                    var o = n ? n + t : t;
                    if (!this._events[o]) return this;
                    if (!e) return s(this, o), this;
                    var a = this._events[o];
                    if (a.fn) a.fn !== e || i && !a.once || r && a.context !== r || s(this, o);
                    else {
                        for (var l = 0, u = [], h = a.length; l < h; l++)(a[l].fn !== e || i && !a[l].once || r && a[l].context !== r) && u.push(a[l]);
                        u.length ? this._events[o] = 1 === u.length ? u[0] : u : s(this, o)
                    }
                    return this
                }, a.prototype.removeAllListeners = function(t) {
                    var e;
                    return t ? (e = n ? n + t : t, this._events[e] && s(this, e)) : (this._events = new r, this._eventsCount = 0), this
                }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = n, a.EventEmitter = a, t.exports = a
            },
            418: t => {
                "use strict";
                var e = Object.getOwnPropertySymbols,
                    n = Object.prototype.hasOwnProperty,
                    r = Object.prototype.propertyIsEnumerable;

                function i(t) {
                    if (null == t) throw new TypeError("Object.assign cannot be called with null or undefined");
                    return Object(t)
                }
                t.exports = function() {
                    try {
                        if (!Object.assign) return !1;
                        var t = new String("abc");
                        if (t[5] = "de", "5" === Object.getOwnPropertyNames(t)[0]) return !1;
                        for (var e = {}, n = 0; n < 10; n++) e["_" + String.fromCharCode(n)] = n;
                        if ("0123456789" !== Object.getOwnPropertyNames(e).map((function(t) {
                                return e[t]
                            })).join("")) return !1;
                        var r = {};
                        return "abcdefghijklmnopqrst".split("").forEach((function(t) {
                            r[t] = t
                        })), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, r)).join("")
                    } catch (t) {
                        return !1
                    }
                }() ? Object.assign : function(t, o) {
                    for (var s, a, l = i(t), u = 1; u < arguments.length; u++) {
                        for (var h in s = Object(arguments[u])) n.call(s, h) && (l[h] = s[h]);
                        if (e) {
                            a = e(s);
                            for (var c = 0; c < a.length; c++) r.call(s, a[c]) && (l[a[c]] = s[a[c]])
                        }
                    }
                    return l
                }
            },
            703: (t, e, n) => {
                "use strict";
                var r = n(414);

                function i() {}

                function o() {}
                o.resetWarningCache = i, t.exports = function() {
                    function t(t, e, n, i, o, s) {
                        if (s !== r) {
                            var a = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                            throw a.name = "Invariant Violation", a
                        }
                    }

                    function e() {
                        return t
                    }
                    t.isRequired = t;
                    var n = {
                        array: t,
                        bigint: t,
                        bool: t,
                        func: t,
                        number: t,
                        object: t,
                        string: t,
                        symbol: t,
                        any: t,
                        arrayOf: e,
                        element: t,
                        elementType: t,
                        instanceOf: e,
                        node: t,
                        objectOf: e,
                        oneOf: e,
                        oneOfType: e,
                        shape: e,
                        exact: e,
                        checkPropTypes: o,
                        resetWarningCache: i
                    };
                    return n.PropTypes = n, n
                }
            },
            697: (t, e, n) => {
                t.exports = n(703)()
            },
            414: t => {
                "use strict";
                t.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
            },
            587: t => {
                "use strict";

                function e(t, e) {
                    return Object.prototype.hasOwnProperty.call(t, e)
                }
                t.exports = function(t, n, r, i) {
                    n = n || "&", r = r || "=";
                    var o = {};
                    if ("string" != typeof t || 0 === t.length) return o;
                    var s = /\+/g;
                    t = t.split(n);
                    var a = 1e3;
                    i && "number" == typeof i.maxKeys && (a = i.maxKeys);
                    var l = t.length;
                    a > 0 && l > a && (l = a);
                    for (var u = 0; u < l; ++u) {
                        var h, c, d, p, f = t[u].replace(s, "%20"),
                            m = f.indexOf(r);
                        m >= 0 ? (h = f.substr(0, m), c = f.substr(m + 1)) : (h = f, c = ""), d = decodeURIComponent(h), p = decodeURIComponent(c), e(o, d) ? Array.isArray(o[d]) ? o[d].push(p) : o[d] = [o[d], p] : o[d] = p
                    }
                    return o
                }
            },
            361: t => {
                "use strict";
                var e = function(t) {
                    switch (typeof t) {
                        case "string":
                            return t;
                        case "boolean":
                            return t ? "true" : "false";
                        case "number":
                            return isFinite(t) ? t : "";
                        default:
                            return ""
                    }
                };
                t.exports = function(t, n, r, i) {
                    return n = n || "&", r = r || "=", null === t && (t = void 0), "object" == typeof t ? Object.keys(t).map((function(i) {
                        var o = encodeURIComponent(e(i)) + r;
                        return Array.isArray(t[i]) ? t[i].map((function(t) {
                            return o + encodeURIComponent(e(t))
                        })).join(n) : o + encodeURIComponent(e(t[i]))
                    })).join(n) : i ? encodeURIComponent(e(i)) + r + encodeURIComponent(e(t)) : ""
                }
            },
            673: (t, e, n) => {
                "use strict";
                e.decode = e.parse = n(587), e.encode = e.stringify = n(361)
            },
            448: (t, e, n) => {
                "use strict";
                var r = n(294),
                    i = n(418),
                    o = n(840);

                function s(t) {
                    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++) e += "&args[]=" + encodeURIComponent(arguments[n]);
                    return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
                }
                if (!r) throw Error(s(227));
                var a = new Set,
                    l = {};

                function u(t, e) {
                    h(t, e), h(t + "Capture", e)
                }

                function h(t, e) {
                    for (l[t] = e, t = 0; t < e.length; t++) a.add(e[t])
                }
                var c = !("undefined" == typeof window || void 0 === window.document || void 0 === window.document.createElement),
                    d = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
                    p = Object.prototype.hasOwnProperty,
                    f = {},
                    m = {};

                function g(t, e, n, r, i, o, s) {
                    this.acceptsBooleans = 2 === e || 3 === e || 4 === e, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = t, this.type = e, this.sanitizeURL = o, this.removeEmptyString = s
                }
                var v = {};
                "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(t) {
                    v[t] = new g(t, 0, !1, t, null, !1, !1)
                })), [
                    ["acceptCharset", "accept-charset"],
                    ["className", "class"],
                    ["htmlFor", "for"],
                    ["httpEquiv", "http-equiv"]
                ].forEach((function(t) {
                    var e = t[0];
                    v[e] = new g(e, 1, !1, t[1], null, !1, !1)
                })), ["contentEditable", "draggable", "spellCheck", "value"].forEach((function(t) {
                    v[t] = new g(t, 2, !1, t.toLowerCase(), null, !1, !1)
                })), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach((function(t) {
                    v[t] = new g(t, 2, !1, t, null, !1, !1)
                })), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(t) {
                    v[t] = new g(t, 3, !1, t.toLowerCase(), null, !1, !1)
                })), ["checked", "multiple", "muted", "selected"].forEach((function(t) {
                    v[t] = new g(t, 3, !0, t, null, !1, !1)
                })), ["capture", "download"].forEach((function(t) {
                    v[t] = new g(t, 4, !1, t, null, !1, !1)
                })), ["cols", "rows", "size", "span"].forEach((function(t) {
                    v[t] = new g(t, 6, !1, t, null, !1, !1)
                })), ["rowSpan", "start"].forEach((function(t) {
                    v[t] = new g(t, 5, !1, t.toLowerCase(), null, !1, !1)
                }));
                var _ = /[\-:]([a-z])/g;

                function y(t) {
                    return t[1].toUpperCase()
                }

                function x(t, e, n, r) {
                    var i = v.hasOwnProperty(e) ? v[e] : null;
                    (null !== i ? 0 === i.type : !r && 2 < e.length && ("o" === e[0] || "O" === e[0]) && ("n" === e[1] || "N" === e[1])) || (function(t, e, n, r) {
                        if (null == e || function(t, e, n, r) {
                                if (null !== n && 0 === n.type) return !1;
                                switch (typeof e) {
                                    case "function":
                                    case "symbol":
                                        return !0;
                                    case "boolean":
                                        return !r && (null !== n ? !n.acceptsBooleans : "data-" !== (t = t.toLowerCase().slice(0, 5)) && "aria-" !== t);
                                    default:
                                        return !1
                                }
                            }(t, e, n, r)) return !0;
                        if (r) return !1;
                        if (null !== n) switch (n.type) {
                            case 3:
                                return !e;
                            case 4:
                                return !1 === e;
                            case 5:
                                return isNaN(e);
                            case 6:
                                return isNaN(e) || 1 > e
                        }
                        return !1
                    }(e, n, i, r) && (n = null), r || null === i ? function(t) {
                        return !!p.call(m, t) || !p.call(f, t) && (d.test(t) ? m[t] = !0 : (f[t] = !0, !1))
                    }(e) && (null === n ? t.removeAttribute(e) : t.setAttribute(e, "" + n)) : i.mustUseProperty ? t[i.propertyName] = null === n ? 3 !== i.type && "" : n : (e = i.attributeName, r = i.attributeNamespace, null === n ? t.removeAttribute(e) : (n = 3 === (i = i.type) || 4 === i && !0 === n ? "" : "" + n, r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n))))
                }
                "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(t) {
                    var e = t.replace(_, y);
                    v[e] = new g(e, 1, !1, t, null, !1, !1)
                })), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(t) {
                    var e = t.replace(_, y);
                    v[e] = new g(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1)
                })), ["xml:base", "xml:lang", "xml:space"].forEach((function(t) {
                    var e = t.replace(_, y);
                    v[e] = new g(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1)
                })), ["tabIndex", "crossOrigin"].forEach((function(t) {
                    v[t] = new g(t, 1, !1, t.toLowerCase(), null, !1, !1)
                })), v.xlinkHref = new g("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach((function(t) {
                    v[t] = new g(t, 1, !1, t.toLowerCase(), null, !0, !0)
                }));
                var b = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
                    E = 60103,
                    T = 60106,
                    S = 60107,
                    w = 60108,
                    M = 60114,
                    A = 60109,
                    R = 60110,
                    P = 60112,
                    I = 60113,
                    C = 60120,
                    O = 60115,
                    L = 60116,
                    N = 60121,
                    D = 60128,
                    U = 60129,
                    F = 60130,
                    B = 60131;
                if ("function" == typeof Symbol && Symbol.for) {
                    var k = Symbol.for;
                    E = k("react.element"), T = k("react.portal"), S = k("react.fragment"), w = k("react.strict_mode"), M = k("react.profiler"), A = k("react.provider"), R = k("react.context"), P = k("react.forward_ref"), I = k("react.suspense"), C = k("react.suspense_list"), O = k("react.memo"), L = k("react.lazy"), N = k("react.block"), k("react.scope"), D = k("react.opaque.id"), U = k("react.debug_trace_mode"), F = k("react.offscreen"), B = k("react.legacy_hidden")
                }
                var G, H = "function" == typeof Symbol && Symbol.iterator;

                function z(t) {
                    return null === t || "object" != typeof t ? null : "function" == typeof(t = H && t[H] || t["@@iterator"]) ? t : null
                }

                function V(t) {
                    if (void 0 === G) try {
                        throw Error()
                    } catch (t) {
                        var e = t.stack.trim().match(/\n( *(at )?)/);
                        G = e && e[1] || ""
                    }
                    return "\n" + G + t
                }
                var W = !1;

                function X(t, e) {
                    if (!t || W) return "";
                    W = !0;
                    var n = Error.prepareStackTrace;
                    Error.prepareStackTrace = void 0;
                    try {
                        if (e)
                            if (e = function() {
                                    throw Error()
                                }, Object.defineProperty(e.prototype, "props", {
                                    set: function() {
                                        throw Error()
                                    }
                                }), "object" == typeof Reflect && Reflect.construct) {
                                try {
                                    Reflect.construct(e, [])
                                } catch (t) {
                                    var r = t
                                }
                                Reflect.construct(t, [], e)
                            } else {
                                try {
                                    e.call()
                                } catch (t) {
                                    r = t
                                }
                                t.call(e.prototype)
                            }
                        else {
                            try {
                                throw Error()
                            } catch (t) {
                                r = t
                            }
                            t()
                        }
                    } catch (t) {
                        if (t && r && "string" == typeof t.stack) {
                            for (var i = t.stack.split("\n"), o = r.stack.split("\n"), s = i.length - 1, a = o.length - 1; 1 <= s && 0 <= a && i[s] !== o[a];) a--;
                            for (; 1 <= s && 0 <= a; s--, a--)
                                if (i[s] !== o[a]) {
                                    if (1 !== s || 1 !== a)
                                        do {
                                            if (s--, 0 > --a || i[s] !== o[a]) return "\n" + i[s].replace(" at new ", " at ")
                                        } while (1 <= s && 0 <= a);
                                    break
                                }
                        }
                    } finally {
                        W = !1, Error.prepareStackTrace = n
                    }
                    return (t = t ? t.displayName || t.name : "") ? V(t) : ""
                }

                function j(t) {
                    switch (t.tag) {
                        case 5:
                            return V(t.type);
                        case 16:
                            return V("Lazy");
                        case 13:
                            return V("Suspense");
                        case 19:
                            return V("SuspenseList");
                        case 0:
                        case 2:
                        case 15:
                            return X(t.type, !1);
                        case 11:
                            return X(t.type.render, !1);
                        case 22:
                            return X(t.type._render, !1);
                        case 1:
                            return X(t.type, !0);
                        default:
                            return ""
                    }
                }

                function Y(t) {
                    if (null == t) return null;
                    if ("function" == typeof t) return t.displayName || t.name || null;
                    if ("string" == typeof t) return t;
                    switch (t) {
                        case S:
                            return "Fragment";
                        case T:
                            return "Portal";
                        case M:
                            return "Profiler";
                        case w:
                            return "StrictMode";
                        case I:
                            return "Suspense";
                        case C:
                            return "SuspenseList"
                    }
                    if ("object" == typeof t) switch (t.$$typeof) {
                        case R:
                            return (t.displayName || "Context") + ".Consumer";
                        case A:
                            return (t._context.displayName || "Context") + ".Provider";
                        case P:
                            var e = t.render;
                            return e = e.displayName || e.name || "", t.displayName || ("" !== e ? "ForwardRef(" + e + ")" : "ForwardRef");
                        case O:
                            return Y(t.type);
                        case N:
                            return Y(t._render);
                        case L:
                            e = t._payload, t = t._init;
                            try {
                                return Y(t(e))
                            } catch (t) {}
                    }
                    return null
                }

                function q(t) {
                    switch (typeof t) {
                        case "boolean":
                        case "number":
                        case "object":
                        case "string":
                        case "undefined":
                            return t;
                        default:
                            return ""
                    }
                }

                function Z(t) {
                    var e = t.type;
                    return (t = t.nodeName) && "input" === t.toLowerCase() && ("checkbox" === e || "radio" === e)
                }

                function K(t) {
                    t._valueTracker || (t._valueTracker = function(t) {
                        var e = Z(t) ? "checked" : "value",
                            n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e),
                            r = "" + t[e];
                        if (!t.hasOwnProperty(e) && void 0 !== n && "function" == typeof n.get && "function" == typeof n.set) {
                            var i = n.get,
                                o = n.set;
                            return Object.defineProperty(t, e, {
                                configurable: !0,
                                get: function() {
                                    return i.call(this)
                                },
                                set: function(t) {
                                    r = "" + t, o.call(this, t)
                                }
                            }), Object.defineProperty(t, e, {
                                enumerable: n.enumerable
                            }), {
                                getValue: function() {
                                    return r
                                },
                                setValue: function(t) {
                                    r = "" + t
                                },
                                stopTracking: function() {
                                    t._valueTracker = null, delete t[e]
                                }
                            }
                        }
                    }(t))
                }

                function J(t) {
                    if (!t) return !1;
                    var e = t._valueTracker;
                    if (!e) return !0;
                    var n = e.getValue(),
                        r = "";
                    return t && (r = Z(t) ? t.checked ? "true" : "false" : t.value), (t = r) !== n && (e.setValue(t), !0)
                }

                function Q(t) {
                    if (void 0 === (t = t || ("undefined" != typeof document ? document : void 0))) return null;
                    try {
                        return t.activeElement || t.body
                    } catch (e) {
                        return t.body
                    }
                }

                function $(t, e) {
                    var n = e.checked;
                    return i({}, e, {
                        defaultChecked: void 0,
                        defaultValue: void 0,
                        value: void 0,
                        checked: null != n ? n : t._wrapperState.initialChecked
                    })
                }

                function tt(t, e) {
                    var n = null == e.defaultValue ? "" : e.defaultValue,
                        r = null != e.checked ? e.checked : e.defaultChecked;
                    n = q(null != e.value ? e.value : n), t._wrapperState = {
                        initialChecked: r,
                        initialValue: n,
                        controlled: "checkbox" === e.type || "radio" === e.type ? null != e.checked : null != e.value
                    }
                }

                function et(t, e) {
                    null != (e = e.checked) && x(t, "checked", e, !1)
                }

                function nt(t, e) {
                    et(t, e);
                    var n = q(e.value),
                        r = e.type;
                    if (null != n) "number" === r ? (0 === n && "" === t.value || t.value != n) && (t.value = "" + n) : t.value !== "" + n && (t.value = "" + n);
                    else if ("submit" === r || "reset" === r) return void t.removeAttribute("value");
                    e.hasOwnProperty("value") ? it(t, e.type, n) : e.hasOwnProperty("defaultValue") && it(t, e.type, q(e.defaultValue)), null == e.checked && null != e.defaultChecked && (t.defaultChecked = !!e.defaultChecked)
                }

                function rt(t, e, n) {
                    if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
                        var r = e.type;
                        if (!("submit" !== r && "reset" !== r || void 0 !== e.value && null !== e.value)) return;
                        e = "" + t._wrapperState.initialValue, n || e === t.value || (t.value = e), t.defaultValue = e
                    }
                    "" !== (n = t.name) && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, "" !== n && (t.name = n)
                }

                function it(t, e, n) {
                    "number" === e && Q(t.ownerDocument) === t || (null == n ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + n && (t.defaultValue = "" + n))
                }

                function ot(t, e) {
                    return t = i({
                        children: void 0
                    }, e), (e = function(t) {
                        var e = "";
                        return r.Children.forEach(t, (function(t) {
                            null != t && (e += t)
                        })), e
                    }(e.children)) && (t.children = e), t
                }

                function st(t, e, n, r) {
                    if (t = t.options, e) {
                        e = {};
                        for (var i = 0; i < n.length; i++) e["$" + n[i]] = !0;
                        for (n = 0; n < t.length; n++) i = e.hasOwnProperty("$" + t[n].value), t[n].selected !== i && (t[n].selected = i), i && r && (t[n].defaultSelected = !0)
                    } else {
                        for (n = "" + q(n), e = null, i = 0; i < t.length; i++) {
                            if (t[i].value === n) return t[i].selected = !0, void(r && (t[i].defaultSelected = !0));
                            null !== e || t[i].disabled || (e = t[i])
                        }
                        null !== e && (e.selected = !0)
                    }
                }

                function at(t, e) {
                    if (null != e.dangerouslySetInnerHTML) throw Error(s(91));
                    return i({}, e, {
                        value: void 0,
                        defaultValue: void 0,
                        children: "" + t._wrapperState.initialValue
                    })
                }

                function lt(t, e) {
                    var n = e.value;
                    if (null == n) {
                        if (n = e.children, e = e.defaultValue, null != n) {
                            if (null != e) throw Error(s(92));
                            if (Array.isArray(n)) {
                                if (!(1 >= n.length)) throw Error(s(93));
                                n = n[0]
                            }
                            e = n
                        }
                        null == e && (e = ""), n = e
                    }
                    t._wrapperState = {
                        initialValue: q(n)
                    }
                }

                function ut(t, e) {
                    var n = q(e.value),
                        r = q(e.defaultValue);
                    null != n && ((n = "" + n) !== t.value && (t.value = n), null == e.defaultValue && t.defaultValue !== n && (t.defaultValue = n)), null != r && (t.defaultValue = "" + r)
                }

                function ht(t) {
                    var e = t.textContent;
                    e === t._wrapperState.initialValue && "" !== e && null !== e && (t.value = e)
                }
                var ct = "http://www.w3.org/1999/xhtml";

                function dt(t) {
                    switch (t) {
                        case "svg":
                            return "http://www.w3.org/2000/svg";
                        case "math":
                            return "http://www.w3.org/1998/Math/MathML";
                        default:
                            return "http://www.w3.org/1999/xhtml"
                    }
                }

                function pt(t, e) {
                    return null == t || "http://www.w3.org/1999/xhtml" === t ? dt(e) : "http://www.w3.org/2000/svg" === t && "foreignObject" === e ? "http://www.w3.org/1999/xhtml" : t
                }
                var ft, mt, gt = (mt = function(t, e) {
                    if ("http://www.w3.org/2000/svg" !== t.namespaceURI || "innerHTML" in t) t.innerHTML = e;
                    else {
                        for ((ft = ft || document.createElement("div")).innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = ft.firstChild; t.firstChild;) t.removeChild(t.firstChild);
                        for (; e.firstChild;) t.appendChild(e.firstChild)
                    }
                }, "undefined" != typeof MSApp && MSApp.execUnsafeLocalFunction ? function(t, e, n, r) {
                    MSApp.execUnsafeLocalFunction((function() {
                        return mt(t, e)
                    }))
                } : mt);

                function vt(t, e) {
                    if (e) {
                        var n = t.firstChild;
                        if (n && n === t.lastChild && 3 === n.nodeType) return void(n.nodeValue = e)
                    }
                    t.textContent = e
                }
                var _t = {
                        animationIterationCount: !0,
                        borderImageOutset: !0,
                        borderImageSlice: !0,
                        borderImageWidth: !0,
                        boxFlex: !0,
                        boxFlexGroup: !0,
                        boxOrdinalGroup: !0,
                        columnCount: !0,
                        columns: !0,
                        flex: !0,
                        flexGrow: !0,
                        flexPositive: !0,
                        flexShrink: !0,
                        flexNegative: !0,
                        flexOrder: !0,
                        gridArea: !0,
                        gridRow: !0,
                        gridRowEnd: !0,
                        gridRowSpan: !0,
                        gridRowStart: !0,
                        gridColumn: !0,
                        gridColumnEnd: !0,
                        gridColumnSpan: !0,
                        gridColumnStart: !0,
                        fontWeight: !0,
                        lineClamp: !0,
                        lineHeight: !0,
                        opacity: !0,
                        order: !0,
                        orphans: !0,
                        tabSize: !0,
                        widows: !0,
                        zIndex: !0,
                        zoom: !0,
                        fillOpacity: !0,
                        floodOpacity: !0,
                        stopOpacity: !0,
                        strokeDasharray: !0,
                        strokeDashoffset: !0,
                        strokeMiterlimit: !0,
                        strokeOpacity: !0,
                        strokeWidth: !0
                    },
                    yt = ["Webkit", "ms", "Moz", "O"];

                function xt(t, e, n) {
                    return null == e || "boolean" == typeof e || "" === e ? "" : n || "number" != typeof e || 0 === e || _t.hasOwnProperty(t) && _t[t] ? ("" + e).trim() : e + "px"
                }

                function bt(t, e) {
                    for (var n in t = t.style, e)
                        if (e.hasOwnProperty(n)) {
                            var r = 0 === n.indexOf("--"),
                                i = xt(n, e[n], r);
                            "float" === n && (n = "cssFloat"), r ? t.setProperty(n, i) : t[n] = i
                        }
                }
                Object.keys(_t).forEach((function(t) {
                    yt.forEach((function(e) {
                        e = e + t.charAt(0).toUpperCase() + t.substring(1), _t[e] = _t[t]
                    }))
                }));
                var Et = i({
                    menuitem: !0
                }, {
                    area: !0,
                    base: !0,
                    br: !0,
                    col: !0,
                    embed: !0,
                    hr: !0,
                    img: !0,
                    input: !0,
                    keygen: !0,
                    link: !0,
                    meta: !0,
                    param: !0,
                    source: !0,
                    track: !0,
                    wbr: !0
                });

                function Tt(t, e) {
                    if (e) {
                        if (Et[t] && (null != e.children || null != e.dangerouslySetInnerHTML)) throw Error(s(137, t));
                        if (null != e.dangerouslySetInnerHTML) {
                            if (null != e.children) throw Error(s(60));
                            if ("object" != typeof e.dangerouslySetInnerHTML || !("__html" in e.dangerouslySetInnerHTML)) throw Error(s(61))
                        }
                        if (null != e.style && "object" != typeof e.style) throw Error(s(62))
                    }
                }

                function St(t, e) {
                    if (-1 === t.indexOf("-")) return "string" == typeof e.is;
                    switch (t) {
                        case "annotation-xml":
                        case "color-profile":
                        case "font-face":
                        case "font-face-src":
                        case "font-face-uri":
                        case "font-face-format":
                        case "font-face-name":
                        case "missing-glyph":
                            return !1;
                        default:
                            return !0
                    }
                }

                function wt(t) {
                    return (t = t.target || t.srcElement || window).correspondingUseElement && (t = t.correspondingUseElement), 3 === t.nodeType ? t.parentNode : t
                }
                var Mt = null,
                    At = null,
                    Rt = null;

                function Pt(t) {
                    if (t = $r(t)) {
                        if ("function" != typeof Mt) throw Error(s(280));
                        var e = t.stateNode;
                        e && (e = ei(e), Mt(t.stateNode, t.type, e))
                    }
                }

                function It(t) {
                    At ? Rt ? Rt.push(t) : Rt = [t] : At = t
                }

                function Ct() {
                    if (At) {
                        var t = At,
                            e = Rt;
                        if (Rt = At = null, Pt(t), e)
                            for (t = 0; t < e.length; t++) Pt(e[t])
                    }
                }

                function Ot(t, e) {
                    return t(e)
                }

                function Lt(t, e, n, r, i) {
                    return t(e, n, r, i)
                }

                function Nt() {}
                var Dt = Ot,
                    Ut = !1,
                    Ft = !1;

                function Bt() {
                    null === At && null === Rt || (Nt(), Ct())
                }

                function kt(t, e) {
                    var n = t.stateNode;
                    if (null === n) return null;
                    var r = ei(n);
                    if (null === r) return null;
                    n = r[e];
                    t: switch (e) {
                        case "onClick":
                        case "onClickCapture":
                        case "onDoubleClick":
                        case "onDoubleClickCapture":
                        case "onMouseDown":
                        case "onMouseDownCapture":
                        case "onMouseMove":
                        case "onMouseMoveCapture":
                        case "onMouseUp":
                        case "onMouseUpCapture":
                        case "onMouseEnter":
                            (r = !r.disabled) || (r = !("button" === (t = t.type) || "input" === t || "select" === t || "textarea" === t)), t = !r;
                            break t;
                        default:
                            t = !1
                    }
                    if (t) return null;
                    if (n && "function" != typeof n) throw Error(s(231, e, typeof n));
                    return n
                }
                var Gt = !1;
                if (c) try {
                    var Ht = {};
                    Object.defineProperty(Ht, "passive", {
                        get: function() {
                            Gt = !0
                        }
                    }), window.addEventListener("test", Ht, Ht), window.removeEventListener("test", Ht, Ht)
                } catch (mt) {
                    Gt = !1
                }

                function zt(t, e, n, r, i, o, s, a, l) {
                    var u = Array.prototype.slice.call(arguments, 3);
                    try {
                        e.apply(n, u)
                    } catch (t) {
                        this.onError(t)
                    }
                }
                var Vt = !1,
                    Wt = null,
                    Xt = !1,
                    jt = null,
                    Yt = {
                        onError: function(t) {
                            Vt = !0, Wt = t
                        }
                    };

                function qt(t, e, n, r, i, o, s, a, l) {
                    Vt = !1, Wt = null, zt.apply(Yt, arguments)
                }

                function Zt(t) {
                    var e = t,
                        n = t;
                    if (t.alternate)
                        for (; e.return;) e = e.return;
                    else {
                        t = e;
                        do {
                            0 != (1026 & (e = t).flags) && (n = e.return), t = e.return
                        } while (t)
                    }
                    return 3 === e.tag ? n : null
                }

                function Kt(t) {
                    if (13 === t.tag) {
                        var e = t.memoizedState;
                        if (null === e && null !== (t = t.alternate) && (e = t.memoizedState), null !== e) return e.dehydrated
                    }
                    return null
                }

                function Jt(t) {
                    if (Zt(t) !== t) throw Error(s(188))
                }

                function Qt(t) {
                    if (!(t = function(t) {
                            var e = t.alternate;
                            if (!e) {
                                if (null === (e = Zt(t))) throw Error(s(188));
                                return e !== t ? null : t
                            }
                            for (var n = t, r = e;;) {
                                var i = n.return;
                                if (null === i) break;
                                var o = i.alternate;
                                if (null === o) {
                                    if (null !== (r = i.return)) {
                                        n = r;
                                        continue
                                    }
                                    break
                                }
                                if (i.child === o.child) {
                                    for (o = i.child; o;) {
                                        if (o === n) return Jt(i), t;
                                        if (o === r) return Jt(i), e;
                                        o = o.sibling
                                    }
                                    throw Error(s(188))
                                }
                                if (n.return !== r.return) n = i, r = o;
                                else {
                                    for (var a = !1, l = i.child; l;) {
                                        if (l === n) {
                                            a = !0, n = i, r = o;
                                            break
                                        }
                                        if (l === r) {
                                            a = !0, r = i, n = o;
                                            break
                                        }
                                        l = l.sibling
                                    }
                                    if (!a) {
                                        for (l = o.child; l;) {
                                            if (l === n) {
                                                a = !0, n = o, r = i;
                                                break
                                            }
                                            if (l === r) {
                                                a = !0, r = o, n = i;
                                                break
                                            }
                                            l = l.sibling
                                        }
                                        if (!a) throw Error(s(189))
                                    }
                                }
                                if (n.alternate !== r) throw Error(s(190))
                            }
                            if (3 !== n.tag) throw Error(s(188));
                            return n.stateNode.current === n ? t : e
                        }(t))) return null;
                    for (var e = t;;) {
                        if (5 === e.tag || 6 === e.tag) return e;
                        if (e.child) e.child.return = e, e = e.child;
                        else {
                            if (e === t) break;
                            for (; !e.sibling;) {
                                if (!e.return || e.return === t) return null;
                                e = e.return
                            }
                            e.sibling.return = e.return, e = e.sibling
                        }
                    }
                    return null
                }

                function $t(t, e) {
                    for (var n = t.alternate; null !== e;) {
                        if (e === t || e === n) return !0;
                        e = e.return
                    }
                    return !1
                }
                var te, ee, ne, re, ie = !1,
                    oe = [],
                    se = null,
                    ae = null,
                    le = null,
                    ue = new Map,
                    he = new Map,
                    ce = [],
                    de = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

                function pe(t, e, n, r, i) {
                    return {
                        blockedOn: t,
                        domEventName: e,
                        eventSystemFlags: 16 | n,
                        nativeEvent: i,
                        targetContainers: [r]
                    }
                }

                function fe(t, e) {
                    switch (t) {
                        case "focusin":
                        case "focusout":
                            se = null;
                            break;
                        case "dragenter":
                        case "dragleave":
                            ae = null;
                            break;
                        case "mouseover":
                        case "mouseout":
                            le = null;
                            break;
                        case "pointerover":
                        case "pointerout":
                            ue.delete(e.pointerId);
                            break;
                        case "gotpointercapture":
                        case "lostpointercapture":
                            he.delete(e.pointerId)
                    }
                }

                function me(t, e, n, r, i, o) {
                    return null === t || t.nativeEvent !== o ? (t = pe(e, n, r, i, o), null !== e && null !== (e = $r(e)) && ee(e), t) : (t.eventSystemFlags |= r, e = t.targetContainers, null !== i && -1 === e.indexOf(i) && e.push(i), t)
                }

                function ge(t) {
                    var e = Qr(t.target);
                    if (null !== e) {
                        var n = Zt(e);
                        if (null !== n)
                            if (13 === (e = n.tag)) {
                                if (null !== (e = Kt(n))) return t.blockedOn = e, void re(t.lanePriority, (function() {
                                    o.unstable_runWithPriority(t.priority, (function() {
                                        ne(n)
                                    }))
                                }))
                            } else if (3 === e && n.stateNode.hydrate) return void(t.blockedOn = 3 === n.tag ? n.stateNode.containerInfo : null)
                    }
                    t.blockedOn = null
                }

                function ve(t) {
                    if (null !== t.blockedOn) return !1;
                    for (var e = t.targetContainers; 0 < e.length;) {
                        var n = Qe(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
                        if (null !== n) return null !== (e = $r(n)) && ee(e), t.blockedOn = n, !1;
                        e.shift()
                    }
                    return !0
                }

                function _e(t, e, n) {
                    ve(t) && n.delete(e)
                }

                function ye() {
                    for (ie = !1; 0 < oe.length;) {
                        var t = oe[0];
                        if (null !== t.blockedOn) {
                            null !== (t = $r(t.blockedOn)) && te(t);
                            break
                        }
                        for (var e = t.targetContainers; 0 < e.length;) {
                            var n = Qe(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
                            if (null !== n) {
                                t.blockedOn = n;
                                break
                            }
                            e.shift()
                        }
                        null === t.blockedOn && oe.shift()
                    }
                    null !== se && ve(se) && (se = null), null !== ae && ve(ae) && (ae = null), null !== le && ve(le) && (le = null), ue.forEach(_e), he.forEach(_e)
                }

                function xe(t, e) {
                    t.blockedOn === e && (t.blockedOn = null, ie || (ie = !0, o.unstable_scheduleCallback(o.unstable_NormalPriority, ye)))
                }

                function be(t) {
                    function e(e) {
                        return xe(e, t)
                    }
                    if (0 < oe.length) {
                        xe(oe[0], t);
                        for (var n = 1; n < oe.length; n++) {
                            var r = oe[n];
                            r.blockedOn === t && (r.blockedOn = null)
                        }
                    }
                    for (null !== se && xe(se, t), null !== ae && xe(ae, t), null !== le && xe(le, t), ue.forEach(e), he.forEach(e), n = 0; n < ce.length; n++)(r = ce[n]).blockedOn === t && (r.blockedOn = null);
                    for (; 0 < ce.length && null === (n = ce[0]).blockedOn;) ge(n), null === n.blockedOn && ce.shift()
                }

                function Ee(t, e) {
                    var n = {};
                    return n[t.toLowerCase()] = e.toLowerCase(), n["Webkit" + t] = "webkit" + e, n["Moz" + t] = "moz" + e, n
                }
                var Te = {
                        animationend: Ee("Animation", "AnimationEnd"),
                        animationiteration: Ee("Animation", "AnimationIteration"),
                        animationstart: Ee("Animation", "AnimationStart"),
                        transitionend: Ee("Transition", "TransitionEnd")
                    },
                    Se = {},
                    we = {};

                function Me(t) {
                    if (Se[t]) return Se[t];
                    if (!Te[t]) return t;
                    var e, n = Te[t];
                    for (e in n)
                        if (n.hasOwnProperty(e) && e in we) return Se[t] = n[e];
                    return t
                }
                c && (we = document.createElement("div").style, "AnimationEvent" in window || (delete Te.animationend.animation, delete Te.animationiteration.animation, delete Te.animationstart.animation), "TransitionEvent" in window || delete Te.transitionend.transition);
                var Ae = Me("animationend"),
                    Re = Me("animationiteration"),
                    Pe = Me("animationstart"),
                    Ie = Me("transitionend"),
                    Ce = new Map,
                    Oe = new Map,
                    Le = ["abort", "abort", Ae, "animationEnd", Re, "animationIteration", Pe, "animationStart", "canplay", "canPlay", "canplaythrough", "canPlayThrough", "durationchange", "durationChange", "emptied", "emptied", "encrypted", "encrypted", "ended", "ended", "error", "error", "gotpointercapture", "gotPointerCapture", "load", "load", "loadeddata", "loadedData", "loadedmetadata", "loadedMetadata", "loadstart", "loadStart", "lostpointercapture", "lostPointerCapture", "playing", "playing", "progress", "progress", "seeking", "seeking", "stalled", "stalled", "suspend", "suspend", "timeupdate", "timeUpdate", Ie, "transitionEnd", "waiting", "waiting"];

                function Ne(t, e) {
                    for (var n = 0; n < t.length; n += 2) {
                        var r = t[n],
                            i = t[n + 1];
                        i = "on" + (i[0].toUpperCase() + i.slice(1)), Oe.set(r, e), Ce.set(r, i), u(i, [r])
                    }
                }(0, o.unstable_now)();
                var De = 8;

                function Ue(t) {
                    if (0 != (1 & t)) return De = 15, 1;
                    if (0 != (2 & t)) return De = 14, 2;
                    if (0 != (4 & t)) return De = 13, 4;
                    var e = 24 & t;
                    return 0 !== e ? (De = 12, e) : 0 != (32 & t) ? (De = 11, 32) : 0 != (e = 192 & t) ? (De = 10, e) : 0 != (256 & t) ? (De = 9, 256) : 0 != (e = 3584 & t) ? (De = 8, e) : 0 != (4096 & t) ? (De = 7, 4096) : 0 != (e = 4186112 & t) ? (De = 6, e) : 0 != (e = 62914560 & t) ? (De = 5, e) : 67108864 & t ? (De = 4, 67108864) : 0 != (134217728 & t) ? (De = 3, 134217728) : 0 != (e = 805306368 & t) ? (De = 2, e) : 0 != (1073741824 & t) ? (De = 1, 1073741824) : (De = 8, t)
                }

                function Fe(t, e) {
                    var n = t.pendingLanes;
                    if (0 === n) return De = 0;
                    var r = 0,
                        i = 0,
                        o = t.expiredLanes,
                        s = t.suspendedLanes,
                        a = t.pingedLanes;
                    if (0 !== o) r = o, i = De = 15;
                    else if (0 != (o = 134217727 & n)) {
                        var l = o & ~s;
                        0 !== l ? (r = Ue(l), i = De) : 0 != (a &= o) && (r = Ue(a), i = De)
                    } else 0 != (o = n & ~s) ? (r = Ue(o), i = De) : 0 !== a && (r = Ue(a), i = De);
                    if (0 === r) return 0;
                    if (r = n & ((0 > (r = 31 - Ve(r)) ? 0 : 1 << r) << 1) - 1, 0 !== e && e !== r && 0 == (e & s)) {
                        if (Ue(e), i <= De) return e;
                        De = i
                    }
                    if (0 !== (e = t.entangledLanes))
                        for (t = t.entanglements, e &= r; 0 < e;) i = 1 << (n = 31 - Ve(e)), r |= t[n], e &= ~i;
                    return r
                }

                function Be(t) {
                    return 0 != (t = -1073741825 & t.pendingLanes) ? t : 1073741824 & t ? 1073741824 : 0
                }

                function ke(t, e) {
                    switch (t) {
                        case 15:
                            return 1;
                        case 14:
                            return 2;
                        case 12:
                            return 0 === (t = Ge(24 & ~e)) ? ke(10, e) : t;
                        case 10:
                            return 0 === (t = Ge(192 & ~e)) ? ke(8, e) : t;
                        case 8:
                            return 0 === (t = Ge(3584 & ~e)) && 0 === (t = Ge(4186112 & ~e)) && (t = 512), t;
                        case 2:
                            return 0 === (e = Ge(805306368 & ~e)) && (e = 268435456), e
                    }
                    throw Error(s(358, t))
                }

                function Ge(t) {
                    return t & -t
                }

                function He(t) {
                    for (var e = [], n = 0; 31 > n; n++) e.push(t);
                    return e
                }

                function ze(t, e, n) {
                    t.pendingLanes |= e;
                    var r = e - 1;
                    t.suspendedLanes &= r, t.pingedLanes &= r, (t = t.eventTimes)[e = 31 - Ve(e)] = n
                }
                var Ve = Math.clz32 ? Math.clz32 : function(t) {
                        return 0 === t ? 32 : 31 - (We(t) / Xe | 0) | 0
                    },
                    We = Math.log,
                    Xe = Math.LN2,
                    je = o.unstable_UserBlockingPriority,
                    Ye = o.unstable_runWithPriority,
                    qe = !0;

                function Ze(t, e, n, r) {
                    Ut || Nt();
                    var i = Je,
                        o = Ut;
                    Ut = !0;
                    try {
                        Lt(i, t, e, n, r)
                    } finally {
                        (Ut = o) || Bt()
                    }
                }

                function Ke(t, e, n, r) {
                    Ye(je, Je.bind(null, t, e, n, r))
                }

                function Je(t, e, n, r) {
                    var i;
                    if (qe)
                        if ((i = 0 == (4 & e)) && 0 < oe.length && -1 < de.indexOf(t)) t = pe(null, t, e, n, r), oe.push(t);
                        else {
                            var o = Qe(t, e, n, r);
                            if (null === o) i && fe(t, r);
                            else {
                                if (i) {
                                    if (-1 < de.indexOf(t)) return t = pe(o, t, e, n, r), void oe.push(t);
                                    if (function(t, e, n, r, i) {
                                            switch (e) {
                                                case "focusin":
                                                    return se = me(se, t, e, n, r, i), !0;
                                                case "dragenter":
                                                    return ae = me(ae, t, e, n, r, i), !0;
                                                case "mouseover":
                                                    return le = me(le, t, e, n, r, i), !0;
                                                case "pointerover":
                                                    var o = i.pointerId;
                                                    return ue.set(o, me(ue.get(o) || null, t, e, n, r, i)), !0;
                                                case "gotpointercapture":
                                                    return o = i.pointerId, he.set(o, me(he.get(o) || null, t, e, n, r, i)), !0
                                            }
                                            return !1
                                        }(o, t, e, n, r)) return;
                                    fe(t, r)
                                }
                                Cr(t, e, r, null, n)
                            }
                        }
                }

                function Qe(t, e, n, r) {
                    var i = wt(r);
                    if (null !== (i = Qr(i))) {
                        var o = Zt(i);
                        if (null === o) i = null;
                        else {
                            var s = o.tag;
                            if (13 === s) {
                                if (null !== (i = Kt(o))) return i;
                                i = null
                            } else if (3 === s) {
                                if (o.stateNode.hydrate) return 3 === o.tag ? o.stateNode.containerInfo : null;
                                i = null
                            } else o !== i && (i = null)
                        }
                    }
                    return Cr(t, e, r, i, n), null
                }
                var $e = null,
                    tn = null,
                    en = null;

                function nn() {
                    if (en) return en;
                    var t, e, n = tn,
                        r = n.length,
                        i = "value" in $e ? $e.value : $e.textContent,
                        o = i.length;
                    for (t = 0; t < r && n[t] === i[t]; t++);
                    var s = r - t;
                    for (e = 1; e <= s && n[r - e] === i[o - e]; e++);
                    return en = i.slice(t, 1 < e ? 1 - e : void 0)
                }

                function rn(t) {
                    var e = t.keyCode;
                    return "charCode" in t ? 0 === (t = t.charCode) && 13 === e && (t = 13) : t = e, 10 === t && (t = 13), 32 <= t || 13 === t ? t : 0
                }

                function on() {
                    return !0
                }

                function sn() {
                    return !1
                }

                function an(t) {
                    function e(e, n, r, i, o) {
                        for (var s in this._reactName = e, this._targetInst = r, this.type = n, this.nativeEvent = i, this.target = o, this.currentTarget = null, t) t.hasOwnProperty(s) && (e = t[s], this[s] = e ? e(i) : i[s]);
                        return this.isDefaultPrevented = (null != i.defaultPrevented ? i.defaultPrevented : !1 === i.returnValue) ? on : sn, this.isPropagationStopped = sn, this
                    }
                    return i(e.prototype, {
                        preventDefault: function() {
                            this.defaultPrevented = !0;
                            var t = this.nativeEvent;
                            t && (t.preventDefault ? t.preventDefault() : "unknown" != typeof t.returnValue && (t.returnValue = !1), this.isDefaultPrevented = on)
                        },
                        stopPropagation: function() {
                            var t = this.nativeEvent;
                            t && (t.stopPropagation ? t.stopPropagation() : "unknown" != typeof t.cancelBubble && (t.cancelBubble = !0), this.isPropagationStopped = on)
                        },
                        persist: function() {},
                        isPersistent: on
                    }), e
                }
                var ln, un, hn, cn = {
                        eventPhase: 0,
                        bubbles: 0,
                        cancelable: 0,
                        timeStamp: function(t) {
                            return t.timeStamp || Date.now()
                        },
                        defaultPrevented: 0,
                        isTrusted: 0
                    },
                    dn = an(cn),
                    pn = i({}, cn, {
                        view: 0,
                        detail: 0
                    }),
                    fn = an(pn),
                    mn = i({}, pn, {
                        screenX: 0,
                        screenY: 0,
                        clientX: 0,
                        clientY: 0,
                        pageX: 0,
                        pageY: 0,
                        ctrlKey: 0,
                        shiftKey: 0,
                        altKey: 0,
                        metaKey: 0,
                        getModifierState: Mn,
                        button: 0,
                        buttons: 0,
                        relatedTarget: function(t) {
                            return void 0 === t.relatedTarget ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget
                        },
                        movementX: function(t) {
                            return "movementX" in t ? t.movementX : (t !== hn && (hn && "mousemove" === t.type ? (ln = t.screenX - hn.screenX, un = t.screenY - hn.screenY) : un = ln = 0, hn = t), ln)
                        },
                        movementY: function(t) {
                            return "movementY" in t ? t.movementY : un
                        }
                    }),
                    gn = an(mn),
                    vn = an(i({}, mn, {
                        dataTransfer: 0
                    })),
                    _n = an(i({}, pn, {
                        relatedTarget: 0
                    })),
                    yn = an(i({}, cn, {
                        animationName: 0,
                        elapsedTime: 0,
                        pseudoElement: 0
                    })),
                    xn = an(i({}, cn, {
                        clipboardData: function(t) {
                            return "clipboardData" in t ? t.clipboardData : window.clipboardData
                        }
                    })),
                    bn = an(i({}, cn, {
                        data: 0
                    })),
                    En = {
                        Esc: "Escape",
                        Spacebar: " ",
                        Left: "ArrowLeft",
                        Up: "ArrowUp",
                        Right: "ArrowRight",
                        Down: "ArrowDown",
                        Del: "Delete",
                        Win: "OS",
                        Menu: "ContextMenu",
                        Apps: "ContextMenu",
                        Scroll: "ScrollLock",
                        MozPrintableKey: "Unidentified"
                    },
                    Tn = {
                        8: "Backspace",
                        9: "Tab",
                        12: "Clear",
                        13: "Enter",
                        16: "Shift",
                        17: "Control",
                        18: "Alt",
                        19: "Pause",
                        20: "CapsLock",
                        27: "Escape",
                        32: " ",
                        33: "PageUp",
                        34: "PageDown",
                        35: "End",
                        36: "Home",
                        37: "ArrowLeft",
                        38: "ArrowUp",
                        39: "ArrowRight",
                        40: "ArrowDown",
                        45: "Insert",
                        46: "Delete",
                        112: "F1",
                        113: "F2",
                        114: "F3",
                        115: "F4",
                        116: "F5",
                        117: "F6",
                        118: "F7",
                        119: "F8",
                        120: "F9",
                        121: "F10",
                        122: "F11",
                        123: "F12",
                        144: "NumLock",
                        145: "ScrollLock",
                        224: "Meta"
                    },
                    Sn = {
                        Alt: "altKey",
                        Control: "ctrlKey",
                        Meta: "metaKey",
                        Shift: "shiftKey"
                    };

                function wn(t) {
                    var e = this.nativeEvent;
                    return e.getModifierState ? e.getModifierState(t) : !!(t = Sn[t]) && !!e[t]
                }

                function Mn() {
                    return wn
                }
                var An = an(i({}, pn, {
                        key: function(t) {
                            if (t.key) {
                                var e = En[t.key] || t.key;
                                if ("Unidentified" !== e) return e
                            }
                            return "keypress" === t.type ? 13 === (t = rn(t)) ? "Enter" : String.fromCharCode(t) : "keydown" === t.type || "keyup" === t.type ? Tn[t.keyCode] || "Unidentified" : ""
                        },
                        code: 0,
                        location: 0,
                        ctrlKey: 0,
                        shiftKey: 0,
                        altKey: 0,
                        metaKey: 0,
                        repeat: 0,
                        locale: 0,
                        getModifierState: Mn,
                        charCode: function(t) {
                            return "keypress" === t.type ? rn(t) : 0
                        },
                        keyCode: function(t) {
                            return "keydown" === t.type || "keyup" === t.type ? t.keyCode : 0
                        },
                        which: function(t) {
                            return "keypress" === t.type ? rn(t) : "keydown" === t.type || "keyup" === t.type ? t.keyCode : 0
                        }
                    })),
                    Rn = an(i({}, mn, {
                        pointerId: 0,
                        width: 0,
                        height: 0,
                        pressure: 0,
                        tangentialPressure: 0,
                        tiltX: 0,
                        tiltY: 0,
                        twist: 0,
                        pointerType: 0,
                        isPrimary: 0
                    })),
                    Pn = an(i({}, pn, {
                        touches: 0,
                        targetTouches: 0,
                        changedTouches: 0,
                        altKey: 0,
                        metaKey: 0,
                        ctrlKey: 0,
                        shiftKey: 0,
                        getModifierState: Mn
                    })),
                    In = an(i({}, cn, {
                        propertyName: 0,
                        elapsedTime: 0,
                        pseudoElement: 0
                    })),
                    Cn = an(i({}, mn, {
                        deltaX: function(t) {
                            return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0
                        },
                        deltaY: function(t) {
                            return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0
                        },
                        deltaZ: 0,
                        deltaMode: 0
                    })),
                    On = [9, 13, 27, 32],
                    Ln = c && "CompositionEvent" in window,
                    Nn = null;
                c && "documentMode" in document && (Nn = document.documentMode);
                var Dn = c && "TextEvent" in window && !Nn,
                    Un = c && (!Ln || Nn && 8 < Nn && 11 >= Nn),
                    Fn = String.fromCharCode(32),
                    Bn = !1;

                function kn(t, e) {
                    switch (t) {
                        case "keyup":
                            return -1 !== On.indexOf(e.keyCode);
                        case "keydown":
                            return 229 !== e.keyCode;
                        case "keypress":
                        case "mousedown":
                        case "focusout":
                            return !0;
                        default:
                            return !1
                    }
                }

                function Gn(t) {
                    return "object" == typeof(t = t.detail) && "data" in t ? t.data : null
                }
                var Hn = !1,
                    zn = {
                        color: !0,
                        date: !0,
                        datetime: !0,
                        "datetime-local": !0,
                        email: !0,
                        month: !0,
                        number: !0,
                        password: !0,
                        range: !0,
                        search: !0,
                        tel: !0,
                        text: !0,
                        time: !0,
                        url: !0,
                        week: !0
                    };

                function Vn(t) {
                    var e = t && t.nodeName && t.nodeName.toLowerCase();
                    return "input" === e ? !!zn[t.type] : "textarea" === e
                }

                function Wn(t, e, n, r) {
                    It(r), 0 < (e = Lr(e, "onChange")).length && (n = new dn("onChange", "change", null, n, r), t.push({
                        event: n,
                        listeners: e
                    }))
                }
                var Xn = null,
                    jn = null;

                function Yn(t) {
                    wr(t, 0)
                }

                function qn(t) {
                    if (J(ti(t))) return t
                }

                function Zn(t, e) {
                    if ("change" === t) return e
                }
                var Kn = !1;
                if (c) {
                    var Jn;
                    if (c) {
                        var Qn = "oninput" in document;
                        if (!Qn) {
                            var $n = document.createElement("div");
                            $n.setAttribute("oninput", "return;"), Qn = "function" == typeof $n.oninput
                        }
                        Jn = Qn
                    } else Jn = !1;
                    Kn = Jn && (!document.documentMode || 9 < document.documentMode)
                }

                function tr() {
                    Xn && (Xn.detachEvent("onpropertychange", er), jn = Xn = null)
                }

                function er(t) {
                    if ("value" === t.propertyName && qn(jn)) {
                        var e = [];
                        if (Wn(e, jn, t, wt(t)), t = Yn, Ut) t(e);
                        else {
                            Ut = !0;
                            try {
                                Ot(t, e)
                            } finally {
                                Ut = !1, Bt()
                            }
                        }
                    }
                }

                function nr(t, e, n) {
                    "focusin" === t ? (tr(), jn = n, (Xn = e).attachEvent("onpropertychange", er)) : "focusout" === t && tr()
                }

                function rr(t) {
                    if ("selectionchange" === t || "keyup" === t || "keydown" === t) return qn(jn)
                }

                function ir(t, e) {
                    if ("click" === t) return qn(e)
                }

                function or(t, e) {
                    if ("input" === t || "change" === t) return qn(e)
                }
                var sr = "function" == typeof Object.is ? Object.is : function(t, e) {
                        return t === e && (0 !== t || 1 / t == 1 / e) || t != t && e != e
                    },
                    ar = Object.prototype.hasOwnProperty;

                function lr(t, e) {
                    if (sr(t, e)) return !0;
                    if ("object" != typeof t || null === t || "object" != typeof e || null === e) return !1;
                    var n = Object.keys(t),
                        r = Object.keys(e);
                    if (n.length !== r.length) return !1;
                    for (r = 0; r < n.length; r++)
                        if (!ar.call(e, n[r]) || !sr(t[n[r]], e[n[r]])) return !1;
                    return !0
                }

                function ur(t) {
                    for (; t && t.firstChild;) t = t.firstChild;
                    return t
                }

                function hr(t, e) {
                    var n, r = ur(t);
                    for (t = 0; r;) {
                        if (3 === r.nodeType) {
                            if (n = t + r.textContent.length, t <= e && n >= e) return {
                                node: r,
                                offset: e - t
                            };
                            t = n
                        }
                        t: {
                            for (; r;) {
                                if (r.nextSibling) {
                                    r = r.nextSibling;
                                    break t
                                }
                                r = r.parentNode
                            }
                            r = void 0
                        }
                        r = ur(r)
                    }
                }

                function cr(t, e) {
                    return !(!t || !e) && (t === e || (!t || 3 !== t.nodeType) && (e && 3 === e.nodeType ? cr(t, e.parentNode) : "contains" in t ? t.contains(e) : !!t.compareDocumentPosition && !!(16 & t.compareDocumentPosition(e))))
                }

                function dr() {
                    for (var t = window, e = Q(); e instanceof t.HTMLIFrameElement;) {
                        try {
                            var n = "string" == typeof e.contentWindow.location.href
                        } catch (t) {
                            n = !1
                        }
                        if (!n) break;
                        e = Q((t = e.contentWindow).document)
                    }
                    return e
                }

                function pr(t) {
                    var e = t && t.nodeName && t.nodeName.toLowerCase();
                    return e && ("input" === e && ("text" === t.type || "search" === t.type || "tel" === t.type || "url" === t.type || "password" === t.type) || "textarea" === e || "true" === t.contentEditable)
                }
                var fr = c && "documentMode" in document && 11 >= document.documentMode,
                    mr = null,
                    gr = null,
                    vr = null,
                    _r = !1;

                function yr(t, e, n) {
                    var r = n.window === n ? n.document : 9 === n.nodeType ? n : n.ownerDocument;
                    _r || null == mr || mr !== Q(r) || (r = "selectionStart" in (r = mr) && pr(r) ? {
                        start: r.selectionStart,
                        end: r.selectionEnd
                    } : {
                        anchorNode: (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection()).anchorNode,
                        anchorOffset: r.anchorOffset,
                        focusNode: r.focusNode,
                        focusOffset: r.focusOffset
                    }, vr && lr(vr, r) || (vr = r, 0 < (r = Lr(gr, "onSelect")).length && (e = new dn("onSelect", "select", null, e, n), t.push({
                        event: e,
                        listeners: r
                    }), e.target = mr)))
                }
                Ne("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "), 0), Ne("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1), Ne(Le, 2);
                for (var xr = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), br = 0; br < xr.length; br++) Oe.set(xr[br], 0);
                h("onMouseEnter", ["mouseout", "mouseover"]), h("onMouseLeave", ["mouseout", "mouseover"]), h("onPointerEnter", ["pointerout", "pointerover"]), h("onPointerLeave", ["pointerout", "pointerover"]), u("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), u("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), u("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), u("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), u("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), u("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
                var Er = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
                    Tr = new Set("cancel close invalid load scroll toggle".split(" ").concat(Er));

                function Sr(t, e, n) {
                    var r = t.type || "unknown-event";
                    t.currentTarget = n,
                        function(t, e, n, r, i, o, a, l, u) {
                            if (qt.apply(this, arguments), Vt) {
                                if (!Vt) throw Error(s(198));
                                var h = Wt;
                                Vt = !1, Wt = null, Xt || (Xt = !0, jt = h)
                            }
                        }(r, e, void 0, t), t.currentTarget = null
                }

                function wr(t, e) {
                    e = 0 != (4 & e);
                    for (var n = 0; n < t.length; n++) {
                        var r = t[n],
                            i = r.event;
                        r = r.listeners;
                        t: {
                            var o = void 0;
                            if (e)
                                for (var s = r.length - 1; 0 <= s; s--) {
                                    var a = r[s],
                                        l = a.instance,
                                        u = a.currentTarget;
                                    if (a = a.listener, l !== o && i.isPropagationStopped()) break t;
                                    Sr(i, a, u), o = l
                                } else
                                    for (s = 0; s < r.length; s++) {
                                        if (l = (a = r[s]).instance, u = a.currentTarget, a = a.listener, l !== o && i.isPropagationStopped()) break t;
                                        Sr(i, a, u), o = l
                                    }
                        }
                    }
                    if (Xt) throw t = jt, Xt = !1, jt = null, t
                }

                function Mr(t, e) {
                    var n = ni(e),
                        r = t + "__bubble";
                    n.has(r) || (Ir(e, t, 2, !1), n.add(r))
                }
                var Ar = "_reactListening" + Math.random().toString(36).slice(2);

                function Rr(t) {
                    t[Ar] || (t[Ar] = !0, a.forEach((function(e) {
                        Tr.has(e) || Pr(e, !1, t, null), Pr(e, !0, t, null)
                    })))
                }

                function Pr(t, e, n, r) {
                    var i = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0,
                        o = n;
                    if ("selectionchange" === t && 9 !== n.nodeType && (o = n.ownerDocument), null !== r && !e && Tr.has(t)) {
                        if ("scroll" !== t) return;
                        i |= 2, o = r
                    }
                    var s = ni(o),
                        a = t + "__" + (e ? "capture" : "bubble");
                    s.has(a) || (e && (i |= 4), Ir(o, t, i, e), s.add(a))
                }

                function Ir(t, e, n, r) {
                    var i = Oe.get(e);
                    switch (void 0 === i ? 2 : i) {
                        case 0:
                            i = Ze;
                            break;
                        case 1:
                            i = Ke;
                            break;
                        default:
                            i = Je
                    }
                    n = i.bind(null, e, n, t), i = void 0, !Gt || "touchstart" !== e && "touchmove" !== e && "wheel" !== e || (i = !0), r ? void 0 !== i ? t.addEventListener(e, n, {
                        capture: !0,
                        passive: i
                    }) : t.addEventListener(e, n, !0) : void 0 !== i ? t.addEventListener(e, n, {
                        passive: i
                    }) : t.addEventListener(e, n, !1)
                }

                function Cr(t, e, n, r, i) {
                    var o = r;
                    if (0 == (1 & e) && 0 == (2 & e) && null !== r) t: for (;;) {
                        if (null === r) return;
                        var s = r.tag;
                        if (3 === s || 4 === s) {
                            var a = r.stateNode.containerInfo;
                            if (a === i || 8 === a.nodeType && a.parentNode === i) break;
                            if (4 === s)
                                for (s = r.return; null !== s;) {
                                    var l = s.tag;
                                    if ((3 === l || 4 === l) && ((l = s.stateNode.containerInfo) === i || 8 === l.nodeType && l.parentNode === i)) return;
                                    s = s.return
                                }
                            for (; null !== a;) {
                                if (null === (s = Qr(a))) return;
                                if (5 === (l = s.tag) || 6 === l) {
                                    r = o = s;
                                    continue t
                                }
                                a = a.parentNode
                            }
                        }
                        r = r.return
                    }! function(t, e, n) {
                        if (Ft) return t();
                        Ft = !0;
                        try {
                            Dt(t, e, n)
                        } finally {
                            Ft = !1, Bt()
                        }
                    }((function() {
                        var r = o,
                            i = wt(n),
                            s = [];
                        t: {
                            var a = Ce.get(t);
                            if (void 0 !== a) {
                                var l = dn,
                                    u = t;
                                switch (t) {
                                    case "keypress":
                                        if (0 === rn(n)) break t;
                                    case "keydown":
                                    case "keyup":
                                        l = An;
                                        break;
                                    case "focusin":
                                        u = "focus", l = _n;
                                        break;
                                    case "focusout":
                                        u = "blur", l = _n;
                                        break;
                                    case "beforeblur":
                                    case "afterblur":
                                        l = _n;
                                        break;
                                    case "click":
                                        if (2 === n.button) break t;
                                    case "auxclick":
                                    case "dblclick":
                                    case "mousedown":
                                    case "mousemove":
                                    case "mouseup":
                                    case "mouseout":
                                    case "mouseover":
                                    case "contextmenu":
                                        l = gn;
                                        break;
                                    case "drag":
                                    case "dragend":
                                    case "dragenter":
                                    case "dragexit":
                                    case "dragleave":
                                    case "dragover":
                                    case "dragstart":
                                    case "drop":
                                        l = vn;
                                        break;
                                    case "touchcancel":
                                    case "touchend":
                                    case "touchmove":
                                    case "touchstart":
                                        l = Pn;
                                        break;
                                    case Ae:
                                    case Re:
                                    case Pe:
                                        l = yn;
                                        break;
                                    case Ie:
                                        l = In;
                                        break;
                                    case "scroll":
                                        l = fn;
                                        break;
                                    case "wheel":
                                        l = Cn;
                                        break;
                                    case "copy":
                                    case "cut":
                                    case "paste":
                                        l = xn;
                                        break;
                                    case "gotpointercapture":
                                    case "lostpointercapture":
                                    case "pointercancel":
                                    case "pointerdown":
                                    case "pointermove":
                                    case "pointerout":
                                    case "pointerover":
                                    case "pointerup":
                                        l = Rn
                                }
                                var h = 0 != (4 & e),
                                    c = !h && "scroll" === t,
                                    d = h ? null !== a ? a + "Capture" : null : a;
                                h = [];
                                for (var p, f = r; null !== f;) {
                                    var m = (p = f).stateNode;
                                    if (5 === p.tag && null !== m && (p = m, null !== d && null != (m = kt(f, d)) && h.push(Or(f, m, p))), c) break;
                                    f = f.return
                                }
                                0 < h.length && (a = new l(a, u, null, n, i), s.push({
                                    event: a,
                                    listeners: h
                                }))
                            }
                        }
                        if (0 == (7 & e)) {
                            if (l = "mouseout" === t || "pointerout" === t, (!(a = "mouseover" === t || "pointerover" === t) || 0 != (16 & e) || !(u = n.relatedTarget || n.fromElement) || !Qr(u) && !u[Kr]) && (l || a) && (a = i.window === i ? i : (a = i.ownerDocument) ? a.defaultView || a.parentWindow : window, l ? (l = r, null !== (u = (u = n.relatedTarget || n.toElement) ? Qr(u) : null) && (u !== (c = Zt(u)) || 5 !== u.tag && 6 !== u.tag) && (u = null)) : (l = null, u = r), l !== u)) {
                                if (h = gn, m = "onMouseLeave", d = "onMouseEnter", f = "mouse", "pointerout" !== t && "pointerover" !== t || (h = Rn, m = "onPointerLeave", d = "onPointerEnter", f = "pointer"), c = null == l ? a : ti(l), p = null == u ? a : ti(u), (a = new h(m, f + "leave", l, n, i)).target = c, a.relatedTarget = p, m = null, Qr(i) === r && ((h = new h(d, f + "enter", u, n, i)).target = p, h.relatedTarget = c, m = h), c = m, l && u) t: {
                                    for (d = u, f = 0, p = h = l; p; p = Nr(p)) f++;
                                    for (p = 0, m = d; m; m = Nr(m)) p++;
                                    for (; 0 < f - p;) h = Nr(h),
                                    f--;
                                    for (; 0 < p - f;) d = Nr(d),
                                    p--;
                                    for (; f--;) {
                                        if (h === d || null !== d && h === d.alternate) break t;
                                        h = Nr(h), d = Nr(d)
                                    }
                                    h = null
                                }
                                else h = null;
                                null !== l && Dr(s, a, l, h, !1), null !== u && null !== c && Dr(s, c, u, h, !0)
                            }
                            if ("select" === (l = (a = r ? ti(r) : window).nodeName && a.nodeName.toLowerCase()) || "input" === l && "file" === a.type) var g = Zn;
                            else if (Vn(a))
                                if (Kn) g = or;
                                else {
                                    g = rr;
                                    var v = nr
                                }
                            else(l = a.nodeName) && "input" === l.toLowerCase() && ("checkbox" === a.type || "radio" === a.type) && (g = ir);
                            switch (g && (g = g(t, r)) ? Wn(s, g, n, i) : (v && v(t, a, r), "focusout" === t && (v = a._wrapperState) && v.controlled && "number" === a.type && it(a, "number", a.value)), v = r ? ti(r) : window, t) {
                                case "focusin":
                                    (Vn(v) || "true" === v.contentEditable) && (mr = v, gr = r, vr = null);
                                    break;
                                case "focusout":
                                    vr = gr = mr = null;
                                    break;
                                case "mousedown":
                                    _r = !0;
                                    break;
                                case "contextmenu":
                                case "mouseup":
                                case "dragend":
                                    _r = !1, yr(s, n, i);
                                    break;
                                case "selectionchange":
                                    if (fr) break;
                                case "keydown":
                                case "keyup":
                                    yr(s, n, i)
                            }
                            var _;
                            if (Ln) t: {
                                switch (t) {
                                    case "compositionstart":
                                        var y = "onCompositionStart";
                                        break t;
                                    case "compositionend":
                                        y = "onCompositionEnd";
                                        break t;
                                    case "compositionupdate":
                                        y = "onCompositionUpdate";
                                        break t
                                }
                                y = void 0
                            }
                            else Hn ? kn(t, n) && (y = "onCompositionEnd") : "keydown" === t && 229 === n.keyCode && (y = "onCompositionStart");
                            y && (Un && "ko" !== n.locale && (Hn || "onCompositionStart" !== y ? "onCompositionEnd" === y && Hn && (_ = nn()) : (tn = "value" in ($e = i) ? $e.value : $e.textContent, Hn = !0)), 0 < (v = Lr(r, y)).length && (y = new bn(y, t, null, n, i), s.push({
                                event: y,
                                listeners: v
                            }), (_ || null !== (_ = Gn(n))) && (y.data = _))), (_ = Dn ? function(t, e) {
                                switch (t) {
                                    case "compositionend":
                                        return Gn(e);
                                    case "keypress":
                                        return 32 !== e.which ? null : (Bn = !0, Fn);
                                    case "textInput":
                                        return (t = e.data) === Fn && Bn ? null : t;
                                    default:
                                        return null
                                }
                            }(t, n) : function(t, e) {
                                if (Hn) return "compositionend" === t || !Ln && kn(t, e) ? (t = nn(), en = tn = $e = null, Hn = !1, t) : null;
                                switch (t) {
                                    case "paste":
                                        return null;
                                    case "keypress":
                                        if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
                                            if (e.char && 1 < e.char.length) return e.char;
                                            if (e.which) return String.fromCharCode(e.which)
                                        }
                                        return null;
                                    case "compositionend":
                                        return Un && "ko" !== e.locale ? null : e.data;
                                    default:
                                        return null
                                }
                            }(t, n)) && 0 < (r = Lr(r, "onBeforeInput")).length && (i = new bn("onBeforeInput", "beforeinput", null, n, i), s.push({
                                event: i,
                                listeners: r
                            }), i.data = _)
                        }
                        wr(s, e)
                    }))
                }

                function Or(t, e, n) {
                    return {
                        instance: t,
                        listener: e,
                        currentTarget: n
                    }
                }

                function Lr(t, e) {
                    for (var n = e + "Capture", r = []; null !== t;) {
                        var i = t,
                            o = i.stateNode;
                        5 === i.tag && null !== o && (i = o, null != (o = kt(t, n)) && r.unshift(Or(t, o, i)), null != (o = kt(t, e)) && r.push(Or(t, o, i))), t = t.return
                    }
                    return r
                }

                function Nr(t) {
                    if (null === t) return null;
                    do {
                        t = t.return
                    } while (t && 5 !== t.tag);
                    return t || null
                }

                function Dr(t, e, n, r, i) {
                    for (var o = e._reactName, s = []; null !== n && n !== r;) {
                        var a = n,
                            l = a.alternate,
                            u = a.stateNode;
                        if (null !== l && l === r) break;
                        5 === a.tag && null !== u && (a = u, i ? null != (l = kt(n, o)) && s.unshift(Or(n, l, a)) : i || null != (l = kt(n, o)) && s.push(Or(n, l, a))), n = n.return
                    }
                    0 !== s.length && t.push({
                        event: e,
                        listeners: s
                    })
                }

                function Ur() {}
                var Fr = null,
                    Br = null;

                function kr(t, e) {
                    switch (t) {
                        case "button":
                        case "input":
                        case "select":
                        case "textarea":
                            return !!e.autoFocus
                    }
                    return !1
                }

                function Gr(t, e) {
                    return "textarea" === t || "option" === t || "noscript" === t || "string" == typeof e.children || "number" == typeof e.children || "object" == typeof e.dangerouslySetInnerHTML && null !== e.dangerouslySetInnerHTML && null != e.dangerouslySetInnerHTML.__html
                }
                var Hr = "function" == typeof setTimeout ? setTimeout : void 0,
                    zr = "function" == typeof clearTimeout ? clearTimeout : void 0;

                function Vr(t) {
                    (1 === t.nodeType || 9 === t.nodeType && null != (t = t.body)) && (t.textContent = "")
                }

                function Wr(t) {
                    for (; null != t; t = t.nextSibling) {
                        var e = t.nodeType;
                        if (1 === e || 3 === e) break
                    }
                    return t
                }

                function Xr(t) {
                    t = t.previousSibling;
                    for (var e = 0; t;) {
                        if (8 === t.nodeType) {
                            var n = t.data;
                            if ("$" === n || "$!" === n || "$?" === n) {
                                if (0 === e) return t;
                                e--
                            } else "/$" === n && e++
                        }
                        t = t.previousSibling
                    }
                    return null
                }
                var jr = 0,
                    Yr = Math.random().toString(36).slice(2),
                    qr = "__reactFiber$" + Yr,
                    Zr = "__reactProps$" + Yr,
                    Kr = "__reactContainer$" + Yr,
                    Jr = "__reactEvents$" + Yr;

                function Qr(t) {
                    var e = t[qr];
                    if (e) return e;
                    for (var n = t.parentNode; n;) {
                        if (e = n[Kr] || n[qr]) {
                            if (n = e.alternate, null !== e.child || null !== n && null !== n.child)
                                for (t = Xr(t); null !== t;) {
                                    if (n = t[qr]) return n;
                                    t = Xr(t)
                                }
                            return e
                        }
                        n = (t = n).parentNode
                    }
                    return null
                }

                function $r(t) {
                    return !(t = t[qr] || t[Kr]) || 5 !== t.tag && 6 !== t.tag && 13 !== t.tag && 3 !== t.tag ? null : t
                }

                function ti(t) {
                    if (5 === t.tag || 6 === t.tag) return t.stateNode;
                    throw Error(s(33))
                }

                function ei(t) {
                    return t[Zr] || null
                }

                function ni(t) {
                    var e = t[Jr];
                    return void 0 === e && (e = t[Jr] = new Set), e
                }
                var ri = [],
                    ii = -1;

                function oi(t) {
                    return {
                        current: t
                    }
                }

                function si(t) {
                    0 > ii || (t.current = ri[ii], ri[ii] = null, ii--)
                }

                function ai(t, e) {
                    ii++, ri[ii] = t.current, t.current = e
                }
                var li = {},
                    ui = oi(li),
                    hi = oi(!1),
                    ci = li;

                function di(t, e) {
                    var n = t.type.contextTypes;
                    if (!n) return li;
                    var r = t.stateNode;
                    if (r && r.__reactInternalMemoizedUnmaskedChildContext === e) return r.__reactInternalMemoizedMaskedChildContext;
                    var i, o = {};
                    for (i in n) o[i] = e[i];
                    return r && ((t = t.stateNode).__reactInternalMemoizedUnmaskedChildContext = e, t.__reactInternalMemoizedMaskedChildContext = o), o
                }

                function pi(t) {
                    return null != t.childContextTypes
                }

                function fi() {
                    si(hi), si(ui)
                }

                function mi(t, e, n) {
                    if (ui.current !== li) throw Error(s(168));
                    ai(ui, e), ai(hi, n)
                }

                function gi(t, e, n) {
                    var r = t.stateNode;
                    if (t = e.childContextTypes, "function" != typeof r.getChildContext) return n;
                    for (var o in r = r.getChildContext())
                        if (!(o in t)) throw Error(s(108, Y(e) || "Unknown", o));
                    return i({}, n, r)
                }

                function vi(t) {
                    return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || li, ci = ui.current, ai(ui, t), ai(hi, hi.current), !0
                }

                function _i(t, e, n) {
                    var r = t.stateNode;
                    if (!r) throw Error(s(169));
                    n ? (t = gi(t, e, ci), r.__reactInternalMemoizedMergedChildContext = t, si(hi), si(ui), ai(ui, t)) : si(hi), ai(hi, n)
                }
                var yi = null,
                    xi = null,
                    bi = o.unstable_runWithPriority,
                    Ei = o.unstable_scheduleCallback,
                    Ti = o.unstable_cancelCallback,
                    Si = o.unstable_shouldYield,
                    wi = o.unstable_requestPaint,
                    Mi = o.unstable_now,
                    Ai = o.unstable_getCurrentPriorityLevel,
                    Ri = o.unstable_ImmediatePriority,
                    Pi = o.unstable_UserBlockingPriority,
                    Ii = o.unstable_NormalPriority,
                    Ci = o.unstable_LowPriority,
                    Oi = o.unstable_IdlePriority,
                    Li = {},
                    Ni = void 0 !== wi ? wi : function() {},
                    Di = null,
                    Ui = null,
                    Fi = !1,
                    Bi = Mi(),
                    ki = 1e4 > Bi ? Mi : function() {
                        return Mi() - Bi
                    };

                function Gi() {
                    switch (Ai()) {
                        case Ri:
                            return 99;
                        case Pi:
                            return 98;
                        case Ii:
                            return 97;
                        case Ci:
                            return 96;
                        case Oi:
                            return 95;
                        default:
                            throw Error(s(332))
                    }
                }

                function Hi(t) {
                    switch (t) {
                        case 99:
                            return Ri;
                        case 98:
                            return Pi;
                        case 97:
                            return Ii;
                        case 96:
                            return Ci;
                        case 95:
                            return Oi;
                        default:
                            throw Error(s(332))
                    }
                }

                function zi(t, e) {
                    return t = Hi(t), bi(t, e)
                }

                function Vi(t, e, n) {
                    return t = Hi(t), Ei(t, e, n)
                }

                function Wi() {
                    if (null !== Ui) {
                        var t = Ui;
                        Ui = null, Ti(t)
                    }
                    Xi()
                }

                function Xi() {
                    if (!Fi && null !== Di) {
                        Fi = !0;
                        var t = 0;
                        try {
                            var e = Di;
                            zi(99, (function() {
                                for (; t < e.length; t++) {
                                    var n = e[t];
                                    do {
                                        n = n(!0)
                                    } while (null !== n)
                                }
                            })), Di = null
                        } catch (e) {
                            throw null !== Di && (Di = Di.slice(t + 1)), Ei(Ri, Wi), e
                        } finally {
                            Fi = !1
                        }
                    }
                }
                var ji = b.ReactCurrentBatchConfig;

                function Yi(t, e) {
                    if (t && t.defaultProps) {
                        for (var n in e = i({}, e), t = t.defaultProps) void 0 === e[n] && (e[n] = t[n]);
                        return e
                    }
                    return e
                }
                var qi = oi(null),
                    Zi = null,
                    Ki = null,
                    Ji = null;

                function Qi() {
                    Ji = Ki = Zi = null
                }

                function $i(t) {
                    var e = qi.current;
                    si(qi), t.type._context._currentValue = e
                }

                function to(t, e) {
                    for (; null !== t;) {
                        var n = t.alternate;
                        if ((t.childLanes & e) === e) {
                            if (null === n || (n.childLanes & e) === e) break;
                            n.childLanes |= e
                        } else t.childLanes |= e, null !== n && (n.childLanes |= e);
                        t = t.return
                    }
                }

                function eo(t, e) {
                    Zi = t, Ji = Ki = null, null !== (t = t.dependencies) && null !== t.firstContext && (0 != (t.lanes & e) && (Ls = !0), t.firstContext = null)
                }

                function no(t, e) {
                    if (Ji !== t && !1 !== e && 0 !== e)
                        if ("number" == typeof e && 1073741823 !== e || (Ji = t, e = 1073741823), e = {
                                context: t,
                                observedBits: e,
                                next: null
                            }, null === Ki) {
                            if (null === Zi) throw Error(s(308));
                            Ki = e, Zi.dependencies = {
                                lanes: 0,
                                firstContext: e,
                                responders: null
                            }
                        } else Ki = Ki.next = e;
                    return t._currentValue
                }
                var ro = !1;

                function io(t) {
                    t.updateQueue = {
                        baseState: t.memoizedState,
                        firstBaseUpdate: null,
                        lastBaseUpdate: null,
                        shared: {
                            pending: null
                        },
                        effects: null
                    }
                }

                function oo(t, e) {
                    t = t.updateQueue, e.updateQueue === t && (e.updateQueue = {
                        baseState: t.baseState,
                        firstBaseUpdate: t.firstBaseUpdate,
                        lastBaseUpdate: t.lastBaseUpdate,
                        shared: t.shared,
                        effects: t.effects
                    })
                }

                function so(t, e) {
                    return {
                        eventTime: t,
                        lane: e,
                        tag: 0,
                        payload: null,
                        callback: null,
                        next: null
                    }
                }

                function ao(t, e) {
                    if (null !== (t = t.updateQueue)) {
                        var n = (t = t.shared).pending;
                        null === n ? e.next = e : (e.next = n.next, n.next = e), t.pending = e
                    }
                }

                function lo(t, e) {
                    var n = t.updateQueue,
                        r = t.alternate;
                    if (null !== r && n === (r = r.updateQueue)) {
                        var i = null,
                            o = null;
                        if (null !== (n = n.firstBaseUpdate)) {
                            do {
                                var s = {
                                    eventTime: n.eventTime,
                                    lane: n.lane,
                                    tag: n.tag,
                                    payload: n.payload,
                                    callback: n.callback,
                                    next: null
                                };
                                null === o ? i = o = s : o = o.next = s, n = n.next
                            } while (null !== n);
                            null === o ? i = o = e : o = o.next = e
                        } else i = o = e;
                        return n = {
                            baseState: r.baseState,
                            firstBaseUpdate: i,
                            lastBaseUpdate: o,
                            shared: r.shared,
                            effects: r.effects
                        }, void(t.updateQueue = n)
                    }
                    null === (t = n.lastBaseUpdate) ? n.firstBaseUpdate = e : t.next = e, n.lastBaseUpdate = e
                }

                function uo(t, e, n, r) {
                    var o = t.updateQueue;
                    ro = !1;
                    var s = o.firstBaseUpdate,
                        a = o.lastBaseUpdate,
                        l = o.shared.pending;
                    if (null !== l) {
                        o.shared.pending = null;
                        var u = l,
                            h = u.next;
                        u.next = null, null === a ? s = h : a.next = h, a = u;
                        var c = t.alternate;
                        if (null !== c) {
                            var d = (c = c.updateQueue).lastBaseUpdate;
                            d !== a && (null === d ? c.firstBaseUpdate = h : d.next = h, c.lastBaseUpdate = u)
                        }
                    }
                    if (null !== s) {
                        for (d = o.baseState, a = 0, c = h = u = null;;) {
                            l = s.lane;
                            var p = s.eventTime;
                            if ((r & l) === l) {
                                null !== c && (c = c.next = {
                                    eventTime: p,
                                    lane: 0,
                                    tag: s.tag,
                                    payload: s.payload,
                                    callback: s.callback,
                                    next: null
                                });
                                t: {
                                    var f = t,
                                        m = s;
                                    switch (l = e, p = n, m.tag) {
                                        case 1:
                                            if ("function" == typeof(f = m.payload)) {
                                                d = f.call(p, d, l);
                                                break t
                                            }
                                            d = f;
                                            break t;
                                        case 3:
                                            f.flags = -4097 & f.flags | 64;
                                        case 0:
                                            if (null == (l = "function" == typeof(f = m.payload) ? f.call(p, d, l) : f)) break t;
                                            d = i({}, d, l);
                                            break t;
                                        case 2:
                                            ro = !0
                                    }
                                }
                                null !== s.callback && (t.flags |= 32, null === (l = o.effects) ? o.effects = [s] : l.push(s))
                            } else p = {
                                eventTime: p,
                                lane: l,
                                tag: s.tag,
                                payload: s.payload,
                                callback: s.callback,
                                next: null
                            }, null === c ? (h = c = p, u = d) : c = c.next = p, a |= l;
                            if (null === (s = s.next)) {
                                if (null === (l = o.shared.pending)) break;
                                s = l.next, l.next = null, o.lastBaseUpdate = l, o.shared.pending = null
                            }
                        }
                        null === c && (u = d), o.baseState = u, o.firstBaseUpdate = h, o.lastBaseUpdate = c, Da |= a, t.lanes = a, t.memoizedState = d
                    }
                }

                function ho(t, e, n) {
                    if (t = e.effects, e.effects = null, null !== t)
                        for (e = 0; e < t.length; e++) {
                            var r = t[e],
                                i = r.callback;
                            if (null !== i) {
                                if (r.callback = null, r = n, "function" != typeof i) throw Error(s(191, i));
                                i.call(r)
                            }
                        }
                }
                var co = (new r.Component).refs;

                function po(t, e, n, r) {
                    n = null == (n = n(r, e = t.memoizedState)) ? e : i({}, e, n), t.memoizedState = n, 0 === t.lanes && (t.updateQueue.baseState = n)
                }
                var fo = {
                    isMounted: function(t) {
                        return !!(t = t._reactInternals) && Zt(t) === t
                    },
                    enqueueSetState: function(t, e, n) {
                        t = t._reactInternals;
                        var r = sl(),
                            i = al(t),
                            o = so(r, i);
                        o.payload = e, null != n && (o.callback = n), ao(t, o), ll(t, i, r)
                    },
                    enqueueReplaceState: function(t, e, n) {
                        t = t._reactInternals;
                        var r = sl(),
                            i = al(t),
                            o = so(r, i);
                        o.tag = 1, o.payload = e, null != n && (o.callback = n), ao(t, o), ll(t, i, r)
                    },
                    enqueueForceUpdate: function(t, e) {
                        t = t._reactInternals;
                        var n = sl(),
                            r = al(t),
                            i = so(n, r);
                        i.tag = 2, null != e && (i.callback = e), ao(t, i), ll(t, r, n)
                    }
                };

                function mo(t, e, n, r, i, o, s) {
                    return "function" == typeof(t = t.stateNode).shouldComponentUpdate ? t.shouldComponentUpdate(r, o, s) : !(e.prototype && e.prototype.isPureReactComponent && lr(n, r) && lr(i, o))
                }

                function go(t, e, n) {
                    var r = !1,
                        i = li,
                        o = e.contextType;
                    return "object" == typeof o && null !== o ? o = no(o) : (i = pi(e) ? ci : ui.current, o = (r = null != (r = e.contextTypes)) ? di(t, i) : li), e = new e(n, o), t.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, e.updater = fo, t.stateNode = e, e._reactInternals = t, r && ((t = t.stateNode).__reactInternalMemoizedUnmaskedChildContext = i, t.__reactInternalMemoizedMaskedChildContext = o), e
                }

                function vo(t, e, n, r) {
                    t = e.state, "function" == typeof e.componentWillReceiveProps && e.componentWillReceiveProps(n, r), "function" == typeof e.UNSAFE_componentWillReceiveProps && e.UNSAFE_componentWillReceiveProps(n, r), e.state !== t && fo.enqueueReplaceState(e, e.state, null)
                }

                function _o(t, e, n, r) {
                    var i = t.stateNode;
                    i.props = n, i.state = t.memoizedState, i.refs = co, io(t);
                    var o = e.contextType;
                    "object" == typeof o && null !== o ? i.context = no(o) : (o = pi(e) ? ci : ui.current, i.context = di(t, o)), uo(t, n, i, r), i.state = t.memoizedState, "function" == typeof(o = e.getDerivedStateFromProps) && (po(t, e, o, n), i.state = t.memoizedState), "function" == typeof e.getDerivedStateFromProps || "function" == typeof i.getSnapshotBeforeUpdate || "function" != typeof i.UNSAFE_componentWillMount && "function" != typeof i.componentWillMount || (e = i.state, "function" == typeof i.componentWillMount && i.componentWillMount(), "function" == typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount(), e !== i.state && fo.enqueueReplaceState(i, i.state, null), uo(t, n, i, r), i.state = t.memoizedState), "function" == typeof i.componentDidMount && (t.flags |= 4)
                }
                var yo = Array.isArray;

                function xo(t, e, n) {
                    if (null !== (t = n.ref) && "function" != typeof t && "object" != typeof t) {
                        if (n._owner) {
                            if (n = n._owner) {
                                if (1 !== n.tag) throw Error(s(309));
                                var r = n.stateNode
                            }
                            if (!r) throw Error(s(147, t));
                            var i = "" + t;
                            return null !== e && null !== e.ref && "function" == typeof e.ref && e.ref._stringRef === i ? e.ref : ((e = function(t) {
                                var e = r.refs;
                                e === co && (e = r.refs = {}), null === t ? delete e[i] : e[i] = t
                            })._stringRef = i, e)
                        }
                        if ("string" != typeof t) throw Error(s(284));
                        if (!n._owner) throw Error(s(290, t))
                    }
                    return t
                }

                function bo(t, e) {
                    if ("textarea" !== t.type) throw Error(s(31, "[object Object]" === Object.prototype.toString.call(e) ? "object with keys {" + Object.keys(e).join(", ") + "}" : e))
                }

                function Eo(t) {
                    function e(e, n) {
                        if (t) {
                            var r = e.lastEffect;
                            null !== r ? (r.nextEffect = n, e.lastEffect = n) : e.firstEffect = e.lastEffect = n, n.nextEffect = null, n.flags = 8
                        }
                    }

                    function n(n, r) {
                        if (!t) return null;
                        for (; null !== r;) e(n, r), r = r.sibling;
                        return null
                    }

                    function r(t, e) {
                        for (t = new Map; null !== e;) null !== e.key ? t.set(e.key, e) : t.set(e.index, e), e = e.sibling;
                        return t
                    }

                    function i(t, e) {
                        return (t = Gl(t, e)).index = 0, t.sibling = null, t
                    }

                    function o(e, n, r) {
                        return e.index = r, t ? null !== (r = e.alternate) ? (r = r.index) < n ? (e.flags = 2, n) : r : (e.flags = 2, n) : n
                    }

                    function a(e) {
                        return t && null === e.alternate && (e.flags = 2), e
                    }

                    function l(t, e, n, r) {
                        return null === e || 6 !== e.tag ? ((e = Wl(n, t.mode, r)).return = t, e) : ((e = i(e, n)).return = t, e)
                    }

                    function u(t, e, n, r) {
                        return null !== e && e.elementType === n.type ? ((r = i(e, n.props)).ref = xo(t, e, n), r.return = t, r) : ((r = Hl(n.type, n.key, n.props, null, t.mode, r)).ref = xo(t, e, n), r.return = t, r)
                    }

                    function h(t, e, n, r) {
                        return null === e || 4 !== e.tag || e.stateNode.containerInfo !== n.containerInfo || e.stateNode.implementation !== n.implementation ? ((e = Xl(n, t.mode, r)).return = t, e) : ((e = i(e, n.children || [])).return = t, e)
                    }

                    function c(t, e, n, r, o) {
                        return null === e || 7 !== e.tag ? ((e = zl(n, t.mode, r, o)).return = t, e) : ((e = i(e, n)).return = t, e)
                    }

                    function d(t, e, n) {
                        if ("string" == typeof e || "number" == typeof e) return (e = Wl("" + e, t.mode, n)).return = t, e;
                        if ("object" == typeof e && null !== e) {
                            switch (e.$$typeof) {
                                case E:
                                    return (n = Hl(e.type, e.key, e.props, null, t.mode, n)).ref = xo(t, null, e), n.return = t, n;
                                case T:
                                    return (e = Xl(e, t.mode, n)).return = t, e
                            }
                            if (yo(e) || z(e)) return (e = zl(e, t.mode, n, null)).return = t, e;
                            bo(t, e)
                        }
                        return null
                    }

                    function p(t, e, n, r) {
                        var i = null !== e ? e.key : null;
                        if ("string" == typeof n || "number" == typeof n) return null !== i ? null : l(t, e, "" + n, r);
                        if ("object" == typeof n && null !== n) {
                            switch (n.$$typeof) {
                                case E:
                                    return n.key === i ? n.type === S ? c(t, e, n.props.children, r, i) : u(t, e, n, r) : null;
                                case T:
                                    return n.key === i ? h(t, e, n, r) : null
                            }
                            if (yo(n) || z(n)) return null !== i ? null : c(t, e, n, r, null);
                            bo(t, n)
                        }
                        return null
                    }

                    function f(t, e, n, r, i) {
                        if ("string" == typeof r || "number" == typeof r) return l(e, t = t.get(n) || null, "" + r, i);
                        if ("object" == typeof r && null !== r) {
                            switch (r.$$typeof) {
                                case E:
                                    return t = t.get(null === r.key ? n : r.key) || null, r.type === S ? c(e, t, r.props.children, i, r.key) : u(e, t, r, i);
                                case T:
                                    return h(e, t = t.get(null === r.key ? n : r.key) || null, r, i)
                            }
                            if (yo(r) || z(r)) return c(e, t = t.get(n) || null, r, i, null);
                            bo(e, r)
                        }
                        return null
                    }

                    function m(i, s, a, l) {
                        for (var u = null, h = null, c = s, m = s = 0, g = null; null !== c && m < a.length; m++) {
                            c.index > m ? (g = c, c = null) : g = c.sibling;
                            var v = p(i, c, a[m], l);
                            if (null === v) {
                                null === c && (c = g);
                                break
                            }
                            t && c && null === v.alternate && e(i, c), s = o(v, s, m), null === h ? u = v : h.sibling = v, h = v, c = g
                        }
                        if (m === a.length) return n(i, c), u;
                        if (null === c) {
                            for (; m < a.length; m++) null !== (c = d(i, a[m], l)) && (s = o(c, s, m), null === h ? u = c : h.sibling = c, h = c);
                            return u
                        }
                        for (c = r(i, c); m < a.length; m++) null !== (g = f(c, i, m, a[m], l)) && (t && null !== g.alternate && c.delete(null === g.key ? m : g.key), s = o(g, s, m), null === h ? u = g : h.sibling = g, h = g);
                        return t && c.forEach((function(t) {
                            return e(i, t)
                        })), u
                    }

                    function g(i, a, l, u) {
                        var h = z(l);
                        if ("function" != typeof h) throw Error(s(150));
                        if (null == (l = h.call(l))) throw Error(s(151));
                        for (var c = h = null, m = a, g = a = 0, v = null, _ = l.next(); null !== m && !_.done; g++, _ = l.next()) {
                            m.index > g ? (v = m, m = null) : v = m.sibling;
                            var y = p(i, m, _.value, u);
                            if (null === y) {
                                null === m && (m = v);
                                break
                            }
                            t && m && null === y.alternate && e(i, m), a = o(y, a, g), null === c ? h = y : c.sibling = y, c = y, m = v
                        }
                        if (_.done) return n(i, m), h;
                        if (null === m) {
                            for (; !_.done; g++, _ = l.next()) null !== (_ = d(i, _.value, u)) && (a = o(_, a, g), null === c ? h = _ : c.sibling = _, c = _);
                            return h
                        }
                        for (m = r(i, m); !_.done; g++, _ = l.next()) null !== (_ = f(m, i, g, _.value, u)) && (t && null !== _.alternate && m.delete(null === _.key ? g : _.key), a = o(_, a, g), null === c ? h = _ : c.sibling = _, c = _);
                        return t && m.forEach((function(t) {
                            return e(i, t)
                        })), h
                    }
                    return function(t, r, o, l) {
                        var u = "object" == typeof o && null !== o && o.type === S && null === o.key;
                        u && (o = o.props.children);
                        var h = "object" == typeof o && null !== o;
                        if (h) switch (o.$$typeof) {
                            case E:
                                t: {
                                    for (h = o.key, u = r; null !== u;) {
                                        if (u.key === h) {
                                            switch (u.tag) {
                                                case 7:
                                                    if (o.type === S) {
                                                        n(t, u.sibling), (r = i(u, o.props.children)).return = t, t = r;
                                                        break t
                                                    }
                                                    break;
                                                default:
                                                    if (u.elementType === o.type) {
                                                        n(t, u.sibling), (r = i(u, o.props)).ref = xo(t, u, o), r.return = t, t = r;
                                                        break t
                                                    }
                                            }
                                            n(t, u);
                                            break
                                        }
                                        e(t, u), u = u.sibling
                                    }
                                    o.type === S ? ((r = zl(o.props.children, t.mode, l, o.key)).return = t, t = r) : ((l = Hl(o.type, o.key, o.props, null, t.mode, l)).ref = xo(t, r, o), l.return = t, t = l)
                                }
                                return a(t);
                            case T:
                                t: {
                                    for (u = o.key; null !== r;) {
                                        if (r.key === u) {
                                            if (4 === r.tag && r.stateNode.containerInfo === o.containerInfo && r.stateNode.implementation === o.implementation) {
                                                n(t, r.sibling), (r = i(r, o.children || [])).return = t, t = r;
                                                break t
                                            }
                                            n(t, r);
                                            break
                                        }
                                        e(t, r), r = r.sibling
                                    }(r = Xl(o, t.mode, l)).return = t,
                                    t = r
                                }
                                return a(t)
                        }
                        if ("string" == typeof o || "number" == typeof o) return o = "" + o, null !== r && 6 === r.tag ? (n(t, r.sibling), (r = i(r, o)).return = t, t = r) : (n(t, r), (r = Wl(o, t.mode, l)).return = t, t = r), a(t);
                        if (yo(o)) return m(t, r, o, l);
                        if (z(o)) return g(t, r, o, l);
                        if (h && bo(t, o), void 0 === o && !u) switch (t.tag) {
                            case 1:
                            case 22:
                            case 0:
                            case 11:
                            case 15:
                                throw Error(s(152, Y(t.type) || "Component"))
                        }
                        return n(t, r)
                    }
                }
                var To = Eo(!0),
                    So = Eo(!1),
                    wo = {},
                    Mo = oi(wo),
                    Ao = oi(wo),
                    Ro = oi(wo);

                function Po(t) {
                    if (t === wo) throw Error(s(174));
                    return t
                }

                function Io(t, e) {
                    switch (ai(Ro, e), ai(Ao, t), ai(Mo, wo), t = e.nodeType) {
                        case 9:
                        case 11:
                            e = (e = e.documentElement) ? e.namespaceURI : pt(null, "");
                            break;
                        default:
                            e = pt(e = (t = 8 === t ? e.parentNode : e).namespaceURI || null, t = t.tagName)
                    }
                    si(Mo), ai(Mo, e)
                }

                function Co() {
                    si(Mo), si(Ao), si(Ro)
                }

                function Oo(t) {
                    Po(Ro.current);
                    var e = Po(Mo.current),
                        n = pt(e, t.type);
                    e !== n && (ai(Ao, t), ai(Mo, n))
                }

                function Lo(t) {
                    Ao.current === t && (si(Mo), si(Ao))
                }
                var No = oi(0);

                function Do(t) {
                    for (var e = t; null !== e;) {
                        if (13 === e.tag) {
                            var n = e.memoizedState;
                            if (null !== n && (null === (n = n.dehydrated) || "$?" === n.data || "$!" === n.data)) return e
                        } else if (19 === e.tag && void 0 !== e.memoizedProps.revealOrder) {
                            if (0 != (64 & e.flags)) return e
                        } else if (null !== e.child) {
                            e.child.return = e, e = e.child;
                            continue
                        }
                        if (e === t) break;
                        for (; null === e.sibling;) {
                            if (null === e.return || e.return === t) return null;
                            e = e.return
                        }
                        e.sibling.return = e.return, e = e.sibling
                    }
                    return null
                }
                var Uo = null,
                    Fo = null,
                    Bo = !1;

                function ko(t, e) {
                    var n = Bl(5, null, null, 0);
                    n.elementType = "DELETED", n.type = "DELETED", n.stateNode = e, n.return = t, n.flags = 8, null !== t.lastEffect ? (t.lastEffect.nextEffect = n, t.lastEffect = n) : t.firstEffect = t.lastEffect = n
                }

                function Go(t, e) {
                    switch (t.tag) {
                        case 5:
                            var n = t.type;
                            return null !== (e = 1 !== e.nodeType || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e) && (t.stateNode = e, !0);
                        case 6:
                            return null !== (e = "" === t.pendingProps || 3 !== e.nodeType ? null : e) && (t.stateNode = e, !0);
                        case 13:
                        default:
                            return !1
                    }
                }

                function Ho(t) {
                    if (Bo) {
                        var e = Fo;
                        if (e) {
                            var n = e;
                            if (!Go(t, e)) {
                                if (!(e = Wr(n.nextSibling)) || !Go(t, e)) return t.flags = -1025 & t.flags | 2, Bo = !1, void(Uo = t);
                                ko(Uo, n)
                            }
                            Uo = t, Fo = Wr(e.firstChild)
                        } else t.flags = -1025 & t.flags | 2, Bo = !1, Uo = t
                    }
                }

                function zo(t) {
                    for (t = t.return; null !== t && 5 !== t.tag && 3 !== t.tag && 13 !== t.tag;) t = t.return;
                    Uo = t
                }

                function Vo(t) {
                    if (t !== Uo) return !1;
                    if (!Bo) return zo(t), Bo = !0, !1;
                    var e = t.type;
                    if (5 !== t.tag || "head" !== e && "body" !== e && !Gr(e, t.memoizedProps))
                        for (e = Fo; e;) ko(t, e), e = Wr(e.nextSibling);
                    if (zo(t), 13 === t.tag) {
                        if (!(t = null !== (t = t.memoizedState) ? t.dehydrated : null)) throw Error(s(317));
                        t: {
                            for (t = t.nextSibling, e = 0; t;) {
                                if (8 === t.nodeType) {
                                    var n = t.data;
                                    if ("/$" === n) {
                                        if (0 === e) {
                                            Fo = Wr(t.nextSibling);
                                            break t
                                        }
                                        e--
                                    } else "$" !== n && "$!" !== n && "$?" !== n || e++
                                }
                                t = t.nextSibling
                            }
                            Fo = null
                        }
                    } else Fo = Uo ? Wr(t.stateNode.nextSibling) : null;
                    return !0
                }

                function Wo() {
                    Fo = Uo = null, Bo = !1
                }
                var Xo = [];

                function jo() {
                    for (var t = 0; t < Xo.length; t++) Xo[t]._workInProgressVersionPrimary = null;
                    Xo.length = 0
                }
                var Yo = b.ReactCurrentDispatcher,
                    qo = b.ReactCurrentBatchConfig,
                    Zo = 0,
                    Ko = null,
                    Jo = null,
                    Qo = null,
                    $o = !1,
                    ts = !1;

                function es() {
                    throw Error(s(321))
                }

                function ns(t, e) {
                    if (null === e) return !1;
                    for (var n = 0; n < e.length && n < t.length; n++)
                        if (!sr(t[n], e[n])) return !1;
                    return !0
                }

                function rs(t, e, n, r, i, o) {
                    if (Zo = o, Ko = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, Yo.current = null === t || null === t.memoizedState ? Ps : Is, t = n(r, i), ts) {
                        o = 0;
                        do {
                            if (ts = !1, !(25 > o)) throw Error(s(301));
                            o += 1, Qo = Jo = null, e.updateQueue = null, Yo.current = Cs, t = n(r, i)
                        } while (ts)
                    }
                    if (Yo.current = Rs, e = null !== Jo && null !== Jo.next, Zo = 0, Qo = Jo = Ko = null, $o = !1, e) throw Error(s(300));
                    return t
                }

                function is() {
                    var t = {
                        memoizedState: null,
                        baseState: null,
                        baseQueue: null,
                        queue: null,
                        next: null
                    };
                    return null === Qo ? Ko.memoizedState = Qo = t : Qo = Qo.next = t, Qo
                }

                function os() {
                    if (null === Jo) {
                        var t = Ko.alternate;
                        t = null !== t ? t.memoizedState : null
                    } else t = Jo.next;
                    var e = null === Qo ? Ko.memoizedState : Qo.next;
                    if (null !== e) Qo = e, Jo = t;
                    else {
                        if (null === t) throw Error(s(310));
                        t = {
                            memoizedState: (Jo = t).memoizedState,
                            baseState: Jo.baseState,
                            baseQueue: Jo.baseQueue,
                            queue: Jo.queue,
                            next: null
                        }, null === Qo ? Ko.memoizedState = Qo = t : Qo = Qo.next = t
                    }
                    return Qo
                }

                function ss(t, e) {
                    return "function" == typeof e ? e(t) : e
                }

                function as(t) {
                    var e = os(),
                        n = e.queue;
                    if (null === n) throw Error(s(311));
                    n.lastRenderedReducer = t;
                    var r = Jo,
                        i = r.baseQueue,
                        o = n.pending;
                    if (null !== o) {
                        if (null !== i) {
                            var a = i.next;
                            i.next = o.next, o.next = a
                        }
                        r.baseQueue = i = o, n.pending = null
                    }
                    if (null !== i) {
                        i = i.next, r = r.baseState;
                        var l = a = o = null,
                            u = i;
                        do {
                            var h = u.lane;
                            if ((Zo & h) === h) null !== l && (l = l.next = {
                                lane: 0,
                                action: u.action,
                                eagerReducer: u.eagerReducer,
                                eagerState: u.eagerState,
                                next: null
                            }), r = u.eagerReducer === t ? u.eagerState : t(r, u.action);
                            else {
                                var c = {
                                    lane: h,
                                    action: u.action,
                                    eagerReducer: u.eagerReducer,
                                    eagerState: u.eagerState,
                                    next: null
                                };
                                null === l ? (a = l = c, o = r) : l = l.next = c, Ko.lanes |= h, Da |= h
                            }
                            u = u.next
                        } while (null !== u && u !== i);
                        null === l ? o = r : l.next = a, sr(r, e.memoizedState) || (Ls = !0), e.memoizedState = r, e.baseState = o, e.baseQueue = l, n.lastRenderedState = r
                    }
                    return [e.memoizedState, n.dispatch]
                }

                function ls(t) {
                    var e = os(),
                        n = e.queue;
                    if (null === n) throw Error(s(311));
                    n.lastRenderedReducer = t;
                    var r = n.dispatch,
                        i = n.pending,
                        o = e.memoizedState;
                    if (null !== i) {
                        n.pending = null;
                        var a = i = i.next;
                        do {
                            o = t(o, a.action), a = a.next
                        } while (a !== i);
                        sr(o, e.memoizedState) || (Ls = !0), e.memoizedState = o, null === e.baseQueue && (e.baseState = o), n.lastRenderedState = o
                    }
                    return [o, r]
                }

                function us(t, e, n) {
                    var r = e._getVersion;
                    r = r(e._source);
                    var i = e._workInProgressVersionPrimary;
                    if (null !== i ? t = i === r : (t = t.mutableReadLanes, (t = (Zo & t) === t) && (e._workInProgressVersionPrimary = r, Xo.push(e))), t) return n(e._source);
                    throw Xo.push(e), Error(s(350))
                }

                function hs(t, e, n, r) {
                    var i = Aa;
                    if (null === i) throw Error(s(349));
                    var o = e._getVersion,
                        a = o(e._source),
                        l = Yo.current,
                        u = l.useState((function() {
                            return us(i, e, n)
                        })),
                        h = u[1],
                        c = u[0];
                    u = Qo;
                    var d = t.memoizedState,
                        p = d.refs,
                        f = p.getSnapshot,
                        m = d.source;
                    d = d.subscribe;
                    var g = Ko;
                    return t.memoizedState = {
                        refs: p,
                        source: e,
                        subscribe: r
                    }, l.useEffect((function() {
                        p.getSnapshot = n, p.setSnapshot = h;
                        var t = o(e._source);
                        if (!sr(a, t)) {
                            t = n(e._source), sr(c, t) || (h(t), t = al(g), i.mutableReadLanes |= t & i.pendingLanes), t = i.mutableReadLanes, i.entangledLanes |= t;
                            for (var r = i.entanglements, s = t; 0 < s;) {
                                var l = 31 - Ve(s),
                                    u = 1 << l;
                                r[l] |= t, s &= ~u
                            }
                        }
                    }), [n, e, r]), l.useEffect((function() {
                        return r(e._source, (function() {
                            var t = p.getSnapshot,
                                n = p.setSnapshot;
                            try {
                                n(t(e._source));
                                var r = al(g);
                                i.mutableReadLanes |= r & i.pendingLanes
                            } catch (t) {
                                n((function() {
                                    throw t
                                }))
                            }
                        }))
                    }), [e, r]), sr(f, n) && sr(m, e) && sr(d, r) || ((t = {
                        pending: null,
                        dispatch: null,
                        lastRenderedReducer: ss,
                        lastRenderedState: c
                    }).dispatch = h = As.bind(null, Ko, t), u.queue = t, u.baseQueue = null, c = us(i, e, n), u.memoizedState = u.baseState = c), c
                }

                function cs(t, e, n) {
                    return hs(os(), t, e, n)
                }

                function ds(t) {
                    var e = is();
                    return "function" == typeof t && (t = t()), e.memoizedState = e.baseState = t, t = (t = e.queue = {
                        pending: null,
                        dispatch: null,
                        lastRenderedReducer: ss,
                        lastRenderedState: t
                    }).dispatch = As.bind(null, Ko, t), [e.memoizedState, t]
                }

                function ps(t, e, n, r) {
                    return t = {
                        tag: t,
                        create: e,
                        destroy: n,
                        deps: r,
                        next: null
                    }, null === (e = Ko.updateQueue) ? (e = {
                        lastEffect: null
                    }, Ko.updateQueue = e, e.lastEffect = t.next = t) : null === (n = e.lastEffect) ? e.lastEffect = t.next = t : (r = n.next, n.next = t, t.next = r, e.lastEffect = t), t
                }

                function fs(t) {
                    return t = {
                        current: t
                    }, is().memoizedState = t
                }

                function ms() {
                    return os().memoizedState
                }

                function gs(t, e, n, r) {
                    var i = is();
                    Ko.flags |= t, i.memoizedState = ps(1 | e, n, void 0, void 0 === r ? null : r)
                }

                function vs(t, e, n, r) {
                    var i = os();
                    r = void 0 === r ? null : r;
                    var o = void 0;
                    if (null !== Jo) {
                        var s = Jo.memoizedState;
                        if (o = s.destroy, null !== r && ns(r, s.deps)) return void ps(e, n, o, r)
                    }
                    Ko.flags |= t, i.memoizedState = ps(1 | e, n, o, r)
                }

                function _s(t, e) {
                    return gs(516, 4, t, e)
                }

                function ys(t, e) {
                    return vs(516, 4, t, e)
                }

                function xs(t, e) {
                    return vs(4, 2, t, e)
                }

                function bs(t, e) {
                    return "function" == typeof e ? (t = t(), e(t), function() {
                        e(null)
                    }) : null != e ? (t = t(), e.current = t, function() {
                        e.current = null
                    }) : void 0
                }

                function Es(t, e, n) {
                    return n = null != n ? n.concat([t]) : null, vs(4, 2, bs.bind(null, e, t), n)
                }

                function Ts() {}

                function Ss(t, e) {
                    var n = os();
                    e = void 0 === e ? null : e;
                    var r = n.memoizedState;
                    return null !== r && null !== e && ns(e, r[1]) ? r[0] : (n.memoizedState = [t, e], t)
                }

                function ws(t, e) {
                    var n = os();
                    e = void 0 === e ? null : e;
                    var r = n.memoizedState;
                    return null !== r && null !== e && ns(e, r[1]) ? r[0] : (t = t(), n.memoizedState = [t, e], t)
                }

                function Ms(t, e) {
                    var n = Gi();
                    zi(98 > n ? 98 : n, (function() {
                        t(!0)
                    })), zi(97 < n ? 97 : n, (function() {
                        var n = qo.transition;
                        qo.transition = 1;
                        try {
                            t(!1), e()
                        } finally {
                            qo.transition = n
                        }
                    }))
                }

                function As(t, e, n) {
                    var r = sl(),
                        i = al(t),
                        o = {
                            lane: i,
                            action: n,
                            eagerReducer: null,
                            eagerState: null,
                            next: null
                        },
                        s = e.pending;
                    if (null === s ? o.next = o : (o.next = s.next, s.next = o), e.pending = o, s = t.alternate, t === Ko || null !== s && s === Ko) ts = $o = !0;
                    else {
                        if (0 === t.lanes && (null === s || 0 === s.lanes) && null !== (s = e.lastRenderedReducer)) try {
                            var a = e.lastRenderedState,
                                l = s(a, n);
                            if (o.eagerReducer = s, o.eagerState = l, sr(l, a)) return
                        } catch (t) {}
                        ll(t, i, r)
                    }
                }
                var Rs = {
                        readContext: no,
                        useCallback: es,
                        useContext: es,
                        useEffect: es,
                        useImperativeHandle: es,
                        useLayoutEffect: es,
                        useMemo: es,
                        useReducer: es,
                        useRef: es,
                        useState: es,
                        useDebugValue: es,
                        useDeferredValue: es,
                        useTransition: es,
                        useMutableSource: es,
                        useOpaqueIdentifier: es,
                        unstable_isNewReconciler: !1
                    },
                    Ps = {
                        readContext: no,
                        useCallback: function(t, e) {
                            return is().memoizedState = [t, void 0 === e ? null : e], t
                        },
                        useContext: no,
                        useEffect: _s,
                        useImperativeHandle: function(t, e, n) {
                            return n = null != n ? n.concat([t]) : null, gs(4, 2, bs.bind(null, e, t), n)
                        },
                        useLayoutEffect: function(t, e) {
                            return gs(4, 2, t, e)
                        },
                        useMemo: function(t, e) {
                            var n = is();
                            return e = void 0 === e ? null : e, t = t(), n.memoizedState = [t, e], t
                        },
                        useReducer: function(t, e, n) {
                            var r = is();
                            return e = void 0 !== n ? n(e) : e, r.memoizedState = r.baseState = e, t = (t = r.queue = {
                                pending: null,
                                dispatch: null,
                                lastRenderedReducer: t,
                                lastRenderedState: e
                            }).dispatch = As.bind(null, Ko, t), [r.memoizedState, t]
                        },
                        useRef: fs,
                        useState: ds,
                        useDebugValue: Ts,
                        useDeferredValue: function(t) {
                            var e = ds(t),
                                n = e[0],
                                r = e[1];
                            return _s((function() {
                                var e = qo.transition;
                                qo.transition = 1;
                                try {
                                    r(t)
                                } finally {
                                    qo.transition = e
                                }
                            }), [t]), n
                        },
                        useTransition: function() {
                            var t = ds(!1),
                                e = t[0];
                            return fs(t = Ms.bind(null, t[1])), [t, e]
                        },
                        useMutableSource: function(t, e, n) {
                            var r = is();
                            return r.memoizedState = {
                                refs: {
                                    getSnapshot: e,
                                    setSnapshot: null
                                },
                                source: t,
                                subscribe: n
                            }, hs(r, t, e, n)
                        },
                        useOpaqueIdentifier: function() {
                            if (Bo) {
                                var t = !1,
                                    e = function(t) {
                                        return {
                                            $$typeof: D,
                                            toString: t,
                                            valueOf: t
                                        }
                                    }((function() {
                                        throw t || (t = !0, n("r:" + (jr++).toString(36))), Error(s(355))
                                    })),
                                    n = ds(e)[1];
                                return 0 == (2 & Ko.mode) && (Ko.flags |= 516, ps(5, (function() {
                                    n("r:" + (jr++).toString(36))
                                }), void 0, null)), e
                            }
                            return ds(e = "r:" + (jr++).toString(36)), e
                        },
                        unstable_isNewReconciler: !1
                    },
                    Is = {
                        readContext: no,
                        useCallback: Ss,
                        useContext: no,
                        useEffect: ys,
                        useImperativeHandle: Es,
                        useLayoutEffect: xs,
                        useMemo: ws,
                        useReducer: as,
                        useRef: ms,
                        useState: function() {
                            return as(ss)
                        },
                        useDebugValue: Ts,
                        useDeferredValue: function(t) {
                            var e = as(ss),
                                n = e[0],
                                r = e[1];
                            return ys((function() {
                                var e = qo.transition;
                                qo.transition = 1;
                                try {
                                    r(t)
                                } finally {
                                    qo.transition = e
                                }
                            }), [t]), n
                        },
                        useTransition: function() {
                            var t = as(ss)[0];
                            return [ms().current, t]
                        },
                        useMutableSource: cs,
                        useOpaqueIdentifier: function() {
                            return as(ss)[0]
                        },
                        unstable_isNewReconciler: !1
                    },
                    Cs = {
                        readContext: no,
                        useCallback: Ss,
                        useContext: no,
                        useEffect: ys,
                        useImperativeHandle: Es,
                        useLayoutEffect: xs,
                        useMemo: ws,
                        useReducer: ls,
                        useRef: ms,
                        useState: function() {
                            return ls(ss)
                        },
                        useDebugValue: Ts,
                        useDeferredValue: function(t) {
                            var e = ls(ss),
                                n = e[0],
                                r = e[1];
                            return ys((function() {
                                var e = qo.transition;
                                qo.transition = 1;
                                try {
                                    r(t)
                                } finally {
                                    qo.transition = e
                                }
                            }), [t]), n
                        },
                        useTransition: function() {
                            var t = ls(ss)[0];
                            return [ms().current, t]
                        },
                        useMutableSource: cs,
                        useOpaqueIdentifier: function() {
                            return ls(ss)[0]
                        },
                        unstable_isNewReconciler: !1
                    },
                    Os = b.ReactCurrentOwner,
                    Ls = !1;

                function Ns(t, e, n, r) {
                    e.child = null === t ? So(e, null, n, r) : To(e, t.child, n, r)
                }

                function Ds(t, e, n, r, i) {
                    n = n.render;
                    var o = e.ref;
                    return eo(e, i), r = rs(t, e, n, r, o, i), null === t || Ls ? (e.flags |= 1, Ns(t, e, r, i), e.child) : (e.updateQueue = t.updateQueue, e.flags &= -517, t.lanes &= ~i, $s(t, e, i))
                }

                function Us(t, e, n, r, i, o) {
                    if (null === t) {
                        var s = n.type;
                        return "function" != typeof s || kl(s) || void 0 !== s.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((t = Hl(n.type, null, r, e, e.mode, o)).ref = e.ref, t.return = e, e.child = t) : (e.tag = 15, e.type = s, Fs(t, e, s, r, i, o))
                    }
                    return s = t.child, 0 == (i & o) && (i = s.memoizedProps, (n = null !== (n = n.compare) ? n : lr)(i, r) && t.ref === e.ref) ? $s(t, e, o) : (e.flags |= 1, (t = Gl(s, r)).ref = e.ref, t.return = e, e.child = t)
                }

                function Fs(t, e, n, r, i, o) {
                    if (null !== t && lr(t.memoizedProps, r) && t.ref === e.ref) {
                        if (Ls = !1, 0 == (o & i)) return e.lanes = t.lanes, $s(t, e, o);
                        0 != (16384 & t.flags) && (Ls = !0)
                    }
                    return Gs(t, e, n, r, o)
                }

                function Bs(t, e, n) {
                    var r = e.pendingProps,
                        i = r.children,
                        o = null !== t ? t.memoizedState : null;
                    if ("hidden" === r.mode || "unstable-defer-without-hiding" === r.mode)
                        if (0 == (4 & e.mode)) e.memoizedState = {
                            baseLanes: 0
                        }, gl(0, n);
                        else {
                            if (0 == (1073741824 & n)) return t = null !== o ? o.baseLanes | n : n, e.lanes = e.childLanes = 1073741824, e.memoizedState = {
                                baseLanes: t
                            }, gl(0, t), null;
                            e.memoizedState = {
                                baseLanes: 0
                            }, gl(0, null !== o ? o.baseLanes : n)
                        }
                    else null !== o ? (r = o.baseLanes | n, e.memoizedState = null) : r = n, gl(0, r);
                    return Ns(t, e, i, n), e.child
                }

                function ks(t, e) {
                    var n = e.ref;
                    (null === t && null !== n || null !== t && t.ref !== n) && (e.flags |= 128)
                }

                function Gs(t, e, n, r, i) {
                    var o = pi(n) ? ci : ui.current;
                    return o = di(e, o), eo(e, i), n = rs(t, e, n, r, o, i), null === t || Ls ? (e.flags |= 1, Ns(t, e, n, i), e.child) : (e.updateQueue = t.updateQueue, e.flags &= -517, t.lanes &= ~i, $s(t, e, i))
                }

                function Hs(t, e, n, r, i) {
                    if (pi(n)) {
                        var o = !0;
                        vi(e)
                    } else o = !1;
                    if (eo(e, i), null === e.stateNode) null !== t && (t.alternate = null, e.alternate = null, e.flags |= 2), go(e, n, r), _o(e, n, r, i), r = !0;
                    else if (null === t) {
                        var s = e.stateNode,
                            a = e.memoizedProps;
                        s.props = a;
                        var l = s.context,
                            u = n.contextType;
                        u = "object" == typeof u && null !== u ? no(u) : di(e, u = pi(n) ? ci : ui.current);
                        var h = n.getDerivedStateFromProps,
                            c = "function" == typeof h || "function" == typeof s.getSnapshotBeforeUpdate;
                        c || "function" != typeof s.UNSAFE_componentWillReceiveProps && "function" != typeof s.componentWillReceiveProps || (a !== r || l !== u) && vo(e, s, r, u), ro = !1;
                        var d = e.memoizedState;
                        s.state = d, uo(e, r, s, i), l = e.memoizedState, a !== r || d !== l || hi.current || ro ? ("function" == typeof h && (po(e, n, h, r), l = e.memoizedState), (a = ro || mo(e, n, a, r, d, l, u)) ? (c || "function" != typeof s.UNSAFE_componentWillMount && "function" != typeof s.componentWillMount || ("function" == typeof s.componentWillMount && s.componentWillMount(), "function" == typeof s.UNSAFE_componentWillMount && s.UNSAFE_componentWillMount()), "function" == typeof s.componentDidMount && (e.flags |= 4)) : ("function" == typeof s.componentDidMount && (e.flags |= 4), e.memoizedProps = r, e.memoizedState = l), s.props = r, s.state = l, s.context = u, r = a) : ("function" == typeof s.componentDidMount && (e.flags |= 4), r = !1)
                    } else {
                        s = e.stateNode, oo(t, e), a = e.memoizedProps, u = e.type === e.elementType ? a : Yi(e.type, a), s.props = u, c = e.pendingProps, d = s.context, l = "object" == typeof(l = n.contextType) && null !== l ? no(l) : di(e, l = pi(n) ? ci : ui.current);
                        var p = n.getDerivedStateFromProps;
                        (h = "function" == typeof p || "function" == typeof s.getSnapshotBeforeUpdate) || "function" != typeof s.UNSAFE_componentWillReceiveProps && "function" != typeof s.componentWillReceiveProps || (a !== c || d !== l) && vo(e, s, r, l), ro = !1, d = e.memoizedState, s.state = d, uo(e, r, s, i);
                        var f = e.memoizedState;
                        a !== c || d !== f || hi.current || ro ? ("function" == typeof p && (po(e, n, p, r), f = e.memoizedState), (u = ro || mo(e, n, u, r, d, f, l)) ? (h || "function" != typeof s.UNSAFE_componentWillUpdate && "function" != typeof s.componentWillUpdate || ("function" == typeof s.componentWillUpdate && s.componentWillUpdate(r, f, l), "function" == typeof s.UNSAFE_componentWillUpdate && s.UNSAFE_componentWillUpdate(r, f, l)), "function" == typeof s.componentDidUpdate && (e.flags |= 4), "function" == typeof s.getSnapshotBeforeUpdate && (e.flags |= 256)) : ("function" != typeof s.componentDidUpdate || a === t.memoizedProps && d === t.memoizedState || (e.flags |= 4), "function" != typeof s.getSnapshotBeforeUpdate || a === t.memoizedProps && d === t.memoizedState || (e.flags |= 256), e.memoizedProps = r, e.memoizedState = f), s.props = r, s.state = f, s.context = l, r = u) : ("function" != typeof s.componentDidUpdate || a === t.memoizedProps && d === t.memoizedState || (e.flags |= 4), "function" != typeof s.getSnapshotBeforeUpdate || a === t.memoizedProps && d === t.memoizedState || (e.flags |= 256), r = !1)
                    }
                    return zs(t, e, n, r, o, i)
                }

                function zs(t, e, n, r, i, o) {
                    ks(t, e);
                    var s = 0 != (64 & e.flags);
                    if (!r && !s) return i && _i(e, n, !1), $s(t, e, o);
                    r = e.stateNode, Os.current = e;
                    var a = s && "function" != typeof n.getDerivedStateFromError ? null : r.render();
                    return e.flags |= 1, null !== t && s ? (e.child = To(e, t.child, null, o), e.child = To(e, null, a, o)) : Ns(t, e, a, o), e.memoizedState = r.state, i && _i(e, n, !0), e.child
                }

                function Vs(t) {
                    var e = t.stateNode;
                    e.pendingContext ? mi(0, e.pendingContext, e.pendingContext !== e.context) : e.context && mi(0, e.context, !1), Io(t, e.containerInfo)
                }
                var Ws, Xs, js, Ys = {
                    dehydrated: null,
                    retryLane: 0
                };

                function qs(t, e, n) {
                    var r, i = e.pendingProps,
                        o = No.current,
                        s = !1;
                    return (r = 0 != (64 & e.flags)) || (r = (null === t || null !== t.memoizedState) && 0 != (2 & o)), r ? (s = !0, e.flags &= -65) : null !== t && null === t.memoizedState || void 0 === i.fallback || !0 === i.unstable_avoidThisFallback || (o |= 1), ai(No, 1 & o), null === t ? (void 0 !== i.fallback && Ho(e), t = i.children, o = i.fallback, s ? (t = Zs(e, t, o, n), e.child.memoizedState = {
                        baseLanes: n
                    }, e.memoizedState = Ys, t) : "number" == typeof i.unstable_expectedLoadTime ? (t = Zs(e, t, o, n), e.child.memoizedState = {
                        baseLanes: n
                    }, e.memoizedState = Ys, e.lanes = 33554432, t) : ((n = Vl({
                        mode: "visible",
                        children: t
                    }, e.mode, n, null)).return = e, e.child = n)) : (t.memoizedState, s ? (i = function(t, e, n, r, i) {
                        var o = e.mode,
                            s = t.child;
                        t = s.sibling;
                        var a = {
                            mode: "hidden",
                            children: n
                        };
                        return 0 == (2 & o) && e.child !== s ? ((n = e.child).childLanes = 0, n.pendingProps = a, null !== (s = n.lastEffect) ? (e.firstEffect = n.firstEffect, e.lastEffect = s, s.nextEffect = null) : e.firstEffect = e.lastEffect = null) : n = Gl(s, a), null !== t ? r = Gl(t, r) : (r = zl(r, o, i, null)).flags |= 2, r.return = e, n.return = e, n.sibling = r, e.child = n, r
                    }(t, e, i.children, i.fallback, n), s = e.child, o = t.child.memoizedState, s.memoizedState = null === o ? {
                        baseLanes: n
                    } : {
                        baseLanes: o.baseLanes | n
                    }, s.childLanes = t.childLanes & ~n, e.memoizedState = Ys, i) : (n = function(t, e, n, r) {
                        var i = t.child;
                        return t = i.sibling, n = Gl(i, {
                            mode: "visible",
                            children: n
                        }), 0 == (2 & e.mode) && (n.lanes = r), n.return = e, n.sibling = null, null !== t && (t.nextEffect = null, t.flags = 8, e.firstEffect = e.lastEffect = t), e.child = n
                    }(t, e, i.children, n), e.memoizedState = null, n))
                }

                function Zs(t, e, n, r) {
                    var i = t.mode,
                        o = t.child;
                    return e = {
                        mode: "hidden",
                        children: e
                    }, 0 == (2 & i) && null !== o ? (o.childLanes = 0, o.pendingProps = e) : o = Vl(e, i, 0, null), n = zl(n, i, r, null), o.return = t, n.return = t, o.sibling = n, t.child = o, n
                }

                function Ks(t, e) {
                    t.lanes |= e;
                    var n = t.alternate;
                    null !== n && (n.lanes |= e), to(t.return, e)
                }

                function Js(t, e, n, r, i, o) {
                    var s = t.memoizedState;
                    null === s ? t.memoizedState = {
                        isBackwards: e,
                        rendering: null,
                        renderingStartTime: 0,
                        last: r,
                        tail: n,
                        tailMode: i,
                        lastEffect: o
                    } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = r, s.tail = n, s.tailMode = i, s.lastEffect = o)
                }

                function Qs(t, e, n) {
                    var r = e.pendingProps,
                        i = r.revealOrder,
                        o = r.tail;
                    if (Ns(t, e, r.children, n), 0 != (2 & (r = No.current))) r = 1 & r | 2, e.flags |= 64;
                    else {
                        if (null !== t && 0 != (64 & t.flags)) t: for (t = e.child; null !== t;) {
                            if (13 === t.tag) null !== t.memoizedState && Ks(t, n);
                            else if (19 === t.tag) Ks(t, n);
                            else if (null !== t.child) {
                                t.child.return = t, t = t.child;
                                continue
                            }
                            if (t === e) break t;
                            for (; null === t.sibling;) {
                                if (null === t.return || t.return === e) break t;
                                t = t.return
                            }
                            t.sibling.return = t.return, t = t.sibling
                        }
                        r &= 1
                    }
                    if (ai(No, r), 0 == (2 & e.mode)) e.memoizedState = null;
                    else switch (i) {
                        case "forwards":
                            for (n = e.child, i = null; null !== n;) null !== (t = n.alternate) && null === Do(t) && (i = n), n = n.sibling;
                            null === (n = i) ? (i = e.child, e.child = null) : (i = n.sibling, n.sibling = null), Js(e, !1, i, n, o, e.lastEffect);
                            break;
                        case "backwards":
                            for (n = null, i = e.child, e.child = null; null !== i;) {
                                if (null !== (t = i.alternate) && null === Do(t)) {
                                    e.child = i;
                                    break
                                }
                                t = i.sibling, i.sibling = n, n = i, i = t
                            }
                            Js(e, !0, n, null, o, e.lastEffect);
                            break;
                        case "together":
                            Js(e, !1, null, null, void 0, e.lastEffect);
                            break;
                        default:
                            e.memoizedState = null
                    }
                    return e.child
                }

                function $s(t, e, n) {
                    if (null !== t && (e.dependencies = t.dependencies), Da |= e.lanes, 0 != (n & e.childLanes)) {
                        if (null !== t && e.child !== t.child) throw Error(s(153));
                        if (null !== e.child) {
                            for (n = Gl(t = e.child, t.pendingProps), e.child = n, n.return = e; null !== t.sibling;) t = t.sibling, (n = n.sibling = Gl(t, t.pendingProps)).return = e;
                            n.sibling = null
                        }
                        return e.child
                    }
                    return null
                }

                function ta(t, e) {
                    if (!Bo) switch (t.tailMode) {
                        case "hidden":
                            e = t.tail;
                            for (var n = null; null !== e;) null !== e.alternate && (n = e), e = e.sibling;
                            null === n ? t.tail = null : n.sibling = null;
                            break;
                        case "collapsed":
                            n = t.tail;
                            for (var r = null; null !== n;) null !== n.alternate && (r = n), n = n.sibling;
                            null === r ? e || null === t.tail ? t.tail = null : t.tail.sibling = null : r.sibling = null
                    }
                }

                function ea(t, e, n) {
                    var r = e.pendingProps;
                    switch (e.tag) {
                        case 2:
                        case 16:
                        case 15:
                        case 0:
                        case 11:
                        case 7:
                        case 8:
                        case 12:
                        case 9:
                        case 14:
                            return null;
                        case 1:
                            return pi(e.type) && fi(), null;
                        case 3:
                            return Co(), si(hi), si(ui), jo(), (r = e.stateNode).pendingContext && (r.context = r.pendingContext, r.pendingContext = null), null !== t && null !== t.child || (Vo(e) ? e.flags |= 4 : r.hydrate || (e.flags |= 256)), null;
                        case 5:
                            Lo(e);
                            var o = Po(Ro.current);
                            if (n = e.type, null !== t && null != e.stateNode) Xs(t, e, n, r), t.ref !== e.ref && (e.flags |= 128);
                            else {
                                if (!r) {
                                    if (null === e.stateNode) throw Error(s(166));
                                    return null
                                }
                                if (t = Po(Mo.current), Vo(e)) {
                                    r = e.stateNode, n = e.type;
                                    var a = e.memoizedProps;
                                    switch (r[qr] = e, r[Zr] = a, n) {
                                        case "dialog":
                                            Mr("cancel", r), Mr("close", r);
                                            break;
                                        case "iframe":
                                        case "object":
                                        case "embed":
                                            Mr("load", r);
                                            break;
                                        case "video":
                                        case "audio":
                                            for (t = 0; t < Er.length; t++) Mr(Er[t], r);
                                            break;
                                        case "source":
                                            Mr("error", r);
                                            break;
                                        case "img":
                                        case "image":
                                        case "link":
                                            Mr("error", r), Mr("load", r);
                                            break;
                                        case "details":
                                            Mr("toggle", r);
                                            break;
                                        case "input":
                                            tt(r, a), Mr("invalid", r);
                                            break;
                                        case "select":
                                            r._wrapperState = {
                                                wasMultiple: !!a.multiple
                                            }, Mr("invalid", r);
                                            break;
                                        case "textarea":
                                            lt(r, a), Mr("invalid", r)
                                    }
                                    for (var u in Tt(n, a), t = null, a) a.hasOwnProperty(u) && (o = a[u], "children" === u ? "string" == typeof o ? r.textContent !== o && (t = ["children", o]) : "number" == typeof o && r.textContent !== "" + o && (t = ["children", "" + o]) : l.hasOwnProperty(u) && null != o && "onScroll" === u && Mr("scroll", r));
                                    switch (n) {
                                        case "input":
                                            K(r), rt(r, a, !0);
                                            break;
                                        case "textarea":
                                            K(r), ht(r);
                                            break;
                                        case "select":
                                        case "option":
                                            break;
                                        default:
                                            "function" == typeof a.onClick && (r.onclick = Ur)
                                    }
                                    r = t, e.updateQueue = r, null !== r && (e.flags |= 4)
                                } else {
                                    switch (u = 9 === o.nodeType ? o : o.ownerDocument, t === ct && (t = dt(n)), t === ct ? "script" === n ? ((t = u.createElement("div")).innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : "string" == typeof r.is ? t = u.createElement(n, {
                                            is: r.is
                                        }) : (t = u.createElement(n), "select" === n && (u = t, r.multiple ? u.multiple = !0 : r.size && (u.size = r.size))) : t = u.createElementNS(t, n), t[qr] = e, t[Zr] = r, Ws(t, e), e.stateNode = t, u = St(n, r), n) {
                                        case "dialog":
                                            Mr("cancel", t), Mr("close", t), o = r;
                                            break;
                                        case "iframe":
                                        case "object":
                                        case "embed":
                                            Mr("load", t), o = r;
                                            break;
                                        case "video":
                                        case "audio":
                                            for (o = 0; o < Er.length; o++) Mr(Er[o], t);
                                            o = r;
                                            break;
                                        case "source":
                                            Mr("error", t), o = r;
                                            break;
                                        case "img":
                                        case "image":
                                        case "link":
                                            Mr("error", t), Mr("load", t), o = r;
                                            break;
                                        case "details":
                                            Mr("toggle", t), o = r;
                                            break;
                                        case "input":
                                            tt(t, r), o = $(t, r), Mr("invalid", t);
                                            break;
                                        case "option":
                                            o = ot(t, r);
                                            break;
                                        case "select":
                                            t._wrapperState = {
                                                wasMultiple: !!r.multiple
                                            }, o = i({}, r, {
                                                value: void 0
                                            }), Mr("invalid", t);
                                            break;
                                        case "textarea":
                                            lt(t, r), o = at(t, r), Mr("invalid", t);
                                            break;
                                        default:
                                            o = r
                                    }
                                    Tt(n, o);
                                    var h = o;
                                    for (a in h)
                                        if (h.hasOwnProperty(a)) {
                                            var c = h[a];
                                            "style" === a ? bt(t, c) : "dangerouslySetInnerHTML" === a ? null != (c = c ? c.__html : void 0) && gt(t, c) : "children" === a ? "string" == typeof c ? ("textarea" !== n || "" !== c) && vt(t, c) : "number" == typeof c && vt(t, "" + c) : "suppressContentEditableWarning" !== a && "suppressHydrationWarning" !== a && "autoFocus" !== a && (l.hasOwnProperty(a) ? null != c && "onScroll" === a && Mr("scroll", t) : null != c && x(t, a, c, u))
                                        } switch (n) {
                                        case "input":
                                            K(t), rt(t, r, !1);
                                            break;
                                        case "textarea":
                                            K(t), ht(t);
                                            break;
                                        case "option":
                                            null != r.value && t.setAttribute("value", "" + q(r.value));
                                            break;
                                        case "select":
                                            t.multiple = !!r.multiple, null != (a = r.value) ? st(t, !!r.multiple, a, !1) : null != r.defaultValue && st(t, !!r.multiple, r.defaultValue, !0);
                                            break;
                                        default:
                                            "function" == typeof o.onClick && (t.onclick = Ur)
                                    }
                                    kr(n, r) && (e.flags |= 4)
                                }
                                null !== e.ref && (e.flags |= 128)
                            }
                            return null;
                        case 6:
                            if (t && null != e.stateNode) js(0, e, t.memoizedProps, r);
                            else {
                                if ("string" != typeof r && null === e.stateNode) throw Error(s(166));
                                n = Po(Ro.current), Po(Mo.current), Vo(e) ? (r = e.stateNode, n = e.memoizedProps, r[qr] = e, r.nodeValue !== n && (e.flags |= 4)) : ((r = (9 === n.nodeType ? n : n.ownerDocument).createTextNode(r))[qr] = e, e.stateNode = r)
                            }
                            return null;
                        case 13:
                            return si(No), r = e.memoizedState, 0 != (64 & e.flags) ? (e.lanes = n, e) : (r = null !== r, n = !1, null === t ? void 0 !== e.memoizedProps.fallback && Vo(e) : n = null !== t.memoizedState, r && !n && 0 != (2 & e.mode) && (null === t && !0 !== e.memoizedProps.unstable_avoidThisFallback || 0 != (1 & No.current) ? 0 === Oa && (Oa = 3) : (0 !== Oa && 3 !== Oa || (Oa = 4), null === Aa || 0 == (134217727 & Da) && 0 == (134217727 & Ua) || dl(Aa, Pa))), (r || n) && (e.flags |= 4), null);
                        case 4:
                            return Co(), null === t && Rr(e.stateNode.containerInfo), null;
                        case 10:
                            return $i(e), null;
                        case 17:
                            return pi(e.type) && fi(), null;
                        case 19:
                            if (si(No), null === (r = e.memoizedState)) return null;
                            if (a = 0 != (64 & e.flags), null === (u = r.rendering))
                                if (a) ta(r, !1);
                                else {
                                    if (0 !== Oa || null !== t && 0 != (64 & t.flags))
                                        for (t = e.child; null !== t;) {
                                            if (null !== (u = Do(t))) {
                                                for (e.flags |= 64, ta(r, !1), null !== (a = u.updateQueue) && (e.updateQueue = a, e.flags |= 4), null === r.lastEffect && (e.firstEffect = null), e.lastEffect = r.lastEffect, r = n, n = e.child; null !== n;) t = r, (a = n).flags &= 2, a.nextEffect = null, a.firstEffect = null, a.lastEffect = null, null === (u = a.alternate) ? (a.childLanes = 0, a.lanes = t, a.child = null, a.memoizedProps = null, a.memoizedState = null, a.updateQueue = null, a.dependencies = null, a.stateNode = null) : (a.childLanes = u.childLanes, a.lanes = u.lanes, a.child = u.child, a.memoizedProps = u.memoizedProps, a.memoizedState = u.memoizedState, a.updateQueue = u.updateQueue, a.type = u.type, t = u.dependencies, a.dependencies = null === t ? null : {
                                                    lanes: t.lanes,
                                                    firstContext: t.firstContext
                                                }), n = n.sibling;
                                                return ai(No, 1 & No.current | 2), e.child
                                            }
                                            t = t.sibling
                                        }
                                    null !== r.tail && ki() > Ga && (e.flags |= 64, a = !0, ta(r, !1), e.lanes = 33554432)
                                }
                            else {
                                if (!a)
                                    if (null !== (t = Do(u))) {
                                        if (e.flags |= 64, a = !0, null !== (n = t.updateQueue) && (e.updateQueue = n, e.flags |= 4), ta(r, !0), null === r.tail && "hidden" === r.tailMode && !u.alternate && !Bo) return null !== (e = e.lastEffect = r.lastEffect) && (e.nextEffect = null), null
                                    } else 2 * ki() - r.renderingStartTime > Ga && 1073741824 !== n && (e.flags |= 64, a = !0, ta(r, !1), e.lanes = 33554432);
                                r.isBackwards ? (u.sibling = e.child, e.child = u) : (null !== (n = r.last) ? n.sibling = u : e.child = u, r.last = u)
                            }
                            return null !== r.tail ? (n = r.tail, r.rendering = n, r.tail = n.sibling, r.lastEffect = e.lastEffect, r.renderingStartTime = ki(), n.sibling = null, e = No.current, ai(No, a ? 1 & e | 2 : 1 & e), n) : null;
                        case 23:
                        case 24:
                            return vl(), null !== t && null !== t.memoizedState != (null !== e.memoizedState) && "unstable-defer-without-hiding" !== r.mode && (e.flags |= 4), null
                    }
                    throw Error(s(156, e.tag))
                }

                function na(t) {
                    switch (t.tag) {
                        case 1:
                            pi(t.type) && fi();
                            var e = t.flags;
                            return 4096 & e ? (t.flags = -4097 & e | 64, t) : null;
                        case 3:
                            if (Co(), si(hi), si(ui), jo(), 0 != (64 & (e = t.flags))) throw Error(s(285));
                            return t.flags = -4097 & e | 64, t;
                        case 5:
                            return Lo(t), null;
                        case 13:
                            return si(No), 4096 & (e = t.flags) ? (t.flags = -4097 & e | 64, t) : null;
                        case 19:
                            return si(No), null;
                        case 4:
                            return Co(), null;
                        case 10:
                            return $i(t), null;
                        case 23:
                        case 24:
                            return vl(), null;
                        default:
                            return null
                    }
                }

                function ra(t, e) {
                    try {
                        var n = "",
                            r = e;
                        do {
                            n += j(r), r = r.return
                        } while (r);
                        var i = n
                    } catch (t) {
                        i = "\nError generating stack: " + t.message + "\n" + t.stack
                    }
                    return {
                        value: t,
                        source: e,
                        stack: i
                    }
                }

                function ia(t, e) {
                    try {
                        console.error(e.value)
                    } catch (t) {
                        setTimeout((function() {
                            throw t
                        }))
                    }
                }
                Ws = function(t, e) {
                    for (var n = e.child; null !== n;) {
                        if (5 === n.tag || 6 === n.tag) t.appendChild(n.stateNode);
                        else if (4 !== n.tag && null !== n.child) {
                            n.child.return = n, n = n.child;
                            continue
                        }
                        if (n === e) break;
                        for (; null === n.sibling;) {
                            if (null === n.return || n.return === e) return;
                            n = n.return
                        }
                        n.sibling.return = n.return, n = n.sibling
                    }
                }, Xs = function(t, e, n, r) {
                    var o = t.memoizedProps;
                    if (o !== r) {
                        t = e.stateNode, Po(Mo.current);
                        var s, a = null;
                        switch (n) {
                            case "input":
                                o = $(t, o), r = $(t, r), a = [];
                                break;
                            case "option":
                                o = ot(t, o), r = ot(t, r), a = [];
                                break;
                            case "select":
                                o = i({}, o, {
                                    value: void 0
                                }), r = i({}, r, {
                                    value: void 0
                                }), a = [];
                                break;
                            case "textarea":
                                o = at(t, o), r = at(t, r), a = [];
                                break;
                            default:
                                "function" != typeof o.onClick && "function" == typeof r.onClick && (t.onclick = Ur)
                        }
                        for (c in Tt(n, r), n = null, o)
                            if (!r.hasOwnProperty(c) && o.hasOwnProperty(c) && null != o[c])
                                if ("style" === c) {
                                    var u = o[c];
                                    for (s in u) u.hasOwnProperty(s) && (n || (n = {}), n[s] = "")
                                } else "dangerouslySetInnerHTML" !== c && "children" !== c && "suppressContentEditableWarning" !== c && "suppressHydrationWarning" !== c && "autoFocus" !== c && (l.hasOwnProperty(c) ? a || (a = []) : (a = a || []).push(c, null));
                        for (c in r) {
                            var h = r[c];
                            if (u = null != o ? o[c] : void 0, r.hasOwnProperty(c) && h !== u && (null != h || null != u))
                                if ("style" === c)
                                    if (u) {
                                        for (s in u) !u.hasOwnProperty(s) || h && h.hasOwnProperty(s) || (n || (n = {}), n[s] = "");
                                        for (s in h) h.hasOwnProperty(s) && u[s] !== h[s] && (n || (n = {}), n[s] = h[s])
                                    } else n || (a || (a = []), a.push(c, n)), n = h;
                            else "dangerouslySetInnerHTML" === c ? (h = h ? h.__html : void 0, u = u ? u.__html : void 0, null != h && u !== h && (a = a || []).push(c, h)) : "children" === c ? "string" != typeof h && "number" != typeof h || (a = a || []).push(c, "" + h) : "suppressContentEditableWarning" !== c && "suppressHydrationWarning" !== c && (l.hasOwnProperty(c) ? (null != h && "onScroll" === c && Mr("scroll", t), a || u === h || (a = [])) : "object" == typeof h && null !== h && h.$$typeof === D ? h.toString() : (a = a || []).push(c, h))
                        }
                        n && (a = a || []).push("style", n);
                        var c = a;
                        (e.updateQueue = c) && (e.flags |= 4)
                    }
                }, js = function(t, e, n, r) {
                    n !== r && (e.flags |= 4)
                };
                var oa = "function" == typeof WeakMap ? WeakMap : Map;

                function sa(t, e, n) {
                    (n = so(-1, n)).tag = 3, n.payload = {
                        element: null
                    };
                    var r = e.value;
                    return n.callback = function() {
                        Wa || (Wa = !0, Xa = r), ia(0, e)
                    }, n
                }

                function aa(t, e, n) {
                    (n = so(-1, n)).tag = 3;
                    var r = t.type.getDerivedStateFromError;
                    if ("function" == typeof r) {
                        var i = e.value;
                        n.payload = function() {
                            return ia(0, e), r(i)
                        }
                    }
                    var o = t.stateNode;
                    return null !== o && "function" == typeof o.componentDidCatch && (n.callback = function() {
                        "function" != typeof r && (null === ja ? ja = new Set([this]) : ja.add(this), ia(0, e));
                        var t = e.stack;
                        this.componentDidCatch(e.value, {
                            componentStack: null !== t ? t : ""
                        })
                    }), n
                }
                var la = "function" == typeof WeakSet ? WeakSet : Set;

                function ua(t) {
                    var e = t.ref;
                    if (null !== e)
                        if ("function" == typeof e) try {
                            e(null)
                        } catch (e) {
                            Nl(t, e)
                        } else e.current = null
                }

                function ha(t, e) {
                    switch (e.tag) {
                        case 0:
                        case 11:
                        case 15:
                        case 22:
                            return;
                        case 1:
                            if (256 & e.flags && null !== t) {
                                var n = t.memoizedProps,
                                    r = t.memoizedState;
                                e = (t = e.stateNode).getSnapshotBeforeUpdate(e.elementType === e.type ? n : Yi(e.type, n), r), t.__reactInternalSnapshotBeforeUpdate = e
                            }
                            return;
                        case 3:
                            return void(256 & e.flags && Vr(e.stateNode.containerInfo));
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            return
                    }
                    throw Error(s(163))
                }

                function ca(t, e, n) {
                    switch (n.tag) {
                        case 0:
                        case 11:
                        case 15:
                        case 22:
                            if (null !== (e = null !== (e = n.updateQueue) ? e.lastEffect : null)) {
                                t = e = e.next;
                                do {
                                    if (3 == (3 & t.tag)) {
                                        var r = t.create;
                                        t.destroy = r()
                                    }
                                    t = t.next
                                } while (t !== e)
                            }
                            if (null !== (e = null !== (e = n.updateQueue) ? e.lastEffect : null)) {
                                t = e = e.next;
                                do {
                                    var i = t;
                                    r = i.next, 0 != (4 & (i = i.tag)) && 0 != (1 & i) && (Cl(n, t), Il(n, t)), t = r
                                } while (t !== e)
                            }
                            return;
                        case 1:
                            return t = n.stateNode, 4 & n.flags && (null === e ? t.componentDidMount() : (r = n.elementType === n.type ? e.memoizedProps : Yi(n.type, e.memoizedProps), t.componentDidUpdate(r, e.memoizedState, t.__reactInternalSnapshotBeforeUpdate))), void(null !== (e = n.updateQueue) && ho(n, e, t));
                        case 3:
                            if (null !== (e = n.updateQueue)) {
                                if (t = null, null !== n.child) switch (n.child.tag) {
                                    case 5:
                                        t = n.child.stateNode;
                                        break;
                                    case 1:
                                        t = n.child.stateNode
                                }
                                ho(n, e, t)
                            }
                            return;
                        case 5:
                            return t = n.stateNode, void(null === e && 4 & n.flags && kr(n.type, n.memoizedProps) && t.focus());
                        case 6:
                        case 4:
                        case 12:
                            return;
                        case 13:
                            return void(null === n.memoizedState && (n = n.alternate, null !== n && (n = n.memoizedState, null !== n && (n = n.dehydrated, null !== n && be(n)))));
                        case 19:
                        case 17:
                        case 20:
                        case 21:
                        case 23:
                        case 24:
                            return
                    }
                    throw Error(s(163))
                }

                function da(t, e) {
                    for (var n = t;;) {
                        if (5 === n.tag) {
                            var r = n.stateNode;
                            if (e) "function" == typeof(r = r.style).setProperty ? r.setProperty("display", "none", "important") : r.display = "none";
                            else {
                                r = n.stateNode;
                                var i = n.memoizedProps.style;
                                i = null != i && i.hasOwnProperty("display") ? i.display : null, r.style.display = xt("display", i)
                            }
                        } else if (6 === n.tag) n.stateNode.nodeValue = e ? "" : n.memoizedProps;
                        else if ((23 !== n.tag && 24 !== n.tag || null === n.memoizedState || n === t) && null !== n.child) {
                            n.child.return = n, n = n.child;
                            continue
                        }
                        if (n === t) break;
                        for (; null === n.sibling;) {
                            if (null === n.return || n.return === t) return;
                            n = n.return
                        }
                        n.sibling.return = n.return, n = n.sibling
                    }
                }

                function pa(t, e) {
                    if (xi && "function" == typeof xi.onCommitFiberUnmount) try {
                        xi.onCommitFiberUnmount(yi, e)
                    } catch (t) {}
                    switch (e.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                        case 22:
                            if (null !== (t = e.updateQueue) && null !== (t = t.lastEffect)) {
                                var n = t = t.next;
                                do {
                                    var r = n,
                                        i = r.destroy;
                                    if (r = r.tag, void 0 !== i)
                                        if (0 != (4 & r)) Cl(e, n);
                                        else {
                                            r = e;
                                            try {
                                                i()
                                            } catch (t) {
                                                Nl(r, t)
                                            }
                                        } n = n.next
                                } while (n !== t)
                            }
                            break;
                        case 1:
                            if (ua(e), "function" == typeof(t = e.stateNode).componentWillUnmount) try {
                                t.props = e.memoizedProps, t.state = e.memoizedState, t.componentWillUnmount()
                            } catch (t) {
                                Nl(e, t)
                            }
                            break;
                        case 5:
                            ua(e);
                            break;
                        case 4:
                            ya(t, e)
                    }
                }

                function fa(t) {
                    t.alternate = null, t.child = null, t.dependencies = null, t.firstEffect = null, t.lastEffect = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.return = null, t.updateQueue = null
                }

                function ma(t) {
                    return 5 === t.tag || 3 === t.tag || 4 === t.tag
                }

                function ga(t) {
                    t: {
                        for (var e = t.return; null !== e;) {
                            if (ma(e)) break t;
                            e = e.return
                        }
                        throw Error(s(160))
                    }
                    var n = e;
                    switch (e = n.stateNode, n.tag) {
                        case 5:
                            var r = !1;
                            break;
                        case 3:
                        case 4:
                            e = e.containerInfo, r = !0;
                            break;
                        default:
                            throw Error(s(161))
                    }
                    16 & n.flags && (vt(e, ""), n.flags &= -17);t: e: for (n = t;;) {
                        for (; null === n.sibling;) {
                            if (null === n.return || ma(n.return)) {
                                n = null;
                                break t
                            }
                            n = n.return
                        }
                        for (n.sibling.return = n.return, n = n.sibling; 5 !== n.tag && 6 !== n.tag && 18 !== n.tag;) {
                            if (2 & n.flags) continue e;
                            if (null === n.child || 4 === n.tag) continue e;
                            n.child.return = n, n = n.child
                        }
                        if (!(2 & n.flags)) {
                            n = n.stateNode;
                            break t
                        }
                    }
                    r ? va(t, n, e) : _a(t, n, e)
                }

                function va(t, e, n) {
                    var r = t.tag,
                        i = 5 === r || 6 === r;
                    if (i) t = i ? t.stateNode : t.stateNode.instance, e ? 8 === n.nodeType ? n.parentNode.insertBefore(t, e) : n.insertBefore(t, e) : (8 === n.nodeType ? (e = n.parentNode).insertBefore(t, n) : (e = n).appendChild(t), null != (n = n._reactRootContainer) || null !== e.onclick || (e.onclick = Ur));
                    else if (4 !== r && null !== (t = t.child))
                        for (va(t, e, n), t = t.sibling; null !== t;) va(t, e, n), t = t.sibling
                }

                function _a(t, e, n) {
                    var r = t.tag,
                        i = 5 === r || 6 === r;
                    if (i) t = i ? t.stateNode : t.stateNode.instance, e ? n.insertBefore(t, e) : n.appendChild(t);
                    else if (4 !== r && null !== (t = t.child))
                        for (_a(t, e, n), t = t.sibling; null !== t;) _a(t, e, n), t = t.sibling
                }

                function ya(t, e) {
                    for (var n, r, i = e, o = !1;;) {
                        if (!o) {
                            o = i.return;
                            t: for (;;) {
                                if (null === o) throw Error(s(160));
                                switch (n = o.stateNode, o.tag) {
                                    case 5:
                                        r = !1;
                                        break t;
                                    case 3:
                                    case 4:
                                        n = n.containerInfo, r = !0;
                                        break t
                                }
                                o = o.return
                            }
                            o = !0
                        }
                        if (5 === i.tag || 6 === i.tag) {
                            t: for (var a = t, l = i, u = l;;)
                                if (pa(a, u), null !== u.child && 4 !== u.tag) u.child.return = u, u = u.child;
                                else {
                                    if (u === l) break t;
                                    for (; null === u.sibling;) {
                                        if (null === u.return || u.return === l) break t;
                                        u = u.return
                                    }
                                    u.sibling.return = u.return, u = u.sibling
                                }r ? (a = n, l = i.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(l) : a.removeChild(l)) : n.removeChild(i.stateNode)
                        }
                        else if (4 === i.tag) {
                            if (null !== i.child) {
                                n = i.stateNode.containerInfo, r = !0, i.child.return = i, i = i.child;
                                continue
                            }
                        } else if (pa(t, i), null !== i.child) {
                            i.child.return = i, i = i.child;
                            continue
                        }
                        if (i === e) break;
                        for (; null === i.sibling;) {
                            if (null === i.return || i.return === e) return;
                            4 === (i = i.return).tag && (o = !1)
                        }
                        i.sibling.return = i.return, i = i.sibling
                    }
                }

                function xa(t, e) {
                    switch (e.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                        case 22:
                            var n = e.updateQueue;
                            if (null !== (n = null !== n ? n.lastEffect : null)) {
                                var r = n = n.next;
                                do {
                                    3 == (3 & r.tag) && (t = r.destroy, r.destroy = void 0, void 0 !== t && t()), r = r.next
                                } while (r !== n)
                            }
                            return;
                        case 1:
                            return;
                        case 5:
                            if (null != (n = e.stateNode)) {
                                r = e.memoizedProps;
                                var i = null !== t ? t.memoizedProps : r;
                                t = e.type;
                                var o = e.updateQueue;
                                if (e.updateQueue = null, null !== o) {
                                    for (n[Zr] = r, "input" === t && "radio" === r.type && null != r.name && et(n, r), St(t, i), e = St(t, r), i = 0; i < o.length; i += 2) {
                                        var a = o[i],
                                            l = o[i + 1];
                                        "style" === a ? bt(n, l) : "dangerouslySetInnerHTML" === a ? gt(n, l) : "children" === a ? vt(n, l) : x(n, a, l, e)
                                    }
                                    switch (t) {
                                        case "input":
                                            nt(n, r);
                                            break;
                                        case "textarea":
                                            ut(n, r);
                                            break;
                                        case "select":
                                            t = n._wrapperState.wasMultiple, n._wrapperState.wasMultiple = !!r.multiple, null != (o = r.value) ? st(n, !!r.multiple, o, !1) : t !== !!r.multiple && (null != r.defaultValue ? st(n, !!r.multiple, r.defaultValue, !0) : st(n, !!r.multiple, r.multiple ? [] : "", !1))
                                    }
                                }
                            }
                            return;
                        case 6:
                            if (null === e.stateNode) throw Error(s(162));
                            return void(e.stateNode.nodeValue = e.memoizedProps);
                        case 3:
                            return void((n = e.stateNode).hydrate && (n.hydrate = !1, be(n.containerInfo)));
                        case 12:
                            return;
                        case 13:
                            return null !== e.memoizedState && (ka = ki(), da(e.child, !0)), void ba(e);
                        case 19:
                            return void ba(e);
                        case 17:
                            return;
                        case 23:
                        case 24:
                            return void da(e, null !== e.memoizedState)
                    }
                    throw Error(s(163))
                }

                function ba(t) {
                    var e = t.updateQueue;
                    if (null !== e) {
                        t.updateQueue = null;
                        var n = t.stateNode;
                        null === n && (n = t.stateNode = new la), e.forEach((function(e) {
                            var r = Ul.bind(null, t, e);
                            n.has(e) || (n.add(e), e.then(r, r))
                        }))
                    }
                }

                function Ea(t, e) {
                    return null !== t && (null === (t = t.memoizedState) || null !== t.dehydrated) && null !== (e = e.memoizedState) && null === e.dehydrated
                }
                var Ta = Math.ceil,
                    Sa = b.ReactCurrentDispatcher,
                    wa = b.ReactCurrentOwner,
                    Ma = 0,
                    Aa = null,
                    Ra = null,
                    Pa = 0,
                    Ia = 0,
                    Ca = oi(0),
                    Oa = 0,
                    La = null,
                    Na = 0,
                    Da = 0,
                    Ua = 0,
                    Fa = 0,
                    Ba = null,
                    ka = 0,
                    Ga = 1 / 0;

                function Ha() {
                    Ga = ki() + 500
                }
                var za, Va = null,
                    Wa = !1,
                    Xa = null,
                    ja = null,
                    Ya = !1,
                    qa = null,
                    Za = 90,
                    Ka = [],
                    Ja = [],
                    Qa = null,
                    $a = 0,
                    tl = null,
                    el = -1,
                    nl = 0,
                    rl = 0,
                    il = null,
                    ol = !1;

                function sl() {
                    return 0 != (48 & Ma) ? ki() : -1 !== el ? el : el = ki()
                }

                function al(t) {
                    if (0 == (2 & (t = t.mode))) return 1;
                    if (0 == (4 & t)) return 99 === Gi() ? 1 : 2;
                    if (0 === nl && (nl = Na), 0 !== ji.transition) {
                        0 !== rl && (rl = null !== Ba ? Ba.pendingLanes : 0), t = nl;
                        var e = 4186112 & ~rl;
                        return 0 == (e &= -e) && 0 == (e = (t = 4186112 & ~t) & -t) && (e = 8192), e
                    }
                    return t = Gi(), t = ke(0 != (4 & Ma) && 98 === t ? 12 : t = function(t) {
                        switch (t) {
                            case 99:
                                return 15;
                            case 98:
                                return 10;
                            case 97:
                            case 96:
                                return 8;
                            case 95:
                                return 2;
                            default:
                                return 0
                        }
                    }(t), nl)
                }

                function ll(t, e, n) {
                    if (50 < $a) throw $a = 0, tl = null, Error(s(185));
                    if (null === (t = ul(t, e))) return null;
                    ze(t, e, n), t === Aa && (Ua |= e, 4 === Oa && dl(t, Pa));
                    var r = Gi();
                    1 === e ? 0 != (8 & Ma) && 0 == (48 & Ma) ? pl(t) : (hl(t, n), 0 === Ma && (Ha(), Wi())) : (0 == (4 & Ma) || 98 !== r && 99 !== r || (null === Qa ? Qa = new Set([t]) : Qa.add(t)), hl(t, n)), Ba = t
                }

                function ul(t, e) {
                    t.lanes |= e;
                    var n = t.alternate;
                    for (null !== n && (n.lanes |= e), n = t, t = t.return; null !== t;) t.childLanes |= e, null !== (n = t.alternate) && (n.childLanes |= e), n = t, t = t.return;
                    return 3 === n.tag ? n.stateNode : null
                }

                function hl(t, e) {
                    for (var n = t.callbackNode, r = t.suspendedLanes, i = t.pingedLanes, o = t.expirationTimes, a = t.pendingLanes; 0 < a;) {
                        var l = 31 - Ve(a),
                            u = 1 << l,
                            h = o[l];
                        if (-1 === h) {
                            if (0 == (u & r) || 0 != (u & i)) {
                                h = e, Ue(u);
                                var c = De;
                                o[l] = 10 <= c ? h + 250 : 6 <= c ? h + 5e3 : -1
                            }
                        } else h <= e && (t.expiredLanes |= u);
                        a &= ~u
                    }
                    if (r = Fe(t, t === Aa ? Pa : 0), e = De, 0 === r) null !== n && (n !== Li && Ti(n), t.callbackNode = null, t.callbackPriority = 0);
                    else {
                        if (null !== n) {
                            if (t.callbackPriority === e) return;
                            n !== Li && Ti(n)
                        }
                        15 === e ? (n = pl.bind(null, t), null === Di ? (Di = [n], Ui = Ei(Ri, Xi)) : Di.push(n), n = Li) : n = 14 === e ? Vi(99, pl.bind(null, t)) : Vi(n = function(t) {
                            switch (t) {
                                case 15:
                                case 14:
                                    return 99;
                                case 13:
                                case 12:
                                case 11:
                                case 10:
                                    return 98;
                                case 9:
                                case 8:
                                case 7:
                                case 6:
                                case 4:
                                case 5:
                                    return 97;
                                case 3:
                                case 2:
                                case 1:
                                    return 95;
                                case 0:
                                    return 90;
                                default:
                                    throw Error(s(358, t))
                            }
                        }(e), cl.bind(null, t)), t.callbackPriority = e, t.callbackNode = n
                    }
                }

                function cl(t) {
                    if (el = -1, rl = nl = 0, 0 != (48 & Ma)) throw Error(s(327));
                    var e = t.callbackNode;
                    if (Pl() && t.callbackNode !== e) return null;
                    var n = Fe(t, t === Aa ? Pa : 0);
                    if (0 === n) return null;
                    var r = n,
                        i = Ma;
                    Ma |= 16;
                    var o = xl();
                    for (Aa === t && Pa === r || (Ha(), _l(t, r));;) try {
                        Tl();
                        break
                    } catch (e) {
                        yl(t, e)
                    }
                    if (Qi(), Sa.current = o, Ma = i, null !== Ra ? r = 0 : (Aa = null, Pa = 0, r = Oa), 0 != (Na & Ua)) _l(t, 0);
                    else if (0 !== r) {
                        if (2 === r && (Ma |= 64, t.hydrate && (t.hydrate = !1, Vr(t.containerInfo)), 0 !== (n = Be(t)) && (r = bl(t, n))), 1 === r) throw e = La, _l(t, 0), dl(t, n), hl(t, ki()), e;
                        switch (t.finishedWork = t.current.alternate, t.finishedLanes = n, r) {
                            case 0:
                            case 1:
                                throw Error(s(345));
                            case 2:
                                Ml(t);
                                break;
                            case 3:
                                if (dl(t, n), (62914560 & n) === n && 10 < (r = ka + 500 - ki())) {
                                    if (0 !== Fe(t, 0)) break;
                                    if (((i = t.suspendedLanes) & n) !== n) {
                                        sl(), t.pingedLanes |= t.suspendedLanes & i;
                                        break
                                    }
                                    t.timeoutHandle = Hr(Ml.bind(null, t), r);
                                    break
                                }
                                Ml(t);
                                break;
                            case 4:
                                if (dl(t, n), (4186112 & n) === n) break;
                                for (r = t.eventTimes, i = -1; 0 < n;) {
                                    var a = 31 - Ve(n);
                                    o = 1 << a, (a = r[a]) > i && (i = a), n &= ~o
                                }
                                if (n = i, 10 < (n = (120 > (n = ki() - n) ? 120 : 480 > n ? 480 : 1080 > n ? 1080 : 1920 > n ? 1920 : 3e3 > n ? 3e3 : 4320 > n ? 4320 : 1960 * Ta(n / 1960)) - n)) {
                                    t.timeoutHandle = Hr(Ml.bind(null, t), n);
                                    break
                                }
                                Ml(t);
                                break;
                            case 5:
                                Ml(t);
                                break;
                            default:
                                throw Error(s(329))
                        }
                    }
                    return hl(t, ki()), t.callbackNode === e ? cl.bind(null, t) : null
                }

                function dl(t, e) {
                    for (e &= ~Fa, e &= ~Ua, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes; 0 < e;) {
                        var n = 31 - Ve(e),
                            r = 1 << n;
                        t[n] = -1, e &= ~r
                    }
                }

                function pl(t) {
                    if (0 != (48 & Ma)) throw Error(s(327));
                    if (Pl(), t === Aa && 0 != (t.expiredLanes & Pa)) {
                        var e = Pa,
                            n = bl(t, e);
                        0 != (Na & Ua) && (n = bl(t, e = Fe(t, e)))
                    } else n = bl(t, e = Fe(t, 0));
                    if (0 !== t.tag && 2 === n && (Ma |= 64, t.hydrate && (t.hydrate = !1, Vr(t.containerInfo)), 0 !== (e = Be(t)) && (n = bl(t, e))), 1 === n) throw n = La, _l(t, 0), dl(t, e), hl(t, ki()), n;
                    return t.finishedWork = t.current.alternate, t.finishedLanes = e, Ml(t), hl(t, ki()), null
                }

                function fl(t, e) {
                    var n = Ma;
                    Ma |= 1;
                    try {
                        return t(e)
                    } finally {
                        0 === (Ma = n) && (Ha(), Wi())
                    }
                }

                function ml(t, e) {
                    var n = Ma;
                    Ma &= -2, Ma |= 8;
                    try {
                        return t(e)
                    } finally {
                        0 === (Ma = n) && (Ha(), Wi())
                    }
                }

                function gl(t, e) {
                    ai(Ca, Ia), Ia |= e, Na |= e
                }

                function vl() {
                    Ia = Ca.current, si(Ca)
                }

                function _l(t, e) {
                    t.finishedWork = null, t.finishedLanes = 0;
                    var n = t.timeoutHandle;
                    if (-1 !== n && (t.timeoutHandle = -1, zr(n)), null !== Ra)
                        for (n = Ra.return; null !== n;) {
                            var r = n;
                            switch (r.tag) {
                                case 1:
                                    null != (r = r.type.childContextTypes) && fi();
                                    break;
                                case 3:
                                    Co(), si(hi), si(ui), jo();
                                    break;
                                case 5:
                                    Lo(r);
                                    break;
                                case 4:
                                    Co();
                                    break;
                                case 13:
                                case 19:
                                    si(No);
                                    break;
                                case 10:
                                    $i(r);
                                    break;
                                case 23:
                                case 24:
                                    vl()
                            }
                            n = n.return
                        }
                    Aa = t, Ra = Gl(t.current, null), Pa = Ia = Na = e, Oa = 0, La = null, Fa = Ua = Da = 0
                }

                function yl(t, e) {
                    for (;;) {
                        var n = Ra;
                        try {
                            if (Qi(), Yo.current = Rs, $o) {
                                for (var r = Ko.memoizedState; null !== r;) {
                                    var i = r.queue;
                                    null !== i && (i.pending = null), r = r.next
                                }
                                $o = !1
                            }
                            if (Zo = 0, Qo = Jo = Ko = null, ts = !1, wa.current = null, null === n || null === n.return) {
                                Oa = 1, La = e, Ra = null;
                                break
                            }
                            t: {
                                var o = t,
                                    s = n.return,
                                    a = n,
                                    l = e;
                                if (e = Pa, a.flags |= 2048, a.firstEffect = a.lastEffect = null, null !== l && "object" == typeof l && "function" == typeof l.then) {
                                    var u = l;
                                    if (0 == (2 & a.mode)) {
                                        var h = a.alternate;
                                        h ? (a.updateQueue = h.updateQueue, a.memoizedState = h.memoizedState, a.lanes = h.lanes) : (a.updateQueue = null, a.memoizedState = null)
                                    }
                                    var c = 0 != (1 & No.current),
                                        d = s;
                                    do {
                                        var p;
                                        if (p = 13 === d.tag) {
                                            var f = d.memoizedState;
                                            if (null !== f) p = null !== f.dehydrated;
                                            else {
                                                var m = d.memoizedProps;
                                                p = void 0 !== m.fallback && (!0 !== m.unstable_avoidThisFallback || !c)
                                            }
                                        }
                                        if (p) {
                                            var g = d.updateQueue;
                                            if (null === g) {
                                                var v = new Set;
                                                v.add(u), d.updateQueue = v
                                            } else g.add(u);
                                            if (0 == (2 & d.mode)) {
                                                if (d.flags |= 64, a.flags |= 16384, a.flags &= -2981, 1 === a.tag)
                                                    if (null === a.alternate) a.tag = 17;
                                                    else {
                                                        var _ = so(-1, 1);
                                                        _.tag = 2, ao(a, _)
                                                    } a.lanes |= 1;
                                                break t
                                            }
                                            l = void 0, a = e;
                                            var y = o.pingCache;
                                            if (null === y ? (y = o.pingCache = new oa, l = new Set, y.set(u, l)) : void 0 === (l = y.get(u)) && (l = new Set, y.set(u, l)), !l.has(a)) {
                                                l.add(a);
                                                var x = Dl.bind(null, o, u, a);
                                                u.then(x, x)
                                            }
                                            d.flags |= 4096, d.lanes = e;
                                            break t
                                        }
                                        d = d.return
                                    } while (null !== d);
                                    l = Error((Y(a.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.")
                                }
                                5 !== Oa && (Oa = 2),
                                l = ra(l, a),
                                d = s;do {
                                    switch (d.tag) {
                                        case 3:
                                            o = l, d.flags |= 4096, e &= -e, d.lanes |= e, lo(d, sa(0, o, e));
                                            break t;
                                        case 1:
                                            o = l;
                                            var b = d.type,
                                                E = d.stateNode;
                                            if (0 == (64 & d.flags) && ("function" == typeof b.getDerivedStateFromError || null !== E && "function" == typeof E.componentDidCatch && (null === ja || !ja.has(E)))) {
                                                d.flags |= 4096, e &= -e, d.lanes |= e, lo(d, aa(d, o, e));
                                                break t
                                            }
                                    }
                                    d = d.return
                                } while (null !== d)
                            }
                            wl(n)
                        } catch (t) {
                            e = t, Ra === n && null !== n && (Ra = n = n.return);
                            continue
                        }
                        break
                    }
                }

                function xl() {
                    var t = Sa.current;
                    return Sa.current = Rs, null === t ? Rs : t
                }

                function bl(t, e) {
                    var n = Ma;
                    Ma |= 16;
                    var r = xl();
                    for (Aa === t && Pa === e || _l(t, e);;) try {
                        El();
                        break
                    } catch (e) {
                        yl(t, e)
                    }
                    if (Qi(), Ma = n, Sa.current = r, null !== Ra) throw Error(s(261));
                    return Aa = null, Pa = 0, Oa
                }

                function El() {
                    for (; null !== Ra;) Sl(Ra)
                }

                function Tl() {
                    for (; null !== Ra && !Si();) Sl(Ra)
                }

                function Sl(t) {
                    var e = za(t.alternate, t, Ia);
                    t.memoizedProps = t.pendingProps, null === e ? wl(t) : Ra = e, wa.current = null
                }

                function wl(t) {
                    var e = t;
                    do {
                        var n = e.alternate;
                        if (t = e.return, 0 == (2048 & e.flags)) {
                            if (null !== (n = ea(n, e, Ia))) return void(Ra = n);
                            if (24 !== (n = e).tag && 23 !== n.tag || null === n.memoizedState || 0 != (1073741824 & Ia) || 0 == (4 & n.mode)) {
                                for (var r = 0, i = n.child; null !== i;) r |= i.lanes | i.childLanes, i = i.sibling;
                                n.childLanes = r
                            }
                            null !== t && 0 == (2048 & t.flags) && (null === t.firstEffect && (t.firstEffect = e.firstEffect), null !== e.lastEffect && (null !== t.lastEffect && (t.lastEffect.nextEffect = e.firstEffect), t.lastEffect = e.lastEffect), 1 < e.flags && (null !== t.lastEffect ? t.lastEffect.nextEffect = e : t.firstEffect = e, t.lastEffect = e))
                        } else {
                            if (null !== (n = na(e))) return n.flags &= 2047, void(Ra = n);
                            null !== t && (t.firstEffect = t.lastEffect = null, t.flags |= 2048)
                        }
                        if (null !== (e = e.sibling)) return void(Ra = e);
                        Ra = e = t
                    } while (null !== e);
                    0 === Oa && (Oa = 5)
                }

                function Ml(t) {
                    var e = Gi();
                    return zi(99, Al.bind(null, t, e)), null
                }

                function Al(t, e) {
                    do {
                        Pl()
                    } while (null !== qa);
                    if (0 != (48 & Ma)) throw Error(s(327));
                    var n = t.finishedWork;
                    if (null === n) return null;
                    if (t.finishedWork = null, t.finishedLanes = 0, n === t.current) throw Error(s(177));
                    t.callbackNode = null;
                    var r = n.lanes | n.childLanes,
                        i = r,
                        o = t.pendingLanes & ~i;
                    t.pendingLanes = i, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= i, t.mutableReadLanes &= i, t.entangledLanes &= i, i = t.entanglements;
                    for (var a = t.eventTimes, l = t.expirationTimes; 0 < o;) {
                        var u = 31 - Ve(o),
                            h = 1 << u;
                        i[u] = 0, a[u] = -1, l[u] = -1, o &= ~h
                    }
                    if (null !== Qa && 0 == (24 & r) && Qa.has(t) && Qa.delete(t), t === Aa && (Ra = Aa = null, Pa = 0), 1 < n.flags ? null !== n.lastEffect ? (n.lastEffect.nextEffect = n, r = n.firstEffect) : r = n : r = n.firstEffect, null !== r) {
                        if (i = Ma, Ma |= 32, wa.current = null, Fr = qe, pr(a = dr())) {
                            if ("selectionStart" in a) l = {
                                start: a.selectionStart,
                                end: a.selectionEnd
                            };
                            else t: if (l = (l = a.ownerDocument) && l.defaultView || window, (h = l.getSelection && l.getSelection()) && 0 !== h.rangeCount) {
                                l = h.anchorNode, o = h.anchorOffset, u = h.focusNode, h = h.focusOffset;
                                try {
                                    l.nodeType, u.nodeType
                                } catch (t) {
                                    l = null;
                                    break t
                                }
                                var c = 0,
                                    d = -1,
                                    p = -1,
                                    f = 0,
                                    m = 0,
                                    g = a,
                                    v = null;
                                e: for (;;) {
                                    for (var _; g !== l || 0 !== o && 3 !== g.nodeType || (d = c + o), g !== u || 0 !== h && 3 !== g.nodeType || (p = c + h), 3 === g.nodeType && (c += g.nodeValue.length), null !== (_ = g.firstChild);) v = g, g = _;
                                    for (;;) {
                                        if (g === a) break e;
                                        if (v === l && ++f === o && (d = c), v === u && ++m === h && (p = c), null !== (_ = g.nextSibling)) break;
                                        v = (g = v).parentNode
                                    }
                                    g = _
                                }
                                l = -1 === d || -1 === p ? null : {
                                    start: d,
                                    end: p
                                }
                            } else l = null;
                            l = l || {
                                start: 0,
                                end: 0
                            }
                        } else l = null;
                        Br = {
                            focusedElem: a,
                            selectionRange: l
                        }, qe = !1, il = null, ol = !1, Va = r;
                        do {
                            try {
                                Rl()
                            } catch (t) {
                                if (null === Va) throw Error(s(330));
                                Nl(Va, t), Va = Va.nextEffect
                            }
                        } while (null !== Va);
                        il = null, Va = r;
                        do {
                            try {
                                for (a = t; null !== Va;) {
                                    var y = Va.flags;
                                    if (16 & y && vt(Va.stateNode, ""), 128 & y) {
                                        var x = Va.alternate;
                                        if (null !== x) {
                                            var b = x.ref;
                                            null !== b && ("function" == typeof b ? b(null) : b.current = null)
                                        }
                                    }
                                    switch (1038 & y) {
                                        case 2:
                                            ga(Va), Va.flags &= -3;
                                            break;
                                        case 6:
                                            ga(Va), Va.flags &= -3, xa(Va.alternate, Va);
                                            break;
                                        case 1024:
                                            Va.flags &= -1025;
                                            break;
                                        case 1028:
                                            Va.flags &= -1025, xa(Va.alternate, Va);
                                            break;
                                        case 4:
                                            xa(Va.alternate, Va);
                                            break;
                                        case 8:
                                            ya(a, l = Va);
                                            var E = l.alternate;
                                            fa(l), null !== E && fa(E)
                                    }
                                    Va = Va.nextEffect
                                }
                            } catch (t) {
                                if (null === Va) throw Error(s(330));
                                Nl(Va, t), Va = Va.nextEffect
                            }
                        } while (null !== Va);
                        if (b = Br, x = dr(), y = b.focusedElem, a = b.selectionRange, x !== y && y && y.ownerDocument && cr(y.ownerDocument.documentElement, y)) {
                            null !== a && pr(y) && (x = a.start, void 0 === (b = a.end) && (b = x), "selectionStart" in y ? (y.selectionStart = x, y.selectionEnd = Math.min(b, y.value.length)) : (b = (x = y.ownerDocument || document) && x.defaultView || window).getSelection && (b = b.getSelection(), l = y.textContent.length, E = Math.min(a.start, l), a = void 0 === a.end ? E : Math.min(a.end, l), !b.extend && E > a && (l = a, a = E, E = l), l = hr(y, E), o = hr(y, a), l && o && (1 !== b.rangeCount || b.anchorNode !== l.node || b.anchorOffset !== l.offset || b.focusNode !== o.node || b.focusOffset !== o.offset) && ((x = x.createRange()).setStart(l.node, l.offset), b.removeAllRanges(), E > a ? (b.addRange(x), b.extend(o.node, o.offset)) : (x.setEnd(o.node, o.offset), b.addRange(x))))), x = [];
                            for (b = y; b = b.parentNode;) 1 === b.nodeType && x.push({
                                element: b,
                                left: b.scrollLeft,
                                top: b.scrollTop
                            });
                            for ("function" == typeof y.focus && y.focus(), y = 0; y < x.length; y++)(b = x[y]).element.scrollLeft = b.left, b.element.scrollTop = b.top
                        }
                        qe = !!Fr, Br = Fr = null, t.current = n, Va = r;
                        do {
                            try {
                                for (y = t; null !== Va;) {
                                    var T = Va.flags;
                                    if (36 & T && ca(y, Va.alternate, Va), 128 & T) {
                                        x = void 0;
                                        var S = Va.ref;
                                        if (null !== S) {
                                            var w = Va.stateNode;
                                            switch (Va.tag) {
                                                case 5:
                                                    x = w;
                                                    break;
                                                default:
                                                    x = w
                                            }
                                            "function" == typeof S ? S(x) : S.current = x
                                        }
                                    }
                                    Va = Va.nextEffect
                                }
                            } catch (t) {
                                if (null === Va) throw Error(s(330));
                                Nl(Va, t), Va = Va.nextEffect
                            }
                        } while (null !== Va);
                        Va = null, Ni(), Ma = i
                    } else t.current = n;
                    if (Ya) Ya = !1, qa = t, Za = e;
                    else
                        for (Va = r; null !== Va;) e = Va.nextEffect, Va.nextEffect = null, 8 & Va.flags && ((T = Va).sibling = null, T.stateNode = null), Va = e;
                    if (0 === (r = t.pendingLanes) && (ja = null), 1 === r ? t === tl ? $a++ : ($a = 0, tl = t) : $a = 0, n = n.stateNode, xi && "function" == typeof xi.onCommitFiberRoot) try {
                        xi.onCommitFiberRoot(yi, n, void 0, 64 == (64 & n.current.flags))
                    } catch (t) {}
                    if (hl(t, ki()), Wa) throw Wa = !1, t = Xa, Xa = null, t;
                    return 0 != (8 & Ma) || Wi(), null
                }

                function Rl() {
                    for (; null !== Va;) {
                        var t = Va.alternate;
                        ol || null === il || (0 != (8 & Va.flags) ? $t(Va, il) && (ol = !0) : 13 === Va.tag && Ea(t, Va) && $t(Va, il) && (ol = !0));
                        var e = Va.flags;
                        0 != (256 & e) && ha(t, Va), 0 == (512 & e) || Ya || (Ya = !0, Vi(97, (function() {
                            return Pl(), null
                        }))), Va = Va.nextEffect
                    }
                }

                function Pl() {
                    if (90 !== Za) {
                        var t = 97 < Za ? 97 : Za;
                        return Za = 90, zi(t, Ol)
                    }
                    return !1
                }

                function Il(t, e) {
                    Ka.push(e, t), Ya || (Ya = !0, Vi(97, (function() {
                        return Pl(), null
                    })))
                }

                function Cl(t, e) {
                    Ja.push(e, t), Ya || (Ya = !0, Vi(97, (function() {
                        return Pl(), null
                    })))
                }

                function Ol() {
                    if (null === qa) return !1;
                    var t = qa;
                    if (qa = null, 0 != (48 & Ma)) throw Error(s(331));
                    var e = Ma;
                    Ma |= 32;
                    var n = Ja;
                    Ja = [];
                    for (var r = 0; r < n.length; r += 2) {
                        var i = n[r],
                            o = n[r + 1],
                            a = i.destroy;
                        if (i.destroy = void 0, "function" == typeof a) try {
                            a()
                        } catch (t) {
                            if (null === o) throw Error(s(330));
                            Nl(o, t)
                        }
                    }
                    for (n = Ka, Ka = [], r = 0; r < n.length; r += 2) {
                        i = n[r], o = n[r + 1];
                        try {
                            var l = i.create;
                            i.destroy = l()
                        } catch (t) {
                            if (null === o) throw Error(s(330));
                            Nl(o, t)
                        }
                    }
                    for (l = t.current.firstEffect; null !== l;) t = l.nextEffect, l.nextEffect = null, 8 & l.flags && (l.sibling = null, l.stateNode = null), l = t;
                    return Ma = e, Wi(), !0
                }

                function Ll(t, e, n) {
                    ao(t, e = sa(0, e = ra(n, e), 1)), e = sl(), null !== (t = ul(t, 1)) && (ze(t, 1, e), hl(t, e))
                }

                function Nl(t, e) {
                    if (3 === t.tag) Ll(t, t, e);
                    else
                        for (var n = t.return; null !== n;) {
                            if (3 === n.tag) {
                                Ll(n, t, e);
                                break
                            }
                            if (1 === n.tag) {
                                var r = n.stateNode;
                                if ("function" == typeof n.type.getDerivedStateFromError || "function" == typeof r.componentDidCatch && (null === ja || !ja.has(r))) {
                                    var i = aa(n, t = ra(e, t), 1);
                                    if (ao(n, i), i = sl(), null !== (n = ul(n, 1))) ze(n, 1, i), hl(n, i);
                                    else if ("function" == typeof r.componentDidCatch && (null === ja || !ja.has(r))) try {
                                        r.componentDidCatch(e, t)
                                    } catch (t) {}
                                    break
                                }
                            }
                            n = n.return
                        }
                }

                function Dl(t, e, n) {
                    var r = t.pingCache;
                    null !== r && r.delete(e), e = sl(), t.pingedLanes |= t.suspendedLanes & n, Aa === t && (Pa & n) === n && (4 === Oa || 3 === Oa && (62914560 & Pa) === Pa && 500 > ki() - ka ? _l(t, 0) : Fa |= n), hl(t, e)
                }

                function Ul(t, e) {
                    var n = t.stateNode;
                    null !== n && n.delete(e), 0 == (e = 0) && (0 == (2 & (e = t.mode)) ? e = 1 : 0 == (4 & e) ? e = 99 === Gi() ? 1 : 2 : (0 === nl && (nl = Na), 0 === (e = Ge(62914560 & ~nl)) && (e = 4194304))), n = sl(), null !== (t = ul(t, e)) && (ze(t, e, n), hl(t, n))
                }

                function Fl(t, e, n, r) {
                    this.tag = t, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.flags = 0, this.lastEffect = this.firstEffect = this.nextEffect = null, this.childLanes = this.lanes = 0, this.alternate = null
                }

                function Bl(t, e, n, r) {
                    return new Fl(t, e, n, r)
                }

                function kl(t) {
                    return !(!(t = t.prototype) || !t.isReactComponent)
                }

                function Gl(t, e) {
                    var n = t.alternate;
                    return null === n ? ((n = Bl(t.tag, e, t.key, t.mode)).elementType = t.elementType, n.type = t.type, n.stateNode = t.stateNode, n.alternate = t, t.alternate = n) : (n.pendingProps = e, n.type = t.type, n.flags = 0, n.nextEffect = null, n.firstEffect = null, n.lastEffect = null), n.childLanes = t.childLanes, n.lanes = t.lanes, n.child = t.child, n.memoizedProps = t.memoizedProps, n.memoizedState = t.memoizedState, n.updateQueue = t.updateQueue, e = t.dependencies, n.dependencies = null === e ? null : {
                        lanes: e.lanes,
                        firstContext: e.firstContext
                    }, n.sibling = t.sibling, n.index = t.index, n.ref = t.ref, n
                }

                function Hl(t, e, n, r, i, o) {
                    var a = 2;
                    if (r = t, "function" == typeof t) kl(t) && (a = 1);
                    else if ("string" == typeof t) a = 5;
                    else t: switch (t) {
                        case S:
                            return zl(n.children, i, o, e);
                        case U:
                            a = 8, i |= 16;
                            break;
                        case w:
                            a = 8, i |= 1;
                            break;
                        case M:
                            return (t = Bl(12, n, e, 8 | i)).elementType = M, t.type = M, t.lanes = o, t;
                        case I:
                            return (t = Bl(13, n, e, i)).type = I, t.elementType = I, t.lanes = o, t;
                        case C:
                            return (t = Bl(19, n, e, i)).elementType = C, t.lanes = o, t;
                        case F:
                            return Vl(n, i, o, e);
                        case B:
                            return (t = Bl(24, n, e, i)).elementType = B, t.lanes = o, t;
                        default:
                            if ("object" == typeof t && null !== t) switch (t.$$typeof) {
                                case A:
                                    a = 10;
                                    break t;
                                case R:
                                    a = 9;
                                    break t;
                                case P:
                                    a = 11;
                                    break t;
                                case O:
                                    a = 14;
                                    break t;
                                case L:
                                    a = 16, r = null;
                                    break t;
                                case N:
                                    a = 22;
                                    break t
                            }
                            throw Error(s(130, null == t ? t : typeof t, ""))
                    }
                    return (e = Bl(a, n, e, i)).elementType = t, e.type = r, e.lanes = o, e
                }

                function zl(t, e, n, r) {
                    return (t = Bl(7, t, r, e)).lanes = n, t
                }

                function Vl(t, e, n, r) {
                    return (t = Bl(23, t, r, e)).elementType = F, t.lanes = n, t
                }

                function Wl(t, e, n) {
                    return (t = Bl(6, t, null, e)).lanes = n, t
                }

                function Xl(t, e, n) {
                    return (e = Bl(4, null !== t.children ? t.children : [], t.key, e)).lanes = n, e.stateNode = {
                        containerInfo: t.containerInfo,
                        pendingChildren: null,
                        implementation: t.implementation
                    }, e
                }

                function jl(t, e, n) {
                    this.tag = e, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.pendingContext = this.context = null, this.hydrate = n, this.callbackNode = null, this.callbackPriority = 0, this.eventTimes = He(0), this.expirationTimes = He(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = He(0), this.mutableSourceEagerHydrationData = null
                }

                function Yl(t, e, n) {
                    var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
                    return {
                        $$typeof: T,
                        key: null == r ? null : "" + r,
                        children: t,
                        containerInfo: e,
                        implementation: n
                    }
                }

                function ql(t, e, n, r) {
                    var i = e.current,
                        o = sl(),
                        a = al(i);
                    t: if (n) {
                        e: {
                            if (Zt(n = n._reactInternals) !== n || 1 !== n.tag) throw Error(s(170));
                            var l = n;do {
                                switch (l.tag) {
                                    case 3:
                                        l = l.stateNode.context;
                                        break e;
                                    case 1:
                                        if (pi(l.type)) {
                                            l = l.stateNode.__reactInternalMemoizedMergedChildContext;
                                            break e
                                        }
                                }
                                l = l.return
                            } while (null !== l);
                            throw Error(s(171))
                        }
                        if (1 === n.tag) {
                            var u = n.type;
                            if (pi(u)) {
                                n = gi(n, u, l);
                                break t
                            }
                        }
                        n = l
                    }
                    else n = li;
                    return null === e.context ? e.context = n : e.pendingContext = n, (e = so(o, a)).payload = {
                        element: t
                    }, null !== (r = void 0 === r ? null : r) && (e.callback = r), ao(i, e), ll(i, a, o), a
                }

                function Zl(t) {
                    if (!(t = t.current).child) return null;
                    switch (t.child.tag) {
                        case 5:
                        default:
                            return t.child.stateNode
                    }
                }

                function Kl(t, e) {
                    if (null !== (t = t.memoizedState) && null !== t.dehydrated) {
                        var n = t.retryLane;
                        t.retryLane = 0 !== n && n < e ? n : e
                    }
                }

                function Jl(t, e) {
                    Kl(t, e), (t = t.alternate) && Kl(t, e)
                }

                function Ql(t, e, n) {
                    var r = null != n && null != n.hydrationOptions && n.hydrationOptions.mutableSources || null;
                    if (n = new jl(t, e, null != n && !0 === n.hydrate), e = Bl(3, null, null, 2 === e ? 7 : 1 === e ? 3 : 0), n.current = e, e.stateNode = n, io(e), t[Kr] = n.current, Rr(8 === t.nodeType ? t.parentNode : t), r)
                        for (t = 0; t < r.length; t++) {
                            var i = (e = r[t])._getVersion;
                            i = i(e._source), null == n.mutableSourceEagerHydrationData ? n.mutableSourceEagerHydrationData = [e, i] : n.mutableSourceEagerHydrationData.push(e, i)
                        }
                    this._internalRoot = n
                }

                function $l(t) {
                    return !(!t || 1 !== t.nodeType && 9 !== t.nodeType && 11 !== t.nodeType && (8 !== t.nodeType || " react-mount-point-unstable " !== t.nodeValue))
                }

                function tu(t, e, n, r, i) {
                    var o = n._reactRootContainer;
                    if (o) {
                        var s = o._internalRoot;
                        if ("function" == typeof i) {
                            var a = i;
                            i = function() {
                                var t = Zl(s);
                                a.call(t)
                            }
                        }
                        ql(e, s, t, i)
                    } else {
                        if (o = n._reactRootContainer = function(t, e) {
                                if (e || (e = !(!(e = t ? 9 === t.nodeType ? t.documentElement : t.firstChild : null) || 1 !== e.nodeType || !e.hasAttribute("data-reactroot"))), !e)
                                    for (var n; n = t.lastChild;) t.removeChild(n);
                                return new Ql(t, 0, e ? {
                                    hydrate: !0
                                } : void 0)
                            }(n, r), s = o._internalRoot, "function" == typeof i) {
                            var l = i;
                            i = function() {
                                var t = Zl(s);
                                l.call(t)
                            }
                        }
                        ml((function() {
                            ql(e, s, t, i)
                        }))
                    }
                    return Zl(s)
                }

                function eu(t, e) {
                    var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
                    if (!$l(e)) throw Error(s(200));
                    return Yl(t, e, null, n)
                }
                za = function(t, e, n) {
                    var r = e.lanes;
                    if (null !== t)
                        if (t.memoizedProps !== e.pendingProps || hi.current) Ls = !0;
                        else {
                            if (0 == (n & r)) {
                                switch (Ls = !1, e.tag) {
                                    case 3:
                                        Vs(e), Wo();
                                        break;
                                    case 5:
                                        Oo(e);
                                        break;
                                    case 1:
                                        pi(e.type) && vi(e);
                                        break;
                                    case 4:
                                        Io(e, e.stateNode.containerInfo);
                                        break;
                                    case 10:
                                        r = e.memoizedProps.value;
                                        var i = e.type._context;
                                        ai(qi, i._currentValue), i._currentValue = r;
                                        break;
                                    case 13:
                                        if (null !== e.memoizedState) return 0 != (n & e.child.childLanes) ? qs(t, e, n) : (ai(No, 1 & No.current), null !== (e = $s(t, e, n)) ? e.sibling : null);
                                        ai(No, 1 & No.current);
                                        break;
                                    case 19:
                                        if (r = 0 != (n & e.childLanes), 0 != (64 & t.flags)) {
                                            if (r) return Qs(t, e, n);
                                            e.flags |= 64
                                        }
                                        if (null !== (i = e.memoizedState) && (i.rendering = null, i.tail = null, i.lastEffect = null), ai(No, No.current), r) break;
                                        return null;
                                    case 23:
                                    case 24:
                                        return e.lanes = 0, Bs(t, e, n)
                                }
                                return $s(t, e, n)
                            }
                            Ls = 0 != (16384 & t.flags)
                        }
                    else Ls = !1;
                    switch (e.lanes = 0, e.tag) {
                        case 2:
                            if (r = e.type, null !== t && (t.alternate = null, e.alternate = null, e.flags |= 2), t = e.pendingProps, i = di(e, ui.current), eo(e, n), i = rs(null, e, r, t, i, n), e.flags |= 1, "object" == typeof i && null !== i && "function" == typeof i.render && void 0 === i.$$typeof) {
                                if (e.tag = 1, e.memoizedState = null, e.updateQueue = null, pi(r)) {
                                    var o = !0;
                                    vi(e)
                                } else o = !1;
                                e.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null, io(e);
                                var a = r.getDerivedStateFromProps;
                                "function" == typeof a && po(e, r, a, t), i.updater = fo, e.stateNode = i, i._reactInternals = e, _o(e, r, t, n), e = zs(null, e, r, !0, o, n)
                            } else e.tag = 0, Ns(null, e, i, n), e = e.child;
                            return e;
                        case 16:
                            i = e.elementType;
                            t: {
                                switch (null !== t && (t.alternate = null, e.alternate = null, e.flags |= 2), t = e.pendingProps, i = (o = i._init)(i._payload), e.type = i, o = e.tag = function(t) {
                                        if ("function" == typeof t) return kl(t) ? 1 : 0;
                                        if (null != t) {
                                            if ((t = t.$$typeof) === P) return 11;
                                            if (t === O) return 14
                                        }
                                        return 2
                                    }(i), t = Yi(i, t), o) {
                                    case 0:
                                        e = Gs(null, e, i, t, n);
                                        break t;
                                    case 1:
                                        e = Hs(null, e, i, t, n);
                                        break t;
                                    case 11:
                                        e = Ds(null, e, i, t, n);
                                        break t;
                                    case 14:
                                        e = Us(null, e, i, Yi(i.type, t), r, n);
                                        break t
                                }
                                throw Error(s(306, i, ""))
                            }
                            return e;
                        case 0:
                            return r = e.type, i = e.pendingProps, Gs(t, e, r, i = e.elementType === r ? i : Yi(r, i), n);
                        case 1:
                            return r = e.type, i = e.pendingProps, Hs(t, e, r, i = e.elementType === r ? i : Yi(r, i), n);
                        case 3:
                            if (Vs(e), r = e.updateQueue, null === t || null === r) throw Error(s(282));
                            if (r = e.pendingProps, i = null !== (i = e.memoizedState) ? i.element : null, oo(t, e), uo(e, r, null, n), (r = e.memoizedState.element) === i) Wo(), e = $s(t, e, n);
                            else {
                                if ((o = (i = e.stateNode).hydrate) && (Fo = Wr(e.stateNode.containerInfo.firstChild), Uo = e, o = Bo = !0), o) {
                                    if (null != (t = i.mutableSourceEagerHydrationData))
                                        for (i = 0; i < t.length; i += 2)(o = t[i])._workInProgressVersionPrimary = t[i + 1], Xo.push(o);
                                    for (n = So(e, null, r, n), e.child = n; n;) n.flags = -3 & n.flags | 1024, n = n.sibling
                                } else Ns(t, e, r, n), Wo();
                                e = e.child
                            }
                            return e;
                        case 5:
                            return Oo(e), null === t && Ho(e), r = e.type, i = e.pendingProps, o = null !== t ? t.memoizedProps : null, a = i.children, Gr(r, i) ? a = null : null !== o && Gr(r, o) && (e.flags |= 16), ks(t, e), Ns(t, e, a, n), e.child;
                        case 6:
                            return null === t && Ho(e), null;
                        case 13:
                            return qs(t, e, n);
                        case 4:
                            return Io(e, e.stateNode.containerInfo), r = e.pendingProps, null === t ? e.child = To(e, null, r, n) : Ns(t, e, r, n), e.child;
                        case 11:
                            return r = e.type, i = e.pendingProps, Ds(t, e, r, i = e.elementType === r ? i : Yi(r, i), n);
                        case 7:
                            return Ns(t, e, e.pendingProps, n), e.child;
                        case 8:
                        case 12:
                            return Ns(t, e, e.pendingProps.children, n), e.child;
                        case 10:
                            t: {
                                r = e.type._context,
                                i = e.pendingProps,
                                a = e.memoizedProps,
                                o = i.value;
                                var l = e.type._context;
                                if (ai(qi, l._currentValue), l._currentValue = o, null !== a)
                                    if (l = a.value, 0 == (o = sr(l, o) ? 0 : 0 | ("function" == typeof r._calculateChangedBits ? r._calculateChangedBits(l, o) : 1073741823))) {
                                        if (a.children === i.children && !hi.current) {
                                            e = $s(t, e, n);
                                            break t
                                        }
                                    } else
                                        for (null !== (l = e.child) && (l.return = e); null !== l;) {
                                            var u = l.dependencies;
                                            if (null !== u) {
                                                a = l.child;
                                                for (var h = u.firstContext; null !== h;) {
                                                    if (h.context === r && 0 != (h.observedBits & o)) {
                                                        1 === l.tag && ((h = so(-1, n & -n)).tag = 2, ao(l, h)), l.lanes |= n, null !== (h = l.alternate) && (h.lanes |= n), to(l.return, n), u.lanes |= n;
                                                        break
                                                    }
                                                    h = h.next
                                                }
                                            } else a = 10 === l.tag && l.type === e.type ? null : l.child;
                                            if (null !== a) a.return = l;
                                            else
                                                for (a = l; null !== a;) {
                                                    if (a === e) {
                                                        a = null;
                                                        break
                                                    }
                                                    if (null !== (l = a.sibling)) {
                                                        l.return = a.return, a = l;
                                                        break
                                                    }
                                                    a = a.return
                                                }
                                            l = a
                                        }
                                Ns(t, e, i.children, n),
                                e = e.child
                            }
                            return e;
                        case 9:
                            return i = e.type, r = (o = e.pendingProps).children, eo(e, n), r = r(i = no(i, o.unstable_observedBits)), e.flags |= 1, Ns(t, e, r, n), e.child;
                        case 14:
                            return o = Yi(i = e.type, e.pendingProps), Us(t, e, i, o = Yi(i.type, o), r, n);
                        case 15:
                            return Fs(t, e, e.type, e.pendingProps, r, n);
                        case 17:
                            return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Yi(r, i), null !== t && (t.alternate = null, e.alternate = null, e.flags |= 2), e.tag = 1, pi(r) ? (t = !0, vi(e)) : t = !1, eo(e, n), go(e, r, i), _o(e, r, i, n), zs(null, e, r, !0, t, n);
                        case 19:
                            return Qs(t, e, n);
                        case 23:
                        case 24:
                            return Bs(t, e, n)
                    }
                    throw Error(s(156, e.tag))
                }, Ql.prototype.render = function(t) {
                    ql(t, this._internalRoot, null, null)
                }, Ql.prototype.unmount = function() {
                    var t = this._internalRoot,
                        e = t.containerInfo;
                    ql(null, t, null, (function() {
                        e[Kr] = null
                    }))
                }, te = function(t) {
                    13 === t.tag && (ll(t, 4, sl()), Jl(t, 4))
                }, ee = function(t) {
                    13 === t.tag && (ll(t, 67108864, sl()), Jl(t, 67108864))
                }, ne = function(t) {
                    if (13 === t.tag) {
                        var e = sl(),
                            n = al(t);
                        ll(t, n, e), Jl(t, n)
                    }
                }, re = function(t, e) {
                    return e()
                }, Mt = function(t, e, n) {
                    switch (e) {
                        case "input":
                            if (nt(t, n), e = n.name, "radio" === n.type && null != e) {
                                for (n = t; n.parentNode;) n = n.parentNode;
                                for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < n.length; e++) {
                                    var r = n[e];
                                    if (r !== t && r.form === t.form) {
                                        var i = ei(r);
                                        if (!i) throw Error(s(90));
                                        J(r), nt(r, i)
                                    }
                                }
                            }
                            break;
                        case "textarea":
                            ut(t, n);
                            break;
                        case "select":
                            null != (e = n.value) && st(t, !!n.multiple, e, !1)
                    }
                }, Ot = fl, Lt = function(t, e, n, r, i) {
                    var o = Ma;
                    Ma |= 4;
                    try {
                        return zi(98, t.bind(null, e, n, r, i))
                    } finally {
                        0 === (Ma = o) && (Ha(), Wi())
                    }
                }, Nt = function() {
                    0 == (49 & Ma) && (function() {
                        if (null !== Qa) {
                            var t = Qa;
                            Qa = null, t.forEach((function(t) {
                                t.expiredLanes |= 24 & t.pendingLanes, hl(t, ki())
                            }))
                        }
                        Wi()
                    }(), Pl())
                }, Dt = function(t, e) {
                    var n = Ma;
                    Ma |= 2;
                    try {
                        return t(e)
                    } finally {
                        0 === (Ma = n) && (Ha(), Wi())
                    }
                };
                var nu = {
                        Events: [$r, ti, ei, It, Ct, Pl, {
                            current: !1
                        }]
                    },
                    ru = {
                        findFiberByHostInstance: Qr,
                        bundleType: 0,
                        version: "17.0.2",
                        rendererPackageName: "react-dom"
                    },
                    iu = {
                        bundleType: ru.bundleType,
                        version: ru.version,
                        rendererPackageName: ru.rendererPackageName,
                        rendererConfig: ru.rendererConfig,
                        overrideHookState: null,
                        overrideHookStateDeletePath: null,
                        overrideHookStateRenamePath: null,
                        overrideProps: null,
                        overridePropsDeletePath: null,
                        overridePropsRenamePath: null,
                        setSuspenseHandler: null,
                        scheduleUpdate: null,
                        currentDispatcherRef: b.ReactCurrentDispatcher,
                        findHostInstanceByFiber: function(t) {
                            return null === (t = Qt(t)) ? null : t.stateNode
                        },
                        findFiberByHostInstance: ru.findFiberByHostInstance || function() {
                            return null
                        },
                        findHostInstancesForRefresh: null,
                        scheduleRefresh: null,
                        scheduleRoot: null,
                        setRefreshHandler: null,
                        getCurrentFiber: null
                    };
                if ("undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
                    var ou = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                    if (!ou.isDisabled && ou.supportsFiber) try {
                        yi = ou.inject(iu), xi = ou
                    } catch (mt) {}
                }
                e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = nu, e.createPortal = eu, e.findDOMNode = function(t) {
                    if (null == t) return null;
                    if (1 === t.nodeType) return t;
                    var e = t._reactInternals;
                    if (void 0 === e) {
                        if ("function" == typeof t.render) throw Error(s(188));
                        throw Error(s(268, Object.keys(t)))
                    }
                    return null === (t = Qt(e)) ? null : t.stateNode
                }, e.flushSync = function(t, e) {
                    var n = Ma;
                    if (0 != (48 & n)) return t(e);
                    Ma |= 1;
                    try {
                        if (t) return zi(99, t.bind(null, e))
                    } finally {
                        Ma = n, Wi()
                    }
                }, e.hydrate = function(t, e, n) {
                    if (!$l(e)) throw Error(s(200));
                    return tu(null, t, e, !0, n)
                }, e.render = function(t, e, n) {
                    if (!$l(e)) throw Error(s(200));
                    return tu(null, t, e, !1, n)
                }, e.unmountComponentAtNode = function(t) {
                    if (!$l(t)) throw Error(s(40));
                    return !!t._reactRootContainer && (ml((function() {
                        tu(null, null, t, !1, (function() {
                            t._reactRootContainer = null, t[Kr] = null
                        }))
                    })), !0)
                }, e.unstable_batchedUpdates = fl, e.unstable_createPortal = function(t, e) {
                    return eu(t, e, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null)
                }, e.unstable_renderSubtreeIntoContainer = function(t, e, n, r) {
                    if (!$l(n)) throw Error(s(200));
                    if (null == t || void 0 === t._reactInternals) throw Error(s(38));
                    return tu(t, e, n, !1, r)
                }, e.version = "17.0.2"
            },
            935: (t, e, n) => {
                "use strict";
                ! function t() {
                    if ("undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE) try {
                        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)
                    } catch (t) {
                        console.error(t)
                    }
                }(), t.exports = n(448)
            },
            87: (t, e) => {
                (() => {
                    var t = {
                            418: t => {
                                "use strict";
                                var e = Object.getOwnPropertySymbols,
                                    n = Object.prototype.hasOwnProperty,
                                    r = Object.prototype.propertyIsEnumerable;

                                function i(t) {
                                    if (null == t) throw new TypeError("Object.assign cannot be called with null or undefined");
                                    return Object(t)
                                }
                                t.exports = function() {
                                    try {
                                        if (!Object.assign) return !1;
                                        var t = new String("abc");
                                        if (t[5] = "de", "5" === Object.getOwnPropertyNames(t)[0]) return !1;
                                        for (var e = {}, n = 0; n < 10; n++) e["_" + String.fromCharCode(n)] = n;
                                        if ("0123456789" !== Object.getOwnPropertyNames(e).map((function(t) {
                                                return e[t]
                                            })).join("")) return !1;
                                        var r = {};
                                        return "abcdefghijklmnopqrst".split("").forEach((function(t) {
                                            r[t] = t
                                        })), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, r)).join("")
                                    } catch (t) {
                                        return !1
                                    }
                                }() ? Object.assign : function(t, o) {
                                    for (var s, a, l = i(t), u = 1; u < arguments.length; u++) {
                                        for (var h in s = Object(arguments[u])) n.call(s, h) && (l[h] = s[h]);
                                        if (e) {
                                            a = e(s);
                                            for (var c = 0; c < a.length; c++) r.call(s, a[c]) && (l[a[c]] = s[a[c]])
                                        }
                                    }
                                    return l
                                }
                            },
                            703: (t, e, n) => {
                                "use strict";
                                var r = n(414);

                                function i() {}

                                function o() {}
                                o.resetWarningCache = i, t.exports = function() {
                                    function t(t, e, n, i, o, s) {
                                        if (s !== r) {
                                            var a = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                                            throw a.name = "Invariant Violation", a
                                        }
                                    }

                                    function e() {
                                        return t
                                    }
                                    t.isRequired = t;
                                    var n = {
                                        array: t,
                                        bool: t,
                                        func: t,
                                        number: t,
                                        object: t,
                                        string: t,
                                        symbol: t,
                                        any: t,
                                        arrayOf: e,
                                        element: t,
                                        elementType: t,
                                        instanceOf: e,
                                        node: t,
                                        objectOf: e,
                                        oneOf: e,
                                        oneOfType: e,
                                        shape: e,
                                        exact: e,
                                        checkPropTypes: o,
                                        resetWarningCache: i
                                    };
                                    return n.PropTypes = n, n
                                }
                            },
                            697: (t, e, n) => {
                                t.exports = n(703)()
                            },
                            414: t => {
                                "use strict";
                                t.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
                            },
                            408: (t, e, n) => {
                                "use strict";
                                var r = n(418),
                                    i = 60103,
                                    o = 60106;
                                e.Fragment = 60107, e.StrictMode = 60108, e.Profiler = 60114;
                                var s = 60109,
                                    a = 60110,
                                    l = 60112;
                                e.Suspense = 60113;
                                var u = 60115,
                                    h = 60116;
                                if ("function" == typeof Symbol && Symbol.for) {
                                    var c = Symbol.for;
                                    i = c("react.element"), o = c("react.portal"), e.Fragment = c("react.fragment"), e.StrictMode = c("react.strict_mode"), e.Profiler = c("react.profiler"), s = c("react.provider"), a = c("react.context"), l = c("react.forward_ref"), e.Suspense = c("react.suspense"), u = c("react.memo"), h = c("react.lazy")
                                }
                                var d = "function" == typeof Symbol && Symbol.iterator;

                                function p(t) {
                                    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++) e += "&args[]=" + encodeURIComponent(arguments[n]);
                                    return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
                                }
                                var f = {
                                        isMounted: function() {
                                            return !1
                                        },
                                        enqueueForceUpdate: function() {},
                                        enqueueReplaceState: function() {},
                                        enqueueSetState: function() {}
                                    },
                                    m = {};

                                function g(t, e, n) {
                                    this.props = t, this.context = e, this.refs = m, this.updater = n || f
                                }

                                function v() {}

                                function _(t, e, n) {
                                    this.props = t, this.context = e, this.refs = m, this.updater = n || f
                                }
                                g.prototype.isReactComponent = {}, g.prototype.setState = function(t, e) {
                                    if ("object" != typeof t && "function" != typeof t && null != t) throw Error(p(85));
                                    this.updater.enqueueSetState(this, t, e, "setState")
                                }, g.prototype.forceUpdate = function(t) {
                                    this.updater.enqueueForceUpdate(this, t, "forceUpdate")
                                }, v.prototype = g.prototype;
                                var y = _.prototype = new v;
                                y.constructor = _, r(y, g.prototype), y.isPureReactComponent = !0;
                                var x = {
                                        current: null
                                    },
                                    b = Object.prototype.hasOwnProperty,
                                    E = {
                                        key: !0,
                                        ref: !0,
                                        __self: !0,
                                        __source: !0
                                    };

                                function T(t, e, n) {
                                    var r, o = {},
                                        s = null,
                                        a = null;
                                    if (null != e)
                                        for (r in void 0 !== e.ref && (a = e.ref), void 0 !== e.key && (s = "" + e.key), e) b.call(e, r) && !E.hasOwnProperty(r) && (o[r] = e[r]);
                                    var l = arguments.length - 2;
                                    if (1 === l) o.children = n;
                                    else if (1 < l) {
                                        for (var u = Array(l), h = 0; h < l; h++) u[h] = arguments[h + 2];
                                        o.children = u
                                    }
                                    if (t && t.defaultProps)
                                        for (r in l = t.defaultProps) void 0 === o[r] && (o[r] = l[r]);
                                    return {
                                        $$typeof: i,
                                        type: t,
                                        key: s,
                                        ref: a,
                                        props: o,
                                        _owner: x.current
                                    }
                                }

                                function S(t) {
                                    return "object" == typeof t && null !== t && t.$$typeof === i
                                }
                                var w = /\/+/g;

                                function M(t, e) {
                                    return "object" == typeof t && null !== t && null != t.key ? function(t) {
                                        var e = {
                                            "=": "=0",
                                            ":": "=2"
                                        };
                                        return "$" + t.replace(/[=:]/g, (function(t) {
                                            return e[t]
                                        }))
                                    }("" + t.key) : e.toString(36)
                                }

                                function A(t, e, n, r, s) {
                                    var a = typeof t;
                                    "undefined" !== a && "boolean" !== a || (t = null);
                                    var l = !1;
                                    if (null === t) l = !0;
                                    else switch (a) {
                                        case "string":
                                        case "number":
                                            l = !0;
                                            break;
                                        case "object":
                                            switch (t.$$typeof) {
                                                case i:
                                                case o:
                                                    l = !0
                                            }
                                    }
                                    if (l) return s = s(l = t), t = "" === r ? "." + M(l, 0) : r, Array.isArray(s) ? (n = "", null != t && (n = t.replace(w, "$&/") + "/"), A(s, e, n, "", (function(t) {
                                        return t
                                    }))) : null != s && (S(s) && (s = function(t, e) {
                                        return {
                                            $$typeof: i,
                                            type: t.type,
                                            key: e,
                                            ref: t.ref,
                                            props: t.props,
                                            _owner: t._owner
                                        }
                                    }(s, n + (!s.key || l && l.key === s.key ? "" : ("" + s.key).replace(w, "$&/") + "/") + t)), e.push(s)), 1;
                                    if (l = 0, r = "" === r ? "." : r + ":", Array.isArray(t))
                                        for (var u = 0; u < t.length; u++) {
                                            var h = r + M(a = t[u], u);
                                            l += A(a, e, n, h, s)
                                        } else if ("function" == typeof(h = function(t) {
                                                return null === t || "object" != typeof t ? null : "function" == typeof(t = d && t[d] || t["@@iterator"]) ? t : null
                                            }(t)))
                                            for (t = h.call(t), u = 0; !(a = t.next()).done;) l += A(a = a.value, e, n, h = r + M(a, u++), s);
                                        else if ("object" === a) throw e = "" + t, Error(p(31, "[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e));
                                    return l
                                }

                                function R(t, e, n) {
                                    if (null == t) return t;
                                    var r = [],
                                        i = 0;
                                    return A(t, r, "", "", (function(t) {
                                        return e.call(n, t, i++)
                                    })), r
                                }

                                function P(t) {
                                    if (-1 === t._status) {
                                        var e = t._result;
                                        e = e(), t._status = 0, t._result = e, e.then((function(e) {
                                            0 === t._status && (e = e.default, t._status = 1, t._result = e)
                                        }), (function(e) {
                                            0 === t._status && (t._status = 2, t._result = e)
                                        }))
                                    }
                                    if (1 === t._status) return t._result;
                                    throw t._result
                                }
                                var I = {
                                    current: null
                                };

                                function C() {
                                    var t = I.current;
                                    if (null === t) throw Error(p(321));
                                    return t
                                }
                                var O = {
                                    ReactCurrentDispatcher: I,
                                    ReactCurrentBatchConfig: {
                                        transition: 0
                                    },
                                    ReactCurrentOwner: x,
                                    IsSomeRendererActing: {
                                        current: !1
                                    },
                                    assign: r
                                };
                                e.Children = {
                                    map: R,
                                    forEach: function(t, e, n) {
                                        R(t, (function() {
                                            e.apply(this, arguments)
                                        }), n)
                                    },
                                    count: function(t) {
                                        var e = 0;
                                        return R(t, (function() {
                                            e++
                                        })), e
                                    },
                                    toArray: function(t) {
                                        return R(t, (function(t) {
                                            return t
                                        })) || []
                                    },
                                    only: function(t) {
                                        if (!S(t)) throw Error(p(143));
                                        return t
                                    }
                                }, e.Component = g, e.PureComponent = _, e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = O, e.cloneElement = function(t, e, n) {
                                    if (null == t) throw Error(p(267, t));
                                    var o = r({}, t.props),
                                        s = t.key,
                                        a = t.ref,
                                        l = t._owner;
                                    if (null != e) {
                                        if (void 0 !== e.ref && (a = e.ref, l = x.current), void 0 !== e.key && (s = "" + e.key), t.type && t.type.defaultProps) var u = t.type.defaultProps;
                                        for (h in e) b.call(e, h) && !E.hasOwnProperty(h) && (o[h] = void 0 === e[h] && void 0 !== u ? u[h] : e[h])
                                    }
                                    var h = arguments.length - 2;
                                    if (1 === h) o.children = n;
                                    else if (1 < h) {
                                        u = Array(h);
                                        for (var c = 0; c < h; c++) u[c] = arguments[c + 2];
                                        o.children = u
                                    }
                                    return {
                                        $$typeof: i,
                                        type: t.type,
                                        key: s,
                                        ref: a,
                                        props: o,
                                        _owner: l
                                    }
                                }, e.createContext = function(t, e) {
                                    return void 0 === e && (e = null), (t = {
                                        $$typeof: a,
                                        _calculateChangedBits: e,
                                        _currentValue: t,
                                        _currentValue2: t,
                                        _threadCount: 0,
                                        Provider: null,
                                        Consumer: null
                                    }).Provider = {
                                        $$typeof: s,
                                        _context: t
                                    }, t.Consumer = t
                                }, e.createElement = T, e.createFactory = function(t) {
                                    var e = T.bind(null, t);
                                    return e.type = t, e
                                }, e.createRef = function() {
                                    return {
                                        current: null
                                    }
                                }, e.forwardRef = function(t) {
                                    return {
                                        $$typeof: l,
                                        render: t
                                    }
                                }, e.isValidElement = S, e.lazy = function(t) {
                                    return {
                                        $$typeof: h,
                                        _payload: {
                                            _status: -1,
                                            _result: t
                                        },
                                        _init: P
                                    }
                                }, e.memo = function(t, e) {
                                    return {
                                        $$typeof: u,
                                        type: t,
                                        compare: void 0 === e ? null : e
                                    }
                                }, e.useCallback = function(t, e) {
                                    return C().useCallback(t, e)
                                }, e.useContext = function(t, e) {
                                    return C().useContext(t, e)
                                }, e.useDebugValue = function() {}, e.useEffect = function(t, e) {
                                    return C().useEffect(t, e)
                                }, e.useImperativeHandle = function(t, e, n) {
                                    return C().useImperativeHandle(t, e, n)
                                }, e.useLayoutEffect = function(t, e) {
                                    return C().useLayoutEffect(t, e)
                                }, e.useMemo = function(t, e) {
                                    return C().useMemo(t, e)
                                }, e.useReducer = function(t, e, n) {
                                    return C().useReducer(t, e, n)
                                }, e.useRef = function(t) {
                                    return C().useRef(t)
                                }, e.useState = function(t) {
                                    return C().useState(t)
                                }, e.version = "17.0.1"
                            },
                            294: (t, e, n) => {
                                "use strict";
                                t.exports = n(408)
                            }
                        },
                        n = {};

                    function r(e) {
                        if (n[e]) return n[e].exports;
                        var i = n[e] = {
                            exports: {}
                        };
                        return t[e](i, i.exports, r), i.exports
                    }
                    r.n = t => {
                        var e = t && t.__esModule ? () => t.default : () => t;
                        return r.d(e, {
                            a: e
                        }), e
                    }, r.d = (t, e) => {
                        for (var n in e) r.o(e, n) && !r.o(t, n) && Object.defineProperty(t, n, {
                            enumerable: !0,
                            get: e[n]
                        })
                    }, r.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), r.r = t => {
                        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                            value: "Module"
                        }), Object.defineProperty(t, "__esModule", {
                            value: !0
                        })
                    };
                    var i = {};
                    (() => {
                        "use strict";
                        r.r(i), r.d(i, {
                            RangeStepInput: () => h
                        });
                        var t = r(294),
                            e = r(697),
                            n = r.n(e);

                        function o(t) {
                            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                                return typeof t
                            } : function(t) {
                                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                            })(t)
                        }

                        function s(t, e) {
                            return (s = Object.setPrototypeOf || function(t, e) {
                                return t.__proto__ = e, t
                            })(t, e)
                        }

                        function a(t, e) {
                            return !e || "object" !== o(e) && "function" != typeof e ? l(t) : e
                        }

                        function l(t) {
                            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                            return t
                        }

                        function u(t) {
                            return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                                return t.__proto__ || Object.getPrototypeOf(t)
                            })(t)
                        }
                        var h = function(e) {
                            ! function(t, e) {
                                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                                t.prototype = Object.create(e && e.prototype, {
                                    constructor: {
                                        value: t,
                                        writable: !0,
                                        configurable: !0
                                    }
                                }), e && s(t, e)
                            }(h, e);
                            var n, r, i, o = (r = h, i = function() {
                                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                                if (Reflect.construct.sham) return !1;
                                if ("function" == typeof Proxy) return !0;
                                try {
                                    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                                } catch (t) {
                                    return !1
                                }
                            }(), function() {
                                var t, e = u(r);
                                if (i) {
                                    var n = u(this).constructor;
                                    t = Reflect.construct(e, arguments, n)
                                } else t = e.apply(this, arguments);
                                return a(this, t)
                            });

                            function h(e) {
                                var n;
                                return function(t, e) {
                                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                                }(this, h), (n = o.call(this, e)).state = {
                                    isMouseDown: !1,
                                    isDragging: !1
                                }, n.onInput = n.onInput.bind(l(n)), n.onMouseDown = n.onMouseDown.bind(l(n)), n.onMouseUp = n.onMouseUp.bind(l(n)), n.onMouseMove = n.onMouseMove.bind(l(n)), n.domRef = t.createRef(), n
                            }
                            return (n = [{
                                key: "render",
                                value: function() {
                                    return t.createElement("input", {
                                        type: "range",
                                        ref: this.domRef,
                                        className: this.props.className,
                                        min: this.props.min,
                                        max: this.props.max,
                                        step: this.props.step,
                                        value: this.props.value,
                                        name: this.props.name,
                                        id: this.props.id,
                                        style: this.props.style,
                                        disabled: this.props.disabled,
                                        onChange: this.props.onChange,
                                        onMouseDown: this.onMouseDown,
                                        onMouseUp: this.onMouseUp,
                                        onMouseMove: this.onMouseMove,
                                        onClick: this.onClick,
                                        onInput: this.onInput
                                    })
                                }
                            }, {
                                key: "onMouseDown",
                                value: function() {
                                    if (this.setState({
                                            isMouseDown: !0
                                        }), this.props.hold) {
                                        this.holdLoop && clearInterval(this.holdLoop);
                                        var t = this.props.value,
                                            e = this;
                                        setTimeout((function() {
                                            e.holdLoop && clearInterval(e.holdLoop), e.holdLoop = e.makeHoldLoop(t)
                                        }), 250)
                                    }
                                }
                            }, {
                                key: "onMouseUp",
                                value: function() {
                                    this.setState({
                                        isMouseDown: !1,
                                        isDragging: !1
                                    }), this.holdLoop && clearInterval(this.holdLoop)
                                }
                            }, {
                                key: "onMouseMove",
                                value: function() {
                                    this.state.isMouseDown && this.setState({
                                        isDragging: !0
                                    })
                                }
                            }, {
                                key: "onInput",
                                value: function(t) {
                                    var e, n = this.props.step,
                                        r = (e = t.target.value, e = Number(e), (isNaN(e) || void 0 === e) && (e = 0), e),
                                        i = this.props.value;
                                    this.state.isMouseDown && this.state.isDragging || !i || (t.target.value = r > i ? i + n : i - n)
                                }
                            }, {
                                key: "makeHoldLoop",
                                value: function(t) {
                                    var e = this;
                                    return setInterval((function() {
                                        if (!e.state.isMouseDown || e.state.isDragging) return e.holdLoop && clearInterval(e.holdLoop), !1;
                                        var n = e.domRef.current,
                                            r = e.props.value;
                                        if (t > r && r - e.props.step >= e.props.min ? r -= e.props.step : t < r && r + e.props.step <= e.props.max && (r += e.props.step), t === r) return !1;
                                        Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, "value").set.call(n, r);
                                        var i = new Event("change", {
                                            bubbles: !0
                                        });
                                        return n.dispatchEvent(i)
                                    }), 100)
                                }
                            }]) && function(t, e) {
                                for (var n = 0; n < e.length; n++) {
                                    var r = e[n];
                                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
                                }
                            }(h.prototype, n), h
                        }(t.Component);
                        h.propTypes = {
                            value: n().number.isRequired,
                            onChange: n().func.isRequired,
                            step: n().number.isRequired,
                            className: n().string,
                            min: n().number,
                            max: n().number,
                            id: n().string,
                            name: n().string,
                            disabled: n().bool,
                            style: n().string,
                            hold: n().bool
                        }, h.defaultProps = {
                            hold: !0
                        }
                    })();
                    var o = e;
                    for (var s in i) o[s] = i[s];
                    i.__esModule && Object.defineProperty(o, "__esModule", {
                        value: !0
                    })
                })()
            },
            408: (t, e, n) => {
                "use strict";
                var r = n(418),
                    i = 60103,
                    o = 60106;
                e.Fragment = 60107, e.StrictMode = 60108, e.Profiler = 60114;
                var s = 60109,
                    a = 60110,
                    l = 60112;
                e.Suspense = 60113;
                var u = 60115,
                    h = 60116;
                if ("function" == typeof Symbol && Symbol.for) {
                    var c = Symbol.for;
                    i = c("react.element"), o = c("react.portal"), e.Fragment = c("react.fragment"), e.StrictMode = c("react.strict_mode"), e.Profiler = c("react.profiler"), s = c("react.provider"), a = c("react.context"), l = c("react.forward_ref"), e.Suspense = c("react.suspense"), u = c("react.memo"), h = c("react.lazy")
                }
                var d = "function" == typeof Symbol && Symbol.iterator;

                function p(t) {
                    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++) e += "&args[]=" + encodeURIComponent(arguments[n]);
                    return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
                }
                var f = {
                        isMounted: function() {
                            return !1
                        },
                        enqueueForceUpdate: function() {},
                        enqueueReplaceState: function() {},
                        enqueueSetState: function() {}
                    },
                    m = {};

                function g(t, e, n) {
                    this.props = t, this.context = e, this.refs = m, this.updater = n || f
                }

                function v() {}

                function _(t, e, n) {
                    this.props = t, this.context = e, this.refs = m, this.updater = n || f
                }
                g.prototype.isReactComponent = {}, g.prototype.setState = function(t, e) {
                    if ("object" != typeof t && "function" != typeof t && null != t) throw Error(p(85));
                    this.updater.enqueueSetState(this, t, e, "setState")
                }, g.prototype.forceUpdate = function(t) {
                    this.updater.enqueueForceUpdate(this, t, "forceUpdate")
                }, v.prototype = g.prototype;
                var y = _.prototype = new v;
                y.constructor = _, r(y, g.prototype), y.isPureReactComponent = !0;
                var x = {
                        current: null
                    },
                    b = Object.prototype.hasOwnProperty,
                    E = {
                        key: !0,
                        ref: !0,
                        __self: !0,
                        __source: !0
                    };

                function T(t, e, n) {
                    var r, o = {},
                        s = null,
                        a = null;
                    if (null != e)
                        for (r in void 0 !== e.ref && (a = e.ref), void 0 !== e.key && (s = "" + e.key), e) b.call(e, r) && !E.hasOwnProperty(r) && (o[r] = e[r]);
                    var l = arguments.length - 2;
                    if (1 === l) o.children = n;
                    else if (1 < l) {
                        for (var u = Array(l), h = 0; h < l; h++) u[h] = arguments[h + 2];
                        o.children = u
                    }
                    if (t && t.defaultProps)
                        for (r in l = t.defaultProps) void 0 === o[r] && (o[r] = l[r]);
                    return {
                        $$typeof: i,
                        type: t,
                        key: s,
                        ref: a,
                        props: o,
                        _owner: x.current
                    }
                }

                function S(t) {
                    return "object" == typeof t && null !== t && t.$$typeof === i
                }
                var w = /\/+/g;

                function M(t, e) {
                    return "object" == typeof t && null !== t && null != t.key ? function(t) {
                        var e = {
                            "=": "=0",
                            ":": "=2"
                        };
                        return "$" + t.replace(/[=:]/g, (function(t) {
                            return e[t]
                        }))
                    }("" + t.key) : e.toString(36)
                }

                function A(t, e, n, r, s) {
                    var a = typeof t;
                    "undefined" !== a && "boolean" !== a || (t = null);
                    var l = !1;
                    if (null === t) l = !0;
                    else switch (a) {
                        case "string":
                        case "number":
                            l = !0;
                            break;
                        case "object":
                            switch (t.$$typeof) {
                                case i:
                                case o:
                                    l = !0
                            }
                    }
                    if (l) return s = s(l = t), t = "" === r ? "." + M(l, 0) : r, Array.isArray(s) ? (n = "", null != t && (n = t.replace(w, "$&/") + "/"), A(s, e, n, "", (function(t) {
                        return t
                    }))) : null != s && (S(s) && (s = function(t, e) {
                        return {
                            $$typeof: i,
                            type: t.type,
                            key: e,
                            ref: t.ref,
                            props: t.props,
                            _owner: t._owner
                        }
                    }(s, n + (!s.key || l && l.key === s.key ? "" : ("" + s.key).replace(w, "$&/") + "/") + t)), e.push(s)), 1;
                    if (l = 0, r = "" === r ? "." : r + ":", Array.isArray(t))
                        for (var u = 0; u < t.length; u++) {
                            var h = r + M(a = t[u], u);
                            l += A(a, e, n, h, s)
                        } else if ("function" == typeof(h = function(t) {
                                return null === t || "object" != typeof t ? null : "function" == typeof(t = d && t[d] || t["@@iterator"]) ? t : null
                            }(t)))
                            for (t = h.call(t), u = 0; !(a = t.next()).done;) l += A(a = a.value, e, n, h = r + M(a, u++), s);
                        else if ("object" === a) throw e = "" + t, Error(p(31, "[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e));
                    return l
                }

                function R(t, e, n) {
                    if (null == t) return t;
                    var r = [],
                        i = 0;
                    return A(t, r, "", "", (function(t) {
                        return e.call(n, t, i++)
                    })), r
                }

                function P(t) {
                    if (-1 === t._status) {
                        var e = t._result;
                        e = e(), t._status = 0, t._result = e, e.then((function(e) {
                            0 === t._status && (e = e.default, t._status = 1, t._result = e)
                        }), (function(e) {
                            0 === t._status && (t._status = 2, t._result = e)
                        }))
                    }
                    if (1 === t._status) return t._result;
                    throw t._result
                }
                var I = {
                    current: null
                };

                function C() {
                    var t = I.current;
                    if (null === t) throw Error(p(321));
                    return t
                }
                var O = {
                    ReactCurrentDispatcher: I,
                    ReactCurrentBatchConfig: {
                        transition: 0
                    },
                    ReactCurrentOwner: x,
                    IsSomeRendererActing: {
                        current: !1
                    },
                    assign: r
                };
                e.Children = {
                    map: R,
                    forEach: function(t, e, n) {
                        R(t, (function() {
                            e.apply(this, arguments)
                        }), n)
                    },
                    count: function(t) {
                        var e = 0;
                        return R(t, (function() {
                            e++
                        })), e
                    },
                    toArray: function(t) {
                        return R(t, (function(t) {
                            return t
                        })) || []
                    },
                    only: function(t) {
                        if (!S(t)) throw Error(p(143));
                        return t
                    }
                }, e.Component = g, e.PureComponent = _, e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = O, e.cloneElement = function(t, e, n) {
                    if (null == t) throw Error(p(267, t));
                    var o = r({}, t.props),
                        s = t.key,
                        a = t.ref,
                        l = t._owner;
                    if (null != e) {
                        if (void 0 !== e.ref && (a = e.ref, l = x.current), void 0 !== e.key && (s = "" + e.key), t.type && t.type.defaultProps) var u = t.type.defaultProps;
                        for (h in e) b.call(e, h) && !E.hasOwnProperty(h) && (o[h] = void 0 === e[h] && void 0 !== u ? u[h] : e[h])
                    }
                    var h = arguments.length - 2;
                    if (1 === h) o.children = n;
                    else if (1 < h) {
                        u = Array(h);
                        for (var c = 0; c < h; c++) u[c] = arguments[c + 2];
                        o.children = u
                    }
                    return {
                        $$typeof: i,
                        type: t.type,
                        key: s,
                        ref: a,
                        props: o,
                        _owner: l
                    }
                }, e.createContext = function(t, e) {
                    return void 0 === e && (e = null), (t = {
                        $$typeof: a,
                        _calculateChangedBits: e,
                        _currentValue: t,
                        _currentValue2: t,
                        _threadCount: 0,
                        Provider: null,
                        Consumer: null
                    }).Provider = {
                        $$typeof: s,
                        _context: t
                    }, t.Consumer = t
                }, e.createElement = T, e.createFactory = function(t) {
                    var e = T.bind(null, t);
                    return e.type = t, e
                }, e.createRef = function() {
                    return {
                        current: null
                    }
                }, e.forwardRef = function(t) {
                    return {
                        $$typeof: l,
                        render: t
                    }
                }, e.isValidElement = S, e.lazy = function(t) {
                    return {
                        $$typeof: h,
                        _payload: {
                            _status: -1,
                            _result: t
                        },
                        _init: P
                    }
                }, e.memo = function(t, e) {
                    return {
                        $$typeof: u,
                        type: t,
                        compare: void 0 === e ? null : e
                    }
                }, e.useCallback = function(t, e) {
                    return C().useCallback(t, e)
                }, e.useContext = function(t, e) {
                    return C().useContext(t, e)
                }, e.useDebugValue = function() {}, e.useEffect = function(t, e) {
                    return C().useEffect(t, e)
                }, e.useImperativeHandle = function(t, e, n) {
                    return C().useImperativeHandle(t, e, n)
                }, e.useLayoutEffect = function(t, e) {
                    return C().useLayoutEffect(t, e)
                }, e.useMemo = function(t, e) {
                    return C().useMemo(t, e)
                }, e.useReducer = function(t, e, n) {
                    return C().useReducer(t, e, n)
                }, e.useRef = function(t) {
                    return C().useRef(t)
                }, e.useState = function(t) {
                    return C().useState(t)
                }, e.version = "17.0.2"
            },
            294: (t, e, n) => {
                "use strict";
                t.exports = n(408)
            },
            53: (t, e) => {
                "use strict";
                var n, r, i, o;
                if ("object" == typeof performance && "function" == typeof performance.now) {
                    var s = performance;
                    e.unstable_now = function() {
                        return s.now()
                    }
                } else {
                    var a = Date,
                        l = a.now();
                    e.unstable_now = function() {
                        return a.now() - l
                    }
                }
                if ("undefined" == typeof window || "function" != typeof MessageChannel) {
                    var u = null,
                        h = null,
                        c = function() {
                            if (null !== u) try {
                                var t = e.unstable_now();
                                u(!0, t), u = null
                            } catch (t) {
                                throw setTimeout(c, 0), t
                            }
                        };
                    n = function(t) {
                        null !== u ? setTimeout(n, 0, t) : (u = t, setTimeout(c, 0))
                    }, r = function(t, e) {
                        h = setTimeout(t, e)
                    }, i = function() {
                        clearTimeout(h)
                    }, e.unstable_shouldYield = function() {
                        return !1
                    }, o = e.unstable_forceFrameRate = function() {}
                } else {
                    var d = window.setTimeout,
                        p = window.clearTimeout;
                    if ("undefined" != typeof console) {
                        var f = window.cancelAnimationFrame;
                        "function" != typeof window.requestAnimationFrame && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), "function" != typeof f && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills")
                    }
                    var m = !1,
                        g = null,
                        v = -1,
                        _ = 5,
                        y = 0;
                    e.unstable_shouldYield = function() {
                        return e.unstable_now() >= y
                    }, o = function() {}, e.unstable_forceFrameRate = function(t) {
                        0 > t || 125 < t ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : _ = 0 < t ? Math.floor(1e3 / t) : 5
                    };
                    var x = new MessageChannel,
                        b = x.port2;
                    x.port1.onmessage = function() {
                        if (null !== g) {
                            var t = e.unstable_now();
                            y = t + _;
                            try {
                                g(!0, t) ? b.postMessage(null) : (m = !1, g = null)
                            } catch (t) {
                                throw b.postMessage(null), t
                            }
                        } else m = !1
                    }, n = function(t) {
                        g = t, m || (m = !0, b.postMessage(null))
                    }, r = function(t, n) {
                        v = d((function() {
                            t(e.unstable_now())
                        }), n)
                    }, i = function() {
                        p(v), v = -1
                    }
                }

                function E(t, e) {
                    var n = t.length;
                    t.push(e);
                    t: for (;;) {
                        var r = n - 1 >>> 1,
                            i = t[r];
                        if (!(void 0 !== i && 0 < w(i, e))) break t;
                        t[r] = e, t[n] = i, n = r
                    }
                }

                function T(t) {
                    return void 0 === (t = t[0]) ? null : t
                }

                function S(t) {
                    var e = t[0];
                    if (void 0 !== e) {
                        var n = t.pop();
                        if (n !== e) {
                            t[0] = n;
                            t: for (var r = 0, i = t.length; r < i;) {
                                var o = 2 * (r + 1) - 1,
                                    s = t[o],
                                    a = o + 1,
                                    l = t[a];
                                if (void 0 !== s && 0 > w(s, n)) void 0 !== l && 0 > w(l, s) ? (t[r] = l, t[a] = n, r = a) : (t[r] = s, t[o] = n, r = o);
                                else {
                                    if (!(void 0 !== l && 0 > w(l, n))) break t;
                                    t[r] = l, t[a] = n, r = a
                                }
                            }
                        }
                        return e
                    }
                    return null
                }

                function w(t, e) {
                    var n = t.sortIndex - e.sortIndex;
                    return 0 !== n ? n : t.id - e.id
                }
                var M = [],
                    A = [],
                    R = 1,
                    P = null,
                    I = 3,
                    C = !1,
                    O = !1,
                    L = !1;

                function N(t) {
                    for (var e = T(A); null !== e;) {
                        if (null === e.callback) S(A);
                        else {
                            if (!(e.startTime <= t)) break;
                            S(A), e.sortIndex = e.expirationTime, E(M, e)
                        }
                        e = T(A)
                    }
                }

                function D(t) {
                    if (L = !1, N(t), !O)
                        if (null !== T(M)) O = !0, n(U);
                        else {
                            var e = T(A);
                            null !== e && r(D, e.startTime - t)
                        }
                }

                function U(t, n) {
                    O = !1, L && (L = !1, i()), C = !0;
                    var o = I;
                    try {
                        for (N(n), P = T(M); null !== P && (!(P.expirationTime > n) || t && !e.unstable_shouldYield());) {
                            var s = P.callback;
                            if ("function" == typeof s) {
                                P.callback = null, I = P.priorityLevel;
                                var a = s(P.expirationTime <= n);
                                n = e.unstable_now(), "function" == typeof a ? P.callback = a : P === T(M) && S(M), N(n)
                            } else S(M);
                            P = T(M)
                        }
                        if (null !== P) var l = !0;
                        else {
                            var u = T(A);
                            null !== u && r(D, u.startTime - n), l = !1
                        }
                        return l
                    } finally {
                        P = null, I = o, C = !1
                    }
                }
                var F = o;
                e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(t) {
                    t.callback = null
                }, e.unstable_continueExecution = function() {
                    O || C || (O = !0, n(U))
                }, e.unstable_getCurrentPriorityLevel = function() {
                    return I
                }, e.unstable_getFirstCallbackNode = function() {
                    return T(M)
                }, e.unstable_next = function(t) {
                    switch (I) {
                        case 1:
                        case 2:
                        case 3:
                            var e = 3;
                            break;
                        default:
                            e = I
                    }
                    var n = I;
                    I = e;
                    try {
                        return t()
                    } finally {
                        I = n
                    }
                }, e.unstable_pauseExecution = function() {}, e.unstable_requestPaint = F, e.unstable_runWithPriority = function(t, e) {
                    switch (t) {
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        default:
                            t = 3
                    }
                    var n = I;
                    I = t;
                    try {
                        return e()
                    } finally {
                        I = n
                    }
                }, e.unstable_scheduleCallback = function(t, o, s) {
                    var a = e.unstable_now();
                    switch (s = "object" == typeof s && null !== s && "number" == typeof(s = s.delay) && 0 < s ? a + s : a, t) {
                        case 1:
                            var l = -1;
                            break;
                        case 2:
                            l = 250;
                            break;
                        case 5:
                            l = 1073741823;
                            break;
                        case 4:
                            l = 1e4;
                            break;
                        default:
                            l = 5e3
                    }
                    return t = {
                        id: R++,
                        callback: o,
                        priorityLevel: t,
                        startTime: s,
                        expirationTime: l = s + l,
                        sortIndex: -1
                    }, s > a ? (t.sortIndex = s, E(A, t), null === T(M) && t === T(A) && (L ? i() : L = !0, r(D, s - a))) : (t.sortIndex = l, E(M, t), O || C || (O = !0, n(U))), t
                }, e.unstable_wrapCallback = function(t) {
                    var e = I;
                    return function() {
                        var n = I;
                        I = e;
                        try {
                            return t.apply(this, arguments)
                        } finally {
                            I = n
                        }
                    }
                }
            },
            840: (t, e, n) => {
                "use strict";
                t.exports = n(53)
            },
            511: function(t, e, n) {
                var r;
                t = n.nmd(t),
                    function(i) {
                        e && e.nodeType, t && t.nodeType;
                        var o = "object" == typeof n.g && n.g;
                        o.global !== o && o.window !== o && o.self;
                        var s, a = 2147483647,
                            l = 36,
                            u = /^xn--/,
                            h = /[^\x20-\x7E]/,
                            c = /[\x2E\u3002\uFF0E\uFF61]/g,
                            d = {
                                overflow: "Overflow: input needs wider integers to process",
                                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                                "invalid-input": "Invalid input"
                            },
                            p = Math.floor,
                            f = String.fromCharCode;

                        function m(t) {
                            throw RangeError(d[t])
                        }

                        function g(t, e) {
                            for (var n = t.length, r = []; n--;) r[n] = e(t[n]);
                            return r
                        }

                        function v(t, e) {
                            var n = t.split("@"),
                                r = "";
                            return n.length > 1 && (r = n[0] + "@", t = n[1]), r + g((t = t.replace(c, ".")).split("."), e).join(".")
                        }

                        function _(t) {
                            for (var e, n, r = [], i = 0, o = t.length; i < o;)(e = t.charCodeAt(i++)) >= 55296 && e <= 56319 && i < o ? 56320 == (64512 & (n = t.charCodeAt(i++))) ? r.push(((1023 & e) << 10) + (1023 & n) + 65536) : (r.push(e), i--) : r.push(e);
                            return r
                        }

                        function y(t) {
                            return g(t, (function(t) {
                                var e = "";
                                return t > 65535 && (e += f((t -= 65536) >>> 10 & 1023 | 55296), t = 56320 | 1023 & t), e + f(t)
                            })).join("")
                        }

                        function x(t, e) {
                            return t + 22 + 75 * (t < 26) - ((0 != e) << 5)
                        }

                        function b(t, e, n) {
                            var r = 0;
                            for (t = n ? p(t / 700) : t >> 1, t += p(t / e); t > 455; r += l) t = p(t / 35);
                            return p(r + 36 * t / (t + 38))
                        }

                        function E(t) {
                            var e, n, r, i, o, s, u, h, c, d, f, g = [],
                                v = t.length,
                                _ = 0,
                                x = 128,
                                E = 72;
                            for ((n = t.lastIndexOf("-")) < 0 && (n = 0), r = 0; r < n; ++r) t.charCodeAt(r) >= 128 && m("not-basic"), g.push(t.charCodeAt(r));
                            for (i = n > 0 ? n + 1 : 0; i < v;) {
                                for (o = _, s = 1, u = l; i >= v && m("invalid-input"), ((h = (f = t.charCodeAt(i++)) - 48 < 10 ? f - 22 : f - 65 < 26 ? f - 65 : f - 97 < 26 ? f - 97 : l) >= l || h > p((a - _) / s)) && m("overflow"), _ += h * s, !(h < (c = u <= E ? 1 : u >= E + 26 ? 26 : u - E)); u += l) s > p(a / (d = l - c)) && m("overflow"), s *= d;
                                E = b(_ - o, e = g.length + 1, 0 == o), p(_ / e) > a - x && m("overflow"), x += p(_ / e), _ %= e, g.splice(_++, 0, x)
                            }
                            return y(g)
                        }

                        function T(t) {
                            var e, n, r, i, o, s, u, h, c, d, g, v, y, E, T, S = [];
                            for (v = (t = _(t)).length, e = 128, n = 0, o = 72, s = 0; s < v; ++s)(g = t[s]) < 128 && S.push(f(g));
                            for (r = i = S.length, i && S.push("-"); r < v;) {
                                for (u = a, s = 0; s < v; ++s)(g = t[s]) >= e && g < u && (u = g);
                                for (u - e > p((a - n) / (y = r + 1)) && m("overflow"), n += (u - e) * y, e = u, s = 0; s < v; ++s)
                                    if ((g = t[s]) < e && ++n > a && m("overflow"), g == e) {
                                        for (h = n, c = l; !(h < (d = c <= o ? 1 : c >= o + 26 ? 26 : c - o)); c += l) T = h - d, E = l - d, S.push(f(x(d + T % E, 0))), h = p(T / E);
                                        S.push(f(x(h, 0))), o = b(n, y, r == i), n = 0, ++r
                                    }++ n, ++e
                            }
                            return S.join("")
                        }
                        s = {
                            version: "1.3.2",
                            ucs2: {
                                decode: _,
                                encode: y
                            },
                            decode: E,
                            encode: T,
                            toASCII: function(t) {
                                return v(t, (function(t) {
                                    return h.test(t) ? "xn--" + T(t) : t
                                }))
                            },
                            toUnicode: function(t) {
                                return v(t, (function(t) {
                                    return u.test(t) ? E(t.slice(4).toLowerCase()) : t
                                }))
                            }
                        }, void 0 === (r = function() {
                            return s
                        }.call(e, n, e, t)) || (t.exports = r)
                    }()
            },
            575: (t, e, n) => {
                "use strict";
                var r = n(511),
                    i = n(502);

                function o() {
                    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null
                }
                e.Qc = y, e.DB = function(t, e) {
                    return y(t, !1, !0).resolve(e)
                }, e.WU = function(t) {
                    return i.isString(t) && (t = y(t)), t instanceof o ? t.format() : o.prototype.format.call(t)
                };
                var s = /^([a-z0-9.+-]+:)/i,
                    a = /:[0-9]*$/,
                    l = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
                    u = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "\t"]),
                    h = ["'"].concat(u),
                    c = ["%", "/", "?", ";", "#"].concat(h),
                    d = ["/", "?", "#"],
                    p = /^[+a-z0-9A-Z_-]{0,63}$/,
                    f = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
                    m = {
                        javascript: !0,
                        "javascript:": !0
                    },
                    g = {
                        javascript: !0,
                        "javascript:": !0
                    },
                    v = {
                        http: !0,
                        https: !0,
                        ftp: !0,
                        gopher: !0,
                        file: !0,
                        "http:": !0,
                        "https:": !0,
                        "ftp:": !0,
                        "gopher:": !0,
                        "file:": !0
                    },
                    _ = n(673);

                function y(t, e, n) {
                    if (t && i.isObject(t) && t instanceof o) return t;
                    var r = new o;
                    return r.parse(t, e, n), r
                }
                o.prototype.parse = function(t, e, n) {
                    if (!i.isString(t)) throw new TypeError("Parameter 'url' must be a string, not " + typeof t);
                    var o = t.indexOf("?"),
                        a = -1 !== o && o < t.indexOf("#") ? "?" : "#",
                        u = t.split(a);
                    u[0] = u[0].replace(/\\/g, "/");
                    var y = t = u.join(a);
                    if (y = y.trim(), !n && 1 === t.split("#").length) {
                        var x = l.exec(y);
                        if (x) return this.path = y, this.href = y, this.pathname = x[1], x[2] ? (this.search = x[2], this.query = e ? _.parse(this.search.substr(1)) : this.search.substr(1)) : e && (this.search = "", this.query = {}), this
                    }
                    var b = s.exec(y);
                    if (b) {
                        var E = (b = b[0]).toLowerCase();
                        this.protocol = E, y = y.substr(b.length)
                    }
                    if (n || b || y.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                        var T = "//" === y.substr(0, 2);
                        !T || b && g[b] || (y = y.substr(2), this.slashes = !0)
                    }
                    if (!g[b] && (T || b && !v[b])) {
                        for (var S, w, M = -1, A = 0; A < d.length; A++) - 1 !== (R = y.indexOf(d[A])) && (-1 === M || R < M) && (M = R);
                        for (-1 !== (w = -1 === M ? y.lastIndexOf("@") : y.lastIndexOf("@", M)) && (S = y.slice(0, w), y = y.slice(w + 1), this.auth = decodeURIComponent(S)), M = -1, A = 0; A < c.length; A++) {
                            var R; - 1 !== (R = y.indexOf(c[A])) && (-1 === M || R < M) && (M = R)
                        } - 1 === M && (M = y.length), this.host = y.slice(0, M), y = y.slice(M), this.parseHost(), this.hostname = this.hostname || "";
                        var P = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
                        if (!P)
                            for (var I = this.hostname.split(/\./), C = (A = 0, I.length); A < C; A++) {
                                var O = I[A];
                                if (O && !O.match(p)) {
                                    for (var L = "", N = 0, D = O.length; N < D; N++) O.charCodeAt(N) > 127 ? L += "x" : L += O[N];
                                    if (!L.match(p)) {
                                        var U = I.slice(0, A),
                                            F = I.slice(A + 1),
                                            B = O.match(f);
                                        B && (U.push(B[1]), F.unshift(B[2])), F.length && (y = "/" + F.join(".") + y), this.hostname = U.join(".");
                                        break
                                    }
                                }
                            }
                        this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), P || (this.hostname = r.toASCII(this.hostname));
                        var k = this.port ? ":" + this.port : "",
                            G = this.hostname || "";
                        this.host = G + k, this.href += this.host, P && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== y[0] && (y = "/" + y))
                    }
                    if (!m[E])
                        for (A = 0, C = h.length; A < C; A++) {
                            var H = h[A];
                            if (-1 !== y.indexOf(H)) {
                                var z = encodeURIComponent(H);
                                z === H && (z = escape(H)), y = y.split(H).join(z)
                            }
                        }
                    var V = y.indexOf("#"); - 1 !== V && (this.hash = y.substr(V), y = y.slice(0, V));
                    var W = y.indexOf("?");
                    if (-1 !== W ? (this.search = y.substr(W), this.query = y.substr(W + 1), e && (this.query = _.parse(this.query)), y = y.slice(0, W)) : e && (this.search = "", this.query = {}), y && (this.pathname = y), v[E] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
                        k = this.pathname || "";
                        var X = this.search || "";
                        this.path = k + X
                    }
                    return this.href = this.format(), this
                }, o.prototype.format = function() {
                    var t = this.auth || "";
                    t && (t = (t = encodeURIComponent(t)).replace(/%3A/i, ":"), t += "@");
                    var e = this.protocol || "",
                        n = this.pathname || "",
                        r = this.hash || "",
                        o = !1,
                        s = "";
                    this.host ? o = t + this.host : this.hostname && (o = t + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (o += ":" + this.port)), this.query && i.isObject(this.query) && Object.keys(this.query).length && (s = _.stringify(this.query));
                    var a = this.search || s && "?" + s || "";
                    return e && ":" !== e.substr(-1) && (e += ":"), this.slashes || (!e || v[e]) && !1 !== o ? (o = "//" + (o || ""), n && "/" !== n.charAt(0) && (n = "/" + n)) : o || (o = ""), r && "#" !== r.charAt(0) && (r = "#" + r), a && "?" !== a.charAt(0) && (a = "?" + a), e + o + (n = n.replace(/[?#]/g, (function(t) {
                        return encodeURIComponent(t)
                    }))) + (a = a.replace("#", "%23")) + r
                }, o.prototype.resolve = function(t) {
                    return this.resolveObject(y(t, !1, !0)).format()
                }, o.prototype.resolveObject = function(t) {
                    if (i.isString(t)) {
                        var e = new o;
                        e.parse(t, !1, !0), t = e
                    }
                    for (var n = new o, r = Object.keys(this), s = 0; s < r.length; s++) {
                        var a = r[s];
                        n[a] = this[a]
                    }
                    if (n.hash = t.hash, "" === t.href) return n.href = n.format(), n;
                    if (t.slashes && !t.protocol) {
                        for (var l = Object.keys(t), u = 0; u < l.length; u++) {
                            var h = l[u];
                            "protocol" !== h && (n[h] = t[h])
                        }
                        return v[n.protocol] && n.hostname && !n.pathname && (n.path = n.pathname = "/"), n.href = n.format(), n
                    }
                    if (t.protocol && t.protocol !== n.protocol) {
                        if (!v[t.protocol]) {
                            for (var c = Object.keys(t), d = 0; d < c.length; d++) {
                                var p = c[d];
                                n[p] = t[p]
                            }
                            return n.href = n.format(), n
                        }
                        if (n.protocol = t.protocol, t.host || g[t.protocol]) n.pathname = t.pathname;
                        else {
                            for (var f = (t.pathname || "").split("/"); f.length && !(t.host = f.shift()););
                            t.host || (t.host = ""), t.hostname || (t.hostname = ""), "" !== f[0] && f.unshift(""), f.length < 2 && f.unshift(""), n.pathname = f.join("/")
                        }
                        if (n.search = t.search, n.query = t.query, n.host = t.host || "", n.auth = t.auth, n.hostname = t.hostname || t.host, n.port = t.port, n.pathname || n.search) {
                            var m = n.pathname || "",
                                _ = n.search || "";
                            n.path = m + _
                        }
                        return n.slashes = n.slashes || t.slashes, n.href = n.format(), n
                    }
                    var y = n.pathname && "/" === n.pathname.charAt(0),
                        x = t.host || t.pathname && "/" === t.pathname.charAt(0),
                        b = x || y || n.host && t.pathname,
                        E = b,
                        T = n.pathname && n.pathname.split("/") || [],
                        S = (f = t.pathname && t.pathname.split("/") || [], n.protocol && !v[n.protocol]);
                    if (S && (n.hostname = "", n.port = null, n.host && ("" === T[0] ? T[0] = n.host : T.unshift(n.host)), n.host = "", t.protocol && (t.hostname = null, t.port = null, t.host && ("" === f[0] ? f[0] = t.host : f.unshift(t.host)), t.host = null), b = b && ("" === f[0] || "" === T[0])), x) n.host = t.host || "" === t.host ? t.host : n.host, n.hostname = t.hostname || "" === t.hostname ? t.hostname : n.hostname, n.search = t.search, n.query = t.query, T = f;
                    else if (f.length) T || (T = []), T.pop(), T = T.concat(f), n.search = t.search, n.query = t.query;
                    else if (!i.isNullOrUndefined(t.search)) return S && (n.hostname = n.host = T.shift(), (P = !!(n.host && n.host.indexOf("@") > 0) && n.host.split("@")) && (n.auth = P.shift(), n.host = n.hostname = P.shift())), n.search = t.search, n.query = t.query, i.isNull(n.pathname) && i.isNull(n.search) || (n.path = (n.pathname ? n.pathname : "") + (n.search ? n.search : "")), n.href = n.format(), n;
                    if (!T.length) return n.pathname = null, n.search ? n.path = "/" + n.search : n.path = null, n.href = n.format(), n;
                    for (var w = T.slice(-1)[0], M = (n.host || t.host || T.length > 1) && ("." === w || ".." === w) || "" === w, A = 0, R = T.length; R >= 0; R--) "." === (w = T[R]) ? T.splice(R, 1) : ".." === w ? (T.splice(R, 1), A++) : A && (T.splice(R, 1), A--);
                    if (!b && !E)
                        for (; A--; A) T.unshift("..");
                    !b || "" === T[0] || T[0] && "/" === T[0].charAt(0) || T.unshift(""), M && "/" !== T.join("/").substr(-1) && T.push("");
                    var P, I = "" === T[0] || T[0] && "/" === T[0].charAt(0);
                    return S && (n.hostname = n.host = I ? "" : T.length ? T.shift() : "", (P = !!(n.host && n.host.indexOf("@") > 0) && n.host.split("@")) && (n.auth = P.shift(), n.host = n.hostname = P.shift())), (b = b || n.host && T.length) && !I && T.unshift(""), T.length ? n.pathname = T.join("/") : (n.pathname = null, n.path = null), i.isNull(n.pathname) && i.isNull(n.search) || (n.path = (n.pathname ? n.pathname : "") + (n.search ? n.search : "")), n.auth = t.auth || n.auth, n.slashes = n.slashes || t.slashes, n.href = n.format(), n
                }, o.prototype.parseHost = function() {
                    var t = this.host,
                        e = a.exec(t);
                    e && (":" !== (e = e[0]) && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), t && (this.hostname = t)
                }
            },
            502: t => {
                "use strict";
                t.exports = {
                    isString: function(t) {
                        return "string" == typeof t
                    },
                    isObject: function(t) {
                        return "object" == typeof t && null !== t
                    },
                    isNull: function(t) {
                        return null === t
                    },
                    isNullOrUndefined: function(t) {
                        return null == t
                    }
                }
            }
        },
        e = {};

    function n(r) {
        var i = e[r];
        if (void 0 !== i) return i.exports;
        var o = e[r] = {
            id: r,
            loaded: !1,
            exports: {}
        };
        return t[r].call(o.exports, o, o.exports, n), o.loaded = !0, o.exports
    }
    n.n = t => {
        var e = t && t.__esModule ? () => t.default : () => t;
        return n.d(e, {
            a: e
        }), e
    }, n.d = (t, e) => {
        for (var r in e) n.o(e, r) && !n.o(t, r) && Object.defineProperty(t, r, {
            enumerable: !0,
            get: e[r]
        })
    }, n.g = function() {
        if ("object" == typeof globalThis) return globalThis;
        try {
            return this || new Function("return this")()
        } catch (t) {
            if ("object" == typeof window) return window
        }
    }(), n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), n.nmd = t => (t.paths = [], t.children || (t.children = []), t), (() => {
        "use strict";
        var t = n(294),
            e = n(935),
            r = n(697),
            i = n.n(r);
        var o = setTimeout;

        function s(t) {
            return Boolean(t && void 0 !== t.length)
        }

        function a() {}

        function l(t) {
            if (!(this instanceof l)) throw new TypeError("Promises must be constructed via new");
            if ("function" != typeof t) throw new TypeError("not a function");
            this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], f(t, this)
        }

        function u(t, e) {
            for (; 3 === t._state;) t = t._value;
            0 !== t._state ? (t._handled = !0, l._immediateFn((function() {
                var n = 1 === t._state ? e.onFulfilled : e.onRejected;
                if (null !== n) {
                    var r;
                    try {
                        r = n(t._value)
                    } catch (t) {
                        return void c(e.promise, t)
                    }
                    h(e.promise, r)
                } else(1 === t._state ? h : c)(e.promise, t._value)
            }))) : t._deferreds.push(e)
        }

        function h(t, e) {
            try {
                if (e === t) throw new TypeError("A promise cannot be resolved with itself.");
                if (e && ("object" == typeof e || "function" == typeof e)) {
                    var n = e.then;
                    if (e instanceof l) return t._state = 3, t._value = e, void d(t);
                    if ("function" == typeof n) return void f((r = n, i = e, function() {
                        r.apply(i, arguments)
                    }), t)
                }
                t._state = 1, t._value = e, d(t)
            } catch (e) {
                c(t, e)
            }
            var r, i
        }

        function c(t, e) {
            t._state = 2, t._value = e, d(t)
        }

        function d(t) {
            2 === t._state && 0 === t._deferreds.length && l._immediateFn((function() {
                t._handled || l._unhandledRejectionFn(t._value)
            }));
            for (var e = 0, n = t._deferreds.length; e < n; e++) u(t, t._deferreds[e]);
            t._deferreds = null
        }

        function p(t, e, n) {
            this.onFulfilled = "function" == typeof t ? t : null, this.onRejected = "function" == typeof e ? e : null, this.promise = n
        }

        function f(t, e) {
            var n = !1;
            try {
                t((function(t) {
                    n || (n = !0, h(e, t))
                }), (function(t) {
                    n || (n = !0, c(e, t))
                }))
            } catch (t) {
                if (n) return;
                n = !0, c(e, t)
            }
        }
        l.prototype.catch = function(t) {
            return this.then(null, t)
        }, l.prototype.then = function(t, e) {
            var n = new this.constructor(a);
            return u(this, new p(t, e, n)), n
        }, l.prototype.finally = function(t) {
            var e = this.constructor;
            return this.then((function(n) {
                return e.resolve(t()).then((function() {
                    return n
                }))
            }), (function(n) {
                return e.resolve(t()).then((function() {
                    return e.reject(n)
                }))
            }))
        }, l.all = function(t) {
            return new l((function(e, n) {
                if (!s(t)) return n(new TypeError("Promise.all accepts an array"));
                var r = Array.prototype.slice.call(t);
                if (0 === r.length) return e([]);
                var i = r.length;

                function o(t, s) {
                    try {
                        if (s && ("object" == typeof s || "function" == typeof s)) {
                            var a = s.then;
                            if ("function" == typeof a) return void a.call(s, (function(e) {
                                o(t, e)
                            }), n)
                        }
                        r[t] = s, 0 == --i && e(r)
                    } catch (t) {
                        n(t)
                    }
                }
                for (var a = 0; a < r.length; a++) o(a, r[a])
            }))
        }, l.allSettled = function(t) {
            return new this((function(e, n) {
                if (!t || void 0 === t.length) return n(new TypeError(typeof t + " " + t + " is not iterable(cannot read property Symbol(Symbol.iterator))"));
                var r = Array.prototype.slice.call(t);
                if (0 === r.length) return e([]);
                var i = r.length;

                function o(t, n) {
                    if (n && ("object" == typeof n || "function" == typeof n)) {
                        var s = n.then;
                        if ("function" == typeof s) return void s.call(n, (function(e) {
                            o(t, e)
                        }), (function(n) {
                            r[t] = {
                                status: "rejected",
                                reason: n
                            }, 0 == --i && e(r)
                        }))
                    }
                    r[t] = {
                        status: "fulfilled",
                        value: n
                    }, 0 == --i && e(r)
                }
                for (var s = 0; s < r.length; s++) o(s, r[s])
            }))
        }, l.resolve = function(t) {
            return t && "object" == typeof t && t.constructor === l ? t : new l((function(e) {
                e(t)
            }))
        }, l.reject = function(t) {
            return new l((function(e, n) {
                n(t)
            }))
        }, l.race = function(t) {
            return new l((function(e, n) {
                if (!s(t)) return n(new TypeError("Promise.race accepts an array"));
                for (var r = 0, i = t.length; r < i; r++) l.resolve(t[r]).then(e, n)
            }))
        }, l._immediateFn = "function" == typeof setImmediate && function(t) {
            setImmediate(t)
        } || function(t) {
            o(t, 0)
        }, l._unhandledRejectionFn = function(t) {
            "undefined" != typeof console && console && console.warn("Possible Unhandled Promise Rejection:", t)
        };
        const m = l;
        var g = n(418),
            v = n.n(g);
        if ("undefined" == typeof globalThis && ("undefined" != typeof self ? self.globalThis = self : void 0 !== n.g && (n.g.globalThis = n.g)), globalThis.Promise || (globalThis.Promise = m), Object.assign || (Object.assign = v()), Date.now && Date.prototype.getTime || (Date.now = function() {
                return (new Date).getTime()
            }), !globalThis.performance || !globalThis.performance.now) {
            var _ = Date.now();
            globalThis.performance || (globalThis.performance = {}), globalThis.performance.now = function() {
                return Date.now() - _
            }
        }
        for (var y = Date.now(), x = ["ms", "moz", "webkit", "o"], b = 0; b < x.length && !globalThis.requestAnimationFrame; ++b) {
            var E = x[b];
            globalThis.requestAnimationFrame = globalThis[E + "RequestAnimationFrame"], globalThis.cancelAnimationFrame = globalThis[E + "CancelAnimationFrame"] || globalThis[E + "CancelRequestAnimationFrame"]
        }
        globalThis.requestAnimationFrame || (globalThis.requestAnimationFrame = function(t) {
            if ("function" != typeof t) throw new TypeError(t + "is not a function");
            var e = Date.now(),
                n = 16 + y - e;
            return n < 0 && (n = 0), y = e, globalThis.self.setTimeout((function() {
                y = Date.now(), t(performance.now())
            }), n)
        }), globalThis.cancelAnimationFrame || (globalThis.cancelAnimationFrame = function(t) {
            return clearTimeout(t)
        }), Math.sign || (Math.sign = function(t) {
            return 0 === (t = Number(t)) || isNaN(t) ? t : t > 0 ? 1 : -1
        }), Number.isInteger || (Number.isInteger = function(t) {
            return "number" == typeof t && isFinite(t) && Math.floor(t) === t
        }), globalThis.ArrayBuffer || (globalThis.ArrayBuffer = Array), globalThis.Float32Array || (globalThis.Float32Array = Array), globalThis.Uint32Array || (globalThis.Uint32Array = Array), globalThis.Uint16Array || (globalThis.Uint16Array = Array), globalThis.Uint8Array || (globalThis.Uint8Array = Array), globalThis.Int32Array || (globalThis.Int32Array = Array);
        var T, S, w, M, A, R, P, I, C, O, L, N, D, U, F, B, k, G, H, z = /iPhone/i,
            V = /iPod/i,
            W = /iPad/i,
            X = /\biOS-universal(?:.+)Mac\b/i,
            j = /\bAndroid(?:.+)Mobile\b/i,
            Y = /Android/i,
            q = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,
            Z = /Silk/i,
            K = /Windows Phone/i,
            J = /\bWindows(?:.+)ARM\b/i,
            Q = /BlackBerry/i,
            $ = /BB10/i,
            tt = /Opera Mini/i,
            et = /\b(CriOS|Chrome)(?:.+)Mobile/i,
            nt = /Mobile(?:.+)Firefox\b/i,
            rt = function(t) {
                return void 0 !== t && "MacIntel" === t.platform && "number" == typeof t.maxTouchPoints && t.maxTouchPoints > 1 && "undefined" == typeof MSStream
            },
            it = function(t) {
                var e = {
                    userAgent: "",
                    platform: "",
                    maxTouchPoints: 0
                };
                t || "undefined" == typeof navigator ? "string" == typeof t ? e.userAgent = t : t && t.userAgent && (e = {
                    userAgent: t.userAgent,
                    platform: t.platform,
                    maxTouchPoints: t.maxTouchPoints || 0
                }) : e = {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    maxTouchPoints: navigator.maxTouchPoints || 0
                };
                var n = e.userAgent,
                    r = n.split("[FBAN");
                void 0 !== r[1] && (n = r[0]), void 0 !== (r = n.split("Twitter"))[1] && (n = r[0]);
                var i = function(t) {
                        return function(e) {
                            return e.test(t)
                        }
                    }(n),
                    o = {
                        apple: {
                            phone: i(z) && !i(K),
                            ipod: i(V),
                            tablet: !i(z) && (i(W) || rt(e)) && !i(K),
                            universal: i(X),
                            device: (i(z) || i(V) || i(W) || i(X) || rt(e)) && !i(K)
                        },
                        amazon: {
                            phone: i(q),
                            tablet: !i(q) && i(Z),
                            device: i(q) || i(Z)
                        },
                        android: {
                            phone: !i(K) && i(q) || !i(K) && i(j),
                            tablet: !i(K) && !i(q) && !i(j) && (i(Z) || i(Y)),
                            device: !i(K) && (i(q) || i(Z) || i(j) || i(Y)) || i(/\bokhttp\b/i)
                        },
                        windows: {
                            phone: i(K),
                            tablet: i(J),
                            device: i(K) || i(J)
                        },
                        other: {
                            blackberry: i(Q),
                            blackberry10: i($),
                            opera: i(tt),
                            firefox: i(nt),
                            chrome: i(et),
                            device: i(Q) || i($) || i(tt) || i(nt) || i(et)
                        },
                        any: !1,
                        phone: !1,
                        tablet: !1
                    };
                return o.any = o.apple.device || o.android.device || o.windows.device || o.other.device, o.phone = o.apple.phone || o.android.phone || o.windows.phone, o.tablet = o.apple.tablet || o.android.tablet || o.windows.tablet, o
            }(globalThis.navigator);
        ! function(t) {
            t[t.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t[t.WEBGL = 1] = "WEBGL", t[t.WEBGL2 = 2] = "WEBGL2"
        }(T || (T = {})),
        function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.WEBGL = 1] = "WEBGL", t[t.CANVAS = 2] = "CANVAS"
        }(S || (S = {})),
        function(t) {
            t[t.COLOR = 16384] = "COLOR", t[t.DEPTH = 256] = "DEPTH", t[t.STENCIL = 1024] = "STENCIL"
        }(w || (w = {})),
        function(t) {
            t[t.NORMAL = 0] = "NORMAL", t[t.ADD = 1] = "ADD", t[t.MULTIPLY = 2] = "MULTIPLY", t[t.SCREEN = 3] = "SCREEN", t[t.OVERLAY = 4] = "OVERLAY", t[t.DARKEN = 5] = "DARKEN", t[t.LIGHTEN = 6] = "LIGHTEN", t[t.COLOR_DODGE = 7] = "COLOR_DODGE", t[t.COLOR_BURN = 8] = "COLOR_BURN", t[t.HARD_LIGHT = 9] = "HARD_LIGHT", t[t.SOFT_LIGHT = 10] = "SOFT_LIGHT", t[t.DIFFERENCE = 11] = "DIFFERENCE", t[t.EXCLUSION = 12] = "EXCLUSION", t[t.HUE = 13] = "HUE", t[t.SATURATION = 14] = "SATURATION", t[t.COLOR = 15] = "COLOR", t[t.LUMINOSITY = 16] = "LUMINOSITY", t[t.NORMAL_NPM = 17] = "NORMAL_NPM", t[t.ADD_NPM = 18] = "ADD_NPM", t[t.SCREEN_NPM = 19] = "SCREEN_NPM", t[t.NONE = 20] = "NONE", t[t.SRC_OVER = 0] = "SRC_OVER", t[t.SRC_IN = 21] = "SRC_IN", t[t.SRC_OUT = 22] = "SRC_OUT", t[t.SRC_ATOP = 23] = "SRC_ATOP", t[t.DST_OVER = 24] = "DST_OVER", t[t.DST_IN = 25] = "DST_IN", t[t.DST_OUT = 26] = "DST_OUT", t[t.DST_ATOP = 27] = "DST_ATOP", t[t.ERASE = 26] = "ERASE", t[t.SUBTRACT = 28] = "SUBTRACT", t[t.XOR = 29] = "XOR"
        }(M || (M = {})),
        function(t) {
            t[t.POINTS = 0] = "POINTS", t[t.LINES = 1] = "LINES", t[t.LINE_LOOP = 2] = "LINE_LOOP", t[t.LINE_STRIP = 3] = "LINE_STRIP", t[t.TRIANGLES = 4] = "TRIANGLES", t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN"
        }(A || (A = {})),
        function(t) {
            t[t.RGBA = 6408] = "RGBA", t[t.RGB = 6407] = "RGB", t[t.RG = 33319] = "RG", t[t.RED = 6403] = "RED", t[t.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t[t.RGB_INTEGER = 36248] = "RGB_INTEGER", t[t.RG_INTEGER = 33320] = "RG_INTEGER", t[t.RED_INTEGER = 36244] = "RED_INTEGER", t[t.ALPHA = 6406] = "ALPHA", t[t.LUMINANCE = 6409] = "LUMINANCE", t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL"
        }(R || (R = {})),
        function(t) {
            t[t.TEXTURE_2D = 3553] = "TEXTURE_2D", t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z"
        }(P || (P = {})),
        function(t) {
            t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t[t.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t[t.BYTE = 5120] = "BYTE", t[t.SHORT = 5122] = "SHORT", t[t.INT = 5124] = "INT", t[t.FLOAT = 5126] = "FLOAT", t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t[t.HALF_FLOAT = 36193] = "HALF_FLOAT"
        }(I || (I = {})),
        function(t) {
            t[t.FLOAT = 0] = "FLOAT", t[t.INT = 1] = "INT", t[t.UINT = 2] = "UINT"
        }(C || (C = {})),
        function(t) {
            t[t.NEAREST = 0] = "NEAREST", t[t.LINEAR = 1] = "LINEAR"
        }(O || (O = {})),
        function(t) {
            t[t.CLAMP = 33071] = "CLAMP", t[t.REPEAT = 10497] = "REPEAT", t[t.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT"
        }(L || (L = {})),
        function(t) {
            t[t.OFF = 0] = "OFF", t[t.POW2 = 1] = "POW2", t[t.ON = 2] = "ON", t[t.ON_MANUAL = 3] = "ON_MANUAL"
        }(N || (N = {})),
        function(t) {
            t[t.NPM = 0] = "NPM", t[t.UNPACK = 1] = "UNPACK", t[t.PMA = 2] = "PMA", t[t.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t[t.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t[t.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t[t.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA"
        }(D || (D = {})),
        function(t) {
            t[t.NO = 0] = "NO", t[t.YES = 1] = "YES", t[t.AUTO = 2] = "AUTO", t[t.BLEND = 0] = "BLEND", t[t.CLEAR = 1] = "CLEAR", t[t.BLIT = 2] = "BLIT"
        }(U || (U = {})),
        function(t) {
            t[t.AUTO = 0] = "AUTO", t[t.MANUAL = 1] = "MANUAL"
        }(F || (F = {})),
        function(t) {
            t.LOW = "lowp", t.MEDIUM = "mediump", t.HIGH = "highp"
        }(B || (B = {})),
        function(t) {
            t[t.NONE = 0] = "NONE", t[t.SCISSOR = 1] = "SCISSOR", t[t.STENCIL = 2] = "STENCIL", t[t.SPRITE = 3] = "SPRITE"
        }(k || (k = {})),
        function(t) {
            t[t.NONE = 0] = "NONE", t[t.LOW = 2] = "LOW", t[t.MEDIUM = 4] = "MEDIUM", t[t.HIGH = 8] = "HIGH"
        }(G || (G = {})),
        function(t) {
            t[t.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t[t.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t[t.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER"
        }(H || (H = {}));
        var ot, st, at, lt, ut, ht, ct, dt, pt, ft, mt, gt, vt, _t, yt, xt, bt, Et, Tt, St = {
                MIPMAP_TEXTURES: N.POW2,
                ANISOTROPIC_LEVEL: 0,
                RESOLUTION: 1,
                FILTER_RESOLUTION: 1,
                FILTER_MULTISAMPLE: G.NONE,
                SPRITE_MAX_TEXTURES: function(t) {
                    var e, n = !0;
                    (it.tablet || it.phone) && (it.apple.device && (e = navigator.userAgent.match(/OS (\d+)_(\d+)?/)) && parseInt(e[1], 10) < 11 && (n = !1), it.android.device && (e = navigator.userAgent.match(/Android\s([0-9.]*)/)) && parseInt(e[1], 10) < 7 && (n = !1));
                    return n ? 32 : 4
                }(),
                SPRITE_BATCH_SIZE: 4096,
                RENDER_OPTIONS: {
                    view: null,
                    antialias: !1,
                    autoDensity: !1,
                    backgroundColor: 0,
                    backgroundAlpha: 1,
                    useContextAlpha: !0,
                    clearBeforeRender: !0,
                    preserveDrawingBuffer: !1,
                    width: 800,
                    height: 600,
                    legacy: !1
                },
                GC_MODE: F.AUTO,
                GC_MAX_IDLE: 3600,
                GC_MAX_CHECK_COUNT: 600,
                WRAP_MODE: L.CLAMP,
                SCALE_MODE: O.LINEAR,
                PRECISION_VERTEX: B.HIGH,
                PRECISION_FRAGMENT: it.apple.device ? B.HIGH : B.MEDIUM,
                CAN_UPLOAD_SAME_BUFFER: !it.apple.device,
                CREATE_IMAGE_BITMAP: !1,
                ROUND_PIXELS: !1
            },
            wt = n(729),
            Mt = n.n(wt),
            At = n(187),
            Rt = n.n(At),
            Pt = n(575);
        ! function(t) {
            t[t.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t[t.WEBGL = 1] = "WEBGL", t[t.WEBGL2 = 2] = "WEBGL2"
        }(ot || (ot = {})),
        function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.WEBGL = 1] = "WEBGL", t[t.CANVAS = 2] = "CANVAS"
        }(st || (st = {})),
        function(t) {
            t[t.COLOR = 16384] = "COLOR", t[t.DEPTH = 256] = "DEPTH", t[t.STENCIL = 1024] = "STENCIL"
        }(at || (at = {})),
        function(t) {
            t[t.NORMAL = 0] = "NORMAL", t[t.ADD = 1] = "ADD", t[t.MULTIPLY = 2] = "MULTIPLY", t[t.SCREEN = 3] = "SCREEN", t[t.OVERLAY = 4] = "OVERLAY", t[t.DARKEN = 5] = "DARKEN", t[t.LIGHTEN = 6] = "LIGHTEN", t[t.COLOR_DODGE = 7] = "COLOR_DODGE", t[t.COLOR_BURN = 8] = "COLOR_BURN", t[t.HARD_LIGHT = 9] = "HARD_LIGHT", t[t.SOFT_LIGHT = 10] = "SOFT_LIGHT", t[t.DIFFERENCE = 11] = "DIFFERENCE", t[t.EXCLUSION = 12] = "EXCLUSION", t[t.HUE = 13] = "HUE", t[t.SATURATION = 14] = "SATURATION", t[t.COLOR = 15] = "COLOR", t[t.LUMINOSITY = 16] = "LUMINOSITY", t[t.NORMAL_NPM = 17] = "NORMAL_NPM", t[t.ADD_NPM = 18] = "ADD_NPM", t[t.SCREEN_NPM = 19] = "SCREEN_NPM", t[t.NONE = 20] = "NONE", t[t.SRC_OVER = 0] = "SRC_OVER", t[t.SRC_IN = 21] = "SRC_IN", t[t.SRC_OUT = 22] = "SRC_OUT", t[t.SRC_ATOP = 23] = "SRC_ATOP", t[t.DST_OVER = 24] = "DST_OVER", t[t.DST_IN = 25] = "DST_IN", t[t.DST_OUT = 26] = "DST_OUT", t[t.DST_ATOP = 27] = "DST_ATOP", t[t.ERASE = 26] = "ERASE", t[t.SUBTRACT = 28] = "SUBTRACT", t[t.XOR = 29] = "XOR"
        }(lt || (lt = {})),
        function(t) {
            t[t.POINTS = 0] = "POINTS", t[t.LINES = 1] = "LINES", t[t.LINE_LOOP = 2] = "LINE_LOOP", t[t.LINE_STRIP = 3] = "LINE_STRIP", t[t.TRIANGLES = 4] = "TRIANGLES", t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN"
        }(ut || (ut = {})),
        function(t) {
            t[t.RGBA = 6408] = "RGBA", t[t.RGB = 6407] = "RGB", t[t.RG = 33319] = "RG", t[t.RED = 6403] = "RED", t[t.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t[t.RGB_INTEGER = 36248] = "RGB_INTEGER", t[t.RG_INTEGER = 33320] = "RG_INTEGER", t[t.RED_INTEGER = 36244] = "RED_INTEGER", t[t.ALPHA = 6406] = "ALPHA", t[t.LUMINANCE = 6409] = "LUMINANCE", t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL"
        }(ht || (ht = {})),
        function(t) {
            t[t.TEXTURE_2D = 3553] = "TEXTURE_2D", t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z"
        }(ct || (ct = {})),
        function(t) {
            t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t[t.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t[t.BYTE = 5120] = "BYTE", t[t.SHORT = 5122] = "SHORT", t[t.INT = 5124] = "INT", t[t.FLOAT = 5126] = "FLOAT", t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t[t.HALF_FLOAT = 36193] = "HALF_FLOAT"
        }(dt || (dt = {})),
        function(t) {
            t[t.FLOAT = 0] = "FLOAT", t[t.INT = 1] = "INT", t[t.UINT = 2] = "UINT"
        }(pt || (pt = {})),
        function(t) {
            t[t.NEAREST = 0] = "NEAREST", t[t.LINEAR = 1] = "LINEAR"
        }(ft || (ft = {})),
        function(t) {
            t[t.CLAMP = 33071] = "CLAMP", t[t.REPEAT = 10497] = "REPEAT", t[t.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT"
        }(mt || (mt = {})),
        function(t) {
            t[t.OFF = 0] = "OFF", t[t.POW2 = 1] = "POW2", t[t.ON = 2] = "ON", t[t.ON_MANUAL = 3] = "ON_MANUAL"
        }(gt || (gt = {})),
        function(t) {
            t[t.NPM = 0] = "NPM", t[t.UNPACK = 1] = "UNPACK", t[t.PMA = 2] = "PMA", t[t.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t[t.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t[t.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t[t.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA"
        }(vt || (vt = {})),
        function(t) {
            t[t.NO = 0] = "NO", t[t.YES = 1] = "YES", t[t.AUTO = 2] = "AUTO", t[t.BLEND = 0] = "BLEND", t[t.CLEAR = 1] = "CLEAR", t[t.BLIT = 2] = "BLIT"
        }(_t || (_t = {})),
        function(t) {
            t[t.AUTO = 0] = "AUTO", t[t.MANUAL = 1] = "MANUAL"
        }(yt || (yt = {})),
        function(t) {
            t.LOW = "lowp", t.MEDIUM = "mediump", t.HIGH = "highp"
        }(xt || (xt = {})),
        function(t) {
            t[t.NONE = 0] = "NONE", t[t.SCISSOR = 1] = "SCISSOR", t[t.STENCIL = 2] = "STENCIL", t[t.SPRITE = 3] = "SPRITE"
        }(bt || (bt = {})),
        function(t) {
            t[t.NONE = 0] = "NONE", t[t.LOW = 2] = "LOW", t[t.MEDIUM = 4] = "MEDIUM", t[t.HIGH = 8] = "HIGH"
        }(Et || (Et = {})),
        function(t) {
            t[t.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t[t.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t[t.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER"
        }(Tt || (Tt = {}));
        var It = {
            parse: Pt.Qc,
            format: Pt.WU,
            resolve: Pt.DB
        };
        St.RETINA_PREFIX = /@([0-9\.]+)x/, St.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
        var Ct, Ot = !1,
            Lt = {
                aliceblue: "#f0f8ff",
                antiquewhite: "#faebd7",
                aqua: "#00ffff",
                aquamarine: "#7fffd4",
                azure: "#f0ffff",
                beige: "#f5f5dc",
                bisque: "#ffe4c4",
                black: "#000000",
                blanchedalmond: "#ffebcd",
                blue: "#0000ff",
                blueviolet: "#8a2be2",
                brown: "#a52a2a",
                burlywood: "#deb887",
                cadetblue: "#5f9ea0",
                chartreuse: "#7fff00",
                chocolate: "#d2691e",
                coral: "#ff7f50",
                cornflowerblue: "#6495ed",
                cornsilk: "#fff8dc",
                crimson: "#dc143c",
                cyan: "#00ffff",
                darkblue: "#00008b",
                darkcyan: "#008b8b",
                darkgoldenrod: "#b8860b",
                darkgray: "#a9a9a9",
                darkgreen: "#006400",
                darkgrey: "#a9a9a9",
                darkkhaki: "#bdb76b",
                darkmagenta: "#8b008b",
                darkolivegreen: "#556b2f",
                darkorange: "#ff8c00",
                darkorchid: "#9932cc",
                darkred: "#8b0000",
                darksalmon: "#e9967a",
                darkseagreen: "#8fbc8f",
                darkslateblue: "#483d8b",
                darkslategray: "#2f4f4f",
                darkslategrey: "#2f4f4f",
                darkturquoise: "#00ced1",
                darkviolet: "#9400d3",
                deeppink: "#ff1493",
                deepskyblue: "#00bfff",
                dimgray: "#696969",
                dimgrey: "#696969",
                dodgerblue: "#1e90ff",
                firebrick: "#b22222",
                floralwhite: "#fffaf0",
                forestgreen: "#228b22",
                fuchsia: "#ff00ff",
                gainsboro: "#dcdcdc",
                ghostwhite: "#f8f8ff",
                goldenrod: "#daa520",
                gold: "#ffd700",
                gray: "#808080",
                green: "#008000",
                greenyellow: "#adff2f",
                grey: "#808080",
                honeydew: "#f0fff0",
                hotpink: "#ff69b4",
                indianred: "#cd5c5c",
                indigo: "#4b0082",
                ivory: "#fffff0",
                khaki: "#f0e68c",
                lavenderblush: "#fff0f5",
                lavender: "#e6e6fa",
                lawngreen: "#7cfc00",
                lemonchiffon: "#fffacd",
                lightblue: "#add8e6",
                lightcoral: "#f08080",
                lightcyan: "#e0ffff",
                lightgoldenrodyellow: "#fafad2",
                lightgray: "#d3d3d3",
                lightgreen: "#90ee90",
                lightgrey: "#d3d3d3",
                lightpink: "#ffb6c1",
                lightsalmon: "#ffa07a",
                lightseagreen: "#20b2aa",
                lightskyblue: "#87cefa",
                lightslategray: "#778899",
                lightslategrey: "#778899",
                lightsteelblue: "#b0c4de",
                lightyellow: "#ffffe0",
                lime: "#00ff00",
                limegreen: "#32cd32",
                linen: "#faf0e6",
                magenta: "#ff00ff",
                maroon: "#800000",
                mediumaquamarine: "#66cdaa",
                mediumblue: "#0000cd",
                mediumorchid: "#ba55d3",
                mediumpurple: "#9370db",
                mediumseagreen: "#3cb371",
                mediumslateblue: "#7b68ee",
                mediumspringgreen: "#00fa9a",
                mediumturquoise: "#48d1cc",
                mediumvioletred: "#c71585",
                midnightblue: "#191970",
                mintcream: "#f5fffa",
                mistyrose: "#ffe4e1",
                moccasin: "#ffe4b5",
                navajowhite: "#ffdead",
                navy: "#000080",
                oldlace: "#fdf5e6",
                olive: "#808000",
                olivedrab: "#6b8e23",
                orange: "#ffa500",
                orangered: "#ff4500",
                orchid: "#da70d6",
                palegoldenrod: "#eee8aa",
                palegreen: "#98fb98",
                paleturquoise: "#afeeee",
                palevioletred: "#db7093",
                papayawhip: "#ffefd5",
                peachpuff: "#ffdab9",
                peru: "#cd853f",
                pink: "#ffc0cb",
                plum: "#dda0dd",
                powderblue: "#b0e0e6",
                purple: "#800080",
                rebeccapurple: "#663399",
                red: "#ff0000",
                rosybrown: "#bc8f8f",
                royalblue: "#4169e1",
                saddlebrown: "#8b4513",
                salmon: "#fa8072",
                sandybrown: "#f4a460",
                seagreen: "#2e8b57",
                seashell: "#fff5ee",
                sienna: "#a0522d",
                silver: "#c0c0c0",
                skyblue: "#87ceeb",
                slateblue: "#6a5acd",
                slategray: "#708090",
                slategrey: "#708090",
                snow: "#fffafa",
                springgreen: "#00ff7f",
                steelblue: "#4682b4",
                tan: "#d2b48c",
                teal: "#008080",
                thistle: "#d8bfd8",
                tomato: "#ff6347",
                turquoise: "#40e0d0",
                violet: "#ee82ee",
                wheat: "#f5deb3",
                white: "#ffffff",
                whitesmoke: "#f5f5f5",
                yellow: "#ffff00",
                yellowgreen: "#9acd32"
            };

        function Nt(t, e) {
            return void 0 === e && (e = []), e[0] = (t >> 16 & 255) / 255, e[1] = (t >> 8 & 255) / 255, e[2] = (255 & t) / 255, e
        }

        function Dt(t) {
            var e = t.toString(16);
            return "#" + ("000000".substring(0, 6 - e.length) + e)
        }

        function Ut(t) {
            return "string" == typeof t && "#" === (t = Lt[t.toLowerCase()] || t)[0] && (t = t.slice(1)), parseInt(t, 16)
        }
        var Ft = function() {
            for (var t = [], e = [], n = 0; n < 32; n++) t[n] = n, e[n] = n;
            t[lt.NORMAL_NPM] = lt.NORMAL, t[lt.ADD_NPM] = lt.ADD, t[lt.SCREEN_NPM] = lt.SCREEN, e[lt.NORMAL] = lt.NORMAL_NPM, e[lt.ADD] = lt.ADD_NPM, e[lt.SCREEN] = lt.SCREEN_NPM;
            var r = [];
            return r.push(e), r.push(t), r
        }();

        function Bt(t, e) {
            return Ft[e ? 1 : 0][t]
        }

        function kt(t, e) {
            if (1 === e) return (255 * e << 24) + t;
            if (0 === e) return 0;
            var n = t >> 16 & 255,
                r = t >> 8 & 255,
                i = 255 & t;
            return (255 * e << 24) + ((n = n * e + .5 | 0) << 16) + ((r = r * e + .5 | 0) << 8) + (i * e + .5 | 0)
        }

        function Gt(t, e, n, r) {
            return (n = n || new Float32Array(4))[0] = (t >> 16 & 255) / 255, n[1] = (t >> 8 & 255) / 255, n[2] = (255 & t) / 255, (r || void 0 === r) && (n[0] *= e, n[1] *= e, n[2] *= e), n[3] = e, n
        }

        function Ht(t) {
            if (4 === t.BYTES_PER_ELEMENT) return t instanceof Float32Array ? "Float32Array" : t instanceof Uint32Array ? "Uint32Array" : "Int32Array";
            if (2 === t.BYTES_PER_ELEMENT) {
                if (t instanceof Uint16Array) return "Uint16Array"
            } else if (1 === t.BYTES_PER_ELEMENT && t instanceof Uint8Array) return "Uint8Array";
            return null
        }

        function zt(t) {
            return t += 0 === t ? 1 : 0, --t, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, 1 + (t |= t >>> 16)
        }

        function Vt(t) {
            return !(t & t - 1 || !t)
        }

        function Wt(t) {
            var e = (t > 65535 ? 1 : 0) << 4,
                n = ((t >>>= e) > 255 ? 1 : 0) << 3;
            return e |= n, e |= n = ((t >>>= n) > 15 ? 1 : 0) << 2, (e |= n = ((t >>>= n) > 3 ? 1 : 0) << 1) | (t >>>= n) >> 1
        }

        function Xt(t, e, n) {
            var r, i = t.length;
            if (!(e >= i || 0 === n)) {
                var o = i - (n = e + n > i ? i - e : n);
                for (r = e; r < o; ++r) t[r] = t[r + n];
                t.length = o
            }
        }

        function jt(t) {
            return 0 === t ? 0 : t < 0 ? -1 : 1
        }
        Float32Array, Uint32Array, Int32Array, Uint8Array;
        var Yt = 0;

        function qt() {
            return ++Yt
        }
        var Zt = {};

        function Kt(t, e, n) {
            if (void 0 === n && (n = 3), !Zt[e]) {
                var r = (new Error).stack;
                void 0 === r ? console.warn("PixiJS Deprecation Warning: ", e + "\nDeprecated since v" + t) : (r = r.split("\n").splice(n).join("\n"), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", e + "\nDeprecated since v" + t), console.warn(r), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", e + "\nDeprecated since v" + t), console.warn(r))), Zt[e] = !0
            }
        }
        var Jt, Qt = {},
            $t = Object.create(null),
            te = Object.create(null),
            ee = function() {
                function t(t, e, n) {
                    this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), this.resolution = n || St.RESOLUTION, this.resize(t, e)
                }
                return t.prototype.clear = function() {
                    this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
                }, t.prototype.resize = function(t, e) {
                    this.canvas.width = Math.round(t * this.resolution), this.canvas.height = Math.round(e * this.resolution)
                }, t.prototype.destroy = function() {
                    this.context = null, this.canvas = null
                }, Object.defineProperty(t.prototype, "width", {
                    get: function() {
                        return this.canvas.width
                    },
                    set: function(t) {
                        this.canvas.width = Math.round(t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "height", {
                    get: function() {
                        return this.canvas.height
                    },
                    set: function(t) {
                        this.canvas.height = Math.round(t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), t
            }();

        function ne(t, e) {
            var n = St.RETINA_PREFIX.exec(t);
            return n ? parseFloat(n[1]) : void 0 !== e ? e : 1
        }
        var re, ie = 2 * Math.PI,
            oe = 180 / Math.PI,
            se = Math.PI / 180;
        ! function(t) {
            t[t.POLY = 0] = "POLY", t[t.RECT = 1] = "RECT", t[t.CIRC = 2] = "CIRC", t[t.ELIP = 3] = "ELIP", t[t.RREC = 4] = "RREC"
        }(re || (re = {}));
        var ae = function() {
                function t(t, e) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), this.x = 0, this.y = 0, this.x = t, this.y = e
                }
                return t.prototype.clone = function() {
                    return new t(this.x, this.y)
                }, t.prototype.copyFrom = function(t) {
                    return this.set(t.x, t.y), this
                }, t.prototype.copyTo = function(t) {
                    return t.set(this.x, this.y), t
                }, t.prototype.equals = function(t) {
                    return t.x === this.x && t.y === this.y
                }, t.prototype.set = function(t, e) {
                    return void 0 === t && (t = 0), void 0 === e && (e = t), this.x = t, this.y = e, this
                }, t.prototype.toString = function() {
                    return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]"
                }, t
            }(),
            le = [new ae, new ae, new ae, new ae],
            ue = function() {
                function t(t, e, n, r) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), this.x = Number(t), this.y = Number(e), this.width = Number(n), this.height = Number(r), this.type = re.RECT
                }
                return Object.defineProperty(t.prototype, "left", {
                    get: function() {
                        return this.x
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "right", {
                    get: function() {
                        return this.x + this.width
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "top", {
                    get: function() {
                        return this.y
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "bottom", {
                    get: function() {
                        return this.y + this.height
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t, "EMPTY", {
                    get: function() {
                        return new t(0, 0, 0, 0)
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.clone = function() {
                    return new t(this.x, this.y, this.width, this.height)
                }, t.prototype.copyFrom = function(t) {
                    return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this
                }, t.prototype.copyTo = function(t) {
                    return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
                }, t.prototype.contains = function(t, e) {
                    return !(this.width <= 0 || this.height <= 0) && t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height
                }, t.prototype.intersects = function(t, e) {
                    if (!e) {
                        var n = this.x < t.x ? t.x : this.x;
                        if ((this.right > t.right ? t.right : this.right) <= n) return !1;
                        var r = this.y < t.y ? t.y : this.y;
                        return (this.bottom > t.bottom ? t.bottom : this.bottom) > r
                    }
                    var i = this.left,
                        o = this.right,
                        s = this.top,
                        a = this.bottom;
                    if (o <= i || a <= s) return !1;
                    var l = le[0].set(t.left, t.top),
                        u = le[1].set(t.left, t.bottom),
                        h = le[2].set(t.right, t.top),
                        c = le[3].set(t.right, t.bottom);
                    if (h.x <= l.x || u.y <= l.y) return !1;
                    var d = Math.sign(e.a * e.d - e.b * e.c);
                    if (0 === d) return !1;
                    if (e.apply(l, l), e.apply(u, u), e.apply(h, h), e.apply(c, c), Math.max(l.x, u.x, h.x, c.x) <= i || Math.min(l.x, u.x, h.x, c.x) >= o || Math.max(l.y, u.y, h.y, c.y) <= s || Math.min(l.y, u.y, h.y, c.y) >= a) return !1;
                    var p = d * (u.y - l.y),
                        f = d * (l.x - u.x),
                        m = p * i + f * s,
                        g = p * o + f * s,
                        v = p * i + f * a,
                        _ = p * o + f * a;
                    if (Math.max(m, g, v, _) <= p * l.x + f * l.y || Math.min(m, g, v, _) >= p * c.x + f * c.y) return !1;
                    var y = d * (l.y - h.y),
                        x = d * (h.x - l.x),
                        b = y * i + x * s,
                        E = y * o + x * s,
                        T = y * i + x * a,
                        S = y * o + x * a;
                    return !(Math.max(b, E, T, S) <= y * l.x + x * l.y || Math.min(b, E, T, S) >= y * c.x + x * c.y)
                }, t.prototype.pad = function(t, e) {
                    return void 0 === t && (t = 0), void 0 === e && (e = t), this.x -= t, this.y -= e, this.width += 2 * t, this.height += 2 * e, this
                }, t.prototype.fit = function(t) {
                    var e = Math.max(this.x, t.x),
                        n = Math.min(this.x + this.width, t.x + t.width),
                        r = Math.max(this.y, t.y),
                        i = Math.min(this.y + this.height, t.y + t.height);
                    return this.x = e, this.width = Math.max(n - e, 0), this.y = r, this.height = Math.max(i - r, 0), this
                }, t.prototype.ceil = function(t, e) {
                    void 0 === t && (t = 1), void 0 === e && (e = .001);
                    var n = Math.ceil((this.x + this.width - e) * t) / t,
                        r = Math.ceil((this.y + this.height - e) * t) / t;
                    return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = n - this.x, this.height = r - this.y, this
                }, t.prototype.enlarge = function(t) {
                    var e = Math.min(this.x, t.x),
                        n = Math.max(this.x + this.width, t.x + t.width),
                        r = Math.min(this.y, t.y),
                        i = Math.max(this.y + this.height, t.y + t.height);
                    return this.x = e, this.width = n - e, this.y = r, this.height = i - r, this
                }, t.prototype.toString = function() {
                    return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]"
                }, t
            }(),
            he = function() {
                function t(t, e, n) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), this.x = t, this.y = e, this.radius = n, this.type = re.CIRC
                }
                return t.prototype.clone = function() {
                    return new t(this.x, this.y, this.radius)
                }, t.prototype.contains = function(t, e) {
                    if (this.radius <= 0) return !1;
                    var n = this.radius * this.radius,
                        r = this.x - t,
                        i = this.y - e;
                    return (r *= r) + (i *= i) <= n
                }, t.prototype.getBounds = function() {
                    return new ue(this.x - this.radius, this.y - this.radius, 2 * this.radius, 2 * this.radius)
                }, t.prototype.toString = function() {
                    return "[@pixi/math:Circle x=" + this.x + " y=" + this.y + " radius=" + this.radius + "]"
                }, t
            }(),
            ce = function() {
                function t(t, e, n, r) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), this.x = t, this.y = e, this.width = n, this.height = r, this.type = re.ELIP
                }
                return t.prototype.clone = function() {
                    return new t(this.x, this.y, this.width, this.height)
                }, t.prototype.contains = function(t, e) {
                    if (this.width <= 0 || this.height <= 0) return !1;
                    var n = (t - this.x) / this.width,
                        r = (e - this.y) / this.height;
                    return (n *= n) + (r *= r) <= 1
                }, t.prototype.getBounds = function() {
                    return new ue(this.x - this.width, this.y - this.height, this.width, this.height)
                }, t.prototype.toString = function() {
                    return "[@pixi/math:Ellipse x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]"
                }, t
            }(),
            de = function() {
                function t() {
                    for (var t = arguments, e = [], n = 0; n < arguments.length; n++) e[n] = t[n];
                    var r = Array.isArray(e[0]) ? e[0] : e;
                    if ("number" != typeof r[0]) {
                        for (var i = [], o = 0, s = r.length; o < s; o++) i.push(r[o].x, r[o].y);
                        r = i
                    }
                    this.points = r, this.type = re.POLY, this.closeStroke = !0
                }
                return t.prototype.clone = function() {
                    var e = new t(this.points.slice());
                    return e.closeStroke = this.closeStroke, e
                }, t.prototype.contains = function(t, e) {
                    for (var n = !1, r = this.points.length / 2, i = 0, o = r - 1; i < r; o = i++) {
                        var s = this.points[2 * i],
                            a = this.points[2 * i + 1],
                            l = this.points[2 * o],
                            u = this.points[2 * o + 1];
                        a > e != u > e && t < (e - a) / (u - a) * (l - s) + s && (n = !n)
                    }
                    return n
                }, t.prototype.toString = function() {
                    return "[@pixi/math:PolygoncloseStroke=" + this.closeStroke + "points=" + this.points.reduce((function(t, e) {
                        return t + ", " + e
                    }), "") + "]"
                }, t
            }(),
            pe = function() {
                function t(t, e, n, r, i) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === i && (i = 20), this.x = t, this.y = e, this.width = n, this.height = r, this.radius = i, this.type = re.RREC
                }
                return t.prototype.clone = function() {
                    return new t(this.x, this.y, this.width, this.height, this.radius)
                }, t.prototype.contains = function(t, e) {
                    if (this.width <= 0 || this.height <= 0) return !1;
                    if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
                        var n = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
                        if (e >= this.y + n && e <= this.y + this.height - n || t >= this.x + n && t <= this.x + this.width - n) return !0;
                        var r = t - (this.x + n),
                            i = e - (this.y + n),
                            o = n * n;
                        if (r * r + i * i <= o) return !0;
                        if ((r = t - (this.x + this.width - n)) * r + i * i <= o) return !0;
                        if (r * r + (i = e - (this.y + this.height - n)) * i <= o) return !0;
                        if ((r = t - (this.x + n)) * r + i * i <= o) return !0
                    }
                    return !1
                }, t.prototype.toString = function() {
                    return "[@pixi/math:RoundedRectangle x=" + this.x + " y=" + this.y + "width=" + this.width + " height=" + this.height + " radius=" + this.radius + "]"
                }, t
            }(),
            fe = function() {
                function t(t, e, n, r) {
                    void 0 === n && (n = 0), void 0 === r && (r = 0), this._x = n, this._y = r, this.cb = t, this.scope = e
                }
                return t.prototype.clone = function(e, n) {
                    return void 0 === e && (e = this.cb), void 0 === n && (n = this.scope), new t(e, n, this._x, this._y)
                }, t.prototype.set = function(t, e) {
                    return void 0 === t && (t = 0), void 0 === e && (e = t), this._x === t && this._y === e || (this._x = t, this._y = e, this.cb.call(this.scope)), this
                }, t.prototype.copyFrom = function(t) {
                    return this._x === t.x && this._y === t.y || (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this
                }, t.prototype.copyTo = function(t) {
                    return t.set(this._x, this._y), t
                }, t.prototype.equals = function(t) {
                    return t.x === this._x && t.y === this._y
                }, t.prototype.toString = function() {
                    return "[@pixi/math:ObservablePoint x=0 y=0 scope=" + this.scope + "]"
                }, Object.defineProperty(t.prototype, "x", {
                    get: function() {
                        return this._x
                    },
                    set: function(t) {
                        this._x !== t && (this._x = t, this.cb.call(this.scope))
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "y", {
                    get: function() {
                        return this._y
                    },
                    set: function(t) {
                        this._y !== t && (this._y = t, this.cb.call(this.scope))
                    },
                    enumerable: !1,
                    configurable: !0
                }), t
            }(),
            me = function() {
                function t(t, e, n, r, i, o) {
                    void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === r && (r = 1), void 0 === i && (i = 0), void 0 === o && (o = 0), this.array = null, this.a = t, this.b = e, this.c = n, this.d = r, this.tx = i, this.ty = o
                }
                return t.prototype.fromArray = function(t) {
                    this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5]
                }, t.prototype.set = function(t, e, n, r, i, o) {
                    return this.a = t, this.b = e, this.c = n, this.d = r, this.tx = i, this.ty = o, this
                }, t.prototype.toArray = function(t, e) {
                    this.array || (this.array = new Float32Array(9));
                    var n = e || this.array;
                    return t ? (n[0] = this.a, n[1] = this.b, n[2] = 0, n[3] = this.c, n[4] = this.d, n[5] = 0, n[6] = this.tx, n[7] = this.ty, n[8] = 1) : (n[0] = this.a, n[1] = this.c, n[2] = this.tx, n[3] = this.b, n[4] = this.d, n[5] = this.ty, n[6] = 0, n[7] = 0, n[8] = 1), n
                }, t.prototype.apply = function(t, e) {
                    e = e || new ae;
                    var n = t.x,
                        r = t.y;
                    return e.x = this.a * n + this.c * r + this.tx, e.y = this.b * n + this.d * r + this.ty, e
                }, t.prototype.applyInverse = function(t, e) {
                    e = e || new ae;
                    var n = 1 / (this.a * this.d + this.c * -this.b),
                        r = t.x,
                        i = t.y;
                    return e.x = this.d * n * r + -this.c * n * i + (this.ty * this.c - this.tx * this.d) * n, e.y = this.a * n * i + -this.b * n * r + (-this.ty * this.a + this.tx * this.b) * n, e
                }, t.prototype.translate = function(t, e) {
                    return this.tx += t, this.ty += e, this
                }, t.prototype.scale = function(t, e) {
                    return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this
                }, t.prototype.rotate = function(t) {
                    var e = Math.cos(t),
                        n = Math.sin(t),
                        r = this.a,
                        i = this.c,
                        o = this.tx;
                    return this.a = r * e - this.b * n, this.b = r * n + this.b * e, this.c = i * e - this.d * n, this.d = i * n + this.d * e, this.tx = o * e - this.ty * n, this.ty = o * n + this.ty * e, this
                }, t.prototype.append = function(t) {
                    var e = this.a,
                        n = this.b,
                        r = this.c,
                        i = this.d;
                    return this.a = t.a * e + t.b * r, this.b = t.a * n + t.b * i, this.c = t.c * e + t.d * r, this.d = t.c * n + t.d * i, this.tx = t.tx * e + t.ty * r + this.tx, this.ty = t.tx * n + t.ty * i + this.ty, this
                }, t.prototype.setTransform = function(t, e, n, r, i, o, s, a, l) {
                    return this.a = Math.cos(s + l) * i, this.b = Math.sin(s + l) * i, this.c = -Math.sin(s - a) * o, this.d = Math.cos(s - a) * o, this.tx = t - (n * this.a + r * this.c), this.ty = e - (n * this.b + r * this.d), this
                }, t.prototype.prepend = function(t) {
                    var e = this.tx;
                    if (1 !== t.a || 0 !== t.b || 0 !== t.c || 1 !== t.d) {
                        var n = this.a,
                            r = this.c;
                        this.a = n * t.a + this.b * t.c, this.b = n * t.b + this.b * t.d, this.c = r * t.a + this.d * t.c, this.d = r * t.b + this.d * t.d
                    }
                    return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this
                }, t.prototype.decompose = function(t) {
                    var e = this.a,
                        n = this.b,
                        r = this.c,
                        i = this.d,
                        o = t.pivot,
                        s = -Math.atan2(-r, i),
                        a = Math.atan2(n, e),
                        l = Math.abs(s + a);
                    return l < 1e-5 || Math.abs(ie - l) < 1e-5 ? (t.rotation = a, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = s, t.skew.y = a), t.scale.x = Math.sqrt(e * e + n * n), t.scale.y = Math.sqrt(r * r + i * i), t.position.x = this.tx + (o.x * e + o.y * r), t.position.y = this.ty + (o.x * n + o.y * i), t
                }, t.prototype.invert = function() {
                    var t = this.a,
                        e = this.b,
                        n = this.c,
                        r = this.d,
                        i = this.tx,
                        o = t * r - e * n;
                    return this.a = r / o, this.b = -e / o, this.c = -n / o, this.d = t / o, this.tx = (n * this.ty - r * i) / o, this.ty = -(t * this.ty - e * i) / o, this
                }, t.prototype.identity = function() {
                    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this
                }, t.prototype.clone = function() {
                    var e = new t;
                    return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e
                }, t.prototype.copyTo = function(t) {
                    return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t
                }, t.prototype.copyFrom = function(t) {
                    return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this
                }, t.prototype.toString = function() {
                    return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]"
                }, Object.defineProperty(t, "IDENTITY", {
                    get: function() {
                        return new t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t, "TEMP_MATRIX", {
                    get: function() {
                        return new t
                    },
                    enumerable: !1,
                    configurable: !0
                }), t
            }(),
            ge = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
            ve = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
            _e = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
            ye = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
            xe = [],
            be = [],
            Ee = Math.sign;
        ! function() {
            for (var t = 0; t < 16; t++) {
                var e = [];
                xe.push(e);
                for (var n = 0; n < 16; n++)
                    for (var r = Ee(ge[t] * ge[n] + _e[t] * ve[n]), i = Ee(ve[t] * ge[n] + ye[t] * ve[n]), o = Ee(ge[t] * _e[n] + _e[t] * ye[n]), s = Ee(ve[t] * _e[n] + ye[t] * ye[n]), a = 0; a < 16; a++)
                        if (ge[a] === r && ve[a] === i && _e[a] === o && ye[a] === s) {
                            e.push(a);
                            break
                        }
            }
            for (t = 0; t < 16; t++) {
                var l = new me;
                l.set(ge[t], ve[t], _e[t], ye[t], 0, 0), be.push(l)
            }
        }();
        var Te = {
                E: 0,
                SE: 1,
                S: 2,
                SW: 3,
                W: 4,
                NW: 5,
                N: 6,
                NE: 7,
                MIRROR_VERTICAL: 8,
                MAIN_DIAGONAL: 10,
                MIRROR_HORIZONTAL: 12,
                REVERSE_DIAGONAL: 14,
                uX: function(t) {
                    return ge[t]
                },
                uY: function(t) {
                    return ve[t]
                },
                vX: function(t) {
                    return _e[t]
                },
                vY: function(t) {
                    return ye[t]
                },
                inv: function(t) {
                    return 8 & t ? 15 & t : 7 & -t
                },
                add: function(t, e) {
                    return xe[t][e]
                },
                sub: function(t, e) {
                    return xe[t][Te.inv(e)]
                },
                rotate180: function(t) {
                    return 4 ^ t
                },
                isVertical: function(t) {
                    return 2 == (3 & t)
                },
                byDirection: function(t, e) {
                    return 2 * Math.abs(t) <= Math.abs(e) ? e >= 0 ? Te.S : Te.N : 2 * Math.abs(e) <= Math.abs(t) ? t > 0 ? Te.E : Te.W : e > 0 ? t > 0 ? Te.SE : Te.SW : t > 0 ? Te.NE : Te.NW
                },
                matrixAppendRotationInv: function(t, e, n, r) {
                    void 0 === n && (n = 0), void 0 === r && (r = 0);
                    var i = be[Te.inv(e)];
                    i.tx = n, i.ty = r, t.append(i)
                }
            },
            Se = function() {
                function t() {
                    this.worldTransform = new me, this.localTransform = new me, this.position = new fe(this.onChange, this, 0, 0), this.scale = new fe(this.onChange, this, 1, 1), this.pivot = new fe(this.onChange, this, 0, 0), this.skew = new fe(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0
                }
                return t.prototype.onChange = function() {
                    this._localID++
                }, t.prototype.updateSkew = function() {
                    this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++
                }, t.prototype.toString = function() {
                    return "[@pixi/math:Transform position=(" + this.position.x + ", " + this.position.y + ") rotation=" + this.rotation + " scale=(" + this.scale.x + ", " + this.scale.y + ") skew=(" + this.skew.x + ", " + this.skew.y + ") ]"
                }, t.prototype.updateLocalTransform = function() {
                    var t = this.localTransform;
                    this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1)
                }, t.prototype.updateTransform = function(t) {
                    var e = this.localTransform;
                    if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t._worldID) {
                        var n = t.worldTransform,
                            r = this.worldTransform;
                        r.a = e.a * n.a + e.b * n.c, r.b = e.a * n.b + e.b * n.d, r.c = e.c * n.a + e.d * n.c, r.d = e.c * n.b + e.d * n.d, r.tx = e.tx * n.a + e.ty * n.c + n.tx, r.ty = e.tx * n.b + e.ty * n.d + n.ty, this._parentID = t._worldID, this._worldID++
                    }
                }, t.prototype.setFromMatrix = function(t) {
                    t.decompose(this), this._localID++
                }, Object.defineProperty(t.prototype, "rotation", {
                    get: function() {
                        return this._rotation
                    },
                    set: function(t) {
                        this._rotation !== t && (this._rotation = t, this.updateSkew())
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.IDENTITY = new t, t
            }();
        St.SORTABLE_CHILDREN = !1;
        var we = function() {
                function t() {
                    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1
                }
                return t.prototype.isEmpty = function() {
                    return this.minX > this.maxX || this.minY > this.maxY
                }, t.prototype.clear = function() {
                    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0
                }, t.prototype.getRectangle = function(t) {
                    return this.minX > this.maxX || this.minY > this.maxY ? ue.EMPTY : ((t = t || new ue(0, 0, 1, 1)).x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t)
                }, t.prototype.addPoint = function(t) {
                    this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y)
                }, t.prototype.addPointMatrix = function(t, e) {
                    var n = t.a,
                        r = t.b,
                        i = t.c,
                        o = t.d,
                        s = t.tx,
                        a = t.ty,
                        l = n * e.x + i * e.y + s,
                        u = r * e.x + o * e.y + a;
                    this.minX = Math.min(this.minX, l), this.maxX = Math.max(this.maxX, l), this.minY = Math.min(this.minY, u), this.maxY = Math.max(this.maxY, u)
                }, t.prototype.addQuad = function(t) {
                    var e = this.minX,
                        n = this.minY,
                        r = this.maxX,
                        i = this.maxY,
                        o = t[0],
                        s = t[1];
                    e = o < e ? o : e, n = s < n ? s : n, r = o > r ? o : r, i = s > i ? s : i, e = (o = t[2]) < e ? o : e, n = (s = t[3]) < n ? s : n, r = o > r ? o : r, i = s > i ? s : i, e = (o = t[4]) < e ? o : e, n = (s = t[5]) < n ? s : n, r = o > r ? o : r, i = s > i ? s : i, e = (o = t[6]) < e ? o : e, n = (s = t[7]) < n ? s : n, r = o > r ? o : r, i = s > i ? s : i, this.minX = e, this.minY = n, this.maxX = r, this.maxY = i
                }, t.prototype.addFrame = function(t, e, n, r, i) {
                    this.addFrameMatrix(t.worldTransform, e, n, r, i)
                }, t.prototype.addFrameMatrix = function(t, e, n, r, i) {
                    var o = t.a,
                        s = t.b,
                        a = t.c,
                        l = t.d,
                        u = t.tx,
                        h = t.ty,
                        c = this.minX,
                        d = this.minY,
                        p = this.maxX,
                        f = this.maxY,
                        m = o * e + a * n + u,
                        g = s * e + l * n + h;
                    c = m < c ? m : c, d = g < d ? g : d, p = m > p ? m : p, f = g > f ? g : f, c = (m = o * r + a * n + u) < c ? m : c, d = (g = s * r + l * n + h) < d ? g : d, p = m > p ? m : p, f = g > f ? g : f, c = (m = o * e + a * i + u) < c ? m : c, d = (g = s * e + l * i + h) < d ? g : d, p = m > p ? m : p, f = g > f ? g : f, c = (m = o * r + a * i + u) < c ? m : c, d = (g = s * r + l * i + h) < d ? g : d, p = m > p ? m : p, f = g > f ? g : f, this.minX = c, this.minY = d, this.maxX = p, this.maxY = f
                }, t.prototype.addVertexData = function(t, e, n) {
                    for (var r = this.minX, i = this.minY, o = this.maxX, s = this.maxY, a = e; a < n; a += 2) {
                        var l = t[a],
                            u = t[a + 1];
                        r = l < r ? l : r, i = u < i ? u : i, o = l > o ? l : o, s = u > s ? u : s
                    }
                    this.minX = r, this.minY = i, this.maxX = o, this.maxY = s
                }, t.prototype.addVertices = function(t, e, n, r) {
                    this.addVerticesMatrix(t.worldTransform, e, n, r)
                }, t.prototype.addVerticesMatrix = function(t, e, n, r, i, o) {
                    void 0 === i && (i = 0), void 0 === o && (o = i);
                    for (var s = t.a, a = t.b, l = t.c, u = t.d, h = t.tx, c = t.ty, d = this.minX, p = this.minY, f = this.maxX, m = this.maxY, g = n; g < r; g += 2) {
                        var v = e[g],
                            _ = e[g + 1],
                            y = s * v + l * _ + h,
                            x = u * _ + a * v + c;
                        d = Math.min(d, y - i), f = Math.max(f, y + i), p = Math.min(p, x - o), m = Math.max(m, x + o)
                    }
                    this.minX = d, this.minY = p, this.maxX = f, this.maxY = m
                }, t.prototype.addBounds = function(t) {
                    var e = this.minX,
                        n = this.minY,
                        r = this.maxX,
                        i = this.maxY;
                    this.minX = t.minX < e ? t.minX : e, this.minY = t.minY < n ? t.minY : n, this.maxX = t.maxX > r ? t.maxX : r, this.maxY = t.maxY > i ? t.maxY : i
                }, t.prototype.addBoundsMask = function(t, e) {
                    var n = t.minX > e.minX ? t.minX : e.minX,
                        r = t.minY > e.minY ? t.minY : e.minY,
                        i = t.maxX < e.maxX ? t.maxX : e.maxX,
                        o = t.maxY < e.maxY ? t.maxY : e.maxY;
                    if (n <= i && r <= o) {
                        var s = this.minX,
                            a = this.minY,
                            l = this.maxX,
                            u = this.maxY;
                        this.minX = n < s ? n : s, this.minY = r < a ? r : a, this.maxX = i > l ? i : l, this.maxY = o > u ? o : u
                    }
                }, t.prototype.addBoundsMatrix = function(t, e) {
                    this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY)
                }, t.prototype.addBoundsArea = function(t, e) {
                    var n = t.minX > e.x ? t.minX : e.x,
                        r = t.minY > e.y ? t.minY : e.y,
                        i = t.maxX < e.x + e.width ? t.maxX : e.x + e.width,
                        o = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;
                    if (n <= i && r <= o) {
                        var s = this.minX,
                            a = this.minY,
                            l = this.maxX,
                            u = this.maxY;
                        this.minX = n < s ? n : s, this.minY = r < a ? r : a, this.maxX = i > l ? i : l, this.maxY = o > u ? o : u
                    }
                }, t.prototype.pad = function(t, e) {
                    void 0 === t && (t = 0), void 0 === e && (e = t), this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e)
                }, t.prototype.addFramePad = function(t, e, n, r, i, o) {
                    t -= i, e -= o, n += i, r += o, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > n ? this.maxX : n, this.minY = this.minY < e ? this.minY : e, this.maxY = this.maxY > r ? this.maxY : r
                }, t
            }(),
            Me = function(t, e) {
                return (Me = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(t, e) {
                        t.__proto__ = e
                    } || function(t, e) {
                        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
                    })(t, e)
            };

        function Ae(t, e) {
            function n() {
                this.constructor = t
            }
            Me(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
        }
        var Re, Pe, Ie, Ce, Oe, Le, Ne, De, Ue, Fe, Be, ke, Ge, He, ze, Ve, We, Xe, je, Ye = function(t) {
                function e() {
                    var e = t.call(this) || this;
                    return e.tempDisplayObjectParent = null, e.transform = new Se, e.alpha = 1, e.visible = !0, e.renderable = !0, e.cullable = !1, e.cullArea = null, e.parent = null, e.worldAlpha = 1, e._lastSortedIndex = 0, e._zIndex = 0, e.filterArea = null, e.filters = null, e._enabledFilters = null, e._bounds = new we, e._localBounds = null, e._boundsID = 0, e._boundsRect = null, e._localBoundsRect = null, e._mask = null, e._maskRefCount = 0, e._destroyed = !1, e.isSprite = !1, e.isMask = !1, e
                }
                return Ae(e, t), e.mixin = function(t) {
                    for (var n = Object.keys(t), r = 0; r < n.length; ++r) {
                        var i = n[r];
                        Object.defineProperty(e.prototype, i, Object.getOwnPropertyDescriptor(t, i))
                    }
                }, Object.defineProperty(e.prototype, "destroyed", {
                    get: function() {
                        return this._destroyed
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype._recursivePostUpdateTransform = function() {
                    this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform)
                }, e.prototype.updateTransform = function() {
                    this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha
                }, e.prototype.getBounds = function(t, e) {
                    return t || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), e || (this._boundsRect || (this._boundsRect = new ue), e = this._boundsRect), this._bounds.getRectangle(e)
                }, e.prototype.getLocalBounds = function(t) {
                    t || (this._localBoundsRect || (this._localBoundsRect = new ue), t = this._localBoundsRect), this._localBounds || (this._localBounds = new we);
                    var e = this.transform,
                        n = this.parent;
                    this.parent = null, this.transform = this._tempDisplayObjectParent.transform;
                    var r = this._bounds,
                        i = this._boundsID;
                    this._bounds = this._localBounds;
                    var o = this.getBounds(!1, t);
                    return this.parent = n, this.transform = e, this._bounds = r, this._bounds.updateID += this._boundsID - i, o
                }, e.prototype.toGlobal = function(t, e, n) {
                    return void 0 === n && (n = !1), n || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(t, e)
                }, e.prototype.toLocal = function(t, e, n, r) {
                    return e && (t = e.toGlobal(t, n, r)), r || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(t, n)
                }, e.prototype.setParent = function(t) {
                    if (!t || !t.addChild) throw new Error("setParent: Argument must be a Container");
                    return t.addChild(this), t
                }, e.prototype.setTransform = function(t, e, n, r, i, o, s, a, l) {
                    return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 1), void 0 === r && (r = 1), void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === a && (a = 0), void 0 === l && (l = 0), this.position.x = t, this.position.y = e, this.scale.x = n || 1, this.scale.y = r || 1, this.rotation = i, this.skew.x = o, this.skew.y = s, this.pivot.x = a, this.pivot.y = l, this
                }, e.prototype.destroy = function(t) {
                    this.parent && this.parent.removeChild(this), this.emit("destroyed"), this.removeAllListeners(), this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this._destroyed = !0
                }, Object.defineProperty(e.prototype, "_tempDisplayObjectParent", {
                    get: function() {
                        return null === this.tempDisplayObjectParent && (this.tempDisplayObjectParent = new qe), this.tempDisplayObjectParent
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype.enableTempParent = function() {
                    var t = this.parent;
                    return this.parent = this._tempDisplayObjectParent, t
                }, e.prototype.disableTempParent = function(t) {
                    this.parent = t
                }, Object.defineProperty(e.prototype, "x", {
                    get: function() {
                        return this.position.x
                    },
                    set: function(t) {
                        this.transform.position.x = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "y", {
                    get: function() {
                        return this.position.y
                    },
                    set: function(t) {
                        this.transform.position.y = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "worldTransform", {
                    get: function() {
                        return this.transform.worldTransform
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "localTransform", {
                    get: function() {
                        return this.transform.localTransform
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "position", {
                    get: function() {
                        return this.transform.position
                    },
                    set: function(t) {
                        this.transform.position.copyFrom(t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "scale", {
                    get: function() {
                        return this.transform.scale
                    },
                    set: function(t) {
                        this.transform.scale.copyFrom(t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "pivot", {
                    get: function() {
                        return this.transform.pivot
                    },
                    set: function(t) {
                        this.transform.pivot.copyFrom(t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "skew", {
                    get: function() {
                        return this.transform.skew
                    },
                    set: function(t) {
                        this.transform.skew.copyFrom(t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "rotation", {
                    get: function() {
                        return this.transform.rotation
                    },
                    set: function(t) {
                        this.transform.rotation = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "angle", {
                    get: function() {
                        return this.transform.rotation * oe
                    },
                    set: function(t) {
                        this.transform.rotation = t * se
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "zIndex", {
                    get: function() {
                        return this._zIndex
                    },
                    set: function(t) {
                        this._zIndex = t, this.parent && (this.parent.sortDirty = !0)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "worldVisible", {
                    get: function() {
                        var t = this;
                        do {
                            if (!t.visible) return !1;
                            t = t.parent
                        } while (t);
                        return !0
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "mask", {
                    get: function() {
                        return this._mask
                    },
                    set: function(t) {
                        var e;
                        this._mask !== t && (this._mask && ((e = this._mask.maskObject || this._mask)._maskRefCount--, 0 === e._maskRefCount && (e.renderable = !0, e.isMask = !1)), this._mask = t, this._mask && (0 === (e = this._mask.maskObject || this._mask)._maskRefCount && (e.renderable = !1, e.isMask = !0), e._maskRefCount++))
                    },
                    enumerable: !1,
                    configurable: !0
                }), e
            }(Mt()),
            qe = function(t) {
                function e() {
                    var e = null !== t && t.apply(this, arguments) || this;
                    return e.sortDirty = null, e
                }
                return Ae(e, t), e
            }(Ye);

        function Ze(t, e) {
            return t.zIndex === e.zIndex ? t._lastSortedIndex - e._lastSortedIndex : t.zIndex - e.zIndex
        }
        Ye.prototype.displayObjectUpdateTransform = Ye.prototype.updateTransform,
            function(t) {
                t[t.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t[t.WEBGL = 1] = "WEBGL", t[t.WEBGL2 = 2] = "WEBGL2"
            }(Re || (Re = {})),
            function(t) {
                t[t.UNKNOWN = 0] = "UNKNOWN", t[t.WEBGL = 1] = "WEBGL", t[t.CANVAS = 2] = "CANVAS"
            }(Pe || (Pe = {})),
            function(t) {
                t[t.COLOR = 16384] = "COLOR", t[t.DEPTH = 256] = "DEPTH", t[t.STENCIL = 1024] = "STENCIL"
            }(Ie || (Ie = {})),
            function(t) {
                t[t.NORMAL = 0] = "NORMAL", t[t.ADD = 1] = "ADD", t[t.MULTIPLY = 2] = "MULTIPLY", t[t.SCREEN = 3] = "SCREEN", t[t.OVERLAY = 4] = "OVERLAY", t[t.DARKEN = 5] = "DARKEN", t[t.LIGHTEN = 6] = "LIGHTEN", t[t.COLOR_DODGE = 7] = "COLOR_DODGE", t[t.COLOR_BURN = 8] = "COLOR_BURN", t[t.HARD_LIGHT = 9] = "HARD_LIGHT", t[t.SOFT_LIGHT = 10] = "SOFT_LIGHT", t[t.DIFFERENCE = 11] = "DIFFERENCE", t[t.EXCLUSION = 12] = "EXCLUSION", t[t.HUE = 13] = "HUE", t[t.SATURATION = 14] = "SATURATION", t[t.COLOR = 15] = "COLOR", t[t.LUMINOSITY = 16] = "LUMINOSITY", t[t.NORMAL_NPM = 17] = "NORMAL_NPM", t[t.ADD_NPM = 18] = "ADD_NPM", t[t.SCREEN_NPM = 19] = "SCREEN_NPM", t[t.NONE = 20] = "NONE", t[t.SRC_OVER = 0] = "SRC_OVER", t[t.SRC_IN = 21] = "SRC_IN", t[t.SRC_OUT = 22] = "SRC_OUT", t[t.SRC_ATOP = 23] = "SRC_ATOP", t[t.DST_OVER = 24] = "DST_OVER", t[t.DST_IN = 25] = "DST_IN", t[t.DST_OUT = 26] = "DST_OUT", t[t.DST_ATOP = 27] = "DST_ATOP", t[t.ERASE = 26] = "ERASE", t[t.SUBTRACT = 28] = "SUBTRACT", t[t.XOR = 29] = "XOR"
            }(Ce || (Ce = {})),
            function(t) {
                t[t.POINTS = 0] = "POINTS", t[t.LINES = 1] = "LINES", t[t.LINE_LOOP = 2] = "LINE_LOOP", t[t.LINE_STRIP = 3] = "LINE_STRIP", t[t.TRIANGLES = 4] = "TRIANGLES", t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN"
            }(Oe || (Oe = {})),
            function(t) {
                t[t.RGBA = 6408] = "RGBA", t[t.RGB = 6407] = "RGB", t[t.RG = 33319] = "RG", t[t.RED = 6403] = "RED", t[t.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t[t.RGB_INTEGER = 36248] = "RGB_INTEGER", t[t.RG_INTEGER = 33320] = "RG_INTEGER", t[t.RED_INTEGER = 36244] = "RED_INTEGER", t[t.ALPHA = 6406] = "ALPHA", t[t.LUMINANCE = 6409] = "LUMINANCE", t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL"
            }(Le || (Le = {})),
            function(t) {
                t[t.TEXTURE_2D = 3553] = "TEXTURE_2D", t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z"
            }(Ne || (Ne = {})),
            function(t) {
                t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t[t.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t[t.BYTE = 5120] = "BYTE", t[t.SHORT = 5122] = "SHORT", t[t.INT = 5124] = "INT", t[t.FLOAT = 5126] = "FLOAT", t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t[t.HALF_FLOAT = 36193] = "HALF_FLOAT"
            }(De || (De = {})),
            function(t) {
                t[t.FLOAT = 0] = "FLOAT", t[t.INT = 1] = "INT", t[t.UINT = 2] = "UINT"
            }(Ue || (Ue = {})),
            function(t) {
                t[t.NEAREST = 0] = "NEAREST", t[t.LINEAR = 1] = "LINEAR"
            }(Fe || (Fe = {})),
            function(t) {
                t[t.CLAMP = 33071] = "CLAMP", t[t.REPEAT = 10497] = "REPEAT", t[t.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT"
            }(Be || (Be = {})),
            function(t) {
                t[t.OFF = 0] = "OFF", t[t.POW2 = 1] = "POW2", t[t.ON = 2] = "ON", t[t.ON_MANUAL = 3] = "ON_MANUAL"
            }(ke || (ke = {})),
            function(t) {
                t[t.NPM = 0] = "NPM", t[t.UNPACK = 1] = "UNPACK", t[t.PMA = 2] = "PMA", t[t.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t[t.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t[t.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t[t.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA"
            }(Ge || (Ge = {})),
            function(t) {
                t[t.NO = 0] = "NO", t[t.YES = 1] = "YES", t[t.AUTO = 2] = "AUTO", t[t.BLEND = 0] = "BLEND", t[t.CLEAR = 1] = "CLEAR", t[t.BLIT = 2] = "BLIT"
            }(He || (He = {})),
            function(t) {
                t[t.AUTO = 0] = "AUTO", t[t.MANUAL = 1] = "MANUAL"
            }(ze || (ze = {})),
            function(t) {
                t.LOW = "lowp", t.MEDIUM = "mediump", t.HIGH = "highp"
            }(Ve || (Ve = {})),
            function(t) {
                t[t.NONE = 0] = "NONE", t[t.SCISSOR = 1] = "SCISSOR", t[t.STENCIL = 2] = "STENCIL", t[t.SPRITE = 3] = "SPRITE"
            }(We || (We = {})),
            function(t) {
                t[t.NONE = 0] = "NONE", t[t.LOW = 2] = "LOW", t[t.MEDIUM = 4] = "MEDIUM", t[t.HIGH = 8] = "HIGH"
            }(Xe || (Xe = {})),
            function(t) {
                t[t.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t[t.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t[t.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER"
            }(je || (je = {}));
        var Ke = function(t) {
            function e() {
                var e = t.call(this) || this;
                return e.children = [], e.sortableChildren = St.SORTABLE_CHILDREN, e.sortDirty = !1, e
            }
            return Ae(e, t), e.prototype.onChildrenChange = function(t) {}, e.prototype.addChild = function() {
                for (var t = arguments, e = [], n = 0; n < arguments.length; n++) e[n] = t[n];
                if (e.length > 1)
                    for (var r = 0; r < e.length; r++) this.addChild(e[r]);
                else {
                    var i = e[0];
                    i.parent && i.parent.removeChild(i), i.parent = this, this.sortDirty = !0, i.transform._parentID = -1, this.children.push(i), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", i, this, this.children.length - 1), i.emit("added", this)
                }
                return e[0]
            }, e.prototype.addChildAt = function(t, e) {
                if (e < 0 || e > this.children.length) throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length);
                return t.parent && t.parent.removeChild(t), t.parent = this, this.sortDirty = !0, t.transform._parentID = -1, this.children.splice(e, 0, t), this._boundsID++, this.onChildrenChange(e), t.emit("added", this), this.emit("childAdded", t, this, e), t
            }, e.prototype.swapChildren = function(t, e) {
                if (t !== e) {
                    var n = this.getChildIndex(t),
                        r = this.getChildIndex(e);
                    this.children[n] = e, this.children[r] = t, this.onChildrenChange(n < r ? n : r)
                }
            }, e.prototype.getChildIndex = function(t) {
                var e = this.children.indexOf(t);
                if (-1 === e) throw new Error("The supplied DisplayObject must be a child of the caller");
                return e
            }, e.prototype.setChildIndex = function(t, e) {
                if (e < 0 || e >= this.children.length) throw new Error("The index " + e + " supplied is out of bounds " + this.children.length);
                var n = this.getChildIndex(t);
                Xt(this.children, n, 1), this.children.splice(e, 0, t), this.onChildrenChange(e)
            }, e.prototype.getChildAt = function(t) {
                if (t < 0 || t >= this.children.length) throw new Error("getChildAt: Index (" + t + ") does not exist.");
                return this.children[t]
            }, e.prototype.removeChild = function() {
                for (var t = arguments, e = [], n = 0; n < arguments.length; n++) e[n] = t[n];
                if (e.length > 1)
                    for (var r = 0; r < e.length; r++) this.removeChild(e[r]);
                else {
                    var i = e[0],
                        o = this.children.indexOf(i);
                    if (-1 === o) return null;
                    i.parent = null, i.transform._parentID = -1, Xt(this.children, o, 1), this._boundsID++, this.onChildrenChange(o), i.emit("removed", this), this.emit("childRemoved", i, this, o)
                }
                return e[0]
            }, e.prototype.removeChildAt = function(t) {
                var e = this.getChildAt(t);
                return e.parent = null, e.transform._parentID = -1, Xt(this.children, t, 1), this._boundsID++, this.onChildrenChange(t), e.emit("removed", this), this.emit("childRemoved", e, this, t), e
            }, e.prototype.removeChildren = function(t, e) {
                void 0 === t && (t = 0), void 0 === e && (e = this.children.length);
                var n, r = t,
                    i = e - r;
                if (i > 0 && i <= e) {
                    n = this.children.splice(r, i);
                    for (var o = 0; o < n.length; ++o) n[o].parent = null, n[o].transform && (n[o].transform._parentID = -1);
                    for (this._boundsID++, this.onChildrenChange(t), o = 0; o < n.length; ++o) n[o].emit("removed", this), this.emit("childRemoved", n[o], this, o);
                    return n
                }
                if (0 === i && 0 === this.children.length) return [];
                throw new RangeError("removeChildren: numeric values are outside the acceptable range.")
            }, e.prototype.sortChildren = function() {
                for (var t = !1, e = 0, n = this.children.length; e < n; ++e) {
                    var r = this.children[e];
                    r._lastSortedIndex = e, t || 0 === r.zIndex || (t = !0)
                }
                t && this.children.length > 1 && this.children.sort(Ze), this.sortDirty = !1
            }, e.prototype.updateTransform = function() {
                this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
                for (var t = 0, e = this.children.length; t < e; ++t) {
                    var n = this.children[t];
                    n.visible && n.updateTransform()
                }
            }, e.prototype.calculateBounds = function() {
                this._bounds.clear(), this._calculateBounds();
                for (var t = 0; t < this.children.length; t++) {
                    var e = this.children[t];
                    if (e.visible && e.renderable)
                        if (e.calculateBounds(), e._mask) {
                            var n = e._mask.maskObject || e._mask;
                            n.calculateBounds(), this._bounds.addBoundsMask(e._bounds, n._bounds)
                        } else e.filterArea ? this._bounds.addBoundsArea(e._bounds, e.filterArea) : this._bounds.addBounds(e._bounds)
                }
                this._bounds.updateID = this._boundsID
            }, e.prototype.getLocalBounds = function(e, n) {
                void 0 === n && (n = !1);
                var r = t.prototype.getLocalBounds.call(this, e);
                if (!n)
                    for (var i = 0, o = this.children.length; i < o; ++i) {
                        var s = this.children[i];
                        s.visible && s.updateTransform()
                    }
                return r
            }, e.prototype._calculateBounds = function() {}, e.prototype._renderWithCulling = function(t) {
                var n = t.renderTexture.sourceFrame;
                if (n.width > 0 && n.height > 0) {
                    var r, i;
                    if (this.cullArea ? (r = this.cullArea, i = this.worldTransform) : this._render !== e.prototype._render && (r = this.getBounds(!0)), r && n.intersects(r, i)) this._render(t);
                    else if (this.cullArea) return;
                    for (var o = 0, s = this.children.length; o < s; ++o) {
                        var a = this.children[o],
                            l = a.cullable;
                        a.cullable = l || !this.cullArea, a.render(t), a.cullable = l
                    }
                }
            }, e.prototype.render = function(t) {
                if (this.visible && !(this.worldAlpha <= 0) && this.renderable)
                    if (this._mask || this.filters && this.filters.length) this.renderAdvanced(t);
                    else if (this.cullable) this._renderWithCulling(t);
                else {
                    this._render(t);
                    for (var e = 0, n = this.children.length; e < n; ++e) this.children[e].render(t)
                }
            }, e.prototype.renderAdvanced = function(t) {
                var e = this.filters,
                    n = this._mask;
                if (e) {
                    this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
                    for (var r = 0; r < e.length; r++) e[r].enabled && this._enabledFilters.push(e[r])
                }
                var i = e && this._enabledFilters && this._enabledFilters.length || n && (!n.isMaskData || n.enabled && (n.autoDetect || n.type !== We.NONE));
                if (i && t.batch.flush(), e && this._enabledFilters && this._enabledFilters.length && t.filter.push(this, this._enabledFilters), n && t.mask.push(this, this._mask), this.cullable) this._renderWithCulling(t);
                else {
                    this._render(t), r = 0;
                    for (var o = this.children.length; r < o; ++r) this.children[r].render(t)
                }
                i && t.batch.flush(), n && t.mask.pop(this), e && this._enabledFilters && this._enabledFilters.length && t.filter.pop()
            }, e.prototype._render = function(t) {}, e.prototype.destroy = function(e) {
                t.prototype.destroy.call(this), this.sortDirty = !1;
                var n = "boolean" == typeof e ? e : e && e.children,
                    r = this.removeChildren(0, this.children.length);
                if (n)
                    for (var i = 0; i < r.length; ++i) r[i].destroy(e)
            }, Object.defineProperty(e.prototype, "width", {
                get: function() {
                    return this.scale.x * this.getLocalBounds().width
                },
                set: function(t) {
                    var e = this.getLocalBounds().width;
                    this.scale.x = 0 !== e ? t / e : 1, this._width = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, "height", {
                get: function() {
                    return this.scale.y * this.getLocalBounds().height
                },
                set: function(t) {
                    var e = this.getLocalBounds().height;
                    this.scale.y = 0 !== e ? t / e : 1, this._height = t
                },
                enumerable: !1,
                configurable: !0
            }), e
        }(Ye);
        Ke.prototype.containerUpdateTransform = Ke.prototype.updateTransform, Ye.mixin({
            accessible: !1,
            accessibleTitle: null,
            accessibleHint: null,
            tabIndex: 0,
            _accessibleActive: !1,
            _accessibleDiv: null,
            accessibleType: "button",
            accessiblePointerEvents: "auto",
            accessibleChildren: !0,
            renderId: -1
        });
        var Je, Qe = function() {
            function t(t) {
                this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (it.tablet || it.phone) && this.createTouchHook();
                var e = document.createElement("div");
                e.style.width = "100px", e.style.height = "100px", e.style.position = "absolute", e.style.top = "0px", e.style.left = "0px", e.style.zIndex = 2..toString(), this.div = e, this.renderer = t, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1)
            }
            return Object.defineProperty(t.prototype, "isActive", {
                get: function() {
                    return this._isActive
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, "isMobileAccessibility", {
                get: function() {
                    return this._isMobileAccessibility
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.createTouchHook = function() {
                var t = this,
                    e = document.createElement("button");
                e.style.width = "1px", e.style.height = "1px", e.style.position = "absolute", e.style.top = "-1000px", e.style.left = "-1000px", e.style.zIndex = 2..toString(), e.style.backgroundColor = "#FF0000", e.title = "select to enable accessibility for this content", e.addEventListener("focus", (function() {
                    t._isMobileAccessibility = !0, t.activate(), t.destroyTouchHook()
                })), document.body.appendChild(e), this._hookDiv = e
            }, t.prototype.destroyTouchHook = function() {
                this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null)
            }, t.prototype.activate = function() {
                var t;
                this._isActive || (this._isActive = !0, globalThis.document.addEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown, !1), this.renderer.on("postrender", this.update, this), null === (t = this.renderer.view.parentNode) || void 0 === t || t.appendChild(this.div))
            }, t.prototype.deactivate = function() {
                var t;
                this._isActive && !this._isMobileAccessibility && (this._isActive = !1, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.addEventListener("keydown", this._onKeyDown, !1), this.renderer.off("postrender", this.update), null === (t = this.div.parentNode) || void 0 === t || t.removeChild(this.div))
            }, t.prototype.updateAccessibleObjects = function(t) {
                if (t.visible && t.accessibleChildren) {
                    t.accessible && t.interactive && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId);
                    var e = t.children;
                    if (e)
                        for (var n = 0; n < e.length; n++) this.updateAccessibleObjects(e[n])
                }
            }, t.prototype.update = function() {
                var t = performance.now();
                if (!(it.android.device && t < this.androidUpdateCount) && (this.androidUpdateCount = t + this.androidUpdateFrequency, this.renderer.renderingToScreen)) {
                    this.renderer._lastObjectRendered && this.updateAccessibleObjects(this.renderer._lastObjectRendered);
                    var e = this.renderer.view.getBoundingClientRect(),
                        n = e.left,
                        r = e.top,
                        i = e.width,
                        o = e.height,
                        s = this.renderer,
                        a = s.width,
                        l = s.height,
                        u = s.resolution,
                        h = i / a * u,
                        c = o / l * u,
                        d = this.div;
                    d.style.left = n + "px", d.style.top = r + "px", d.style.width = a + "px", d.style.height = l + "px";
                    for (var p = 0; p < this.children.length; p++) {
                        var f = this.children[p];
                        if (f.renderId !== this.renderId) f._accessibleActive = !1, Xt(this.children, p, 1), this.div.removeChild(f._accessibleDiv), this.pool.push(f._accessibleDiv), f._accessibleDiv = null, p--;
                        else {
                            d = f._accessibleDiv;
                            var m = f.hitArea,
                                g = f.worldTransform;
                            f.hitArea ? (d.style.left = (g.tx + m.x * g.a) * h + "px", d.style.top = (g.ty + m.y * g.d) * c + "px", d.style.width = m.width * g.a * h + "px", d.style.height = m.height * g.d * c + "px") : (m = f.getBounds(), this.capHitArea(m), d.style.left = m.x * h + "px", d.style.top = m.y * c + "px", d.style.width = m.width * h + "px", d.style.height = m.height * c + "px", d.title !== f.accessibleTitle && null !== f.accessibleTitle && (d.title = f.accessibleTitle), d.getAttribute("aria-label") !== f.accessibleHint && null !== f.accessibleHint && d.setAttribute("aria-label", f.accessibleHint)), f.accessibleTitle === d.title && f.tabIndex === d.tabIndex || (d.title = f.accessibleTitle, d.tabIndex = f.tabIndex, this.debug && this.updateDebugHTML(d))
                        }
                    }
                    this.renderId++
                }
            }, t.prototype.updateDebugHTML = function(t) {
                t.innerHTML = "type: " + t.type + "</br> title : " + t.title + "</br> tabIndex: " + t.tabIndex
            }, t.prototype.capHitArea = function(t) {
                t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0);
                var e = this.renderer,
                    n = e.width,
                    r = e.height;
                t.x + t.width > n && (t.width = n - t.x), t.y + t.height > r && (t.height = r - t.y)
            }, t.prototype.addChild = function(t) {
                var e = this.pool.pop();
                e || ((e = document.createElement("button")).style.width = "100px", e.style.height = "100px", e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", e.style.position = "absolute", e.style.zIndex = 2..toString(), e.style.borderStyle = "none", navigator.userAgent.toLowerCase().indexOf("chrome") > -1 ? e.setAttribute("aria-live", "off") : e.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute("aria-relevant", "additions") : e.setAttribute("aria-relevant", "text"), e.addEventListener("click", this._onClick.bind(this)), e.addEventListener("focus", this._onFocus.bind(this)), e.addEventListener("focusout", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && null !== t.accessibleTitle ? e.title = t.accessibleTitle : t.accessibleHint && null !== t.accessibleHint || (e.title = "displayObject " + t.tabIndex), t.accessibleHint && null !== t.accessibleHint && e.setAttribute("aria-label", t.accessibleHint), this.debug && this.updateDebugHTML(e), t._accessibleActive = !0, t._accessibleDiv = e, e.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex
            }, t.prototype._onClick = function(t) {
                var e = this.renderer.plugins.interaction,
                    n = t.target.displayObject,
                    r = e.eventData;
                e.dispatchEvent(n, "click", r), e.dispatchEvent(n, "pointertap", r), e.dispatchEvent(n, "tap", r)
            }, t.prototype._onFocus = function(t) {
                t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive");
                var e = this.renderer.plugins.interaction,
                    n = t.target.displayObject,
                    r = e.eventData;
                e.dispatchEvent(n, "mouseover", r)
            }, t.prototype._onFocusOut = function(t) {
                t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite");
                var e = this.renderer.plugins.interaction,
                    n = t.target.displayObject,
                    r = e.eventData;
                e.dispatchEvent(n, "mouseout", r)
            }, t.prototype._onKeyDown = function(t) {
                9 === t.keyCode && this.activate()
            }, t.prototype._onMouseMove = function(t) {
                0 === t.movementX && 0 === t.movementY || this.deactivate()
            }, t.prototype.destroy = function() {
                this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null
            }, t
        }();
        St.TARGET_FPMS = .06,
            function(t) {
                t[t.INTERACTION = 50] = "INTERACTION", t[t.HIGH = 25] = "HIGH", t[t.NORMAL = 0] = "NORMAL", t[t.LOW = -25] = "LOW", t[t.UTILITY = -50] = "UTILITY"
            }(Je || (Je = {}));
        var $e = function() {
                function t(t, e, n, r) {
                    void 0 === e && (e = null), void 0 === n && (n = 0), void 0 === r && (r = !1), this.next = null, this.previous = null, this._destroyed = !1, this.fn = t, this.context = e, this.priority = n, this.once = r
                }
                return t.prototype.match = function(t, e) {
                    return void 0 === e && (e = null), this.fn === t && this.context === e
                }, t.prototype.emit = function(t) {
                    this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));
                    var e = this.next;
                    return this.once && this.destroy(!0), this._destroyed && (this.next = null), e
                }, t.prototype.connect = function(t) {
                    this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this
                }, t.prototype.destroy = function(t) {
                    void 0 === t && (t = !1), this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
                    var e = this.next;
                    return this.next = t ? null : e, this.previous = null, e
                }, t
            }(),
            tn = function() {
                function t() {
                    var t = this;
                    this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new $e(null, null, 1 / 0), this.deltaMS = 1 / St.TARGET_FPMS, this.elapsedMS = 1 / St.TARGET_FPMS, this._tick = function(e) {
                        t._requestId = null, t.started && (t.update(e), t.started && null === t._requestId && t._head.next && (t._requestId = requestAnimationFrame(t._tick)))
                    }
                }
                return t.prototype._requestIfNeeded = function() {
                    null === this._requestId && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick))
                }, t.prototype._cancelIfNeeded = function() {
                    null !== this._requestId && (cancelAnimationFrame(this._requestId), this._requestId = null)
                }, t.prototype._startIfPossible = function() {
                    this.started ? this._requestIfNeeded() : this.autoStart && this.start()
                }, t.prototype.add = function(t, e, n) {
                    return void 0 === n && (n = Je.NORMAL), this._addListener(new $e(t, e, n))
                }, t.prototype.addOnce = function(t, e, n) {
                    return void 0 === n && (n = Je.NORMAL), this._addListener(new $e(t, e, n, !0))
                }, t.prototype._addListener = function(t) {
                    var e = this._head.next,
                        n = this._head;
                    if (e) {
                        for (; e;) {
                            if (t.priority > e.priority) {
                                t.connect(n);
                                break
                            }
                            n = e, e = e.next
                        }
                        t.previous || t.connect(n)
                    } else t.connect(n);
                    return this._startIfPossible(), this
                }, t.prototype.remove = function(t, e) {
                    for (var n = this._head.next; n;) n = n.match(t, e) ? n.destroy() : n.next;
                    return this._head.next || this._cancelIfNeeded(), this
                }, Object.defineProperty(t.prototype, "count", {
                    get: function() {
                        if (!this._head) return 0;
                        for (var t = 0, e = this._head; e = e.next;) t++;
                        return t
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.start = function() {
                    this.started || (this.started = !0, this._requestIfNeeded())
                }, t.prototype.stop = function() {
                    this.started && (this.started = !1, this._cancelIfNeeded())
                }, t.prototype.destroy = function() {
                    if (!this._protected) {
                        this.stop();
                        for (var t = this._head.next; t;) t = t.destroy(!0);
                        this._head.destroy(), this._head = null
                    }
                }, t.prototype.update = function(t) {
                    var e;
                    if (void 0 === t && (t = performance.now()), t > this.lastTime) {
                        if ((e = this.elapsedMS = t - this.lastTime) > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
                            var n = t - this._lastFrame | 0;
                            if (n < this._minElapsedMS) return;
                            this._lastFrame = t - n % this._minElapsedMS
                        }
                        this.deltaMS = e, this.deltaTime = this.deltaMS * St.TARGET_FPMS;
                        for (var r = this._head, i = r.next; i;) i = i.emit(this.deltaTime);
                        r.next || this._cancelIfNeeded()
                    } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
                    this.lastTime = t
                }, Object.defineProperty(t.prototype, "FPS", {
                    get: function() {
                        return 1e3 / this.elapsedMS
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "minFPS", {
                    get: function() {
                        return 1e3 / this._maxElapsedMS
                    },
                    set: function(t) {
                        var e = Math.min(this.maxFPS, t),
                            n = Math.min(Math.max(0, e) / 1e3, St.TARGET_FPMS);
                        this._maxElapsedMS = 1 / n
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "maxFPS", {
                    get: function() {
                        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
                    },
                    set: function(t) {
                        if (0 === t) this._minElapsedMS = 0;
                        else {
                            var e = Math.max(this.minFPS, t);
                            this._minElapsedMS = 1 / (e / 1e3)
                        }
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t, "shared", {
                    get: function() {
                        if (!t._shared) {
                            var e = t._shared = new t;
                            e.autoStart = !0, e._protected = !0
                        }
                        return t._shared
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t, "system", {
                    get: function() {
                        if (!t._system) {
                            var e = t._system = new t;
                            e.autoStart = !0, e._protected = !0
                        }
                        return t._system
                    },
                    enumerable: !1,
                    configurable: !0
                }), t
            }(),
            en = function() {
                function t() {}
                return t.init = function(t) {
                    var e = this;
                    t = Object.assign({
                        autoStart: !0,
                        sharedTicker: !1
                    }, t), Object.defineProperty(this, "ticker", {
                        set: function(t) {
                            this._ticker && this._ticker.remove(this.render, this), this._ticker = t, t && t.add(this.render, this, Je.LOW)
                        },
                        get: function() {
                            return this._ticker
                        }
                    }), this.stop = function() {
                        e._ticker.stop()
                    }, this.start = function() {
                        e._ticker.start()
                    }, this._ticker = null, this.ticker = t.sharedTicker ? tn.shared : new tn, t.autoStart && this.start()
                }, t.destroy = function() {
                    if (this._ticker) {
                        var t = this._ticker;
                        this.ticker = null, t.destroy()
                    }
                }, t
            }(),
            nn = function() {
                function t() {
                    this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new ae, this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = !1, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0
                }
                return Object.defineProperty(t.prototype, "pointerId", {
                    get: function() {
                        return this.identifier
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.getLocalPosition = function(t, e, n) {
                    return t.worldTransform.applyInverse(n || this.global, e)
                }, t.prototype.copyEvent = function(t) {
                    "isPrimary" in t && t.isPrimary && (this.isPrimary = !0), this.button = "button" in t && t.button;
                    var e = "buttons" in t && t.buttons;
                    this.buttons = Number.isInteger(e) ? e : "which" in t && t.which, this.width = "width" in t && t.width, this.height = "height" in t && t.height, this.tiltX = "tiltX" in t && t.tiltX, this.tiltY = "tiltY" in t && t.tiltY, this.pointerType = "pointerType" in t && t.pointerType, this.pressure = "pressure" in t && t.pressure, this.rotationAngle = "rotationAngle" in t && t.rotationAngle, this.twist = "twist" in t && t.twist || 0, this.tangentialPressure = "tangentialPressure" in t && t.tangentialPressure || 0
                }, t.prototype.reset = function() {
                    this.isPrimary = !1
                }, t
            }(),
            rn = function(t, e) {
                return (rn = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(t, e) {
                        t.__proto__ = e
                    } || function(t, e) {
                        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
                    })(t, e)
            },
            on = function() {
                function t() {
                    this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.target = null, this.currentTarget = null, this.type = null, this.data = null
                }
                return t.prototype.stopPropagation = function() {
                    this.stopped = !0, this.stopPropagationHint = !0, this.stopsPropagatingAt = this.currentTarget
                }, t.prototype.reset = function() {
                    this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.currentTarget = null, this.target = null
                }, t
            }(),
            sn = function() {
                function t(e) {
                    this._pointerId = e, this._flags = t.FLAGS.NONE
                }
                return t.prototype._doSet = function(t, e) {
                    this._flags = e ? this._flags | t : this._flags & ~t
                }, Object.defineProperty(t.prototype, "pointerId", {
                    get: function() {
                        return this._pointerId
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "flags", {
                    get: function() {
                        return this._flags
                    },
                    set: function(t) {
                        this._flags = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "none", {
                    get: function() {
                        return this._flags === t.FLAGS.NONE
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "over", {
                    get: function() {
                        return 0 != (this._flags & t.FLAGS.OVER)
                    },
                    set: function(e) {
                        this._doSet(t.FLAGS.OVER, e)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "rightDown", {
                    get: function() {
                        return 0 != (this._flags & t.FLAGS.RIGHT_DOWN)
                    },
                    set: function(e) {
                        this._doSet(t.FLAGS.RIGHT_DOWN, e)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "leftDown", {
                    get: function() {
                        return 0 != (this._flags & t.FLAGS.LEFT_DOWN)
                    },
                    set: function(e) {
                        this._doSet(t.FLAGS.LEFT_DOWN, e)
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.FLAGS = Object.freeze({
                    NONE: 0,
                    OVER: 1,
                    LEFT_DOWN: 2,
                    RIGHT_DOWN: 4
                }), t
            }(),
            an = function() {
                function t() {
                    this._tempPoint = new ae
                }
                return t.prototype.recursiveFindHit = function(t, e, n, r, i) {
                    if (!e || !e.visible) return !1;
                    var o = t.data.global,
                        s = !1,
                        a = i = e.interactive || i,
                        l = !0;
                    if (e.hitArea ? (r && (e.worldTransform.applyInverse(o, this._tempPoint), e.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? s = !0 : (r = !1, l = !1)), a = !1) : e._mask && r && (e._mask.containsPoint && e._mask.containsPoint(o) || (r = !1)), l && e.interactiveChildren && e.children)
                        for (var u = e.children, h = u.length - 1; h >= 0; h--) {
                            var c = u[h],
                                d = this.recursiveFindHit(t, c, n, r, a);
                            if (d) {
                                if (!c.parent) continue;
                                a = !1, d && (t.target && (r = !1), s = !0)
                            }
                        }
                    return i && (r && !t.target && !e.hitArea && e.containsPoint && e.containsPoint(o) && (s = !0), e.interactive && (s && !t.target && (t.target = e), n && n(t, e, !!s))), s
                }, t.prototype.findHit = function(t, e, n, r) {
                    this.recursiveFindHit(t, e, n, r, !1)
                }, t
            }(),
            ln = {
                interactive: !1,
                interactiveChildren: !0,
                hitArea: null,
                get buttonMode() {
                    return "pointer" === this.cursor
                },
                set buttonMode(t) {
                    t ? this.cursor = "pointer" : "pointer" === this.cursor && (this.cursor = null)
                },
                cursor: null,
                get trackedPointers() {
                    return void 0 === this._trackedPointers && (this._trackedPointers = {}), this._trackedPointers
                },
                _trackedPointers: void 0
            };
        Ye.mixin(ln);
        var un = {
                target: null,
                data: {
                    global: null
                }
            },
            hn = function(t) {
                function e(e, n) {
                    var r = t.call(this) || this;
                    return n = n || {}, r.renderer = e, r.autoPreventDefault = void 0 === n.autoPreventDefault || n.autoPreventDefault, r.interactionFrequency = n.interactionFrequency || 10, r.mouse = new nn, r.mouse.identifier = 1, r.mouse.global.set(-999999), r.activeInteractionData = {}, r.activeInteractionData[1] = r.mouse, r.interactionDataPool = [], r.eventData = new on, r.interactionDOMElement = null, r.moveWhenInside = !1, r.eventsAdded = !1, r.tickerAdded = !1, r.mouseOverRenderer = !("PointerEvent" in globalThis), r.supportsTouchEvents = "ontouchstart" in globalThis, r.supportsPointerEvents = !!globalThis.PointerEvent, r.onPointerUp = r.onPointerUp.bind(r), r.processPointerUp = r.processPointerUp.bind(r), r.onPointerCancel = r.onPointerCancel.bind(r), r.processPointerCancel = r.processPointerCancel.bind(r), r.onPointerDown = r.onPointerDown.bind(r), r.processPointerDown = r.processPointerDown.bind(r), r.onPointerMove = r.onPointerMove.bind(r), r.processPointerMove = r.processPointerMove.bind(r), r.onPointerOut = r.onPointerOut.bind(r), r.processPointerOverOut = r.processPointerOverOut.bind(r), r.onPointerOver = r.onPointerOver.bind(r), r.cursorStyles = {
                        default: "inherit",
                        pointer: "pointer"
                    }, r.currentCursorMode = null, r.cursor = null, r.resolution = 1, r.delayedEvents = [], r.search = new an, r._tempDisplayObject = new qe, r._eventListenerOptions = {
                        capture: !0,
                        passive: !1
                    }, r._useSystemTicker = void 0 === n.useSystemTicker || n.useSystemTicker, r.setTargetElement(r.renderer.view, r.renderer.resolution), r
                }
                return function(t, e) {
                    function n() {
                        this.constructor = t
                    }
                    rn(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
                }(e, t), Object.defineProperty(e.prototype, "useSystemTicker", {
                    get: function() {
                        return this._useSystemTicker
                    },
                    set: function(t) {
                        this._useSystemTicker = t, t ? this.addTickerListener() : this.removeTickerListener()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "lastObjectRendered", {
                    get: function() {
                        return this.renderer._lastObjectRendered || this._tempDisplayObject
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype.hitTest = function(t, e) {
                    return un.target = null, un.data.global = t, e || (e = this.lastObjectRendered), this.processInteractive(un, e, null, !0), un.target
                }, e.prototype.setTargetElement = function(t, e) {
                    void 0 === e && (e = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = t, this.resolution = e, this.addEvents(), this.addTickerListener()
                }, e.prototype.addTickerListener = function() {
                    !this.tickerAdded && this.interactionDOMElement && this._useSystemTicker && (tn.system.add(this.tickerUpdate, this, Je.INTERACTION), this.tickerAdded = !0)
                }, e.prototype.removeTickerListener = function() {
                    this.tickerAdded && (tn.system.remove(this.tickerUpdate, this), this.tickerAdded = !1)
                }, e.prototype.addEvents = function() {
                    if (!this.eventsAdded && this.interactionDOMElement) {
                        var t = this.interactionDOMElement.style;
                        globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "none", t.msTouchAction = "none") : this.supportsPointerEvents && (t.touchAction = "none"), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.addEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.eventsAdded = !0
                    }
                }, e.prototype.removeEvents = function() {
                    if (this.eventsAdded && this.interactionDOMElement) {
                        var t = this.interactionDOMElement.style;
                        globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "", t.msTouchAction = "") : this.supportsPointerEvents && (t.touchAction = ""), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.removeEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.interactionDOMElement = null, this.eventsAdded = !1
                    }
                }, e.prototype.tickerUpdate = function(t) {
                    this._deltaTime += t, this._deltaTime < this.interactionFrequency || (this._deltaTime = 0, this.update())
                }, e.prototype.update = function() {
                    if (this.interactionDOMElement)
                        if (this._didMove) this._didMove = !1;
                        else {
                            for (var t in this.cursor = null, this.activeInteractionData)
                                if (this.activeInteractionData.hasOwnProperty(t)) {
                                    var e = this.activeInteractionData[t];
                                    if (e.originalEvent && "touch" !== e.pointerType) {
                                        var n = this.configureInteractionEventForDOMEvent(this.eventData, e.originalEvent, e);
                                        this.processInteractive(n, this.lastObjectRendered, this.processPointerOverOut, !0)
                                    }
                                } this.setCursorMode(this.cursor)
                        }
                }, e.prototype.setCursorMode = function(t) {
                    t = t || "default";
                    var e = !0;
                    if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas && (e = !1), this.currentCursorMode !== t) {
                        this.currentCursorMode = t;
                        var n = this.cursorStyles[t];
                        if (n) switch (typeof n) {
                            case "string":
                                e && (this.interactionDOMElement.style.cursor = n);
                                break;
                            case "function":
                                n(t);
                                break;
                            case "object":
                                e && Object.assign(this.interactionDOMElement.style, n)
                        } else e && "string" == typeof t && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t) && (this.interactionDOMElement.style.cursor = t)
                    }
                }, e.prototype.dispatchEvent = function(t, e, n) {
                    n.stopPropagationHint && t !== n.stopsPropagatingAt || (n.currentTarget = t, n.type = e, t.emit(e, n), t[e] && t[e](n))
                }, e.prototype.delayDispatchEvent = function(t, e, n) {
                    this.delayedEvents.push({
                        displayObject: t,
                        eventString: e,
                        eventData: n
                    })
                }, e.prototype.mapPositionToPoint = function(t, e, n) {
                    var r;
                    r = this.interactionDOMElement.parentElement ? this.interactionDOMElement.getBoundingClientRect() : {
                        x: 0,
                        y: 0,
                        width: this.interactionDOMElement.width,
                        height: this.interactionDOMElement.height,
                        left: 0,
                        top: 0
                    };
                    var i = 1 / this.resolution;
                    t.x = (e - r.left) * (this.interactionDOMElement.width / r.width) * i, t.y = (n - r.top) * (this.interactionDOMElement.height / r.height) * i
                }, e.prototype.processInteractive = function(t, e, n, r) {
                    var i = this.search.findHit(t, e, n, r),
                        o = this.delayedEvents;
                    if (!o.length) return i;
                    t.stopPropagationHint = !1;
                    var s = o.length;
                    this.delayedEvents = [];
                    for (var a = 0; a < s; a++) {
                        var l = o[a],
                            u = l.displayObject,
                            h = l.eventString,
                            c = l.eventData;
                        c.stopsPropagatingAt === u && (c.stopPropagationHint = !0), this.dispatchEvent(u, h, c)
                    }
                    return i
                }, e.prototype.onPointerDown = function(t) {
                    if (!this.supportsTouchEvents || "touch" !== t.pointerType) {
                        var e = this.normalizeToPointerData(t);
                        this.autoPreventDefault && e[0].isNormalized && (t.cancelable || !("cancelable" in t)) && t.preventDefault();
                        for (var n = e.length, r = 0; r < n; r++) {
                            var i = e[r],
                                o = this.getInteractionDataForPointerId(i),
                                s = this.configureInteractionEventForDOMEvent(this.eventData, i, o);
                            if (s.data.originalEvent = t, this.processInteractive(s, this.lastObjectRendered, this.processPointerDown, !0), this.emit("pointerdown", s), "touch" === i.pointerType) this.emit("touchstart", s);
                            else if ("mouse" === i.pointerType || "pen" === i.pointerType) {
                                var a = 2 === i.button;
                                this.emit(a ? "rightdown" : "mousedown", this.eventData)
                            }
                        }
                    }
                }, e.prototype.processPointerDown = function(t, e, n) {
                    var r = t.data,
                        i = t.data.identifier;
                    if (n)
                        if (e.trackedPointers[i] || (e.trackedPointers[i] = new sn(i)), this.dispatchEvent(e, "pointerdown", t), "touch" === r.pointerType) this.dispatchEvent(e, "touchstart", t);
                        else if ("mouse" === r.pointerType || "pen" === r.pointerType) {
                        var o = 2 === r.button;
                        o ? e.trackedPointers[i].rightDown = !0 : e.trackedPointers[i].leftDown = !0, this.dispatchEvent(e, o ? "rightdown" : "mousedown", t)
                    }
                }, e.prototype.onPointerComplete = function(t, e, n) {
                    for (var r = this.normalizeToPointerData(t), i = r.length, o = t.target !== this.interactionDOMElement ? "outside" : "", s = 0; s < i; s++) {
                        var a = r[s],
                            l = this.getInteractionDataForPointerId(a),
                            u = this.configureInteractionEventForDOMEvent(this.eventData, a, l);
                        if (u.data.originalEvent = t, this.processInteractive(u, this.lastObjectRendered, n, e || !o), this.emit(e ? "pointercancel" : "pointerup" + o, u), "mouse" === a.pointerType || "pen" === a.pointerType) {
                            var h = 2 === a.button;
                            this.emit(h ? "rightup" + o : "mouseup" + o, u)
                        } else "touch" === a.pointerType && (this.emit(e ? "touchcancel" : "touchend" + o, u), this.releaseInteractionDataForPointerId(a.pointerId))
                    }
                }, e.prototype.onPointerCancel = function(t) {
                    this.supportsTouchEvents && "touch" === t.pointerType || this.onPointerComplete(t, !0, this.processPointerCancel)
                }, e.prototype.processPointerCancel = function(t, e) {
                    var n = t.data,
                        r = t.data.identifier;
                    void 0 !== e.trackedPointers[r] && (delete e.trackedPointers[r], this.dispatchEvent(e, "pointercancel", t), "touch" === n.pointerType && this.dispatchEvent(e, "touchcancel", t))
                }, e.prototype.onPointerUp = function(t) {
                    this.supportsTouchEvents && "touch" === t.pointerType || this.onPointerComplete(t, !1, this.processPointerUp)
                }, e.prototype.processPointerUp = function(t, e, n) {
                    var r = t.data,
                        i = t.data.identifier,
                        o = e.trackedPointers[i],
                        s = "touch" === r.pointerType,
                        a = "mouse" === r.pointerType || "pen" === r.pointerType,
                        l = !1;
                    if (a) {
                        var u = 2 === r.button,
                            h = sn.FLAGS,
                            c = u ? h.RIGHT_DOWN : h.LEFT_DOWN,
                            d = void 0 !== o && o.flags & c;
                        n ? (this.dispatchEvent(e, u ? "rightup" : "mouseup", t), d && (this.dispatchEvent(e, u ? "rightclick" : "click", t), l = !0)) : d && this.dispatchEvent(e, u ? "rightupoutside" : "mouseupoutside", t), o && (u ? o.rightDown = !1 : o.leftDown = !1)
                    }
                    n ? (this.dispatchEvent(e, "pointerup", t), s && this.dispatchEvent(e, "touchend", t), o && (a && !l || this.dispatchEvent(e, "pointertap", t), s && (this.dispatchEvent(e, "tap", t), o.over = !1))) : o && (this.dispatchEvent(e, "pointerupoutside", t), s && this.dispatchEvent(e, "touchendoutside", t)), o && o.none && delete e.trackedPointers[i]
                }, e.prototype.onPointerMove = function(t) {
                    if (!this.supportsTouchEvents || "touch" !== t.pointerType) {
                        var e = this.normalizeToPointerData(t);
                        "mouse" !== e[0].pointerType && "pen" !== e[0].pointerType || (this._didMove = !0, this.cursor = null);
                        for (var n = e.length, r = 0; r < n; r++) {
                            var i = e[r],
                                o = this.getInteractionDataForPointerId(i),
                                s = this.configureInteractionEventForDOMEvent(this.eventData, i, o);
                            s.data.originalEvent = t, this.processInteractive(s, this.lastObjectRendered, this.processPointerMove, !0), this.emit("pointermove", s), "touch" === i.pointerType && this.emit("touchmove", s), "mouse" !== i.pointerType && "pen" !== i.pointerType || this.emit("mousemove", s)
                        }
                        "mouse" === e[0].pointerType && this.setCursorMode(this.cursor)
                    }
                }, e.prototype.processPointerMove = function(t, e, n) {
                    var r = t.data,
                        i = "touch" === r.pointerType,
                        o = "mouse" === r.pointerType || "pen" === r.pointerType;
                    o && this.processPointerOverOut(t, e, n), this.moveWhenInside && !n || (this.dispatchEvent(e, "pointermove", t), i && this.dispatchEvent(e, "touchmove", t), o && this.dispatchEvent(e, "mousemove", t))
                }, e.prototype.onPointerOut = function(t) {
                    if (!this.supportsTouchEvents || "touch" !== t.pointerType) {
                        var e = this.normalizeToPointerData(t)[0];
                        "mouse" === e.pointerType && (this.mouseOverRenderer = !1, this.setCursorMode(null));
                        var n = this.getInteractionDataForPointerId(e),
                            r = this.configureInteractionEventForDOMEvent(this.eventData, e, n);
                        r.data.originalEvent = e, this.processInteractive(r, this.lastObjectRendered, this.processPointerOverOut, !1), this.emit("pointerout", r), "mouse" === e.pointerType || "pen" === e.pointerType ? this.emit("mouseout", r) : this.releaseInteractionDataForPointerId(n.identifier)
                    }
                }, e.prototype.processPointerOverOut = function(t, e, n) {
                    var r = t.data,
                        i = t.data.identifier,
                        o = "mouse" === r.pointerType || "pen" === r.pointerType,
                        s = e.trackedPointers[i];
                    n && !s && (s = e.trackedPointers[i] = new sn(i)), void 0 !== s && (n && this.mouseOverRenderer ? (s.over || (s.over = !0, this.delayDispatchEvent(e, "pointerover", t), o && this.delayDispatchEvent(e, "mouseover", t)), o && null === this.cursor && (this.cursor = e.cursor)) : s.over && (s.over = !1, this.dispatchEvent(e, "pointerout", this.eventData), o && this.dispatchEvent(e, "mouseout", t), s.none && delete e.trackedPointers[i]))
                }, e.prototype.onPointerOver = function(t) {
                    var e = this.normalizeToPointerData(t)[0],
                        n = this.getInteractionDataForPointerId(e),
                        r = this.configureInteractionEventForDOMEvent(this.eventData, e, n);
                    r.data.originalEvent = e, "mouse" === e.pointerType && (this.mouseOverRenderer = !0), this.emit("pointerover", r), "mouse" !== e.pointerType && "pen" !== e.pointerType || this.emit("mouseover", r)
                }, e.prototype.getInteractionDataForPointerId = function(t) {
                    var e, n = t.pointerId;
                    return 1 === n || "mouse" === t.pointerType ? e = this.mouse : this.activeInteractionData[n] ? e = this.activeInteractionData[n] : ((e = this.interactionDataPool.pop() || new nn).identifier = n, this.activeInteractionData[n] = e), e.copyEvent(t), e
                }, e.prototype.releaseInteractionDataForPointerId = function(t) {
                    var e = this.activeInteractionData[t];
                    e && (delete this.activeInteractionData[t], e.reset(), this.interactionDataPool.push(e))
                }, e.prototype.configureInteractionEventForDOMEvent = function(t, e, n) {
                    return t.data = n, this.mapPositionToPoint(n.global, e.clientX, e.clientY), "touch" === e.pointerType && (e.globalX = n.global.x, e.globalY = n.global.y), n.originalEvent = e, t.reset(), t
                }, e.prototype.normalizeToPointerData = function(t) {
                    var e = [];
                    if (this.supportsTouchEvents && t instanceof TouchEvent)
                        for (var n = 0, r = t.changedTouches.length; n < r; n++) {
                            var i = t.changedTouches[n];
                            void 0 === i.button && (i.button = t.touches.length ? 1 : 0), void 0 === i.buttons && (i.buttons = t.touches.length ? 1 : 0), void 0 === i.isPrimary && (i.isPrimary = 1 === t.touches.length && "touchstart" === t.type), void 0 === i.width && (i.width = i.radiusX || 1), void 0 === i.height && (i.height = i.radiusY || 1), void 0 === i.tiltX && (i.tiltX = 0), void 0 === i.tiltY && (i.tiltY = 0), void 0 === i.pointerType && (i.pointerType = "touch"), void 0 === i.pointerId && (i.pointerId = i.identifier || 0), void 0 === i.pressure && (i.pressure = i.force || .5), void 0 === i.twist && (i.twist = 0), void 0 === i.tangentialPressure && (i.tangentialPressure = 0), void 0 === i.layerX && (i.layerX = i.offsetX = i.clientX), void 0 === i.layerY && (i.layerY = i.offsetY = i.clientY), i.isNormalized = !0, e.push(i)
                        } else if (!globalThis.MouseEvent || t instanceof MouseEvent && !(this.supportsPointerEvents && t instanceof globalThis.PointerEvent)) {
                            var o = t;
                            void 0 === o.isPrimary && (o.isPrimary = !0), void 0 === o.width && (o.width = 1), void 0 === o.height && (o.height = 1), void 0 === o.tiltX && (o.tiltX = 0), void 0 === o.tiltY && (o.tiltY = 0), void 0 === o.pointerType && (o.pointerType = "mouse"), void 0 === o.pointerId && (o.pointerId = 1), void 0 === o.pressure && (o.pressure = .5), void 0 === o.twist && (o.twist = 0), void 0 === o.tangentialPressure && (o.tangentialPressure = 0), o.isNormalized = !0, e.push(o)
                        } else e.push(t);
                    return e
                }, e.prototype.destroy = function() {
                    this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null
                }, e
            }(Mt()),
            cn = function() {
                function t(t) {
                    this.items = [], this._name = t, this._aliasCount = 0
                }
                return t.prototype.emit = function(t, e, n, r, i, o, s, a) {
                    if (arguments.length > 8) throw new Error("max arguments reached");
                    var l = this,
                        u = l.name,
                        h = l.items;
                    this._aliasCount++;
                    for (var c = 0, d = h.length; c < d; c++) h[c][u](t, e, n, r, i, o, s, a);
                    return h === this.items && this._aliasCount--, this
                }, t.prototype.ensureNonAliasedItems = function() {
                    this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0))
                }, t.prototype.add = function(t) {
                    return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this
                }, t.prototype.remove = function(t) {
                    var e = this.items.indexOf(t);
                    return -1 !== e && (this.ensureNonAliasedItems(), this.items.splice(e, 1)), this
                }, t.prototype.contains = function(t) {
                    return -1 !== this.items.indexOf(t)
                }, t.prototype.removeAll = function() {
                    return this.ensureNonAliasedItems(), this.items.length = 0, this
                }, t.prototype.destroy = function() {
                    this.removeAll(), this.items = null, this._name = null
                }, Object.defineProperty(t.prototype, "empty", {
                    get: function() {
                        return 0 === this.items.length
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "name", {
                    get: function() {
                        return this._name
                    },
                    enumerable: !1,
                    configurable: !0
                }), t
            }();
        Object.defineProperties(cn.prototype, {
            dispatch: {
                value: cn.prototype.emit
            },
            run: {
                value: cn.prototype.emit
            }
        }), St.PREFER_ENV = it.any ? ot.WEBGL : ot.WEBGL2, St.STRICT_TEXTURE_CACHE = !1;
        var dn = [];

        function pn(t, e) {
            if (!t) return null;
            var n = "";
            if ("string" == typeof t) {
                var r = /\.(\w{3,4})(?:$|\?|#)/i.exec(t);
                r && (n = r[1].toLowerCase())
            }
            for (var i = dn.length - 1; i >= 0; --i) {
                var o = dn[i];
                if (o.test && o.test(t, n)) return new o(t, e)
            }
            throw new Error("Unrecognized source type to auto-detect Resource")
        }
        var fn = function(t, e) {
            return (fn = Object.setPrototypeOf || {
                    __proto__: []
                }
                instanceof Array && function(t, e) {
                    t.__proto__ = e
                } || function(t, e) {
                    for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
                })(t, e)
        };

        function mn(t, e) {
            function n() {
                this.constructor = t
            }
            fn(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
        }
        var gn = function() {
                return (gn = Object.assign || function(t) {
                    for (var e, n = arguments, r = 1, i = arguments.length; r < i; r++)
                        for (var o in e = n[r]) Object.prototype.hasOwnProperty.call(e, o) && (t[o] = e[o]);
                    return t
                }).apply(this, arguments)
            },
            vn = function() {
                function t(t, e) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), this._width = t, this._height = e, this.destroyed = !1, this.internal = !1, this.onResize = new cn("setRealSize"), this.onUpdate = new cn("update"), this.onError = new cn("onError")
                }
                return t.prototype.bind = function(t) {
                    this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height)
                }, t.prototype.unbind = function(t) {
                    this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t)
                }, t.prototype.resize = function(t, e) {
                    t === this._width && e === this._height || (this._width = t, this._height = e, this.onResize.emit(t, e))
                }, Object.defineProperty(t.prototype, "valid", {
                    get: function() {
                        return !!this._width && !!this._height
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.update = function() {
                    this.destroyed || this.onUpdate.emit()
                }, t.prototype.load = function() {
                    return Promise.resolve(this)
                }, Object.defineProperty(t.prototype, "width", {
                    get: function() {
                        return this._width
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "height", {
                    get: function() {
                        return this._height
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.style = function(t, e, n) {
                    return !1
                }, t.prototype.dispose = function() {}, t.prototype.destroy = function() {
                    this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null)
                }, t.test = function(t, e) {
                    return !1
                }, t
            }(),
            _n = function(t) {
                function e(e, n) {
                    var r = this,
                        i = n || {},
                        o = i.width,
                        s = i.height;
                    if (!o || !s) throw new Error("BufferResource width or height invalid");
                    return (r = t.call(this, o, s) || this).data = e, r
                }
                return mn(e, t), e.prototype.upload = function(t, e, n) {
                    var r = t.gl;
                    r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === vt.UNPACK);
                    var i = e.realWidth,
                        o = e.realHeight;
                    return n.width === i && n.height === o ? r.texSubImage2D(e.target, 0, 0, 0, i, o, e.format, n.type, this.data) : (n.width = i, n.height = o, r.texImage2D(e.target, 0, n.internalFormat, i, o, 0, e.format, n.type, this.data)), !0
                }, e.prototype.dispose = function() {
                    this.data = null
                }, e.test = function(t) {
                    return t instanceof Float32Array || t instanceof Uint8Array || t instanceof Uint32Array
                }, e
            }(vn),
            yn = {
                scaleMode: ft.NEAREST,
                format: ht.RGBA,
                alphaMode: vt.NPM
            },
            xn = function(t) {
                function e(e, n) {
                    void 0 === e && (e = null), void 0 === n && (n = null);
                    var r = t.call(this) || this,
                        i = (n = n || {}).alphaMode,
                        o = n.mipmap,
                        s = n.anisotropicLevel,
                        a = n.scaleMode,
                        l = n.width,
                        u = n.height,
                        h = n.wrapMode,
                        c = n.format,
                        d = n.type,
                        p = n.target,
                        f = n.resolution,
                        m = n.resourceOptions;
                    return !e || e instanceof vn || ((e = pn(e, m)).internal = !0), r.resolution = f || St.RESOLUTION, r.width = Math.round((l || 0) * r.resolution) / r.resolution, r.height = Math.round((u || 0) * r.resolution) / r.resolution, r._mipmap = void 0 !== o ? o : St.MIPMAP_TEXTURES, r.anisotropicLevel = void 0 !== s ? s : St.ANISOTROPIC_LEVEL, r._wrapMode = h || St.WRAP_MODE, r._scaleMode = void 0 !== a ? a : St.SCALE_MODE, r.format = c || ht.RGBA, r.type = d || dt.UNSIGNED_BYTE, r.target = p || ct.TEXTURE_2D, r.alphaMode = void 0 !== i ? i : vt.UNPACK, r.uid = qt(), r.touched = 0, r.isPowerOfTwo = !1, r._refreshPOT(), r._glTextures = {}, r.dirtyId = 0, r.dirtyStyleId = 0, r.cacheId = null, r.valid = l > 0 && u > 0, r.textureCacheIds = [], r.destroyed = !1, r.resource = null, r._batchEnabled = 0, r._batchLocation = 0, r.parentTextureArray = null, r.setResource(e), r
                }
                return mn(e, t), Object.defineProperty(e.prototype, "realWidth", {
                    get: function() {
                        return Math.round(this.width * this.resolution)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "realHeight", {
                    get: function() {
                        return Math.round(this.height * this.resolution)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "mipmap", {
                    get: function() {
                        return this._mipmap
                    },
                    set: function(t) {
                        this._mipmap !== t && (this._mipmap = t, this.dirtyStyleId++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "scaleMode", {
                    get: function() {
                        return this._scaleMode
                    },
                    set: function(t) {
                        this._scaleMode !== t && (this._scaleMode = t, this.dirtyStyleId++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "wrapMode", {
                    get: function() {
                        return this._wrapMode
                    },
                    set: function(t) {
                        this._wrapMode !== t && (this._wrapMode = t, this.dirtyStyleId++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype.setStyle = function(t, e) {
                    var n;
                    return void 0 !== t && t !== this.scaleMode && (this.scaleMode = t, n = !0), void 0 !== e && e !== this.mipmap && (this.mipmap = e, n = !0), n && this.dirtyStyleId++, this
                }, e.prototype.setSize = function(t, e, n) {
                    return n = n || this.resolution, this.setRealSize(t * n, e * n, n)
                }, e.prototype.setRealSize = function(t, e, n) {
                    return this.resolution = n || this.resolution, this.width = Math.round(t) / this.resolution, this.height = Math.round(e) / this.resolution, this._refreshPOT(), this.update(), this
                }, e.prototype._refreshPOT = function() {
                    this.isPowerOfTwo = Vt(this.realWidth) && Vt(this.realHeight)
                }, e.prototype.setResolution = function(t) {
                    var e = this.resolution;
                    return e === t || (this.resolution = t, this.valid && (this.width = Math.round(this.width * e) / t, this.height = Math.round(this.height * e) / t, this.emit("update", this)), this._refreshPOT()), this
                }, e.prototype.setResource = function(t) {
                    if (this.resource === t) return this;
                    if (this.resource) throw new Error("Resource can be set only once");
                    return t.bind(this), this.resource = t, this
                }, e.prototype.update = function() {
                    this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit("loaded", this), this.emit("update", this))
                }, e.prototype.onError = function(t) {
                    this.emit("error", this, t)
                }, e.prototype.destroy = function() {
                    this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete te[this.cacheId], delete $t[this.cacheId], this.cacheId = null), this.dispose(), e.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0
                }, e.prototype.dispose = function() {
                    this.emit("dispose", this)
                }, e.prototype.castToBaseTexture = function() {
                    return this
                }, e.from = function(t, n, r) {
                    void 0 === r && (r = St.STRICT_TEXTURE_CACHE);
                    var i = "string" == typeof t,
                        o = null;
                    if (i) o = t;
                    else {
                        if (!t._pixiId) {
                            var s = n && n.pixiIdPrefix || "pixiid";
                            t._pixiId = s + "_" + qt()
                        }
                        o = t._pixiId
                    }
                    var a = te[o];
                    if (i && r && !a) throw new Error('The cacheId "' + o + '" does not exist in BaseTextureCache.');
                    return a || ((a = new e(t, n)).cacheId = o, e.addToCache(a, o)), a
                }, e.fromBuffer = function(t, n, r, i) {
                    t = t || new Float32Array(n * r * 4);
                    var o = new _n(t, {
                            width: n,
                            height: r
                        }),
                        s = t instanceof Float32Array ? dt.FLOAT : dt.UNSIGNED_BYTE;
                    return new e(o, Object.assign(yn, i || {
                        width: n,
                        height: r,
                        type: s
                    }))
                }, e.addToCache = function(t, e) {
                    e && (-1 === t.textureCacheIds.indexOf(e) && t.textureCacheIds.push(e), te[e] && console.warn("BaseTexture added to the cache with an id [" + e + "] that already had an entry"), te[e] = t)
                }, e.removeFromCache = function(t) {
                    if ("string" == typeof t) {
                        var e = te[t];
                        if (e) {
                            var n = e.textureCacheIds.indexOf(t);
                            return n > -1 && e.textureCacheIds.splice(n, 1), delete te[t], e
                        }
                    } else if (t && t.textureCacheIds) {
                        for (var r = 0; r < t.textureCacheIds.length; ++r) delete te[t.textureCacheIds[r]];
                        return t.textureCacheIds.length = 0, t
                    }
                    return null
                }, e._globalBatch = 0, e
            }(Mt()),
            bn = function(t) {
                function e(e, n) {
                    var r = this,
                        i = n || {},
                        o = i.width,
                        s = i.height;
                    (r = t.call(this, o, s) || this).items = [], r.itemDirtyIds = [];
                    for (var a = 0; a < e; a++) {
                        var l = new xn;
                        r.items.push(l), r.itemDirtyIds.push(-2)
                    }
                    return r.length = e, r._load = null, r.baseTexture = null, r
                }
                return mn(e, t), e.prototype.initFromArray = function(t, e) {
                    for (var n = 0; n < this.length; n++) t[n] && (t[n].castToBaseTexture ? this.addBaseTextureAt(t[n].castToBaseTexture(), n) : t[n] instanceof vn ? this.addResourceAt(t[n], n) : this.addResourceAt(pn(t[n], e), n))
                }, e.prototype.dispose = function() {
                    for (var t = 0, e = this.length; t < e; t++) this.items[t].destroy();
                    this.items = null, this.itemDirtyIds = null, this._load = null
                }, e.prototype.addResourceAt = function(t, e) {
                    if (!this.items[e]) throw new Error("Index " + e + " is out of bounds");
                    return t.valid && !this.valid && this.resize(t.width, t.height), this.items[e].setResource(t), this
                }, e.prototype.bind = function(e) {
                    if (null !== this.baseTexture) throw new Error("Only one base texture per TextureArray is allowed");
                    t.prototype.bind.call(this, e);
                    for (var n = 0; n < this.length; n++) this.items[n].parentTextureArray = e, this.items[n].on("update", e.update, e)
                }, e.prototype.unbind = function(e) {
                    t.prototype.unbind.call(this, e);
                    for (var n = 0; n < this.length; n++) this.items[n].parentTextureArray = null, this.items[n].off("update", e.update, e)
                }, e.prototype.load = function() {
                    var t = this;
                    if (this._load) return this._load;
                    var e = this.items.map((function(t) {
                        return t.resource
                    })).filter((function(t) {
                        return t
                    })).map((function(t) {
                        return t.load()
                    }));
                    return this._load = Promise.all(e).then((function() {
                        var e = t.items[0],
                            n = e.realWidth,
                            r = e.realHeight;
                        return t.resize(n, r), Promise.resolve(t)
                    })), this._load
                }, e
            }(vn),
            En = function(t) {
                function e(e, n) {
                    var r, i, o = this,
                        s = n || {},
                        a = s.width,
                        l = s.height;
                    return Array.isArray(e) ? (r = e, i = e.length) : i = e, o = t.call(this, i, {
                        width: a,
                        height: l
                    }) || this, r && o.initFromArray(r, n), o
                }
                return mn(e, t), e.prototype.addBaseTextureAt = function(t, e) {
                    if (!t.resource) throw new Error("ArrayResource does not support RenderTexture");
                    return this.addResourceAt(t.resource, e), this
                }, e.prototype.bind = function(e) {
                    t.prototype.bind.call(this, e), e.target = ct.TEXTURE_2D_ARRAY
                }, e.prototype.upload = function(t, e, n) {
                    var r = this,
                        i = r.length,
                        o = r.itemDirtyIds,
                        s = r.items,
                        a = t.gl;
                    n.dirtyId < 0 && a.texImage3D(a.TEXTURE_2D_ARRAY, 0, n.internalFormat, this._width, this._height, i, 0, e.format, n.type, null);
                    for (var l = 0; l < i; l++) {
                        var u = s[l];
                        o[l] < u.dirtyId && (o[l] = u.dirtyId, u.valid && a.texSubImage3D(a.TEXTURE_2D_ARRAY, 0, 0, 0, l, u.resource.width, u.resource.height, 1, e.format, n.type, u.resource.source))
                    }
                    return !0
                }, e
            }(bn),
            Tn = function(t) {
                function e(e) {
                    var n = this,
                        r = e,
                        i = r.naturalWidth || r.videoWidth || r.width,
                        o = r.naturalHeight || r.videoHeight || r.height;
                    return (n = t.call(this, i, o) || this).source = e, n.noSubImage = !1, n
                }
                return mn(e, t), e.crossOrigin = function(t, e, n) {
                    void 0 === n && 0 !== e.indexOf("data:") ? t.crossOrigin = function(t, e) {
                        if (void 0 === e && (e = globalThis.location), 0 === t.indexOf("data:")) return "";
                        e = e || globalThis.location, Jt || (Jt = document.createElement("a")), Jt.href = t;
                        var n = It.parse(Jt.href),
                            r = !n.port && "" === e.port || n.port === e.port;
                        return n.hostname === e.hostname && r && n.protocol === e.protocol ? "" : "anonymous"
                    }(e) : !1 !== n && (t.crossOrigin = "string" == typeof n ? n : "anonymous")
                }, e.prototype.upload = function(t, e, n, r) {
                    var i = t.gl,
                        o = e.realWidth,
                        s = e.realHeight;
                    if ((r = r || this.source) instanceof HTMLImageElement) {
                        if (!r.complete || 0 === r.naturalWidth) return !1
                    } else if (r instanceof HTMLVideoElement && r.readyState <= 1) return !1;
                    return i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === vt.UNPACK), this.noSubImage || e.target !== i.TEXTURE_2D || n.width !== o || n.height !== s ? (n.width = o, n.height = s, i.texImage2D(e.target, 0, n.internalFormat, e.format, n.type, r)) : i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, e.format, n.type, r), !0
                }, e.prototype.update = function() {
                    if (!this.destroyed) {
                        var e = this.source,
                            n = e.naturalWidth || e.videoWidth || e.width,
                            r = e.naturalHeight || e.videoHeight || e.height;
                        this.resize(n, r), t.prototype.update.call(this)
                    }
                }, e.prototype.dispose = function() {
                    this.source = null
                }, e
            }(vn),
            Sn = function(t) {
                function e(e) {
                    return t.call(this, e) || this
                }
                return mn(e, t), e.test = function(t) {
                    var e = globalThis.OffscreenCanvas;
                    return !!(e && t instanceof e) || globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement
                }, e
            }(Tn),
            wn = function(t) {
                function e(n, r) {
                    var i = this,
                        o = r || {},
                        s = o.width,
                        a = o.height,
                        l = o.autoLoad,
                        u = o.linkBaseTexture;
                    if (n && n.length !== e.SIDES) throw new Error("Invalid length. Got " + n.length + ", expected 6");
                    i = t.call(this, 6, {
                        width: s,
                        height: a
                    }) || this;
                    for (var h = 0; h < e.SIDES; h++) i.items[h].target = ct.TEXTURE_CUBE_MAP_POSITIVE_X + h;
                    return i.linkBaseTexture = !1 !== u, n && i.initFromArray(n, r), !1 !== l && i.load(), i
                }
                return mn(e, t), e.prototype.bind = function(e) {
                    t.prototype.bind.call(this, e), e.target = ct.TEXTURE_CUBE_MAP
                }, e.prototype.addBaseTextureAt = function(t, e, n) {
                    if (void 0 === n && (n = this.linkBaseTexture), !this.items[e]) throw new Error("Index " + e + " is out of bounds");
                    if (!this.linkBaseTexture || t.parentTextureArray || Object.keys(t._glTextures).length > 0) {
                        if (!t.resource) throw new Error("CubeResource does not support copying of renderTexture.");
                        this.addResourceAt(t.resource, e)
                    } else t.target = ct.TEXTURE_CUBE_MAP_POSITIVE_X + e, t.parentTextureArray = this.baseTexture, this.items[e] = t;
                    return t.valid && !this.valid && this.resize(t.realWidth, t.realHeight), this.items[e] = t, this
                }, e.prototype.upload = function(t, n, r) {
                    for (var i = this.itemDirtyIds, o = 0; o < e.SIDES; o++) {
                        var s = this.items[o];
                        i[o] < s.dirtyId && (s.valid && s.resource ? (s.resource.upload(t, s, r), i[o] = s.dirtyId) : i[o] < -1 && (t.gl.texImage2D(s.target, 0, r.internalFormat, n.realWidth, n.realHeight, 0, n.format, r.type, null), i[o] = -1))
                    }
                    return !0
                }, e.test = function(t) {
                    return Array.isArray(t) && t.length === e.SIDES
                }, e.SIDES = 6, e
            }(bn),
            Mn = function(t) {
                function e(e, n) {
                    var r = this;
                    if (n = n || {}, !(e instanceof HTMLImageElement)) {
                        var i = new Image;
                        Tn.crossOrigin(i, e, n.crossorigin), i.src = e, e = i
                    }
                    return r = t.call(this, e) || this, !e.complete && r._width && r._height && (r._width = 0, r._height = 0), r.url = e.src, r._process = null, r.preserveBitmap = !1, r.createBitmap = (void 0 !== n.createBitmap ? n.createBitmap : St.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, r.alphaMode = "number" == typeof n.alphaMode ? n.alphaMode : null, r.bitmap = null, r._load = null, !1 !== n.autoLoad && r.load(), r
                }
                return mn(e, t), e.prototype.load = function(t) {
                    var e = this;
                    return this._load || (void 0 !== t && (this.createBitmap = t), this._load = new Promise((function(t, n) {
                        var r = e.source;
                        e.url = r.src;
                        var i = function() {
                            e.destroyed || (r.onload = null, r.onerror = null, e.resize(r.width, r.height), e._load = null, e.createBitmap ? t(e.process()) : t(e))
                        };
                        r.complete && r.src ? i() : (r.onload = i, r.onerror = function(t) {
                            n(t), e.onError.emit(t)
                        })
                    }))), this._load
                }, e.prototype.process = function() {
                    var t = this,
                        e = this.source;
                    if (null !== this._process) return this._process;
                    if (null !== this.bitmap || !globalThis.createImageBitmap) return Promise.resolve(this);
                    var n = globalThis.createImageBitmap,
                        r = !e.crossOrigin || "anonymous" === e.crossOrigin;
                    return this._process = fetch(e.src, {
                        mode: r ? "cors" : "no-cors"
                    }).then((function(t) {
                        return t.blob()
                    })).then((function(r) {
                        return n(r, 0, 0, e.width, e.height, {
                            premultiplyAlpha: t.alphaMode === vt.UNPACK ? "premultiply" : "none"
                        })
                    })).then((function(e) {
                        return t.destroyed ? Promise.reject() : (t.bitmap = e, t.update(), t._process = null, Promise.resolve(t))
                    })), this._process
                }, e.prototype.upload = function(e, n, r) {
                    if ("number" == typeof this.alphaMode && (n.alphaMode = this.alphaMode), !this.createBitmap) return t.prototype.upload.call(this, e, n, r);
                    if (!this.bitmap && (this.process(), !this.bitmap)) return !1;
                    if (t.prototype.upload.call(this, e, n, r, this.bitmap), !this.preserveBitmap) {
                        var i = !0,
                            o = n._glTextures;
                        for (var s in o) {
                            var a = o[s];
                            if (a !== r && a.dirtyId !== n.dirtyId) {
                                i = !1;
                                break
                            }
                        }
                        i && (this.bitmap.close && this.bitmap.close(), this.bitmap = null)
                    }
                    return !0
                }, e.prototype.dispose = function() {
                    this.source.onload = null, this.source.onerror = null, t.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null
                }, e.test = function(t) {
                    return "string" == typeof t || t instanceof HTMLImageElement
                }, e
            }(Tn),
            An = function(t) {
                function e(e, n) {
                    var r = this;
                    return n = n || {}, (r = t.call(this, document.createElement("canvas")) || this)._width = 0, r._height = 0, r.svg = e, r.scale = n.scale || 1, r._overrideWidth = n.width, r._overrideHeight = n.height, r._resolve = null, r._crossorigin = n.crossorigin, r._load = null, !1 !== n.autoLoad && r.load(), r
                }
                return mn(e, t), e.prototype.load = function() {
                    var t = this;
                    return this._load || (this._load = new Promise((function(n) {
                        if (t._resolve = function() {
                                t.resize(t.source.width, t.source.height), n(t)
                            }, e.SVG_XML.test(t.svg.trim())) {
                            if (!btoa) throw new Error("Your browser doesn't support base64 conversions.");
                            t.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(t.svg)))
                        }
                        t._loadSvg()
                    }))), this._load
                }, e.prototype._loadSvg = function() {
                    var t = this,
                        e = new Image;
                    Tn.crossOrigin(e, this.svg, this._crossorigin), e.src = this.svg, e.onerror = function(n) {
                        t._resolve && (e.onerror = null, t.onError.emit(n))
                    }, e.onload = function() {
                        if (t._resolve) {
                            var n = e.width,
                                r = e.height;
                            if (!n || !r) throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
                            var i = n * t.scale,
                                o = r * t.scale;
                            (t._overrideWidth || t._overrideHeight) && (i = t._overrideWidth || t._overrideHeight / r * n, o = t._overrideHeight || t._overrideWidth / n * r), i = Math.round(i), o = Math.round(o);
                            var s = t.source;
                            s.width = i, s.height = o, s._pixiId = "canvas_" + qt(), s.getContext("2d").drawImage(e, 0, 0, n, r, 0, 0, i, o), t._resolve(), t._resolve = null
                        }
                    }
                }, e.getSize = function(t) {
                    var n = e.SVG_SIZE.exec(t),
                        r = {};
                    return n && (r[n[1]] = Math.round(parseFloat(n[3])), r[n[5]] = Math.round(parseFloat(n[7]))), r
                }, e.prototype.dispose = function() {
                    t.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null
                }, e.test = function(t, n) {
                    return "svg" === n || "string" == typeof t && /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(t) || "string" == typeof t && e.SVG_XML.test(t)
                }, e.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, e.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i, e
            }(Tn),
            Rn = function(t) {
                function e(n, r) {
                    var i = this;
                    if (r = r || {}, !(n instanceof HTMLVideoElement)) {
                        var o = document.createElement("video");
                        o.setAttribute("preload", "auto"), o.setAttribute("webkit-playsinline", ""), o.setAttribute("playsinline", ""), "string" == typeof n && (n = [n]);
                        var s = n[0].src || n[0];
                        Tn.crossOrigin(o, s, r.crossorigin);
                        for (var a = 0; a < n.length; ++a) {
                            var l = document.createElement("source"),
                                u = n[a],
                                h = u.src,
                                c = u.mime,
                                d = (h = h || n[a]).split("?").shift().toLowerCase(),
                                p = d.slice(d.lastIndexOf(".") + 1);
                            c = c || e.MIME_TYPES[p] || "video/" + p, l.src = h, l.type = c, o.appendChild(l)
                        }
                        n = o
                    }
                    return (i = t.call(this, n) || this).noSubImage = !0, i._autoUpdate = !0, i._isConnectedToTicker = !1, i._updateFPS = r.updateFPS || 0, i._msToNextUpdate = 0, i.autoPlay = !1 !== r.autoPlay, i._load = null, i._resolve = null, i._onCanPlay = i._onCanPlay.bind(i), i._onError = i._onError.bind(i), !1 !== r.autoLoad && i.load(), i
                }
                return mn(e, t), e.prototype.update = function(e) {
                    if (!this.destroyed) {
                        var n = tn.shared.elapsedMS * this.source.playbackRate;
                        this._msToNextUpdate = Math.floor(this._msToNextUpdate - n), (!this._updateFPS || this._msToNextUpdate <= 0) && (t.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0)
                    }
                }, e.prototype.load = function() {
                    var t = this;
                    if (this._load) return this._load;
                    var e = this.source;
                    return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0), e.addEventListener("play", this._onPlayStart.bind(this)), e.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (e.addEventListener("canplay", this._onCanPlay), e.addEventListener("canplaythrough", this._onCanPlay), e.addEventListener("error", this._onError, !0)), this._load = new Promise((function(n) {
                        t.valid ? n(t) : (t._resolve = n, e.load())
                    })), this._load
                }, e.prototype._onError = function(t) {
                    this.source.removeEventListener("error", this._onError, !0), this.onError.emit(t)
                }, e.prototype._isSourcePlaying = function() {
                    var t = this.source;
                    return t.currentTime > 0 && !1 === t.paused && !1 === t.ended && t.readyState > 2
                }, e.prototype._isSourceReady = function() {
                    var t = this.source;
                    return 3 === t.readyState || 4 === t.readyState
                }, e.prototype._onPlayStart = function() {
                    this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (tn.shared.add(this.update, this), this._isConnectedToTicker = !0)
                }, e.prototype._onPlayStop = function() {
                    this._isConnectedToTicker && (tn.shared.remove(this.update, this), this._isConnectedToTicker = !1)
                }, e.prototype._onCanPlay = function() {
                    var t = this.source;
                    t.removeEventListener("canplay", this._onCanPlay), t.removeEventListener("canplaythrough", this._onCanPlay);
                    var e = this.valid;
                    this.resize(t.videoWidth, t.videoHeight), !e && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && t.play()
                }, e.prototype.dispose = function() {
                    this._isConnectedToTicker && (tn.shared.remove(this.update, this), this._isConnectedToTicker = !1);
                    var e = this.source;
                    e && (e.removeEventListener("error", this._onError, !0), e.pause(), e.src = "", e.load()), t.prototype.dispose.call(this)
                }, Object.defineProperty(e.prototype, "autoUpdate", {
                    get: function() {
                        return this._autoUpdate
                    },
                    set: function(t) {
                        t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (tn.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (tn.shared.add(this.update, this), this._isConnectedToTicker = !0))
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "updateFPS", {
                    get: function() {
                        return this._updateFPS
                    },
                    set: function(t) {
                        t !== this._updateFPS && (this._updateFPS = t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.test = function(t, n) {
                    return globalThis.HTMLVideoElement && t instanceof HTMLVideoElement || e.TYPES.indexOf(n) > -1
                }, e.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], e.MIME_TYPES = {
                    ogv: "video/ogg",
                    mov: "video/quicktime",
                    m4v: "video/mp4"
                }, e
            }(Tn),
            Pn = function(t) {
                function e(e) {
                    return t.call(this, e) || this
                }
                return mn(e, t), e.test = function(t) {
                    return !!globalThis.createImageBitmap && t instanceof ImageBitmap
                }, e
            }(Tn);
        dn.push(Mn, Pn, Sn, Rn, An, _n, wn, En);
        var In = {
                __proto__: null,
                Resource: vn,
                BaseImageResource: Tn,
                INSTALLED: dn,
                autoDetectResource: pn,
                AbstractMultiResource: bn,
                ArrayResource: En,
                BufferResource: _n,
                CanvasResource: Sn,
                CubeResource: wn,
                ImageResource: Mn,
                SVGResource: An,
                VideoResource: Rn,
                ImageBitmapResource: Pn
            },
            Cn = function(t) {
                function e() {
                    return null !== t && t.apply(this, arguments) || this
                }
                return mn(e, t), e.prototype.upload = function(t, e, n) {
                    var r = t.gl;
                    r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === vt.UNPACK);
                    var i = e.realWidth,
                        o = e.realHeight;
                    return n.width === i && n.height === o ? r.texSubImage2D(e.target, 0, 0, 0, i, o, e.format, n.type, this.data) : (n.width = i, n.height = o, r.texImage2D(e.target, 0, n.internalFormat, i, o, 0, e.format, n.type, this.data)), !0
                }, e
            }(_n),
            On = function() {
                function t(t, e) {
                    this.width = Math.round(t || 100), this.height = Math.round(e || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new cn("disposeFramebuffer"), this.multisample = Et.NONE
                }
                return Object.defineProperty(t.prototype, "colorTexture", {
                    get: function() {
                        return this.colorTextures[0]
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.addColorTexture = function(t, e) {
                    return void 0 === t && (t = 0), this.colorTextures[t] = e || new xn(null, {
                        scaleMode: ft.NEAREST,
                        resolution: 1,
                        mipmap: gt.OFF,
                        width: this.width,
                        height: this.height
                    }), this.dirtyId++, this.dirtyFormat++, this
                }, t.prototype.addDepthTexture = function(t) {
                    return this.depthTexture = t || new xn(new Cn(null, {
                        width: this.width,
                        height: this.height
                    }), {
                        scaleMode: ft.NEAREST,
                        resolution: 1,
                        width: this.width,
                        height: this.height,
                        mipmap: gt.OFF,
                        format: ht.DEPTH_COMPONENT,
                        type: dt.UNSIGNED_SHORT
                    }), this.dirtyId++, this.dirtyFormat++, this
                }, t.prototype.enableDepth = function() {
                    return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this
                }, t.prototype.enableStencil = function() {
                    return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this
                }, t.prototype.resize = function(t, e) {
                    if (t = Math.round(t), e = Math.round(e), t !== this.width || e !== this.height) {
                        this.width = t, this.height = e, this.dirtyId++, this.dirtySize++;
                        for (var n = 0; n < this.colorTextures.length; n++) {
                            var r = this.colorTextures[n],
                                i = r.resolution;
                            r.setSize(t / i, e / i)
                        }
                        this.depthTexture && (i = this.depthTexture.resolution, this.depthTexture.setSize(t / i, e / i))
                    }
                }, t.prototype.dispose = function() {
                    this.disposeRunner.emit(this, !1)
                }, t.prototype.destroyDepthTexture = function() {
                    this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat)
                }, t
            }(),
            Ln = function(t) {
                function e(e) {
                    void 0 === e && (e = {});
                    var n = this;
                    if ("number" == typeof e) {
                        var r = arguments[0],
                            i = arguments[1],
                            o = arguments[2],
                            s = arguments[3];
                        e = {
                            width: r,
                            height: i,
                            scaleMode: o,
                            resolution: s
                        }
                    }
                    return e.width = e.width || 100, e.height = e.height || 100, e.multisample = void 0 !== e.multisample ? e.multisample : Et.NONE, (n = t.call(this, null, e) || this).mipmap = gt.OFF, n.valid = !0, n.clearColor = [0, 0, 0, 0], n.framebuffer = new On(n.realWidth, n.realHeight).addColorTexture(0, n), n.framebuffer.multisample = e.multisample, n.maskStack = [], n.filterStack = [{}], n
                }
                return mn(e, t), e.prototype.resize = function(t, e) {
                    this.framebuffer.resize(t * this.resolution, e * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height)
                }, e.prototype.dispose = function() {
                    this.framebuffer.dispose(), t.prototype.dispose.call(this)
                }, e.prototype.destroy = function() {
                    t.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null
                }, e
            }(xn),
            Nn = function() {
                function t() {
                    this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8)
                }
                return t.prototype.set = function(t, e, n) {
                    var r = e.width,
                        i = e.height;
                    if (n) {
                        var o = t.width / 2 / r,
                            s = t.height / 2 / i,
                            a = t.x / r + o,
                            l = t.y / i + s;
                        n = Te.add(n, Te.NW), this.x0 = a + o * Te.uX(n), this.y0 = l + s * Te.uY(n), n = Te.add(n, 2), this.x1 = a + o * Te.uX(n), this.y1 = l + s * Te.uY(n), n = Te.add(n, 2), this.x2 = a + o * Te.uX(n), this.y2 = l + s * Te.uY(n), n = Te.add(n, 2), this.x3 = a + o * Te.uX(n), this.y3 = l + s * Te.uY(n)
                    } else this.x0 = t.x / r, this.y0 = t.y / i, this.x1 = (t.x + t.width) / r, this.y1 = t.y / i, this.x2 = (t.x + t.width) / r, this.y2 = (t.y + t.height) / i, this.x3 = t.x / r, this.y3 = (t.y + t.height) / i;
                    this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3
                }, t.prototype.toString = function() {
                    return "[@pixi/core:TextureUvs x0=" + this.x0 + " y0=" + this.y0 + " x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3 + "]"
                }, t
            }(),
            Dn = new Nn,
            Un = function(t) {
                function e(n, r, i, o, s, a) {
                    var l = t.call(this) || this;
                    if (l.noFrame = !1, r || (l.noFrame = !0, r = new ue(0, 0, 1, 1)), n instanceof e && (n = n.baseTexture), l.baseTexture = n, l._frame = r, l.trim = o, l.valid = !1, l._uvs = Dn, l.uvMatrix = null, l.orig = i || r, l._rotate = Number(s || 0), !0 === s) l._rotate = 2;
                    else if (l._rotate % 2 != 0) throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
                    return l.defaultAnchor = a ? new ae(a.x, a.y) : new ae(0, 0), l._updateID = 0, l.textureCacheIds = [], n.valid ? l.noFrame ? n.valid && l.onBaseTextureUpdated(n) : l.frame = r : n.once("loaded", l.onBaseTextureUpdated, l), l.noFrame && n.on("update", l.onBaseTextureUpdated, l), l
                }
                return mn(e, t), e.prototype.update = function() {
                    this.baseTexture.resource && this.baseTexture.resource.update()
                }, e.prototype.onBaseTextureUpdated = function(t) {
                    if (this.noFrame) {
                        if (!this.baseTexture.valid) return;
                        this._frame.width = t.width, this._frame.height = t.height, this.valid = !0, this.updateUvs()
                    } else this.frame = this._frame;
                    this.emit("update", this)
                }, e.prototype.destroy = function(t) {
                    if (this.baseTexture) {
                        if (t) {
                            var n = this.baseTexture.resource;
                            n && n.url && $t[n.url] && e.removeFromCache(n.url), this.baseTexture.destroy()
                        }
                        this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null
                    }
                    this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, e.removeFromCache(this), this.textureCacheIds = null
                }, e.prototype.clone = function() {
                    var t = this._frame.clone(),
                        n = this._frame === this.orig ? t : this.orig.clone(),
                        r = new e(this.baseTexture, !this.noFrame && t, n, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
                    return this.noFrame && (r._frame = t), r
                }, e.prototype.updateUvs = function() {
                    this._uvs === Dn && (this._uvs = new Nn), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++
                }, e.from = function(t, n, r) {
                    void 0 === n && (n = {}), void 0 === r && (r = St.STRICT_TEXTURE_CACHE);
                    var i = "string" == typeof t,
                        o = null;
                    if (i) o = t;
                    else if (t instanceof xn) {
                        if (!t.cacheId) {
                            var s = n && n.pixiIdPrefix || "pixiid";
                            t.cacheId = s + "-" + qt(), xn.addToCache(t, t.cacheId)
                        }
                        o = t.cacheId
                    } else t._pixiId || (s = n && n.pixiIdPrefix || "pixiid", t._pixiId = s + "_" + qt()), o = t._pixiId;
                    var a = $t[o];
                    if (i && r && !a) throw new Error('The cacheId "' + o + '" does not exist in TextureCache.');
                    return a || t instanceof xn ? !a && t instanceof xn && (a = new e(t), e.addToCache(a, o)) : (n.resolution || (n.resolution = ne(t)), (a = new e(new xn(t, n))).baseTexture.cacheId = o, xn.addToCache(a.baseTexture, o), e.addToCache(a, o)), a
                }, e.fromURL = function(t, n) {
                    var r = Object.assign({
                            autoLoad: !1
                        }, null == n ? void 0 : n.resourceOptions),
                        i = e.from(t, Object.assign({
                            resourceOptions: r
                        }, n), !1),
                        o = i.baseTexture.resource;
                    return i.baseTexture.valid ? Promise.resolve(i) : o.load().then((function() {
                        return Promise.resolve(i)
                    }))
                }, e.fromBuffer = function(t, n, r, i) {
                    return new e(xn.fromBuffer(t, n, r, i))
                }, e.fromLoader = function(t, n, r, i) {
                    var o = new xn(t, Object.assign({
                            scaleMode: St.SCALE_MODE,
                            resolution: ne(n)
                        }, i)),
                        s = o.resource;
                    s instanceof Mn && (s.url = n);
                    var a = new e(o);
                    return r || (r = n), xn.addToCache(a.baseTexture, r), e.addToCache(a, r), r !== n && (xn.addToCache(a.baseTexture, n), e.addToCache(a, n)), a.baseTexture.valid ? Promise.resolve(a) : new Promise((function(t) {
                        a.baseTexture.once("loaded", (function() {
                            return t(a)
                        }))
                    }))
                }, e.addToCache = function(t, e) {
                    e && (-1 === t.textureCacheIds.indexOf(e) && t.textureCacheIds.push(e), $t[e] && console.warn("Texture added to the cache with an id [" + e + "] that already had an entry"), $t[e] = t)
                }, e.removeFromCache = function(t) {
                    if ("string" == typeof t) {
                        var e = $t[t];
                        if (e) {
                            var n = e.textureCacheIds.indexOf(t);
                            return n > -1 && e.textureCacheIds.splice(n, 1), delete $t[t], e
                        }
                    } else if (t && t.textureCacheIds) {
                        for (var r = 0; r < t.textureCacheIds.length; ++r) $t[t.textureCacheIds[r]] === t && delete $t[t.textureCacheIds[r]];
                        return t.textureCacheIds.length = 0, t
                    }
                    return null
                }, Object.defineProperty(e.prototype, "resolution", {
                    get: function() {
                        return this.baseTexture.resolution
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "frame", {
                    get: function() {
                        return this._frame
                    },
                    set: function(t) {
                        this._frame = t, this.noFrame = !1;
                        var e = t.x,
                            n = t.y,
                            r = t.width,
                            i = t.height,
                            o = e + r > this.baseTexture.width,
                            s = n + i > this.baseTexture.height;
                        if (o || s) {
                            var a = o && s ? "and" : "or",
                                l = "X: " + e + " + " + r + " = " + (e + r) + " > " + this.baseTexture.width,
                                u = "Y: " + n + " + " + i + " = " + (n + i) + " > " + this.baseTexture.height;
                            throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + l + " " + a + " " + u)
                        }
                        this.valid = r && i && this.baseTexture.valid, this.trim || this.rotate || (this.orig = t), this.valid && this.updateUvs()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "rotate", {
                    get: function() {
                        return this._rotate
                    },
                    set: function(t) {
                        this._rotate = t, this.valid && this.updateUvs()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "width", {
                    get: function() {
                        return this.orig.width
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "height", {
                    get: function() {
                        return this.orig.height
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype.castToBaseTexture = function() {
                    return this.baseTexture
                }, e
            }(Mt());

        function Fn(t) {
            t.destroy = function() {}, t.on = function() {}, t.once = function() {}, t.emit = function() {}
        }
        Un.EMPTY = new Un(new xn), Fn(Un.EMPTY), Fn(Un.EMPTY.baseTexture), Un.WHITE = function() {
            var t = document.createElement("canvas");
            t.width = 16, t.height = 16;
            var e = t.getContext("2d");
            return e.fillStyle = "white", e.fillRect(0, 0, 16, 16), new Un(new xn(new Sn(t)))
        }(), Fn(Un.WHITE), Fn(Un.WHITE.baseTexture);
        var Bn = function(t) {
                function e(e, n) {
                    var r = t.call(this, e, n) || this;
                    return r.valid = !0, r.filterFrame = null, r.filterPoolKey = null, r.updateUvs(), r
                }
                return mn(e, t), Object.defineProperty(e.prototype, "framebuffer", {
                    get: function() {
                        return this.baseTexture.framebuffer
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "multisample", {
                    get: function() {
                        return this.framebuffer.multisample
                    },
                    set: function(t) {
                        this.framebuffer.multisample = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype.resize = function(t, e, n) {
                    void 0 === n && (n = !0);
                    var r = this.baseTexture.resolution,
                        i = Math.round(t * r) / r,
                        o = Math.round(e * r) / r;
                    this.valid = i > 0 && o > 0, this._frame.width = this.orig.width = i, this._frame.height = this.orig.height = o, n && this.baseTexture.resize(i, o), this.updateUvs()
                }, e.prototype.setResolution = function(t) {
                    var e = this.baseTexture;
                    e.resolution !== t && (e.setResolution(t), this.resize(e.width, e.height, !1))
                }, e.create = function(t) {
                    for (var n = arguments, r = [], i = 1; i < arguments.length; i++) r[i - 1] = n[i];
                    return "number" == typeof t && (Kt("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated."), t = {
                        width: t,
                        height: r[0],
                        scaleMode: r[1],
                        resolution: r[2]
                    }), new e(new Ln(t))
                }, e
            }(Un),
            kn = function() {
                function t(t) {
                    this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0
                }
                return t.prototype.createTexture = function(t, e, n) {
                    void 0 === n && (n = Et.NONE);
                    var r = new Ln(Object.assign({
                        width: t,
                        height: e,
                        resolution: 1,
                        multisample: n
                    }, this.textureOptions));
                    return new Bn(r)
                }, t.prototype.getOptimalTexture = function(t, e, n, r) {
                    var i;
                    void 0 === n && (n = 1), void 0 === r && (r = Et.NONE), t = Math.ceil(t * n - 1e-6), e = Math.ceil(e * n - 1e-6), this.enableFullScreen && t === this._pixelsWidth && e === this._pixelsHeight ? i = r > 1 ? -r : -1 : (i = ((65535 & (t = zt(t))) << 16 | 65535 & (e = zt(e))) >>> 0, r > 1 && (i += 4294967296 * r)), this.texturePool[i] || (this.texturePool[i] = []);
                    var o = this.texturePool[i].pop();
                    return o || (o = this.createTexture(t, e, r)), o.filterPoolKey = i, o.setResolution(n), o
                }, t.prototype.getFilterTexture = function(t, e, n) {
                    var r = this.getOptimalTexture(t.width, t.height, e || t.resolution, n || Et.NONE);
                    return r.filterFrame = t.filterFrame, r
                }, t.prototype.returnTexture = function(t) {
                    var e = t.filterPoolKey;
                    t.filterFrame = null, this.texturePool[e].push(t)
                }, t.prototype.returnFilterTexture = function(t) {
                    this.returnTexture(t)
                }, t.prototype.clear = function(t) {
                    if (t = !1 !== t)
                        for (var e in this.texturePool) {
                            var n = this.texturePool[e];
                            if (n)
                                for (var r = 0; r < n.length; r++) n[r].destroy(!0)
                        }
                    this.texturePool = {}
                }, t.prototype.setScreenSize = function(t) {
                    if (t.width !== this._pixelsWidth || t.height !== this._pixelsHeight) {
                        for (var e in this.enableFullScreen = t.width > 0 && t.height > 0, this.texturePool)
                            if (Number(e) < 0) {
                                var n = this.texturePool[e];
                                if (n)
                                    for (var r = 0; r < n.length; r++) n[r].destroy(!0);
                                this.texturePool[e] = []
                            } this._pixelsWidth = t.width, this._pixelsHeight = t.height
                    }
                }, t.SCREEN_KEY = -1, t
            }(),
            Gn = function() {
                function t(t, e, n, r, i, o, s) {
                    void 0 === e && (e = 0), void 0 === n && (n = !1), void 0 === r && (r = dt.FLOAT), this.buffer = t, this.size = e, this.normalized = n, this.type = r, this.stride = i, this.start = o, this.instance = s
                }
                return t.prototype.destroy = function() {
                    this.buffer = null
                }, t.from = function(e, n, r, i, o) {
                    return new t(e, n, r, i, o)
                }, t
            }(),
            Hn = 0,
            zn = function() {
                function t(t, e, n) {
                    void 0 === e && (e = !0), void 0 === n && (n = !1), this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = n, this.static = e, this.id = Hn++, this.disposeRunner = new cn("disposeBuffer")
                }
                return t.prototype.update = function(t) {
                    t instanceof Array && (t = new Float32Array(t)), this.data = t || this.data, this._updateID++
                }, t.prototype.dispose = function() {
                    this.disposeRunner.emit(this, !1)
                }, t.prototype.destroy = function() {
                    this.dispose(), this.data = null
                }, Object.defineProperty(t.prototype, "index", {
                    get: function() {
                        return this.type === Tt.ELEMENT_ARRAY_BUFFER
                    },
                    set: function(t) {
                        this.type = t ? Tt.ELEMENT_ARRAY_BUFFER : Tt.ARRAY_BUFFER
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.from = function(e) {
                    return e instanceof Array && (e = new Float32Array(e)), new t(e)
                }, t
            }(),
            Vn = {
                Float32Array,
                Uint32Array,
                Int32Array,
                Uint8Array
            },
            Wn = {
                5126: 4,
                5123: 2,
                5121: 1
            },
            Xn = 0,
            jn = {
                Float32Array,
                Uint32Array,
                Int32Array,
                Uint8Array,
                Uint16Array
            },
            Yn = function() {
                function t(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = {}), this.buffers = t, this.indexBuffer = null, this.attributes = e, this.glVertexArrayObjects = {}, this.id = Xn++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new cn("disposeGeometry"), this.refCount = 0
                }
                return t.prototype.addAttribute = function(t, e, n, r, i, o, s, a) {
                    if (void 0 === n && (n = 0), void 0 === r && (r = !1), void 0 === a && (a = !1), !e) throw new Error("You must pass a buffer when creating an attribute");
                    e instanceof zn || (e instanceof Array && (e = new Float32Array(e)), e = new zn(e));
                    var l = t.split("|");
                    if (l.length > 1) {
                        for (var u = 0; u < l.length; u++) this.addAttribute(l[u], e, n, r, i);
                        return this
                    }
                    var h = this.buffers.indexOf(e);
                    return -1 === h && (this.buffers.push(e), h = this.buffers.length - 1), this.attributes[t] = new Gn(h, n, r, i, o, s, a), this.instanced = this.instanced || a, this
                }, t.prototype.getAttribute = function(t) {
                    return this.attributes[t]
                }, t.prototype.getBuffer = function(t) {
                    return this.buffers[this.getAttribute(t).buffer]
                }, t.prototype.addIndex = function(t) {
                    return t instanceof zn || (t instanceof Array && (t = new Uint16Array(t)), t = new zn(t)), t.type = Tt.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t, -1 === this.buffers.indexOf(t) && this.buffers.push(t), this
                }, t.prototype.getIndex = function() {
                    return this.indexBuffer
                }, t.prototype.interleave = function() {
                    if (1 === this.buffers.length || 2 === this.buffers.length && this.indexBuffer) return this;
                    var t, e = [],
                        n = [],
                        r = new zn;
                    for (t in this.attributes) {
                        var i = this.attributes[t],
                            o = this.buffers[i.buffer];
                        e.push(o.data), n.push(i.size * Wn[i.type] / 4), i.buffer = 0
                    }
                    for (r.data = function(t, e) {
                            for (var n = 0, r = 0, i = {}, o = 0; o < t.length; o++) r += e[o], n += t[o].length;
                            var s = new ArrayBuffer(4 * n),
                                a = null,
                                l = 0;
                            for (o = 0; o < t.length; o++) {
                                var u = e[o],
                                    h = t[o],
                                    c = Ht(h);
                                i[c] || (i[c] = new Vn[c](s)), a = i[c];
                                for (var d = 0; d < h.length; d++) a[(d / u | 0) * r + l + d % u] = h[d];
                                l += u
                            }
                            return new Float32Array(s)
                        }(e, n), t = 0; t < this.buffers.length; t++) this.buffers[t] !== this.indexBuffer && this.buffers[t].destroy();
                    return this.buffers = [r], this.indexBuffer && this.buffers.push(this.indexBuffer), this
                }, t.prototype.getSize = function() {
                    for (var t in this.attributes) {
                        var e = this.attributes[t];
                        return this.buffers[e.buffer].data.length / (e.stride / 4 || e.size)
                    }
                    return 0
                }, t.prototype.dispose = function() {
                    this.disposeRunner.emit(this, !1)
                }, t.prototype.destroy = function() {
                    this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null
                }, t.prototype.clone = function() {
                    for (var e = new t, n = 0; n < this.buffers.length; n++) e.buffers[n] = new zn(this.buffers[n].data.slice(0));
                    for (var n in this.attributes) {
                        var r = this.attributes[n];
                        e.attributes[n] = new Gn(r.buffer, r.size, r.normalized, r.type, r.stride, r.start, r.instance)
                    }
                    return this.indexBuffer && (e.indexBuffer = e.buffers[this.buffers.indexOf(this.indexBuffer)], e.indexBuffer.type = Tt.ELEMENT_ARRAY_BUFFER), e
                }, t.merge = function(e) {
                    for (var n, r = new t, i = [], o = [], s = [], a = 0; a < e.length; a++) {
                        n = e[a];
                        for (var l = 0; l < n.buffers.length; l++) o[l] = o[l] || 0, o[l] += n.buffers[l].data.length, s[l] = 0
                    }
                    for (a = 0; a < n.buffers.length; a++) i[a] = new(jn[Ht(n.buffers[a].data)])(o[a]), r.buffers[a] = new zn(i[a]);
                    for (a = 0; a < e.length; a++)
                        for (n = e[a], l = 0; l < n.buffers.length; l++) i[l].set(n.buffers[l].data, s[l]), s[l] += n.buffers[l].data.length;
                    if (r.attributes = n.attributes, n.indexBuffer) {
                        r.indexBuffer = r.buffers[n.buffers.indexOf(n.indexBuffer)], r.indexBuffer.type = Tt.ELEMENT_ARRAY_BUFFER;
                        var u = 0,
                            h = 0,
                            c = 0,
                            d = 0;
                        for (a = 0; a < n.buffers.length; a++)
                            if (n.buffers[a] !== n.indexBuffer) {
                                d = a;
                                break
                            } for (var a in n.attributes) {
                            var p = n.attributes[a];
                            (0 | p.buffer) === d && (h += p.size * Wn[p.type] / 4)
                        }
                        for (a = 0; a < e.length; a++) {
                            var f = e[a].indexBuffer.data;
                            for (l = 0; l < f.length; l++) r.indexBuffer.data[l + c] += u;
                            u += e[a].buffers[d].data.length / h, c += f.length
                        }
                    }
                    return r
                }, t
            }(),
            qn = function(t) {
                function e() {
                    var e = t.call(this) || this;
                    return e.addAttribute("aVertexPosition", new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2]), e
                }
                return mn(e, t), e
            }(Yn),
            Zn = function(t) {
                function e() {
                    var e = t.call(this) || this;
                    return e.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), e.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), e.vertexBuffer = new zn(e.vertices), e.uvBuffer = new zn(e.uvs), e.addAttribute("aVertexPosition", e.vertexBuffer).addAttribute("aTextureCoord", e.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e
                }
                return mn(e, t), e.prototype.map = function(t, e) {
                    var n = 0,
                        r = 0;
                    return this.uvs[0] = n, this.uvs[1] = r, this.uvs[2] = n + e.width / t.width, this.uvs[3] = r, this.uvs[4] = n + e.width / t.width, this.uvs[5] = r + e.height / t.height, this.uvs[6] = n, this.uvs[7] = r + e.height / t.height, n = e.x, r = e.y, this.vertices[0] = n, this.vertices[1] = r, this.vertices[2] = n + e.width, this.vertices[3] = r, this.vertices[4] = n + e.width, this.vertices[5] = r + e.height, this.vertices[6] = n, this.vertices[7] = r + e.height, this.invalidate(), this
                }, e.prototype.invalidate = function() {
                    return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this
                }, e
            }(Yn),
            Kn = 0,
            Jn = function() {
                function t(t, e, n) {
                    this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = Kn++, this.static = !!e, this.ubo = !!n, t instanceof zn ? (this.buffer = t, this.buffer.type = Tt.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = t, this.ubo && (this.buffer = new zn(new Float32Array(1)), this.buffer.type = Tt.UNIFORM_BUFFER, this.autoManage = !0))
                }
                return t.prototype.update = function() {
                    this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update()
                }, t.prototype.add = function(e, n, r) {
                    if (this.ubo) throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
                    this.uniforms[e] = new t(n, r)
                }, t.from = function(e, n, r) {
                    return new t(e, n, r)
                }, t.uboFrom = function(e, n) {
                    return new t(e, null == n || n, !0)
                }, t
            }(),
            Qn = function() {
                function t() {
                    this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = Et.NONE, this.sourceFrame = new ue, this.destinationFrame = new ue, this.bindingSourceFrame = new ue, this.bindingDestinationFrame = new ue, this.filters = [], this.transform = null
                }
                return t.prototype.clear = function() {
                    this.target = null, this.filters = null, this.renderTexture = null
                }, t
            }(),
            $n = [new ae, new ae, new ae, new ae],
            tr = new me,
            er = function() {
                function t(t) {
                    this.renderer = t, this.defaultFilterStack = [{}], this.texturePool = new kn, this.texturePool.setScreenSize(t.view), this.statePool = [], this.quad = new qn, this.quadUv = new Zn, this.tempRect = new ue, this.activeState = {}, this.globalUniforms = new Jn({
                        outputFrame: new ue,
                        inputSize: new Float32Array(4),
                        inputPixel: new Float32Array(4),
                        inputClamp: new Float32Array(4),
                        resolution: 1,
                        filterArea: new Float32Array(4),
                        filterClamp: new Float32Array(4)
                    }, !0), this.forceClear = !1, this.useMaxPadding = !1
                }
                return t.prototype.push = function(t, e) {
                    for (var n, r, i = this.renderer, o = this.defaultFilterStack, s = this.statePool.pop() || new Qn, a = this.renderer.renderTexture, l = e[0].resolution, u = e[0].multisample, h = e[0].padding, c = e[0].autoFit, d = null === (n = e[0].legacy) || void 0 === n || n, p = 1; p < e.length; p++) {
                        var f = e[p];
                        l = Math.min(l, f.resolution), u = Math.min(u, f.multisample), h = this.useMaxPadding ? Math.max(h, f.padding) : h + f.padding, c = c && f.autoFit, d = d || null === (r = f.legacy) || void 0 === r || r
                    }
                    if (1 === o.length && (this.defaultFilterStack[0].renderTexture = a.current), o.push(s), s.resolution = l, s.multisample = u, s.legacy = d, s.target = t, s.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), s.sourceFrame.pad(h), c) {
                        var m = this.tempRect.copyFrom(a.sourceFrame);
                        i.projection.transform && this.transformAABB(tr.copyFrom(i.projection.transform).invert(), m), s.sourceFrame.fit(m)
                    }
                    this.roundFrame(s.sourceFrame, a.current ? a.current.resolution : i.resolution, a.sourceFrame, a.destinationFrame, i.projection.transform), s.renderTexture = this.getOptimalFilterTexture(s.sourceFrame.width, s.sourceFrame.height, l, u), s.filters = e, s.destinationFrame.width = s.renderTexture.width, s.destinationFrame.height = s.renderTexture.height;
                    var g = this.tempRect;
                    g.x = 0, g.y = 0, g.width = s.sourceFrame.width, g.height = s.sourceFrame.height, s.renderTexture.filterFrame = s.sourceFrame, s.bindingSourceFrame.copyFrom(a.sourceFrame), s.bindingDestinationFrame.copyFrom(a.destinationFrame), s.transform = i.projection.transform, i.projection.transform = null, a.bind(s.renderTexture, s.sourceFrame, g), i.framebuffer.clear(0, 0, 0, 0)
                }, t.prototype.pop = function() {
                    var t = this.defaultFilterStack,
                        e = t.pop(),
                        n = e.filters;
                    this.activeState = e;
                    var r = this.globalUniforms.uniforms;
                    r.outputFrame = e.sourceFrame, r.resolution = e.resolution;
                    var i = r.inputSize,
                        o = r.inputPixel,
                        s = r.inputClamp;
                    if (i[0] = e.destinationFrame.width, i[1] = e.destinationFrame.height, i[2] = 1 / i[0], i[3] = 1 / i[1], o[0] = Math.round(i[0] * e.resolution), o[1] = Math.round(i[1] * e.resolution), o[2] = 1 / o[0], o[3] = 1 / o[1], s[0] = .5 * o[2], s[1] = .5 * o[3], s[2] = e.sourceFrame.width * i[2] - .5 * o[2], s[3] = e.sourceFrame.height * i[3] - .5 * o[3], e.legacy) {
                        var a = r.filterArea;
                        a[0] = e.destinationFrame.width, a[1] = e.destinationFrame.height, a[2] = e.sourceFrame.x, a[3] = e.sourceFrame.y, r.filterClamp = r.inputClamp
                    }
                    this.globalUniforms.update();
                    var l = t[t.length - 1];
                    if (this.renderer.framebuffer.blit(), 1 === n.length) n[0].apply(this, e.renderTexture, l.renderTexture, _t.BLEND, e), this.returnFilterTexture(e.renderTexture);
                    else {
                        var u = e.renderTexture,
                            h = this.getOptimalFilterTexture(u.width, u.height, e.resolution);
                        h.filterFrame = u.filterFrame;
                        var c = 0;
                        for (c = 0; c < n.length - 1; ++c) {
                            1 === c && e.multisample > 1 && ((h = this.getOptimalFilterTexture(u.width, u.height, e.resolution)).filterFrame = u.filterFrame), n[c].apply(this, u, h, _t.CLEAR, e);
                            var d = u;
                            u = h, h = d
                        }
                        n[c].apply(this, u, l.renderTexture, _t.BLEND, e), c > 1 && e.multisample > 1 && this.returnFilterTexture(e.renderTexture), this.returnFilterTexture(u), this.returnFilterTexture(h)
                    }
                    e.clear(), this.statePool.push(e)
                }, t.prototype.bindAndClear = function(t, e) {
                    void 0 === e && (e = _t.CLEAR);
                    var n = this.renderer,
                        r = n.renderTexture,
                        i = n.state;
                    if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t && t.filterFrame) {
                        var o = this.tempRect;
                        o.x = 0, o.y = 0, o.width = t.filterFrame.width, o.height = t.filterFrame.height, r.bind(t, t.filterFrame, o)
                    } else t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? r.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
                    var s = 1 & i.stateId || this.forceClear;
                    (e === _t.CLEAR || e === _t.BLIT && s) && this.renderer.framebuffer.clear(0, 0, 0, 0)
                }, t.prototype.applyFilter = function(t, e, n, r) {
                    var i = this.renderer;
                    i.state.set(t.state), this.bindAndClear(n, r), t.uniforms.uSampler = e, t.uniforms.filterGlobals = this.globalUniforms, i.shader.bind(t), t.legacy = !!t.program.attributeData.aTextureCoord, t.legacy ? (this.quadUv.map(e._frame, e.filterFrame), i.geometry.bind(this.quadUv), i.geometry.draw(ut.TRIANGLES)) : (i.geometry.bind(this.quad), i.geometry.draw(ut.TRIANGLE_STRIP))
                }, t.prototype.calculateSpriteMatrix = function(t, e) {
                    var n = this.activeState,
                        r = n.sourceFrame,
                        i = n.destinationFrame,
                        o = e._texture.orig,
                        s = t.set(i.width, 0, 0, i.height, r.x, r.y),
                        a = e.worldTransform.copyTo(me.TEMP_MATRIX);
                    return a.invert(), s.prepend(a), s.scale(1 / o.width, 1 / o.height), s.translate(e.anchor.x, e.anchor.y), s
                }, t.prototype.destroy = function() {
                    this.renderer = null, this.texturePool.clear(!1)
                }, t.prototype.getOptimalFilterTexture = function(t, e, n, r) {
                    return void 0 === n && (n = 1), void 0 === r && (r = Et.NONE), this.texturePool.getOptimalTexture(t, e, n, r)
                }, t.prototype.getFilterTexture = function(t, e, n) {
                    if ("number" == typeof t) {
                        var r = t;
                        t = e, e = r
                    }
                    t = t || this.activeState.renderTexture;
                    var i = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution, n || Et.NONE);
                    return i.filterFrame = t.filterFrame, i
                }, t.prototype.returnFilterTexture = function(t) {
                    this.texturePool.returnTexture(t)
                }, t.prototype.emptyPool = function() {
                    this.texturePool.clear(!0)
                }, t.prototype.resize = function() {
                    this.texturePool.setScreenSize(this.renderer.view)
                }, t.prototype.transformAABB = function(t, e) {
                    var n = $n[0],
                        r = $n[1],
                        i = $n[2],
                        o = $n[3];
                    n.set(e.left, e.top), r.set(e.left, e.bottom), i.set(e.right, e.top), o.set(e.right, e.bottom), t.apply(n, n), t.apply(r, r), t.apply(i, i), t.apply(o, o);
                    var s = Math.min(n.x, r.x, i.x, o.x),
                        a = Math.min(n.y, r.y, i.y, o.y),
                        l = Math.max(n.x, r.x, i.x, o.x),
                        u = Math.max(n.y, r.y, i.y, o.y);
                    e.x = s, e.y = a, e.width = l - s, e.height = u - a
                }, t.prototype.roundFrame = function(t, e, n, r, i) {
                    if (!(t.width <= 0 || t.height <= 0 || n.width <= 0 || n.height <= 0)) {
                        if (i) {
                            var o = i.a,
                                s = i.b,
                                a = i.c,
                                l = i.d;
                            if ((Math.abs(s) > 1e-4 || Math.abs(a) > 1e-4) && (Math.abs(o) > 1e-4 || Math.abs(l) > 1e-4)) return
                        }(i = i ? tr.copyFrom(i) : tr.identity()).translate(-n.x, -n.y).scale(r.width / n.width, r.height / n.height).translate(r.x, r.y), this.transformAABB(i, t), t.ceil(e), this.transformAABB(i.invert(), t)
                    }
                }, t
            }(),
            nr = function() {
                function t(t) {
                    this.renderer = t
                }
                return t.prototype.flush = function() {}, t.prototype.destroy = function() {
                    this.renderer = null
                }, t.prototype.start = function() {}, t.prototype.stop = function() {
                    this.flush()
                }, t.prototype.render = function(t) {}, t
            }(),
            rr = function() {
                function t(t) {
                    this.renderer = t, this.emptyRenderer = new nr(t), this.currentRenderer = this.emptyRenderer
                }
                return t.prototype.setObjectRenderer = function(t) {
                    this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start())
                }, t.prototype.flush = function() {
                    this.setObjectRenderer(this.emptyRenderer)
                }, t.prototype.reset = function() {
                    this.setObjectRenderer(this.emptyRenderer)
                }, t.prototype.copyBoundTextures = function(t, e) {
                    for (var n = this.renderer.texture.boundTextures, r = e - 1; r >= 0; --r) t[r] = n[r] || null, t[r] && (t[r]._batchLocation = r)
                }, t.prototype.boundArray = function(t, e, n, r) {
                    for (var i = t.elements, o = t.ids, s = t.count, a = 0, l = 0; l < s; l++) {
                        var u = i[l],
                            h = u._batchLocation;
                        if (h >= 0 && h < r && e[h] === u) o[l] = h;
                        else
                            for (; a < r;) {
                                var c = e[a];
                                if (!c || c._batchEnabled !== n || c._batchLocation !== a) {
                                    o[l] = a, u._batchLocation = a, e[a] = u;
                                    break
                                }
                                a++
                            }
                    }
                }, t.prototype.destroy = function() {
                    this.renderer = null
                }, t
            }(),
            ir = 0,
            or = function() {
                function t(t) {
                    this.renderer = t, this.webGLVersion = 1, this.extensions = {}, this.supports = {
                        uint32Indices: !1
                    }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), t.view.addEventListener("webglcontextlost", this.handleContextLost, !1), t.view.addEventListener("webglcontextrestored", this.handleContextRestored, !1)
                }
                return Object.defineProperty(t.prototype, "isLost", {
                    get: function() {
                        return !this.gl || this.gl.isContextLost()
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.contextChange = function(t) {
                    this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = ir++, t.isContextLost() && t.getExtension("WEBGL_lose_context") && t.getExtension("WEBGL_lose_context").restoreContext()
                }, t.prototype.initFromContext = function(t) {
                    this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = ir++, this.renderer.runners.contextChange.emit(t)
                }, t.prototype.initFromOptions = function(t) {
                    var e = this.createContext(this.renderer.view, t);
                    this.initFromContext(e)
                }, t.prototype.createContext = function(t, e) {
                    var n;
                    if (St.PREFER_ENV >= ot.WEBGL2 && (n = t.getContext("webgl2", e)), n) this.webGLVersion = 2;
                    else if (this.webGLVersion = 1, !(n = t.getContext("webgl", e) || t.getContext("experimental-webgl", e))) throw new Error("This browser does not support WebGL. Try using the canvas renderer");
                    return this.gl = n, this.getExtensions(), this.gl
                }, t.prototype.getExtensions = function() {
                    var t = this.gl,
                        e = {
                            anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
                            floatTextureLinear: t.getExtension("OES_texture_float_linear"),
                            s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
                            s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
                            etc: t.getExtension("WEBGL_compressed_texture_etc"),
                            etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
                            pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                            atc: t.getExtension("WEBGL_compressed_texture_atc"),
                            astc: t.getExtension("WEBGL_compressed_texture_astc")
                        };
                    1 === this.webGLVersion ? Object.assign(this.extensions, e, {
                        drawBuffers: t.getExtension("WEBGL_draw_buffers"),
                        depthTexture: t.getExtension("WEBGL_depth_texture"),
                        loseContext: t.getExtension("WEBGL_lose_context"),
                        vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
                        uint32ElementIndex: t.getExtension("OES_element_index_uint"),
                        floatTexture: t.getExtension("OES_texture_float"),
                        floatTextureLinear: t.getExtension("OES_texture_float_linear"),
                        textureHalfFloat: t.getExtension("OES_texture_half_float"),
                        textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear")
                    }) : 2 === this.webGLVersion && Object.assign(this.extensions, e, {
                        colorBufferFloat: t.getExtension("EXT_color_buffer_float")
                    })
                }, t.prototype.handleContextLost = function(t) {
                    t.preventDefault()
                }, t.prototype.handleContextRestored = function() {
                    this.renderer.runners.contextChange.emit(this.gl)
                }, t.prototype.destroy = function() {
                    var t = this.renderer.view;
                    this.renderer = null, t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext()
                }, t.prototype.postrender = function() {
                    this.renderer.renderingToScreen && this.gl.flush()
                }, t.prototype.validateContext = function(t) {
                    var e = t.getContextAttributes(),
                        n = "WebGL2RenderingContext" in globalThis && t instanceof globalThis.WebGL2RenderingContext;
                    n && (this.webGLVersion = 2), e.stencil || console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
                    var r = n || !!t.getExtension("OES_element_index_uint");
                    this.supports.uint32Indices = r, r || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly")
                }, t
            }(),
            sr = function(t) {
                this.framebuffer = t, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = Et.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0
            },
            ar = new ue,
            lr = function() {
                function t(t) {
                    this.renderer = t, this.managedFramebuffers = [], this.unknownFramebuffer = new On(10, 10), this.msaaSamples = null
                }
                return t.prototype.contextChange = function() {
                    var t = this.gl = this.renderer.gl;
                    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new ue, this.hasMRT = !0, this.writeDepthTexture = !0, this.disposeAll(!0), 1 === this.renderer.context.webGLVersion) {
                        var e = this.renderer.context.extensions.drawBuffers,
                            n = this.renderer.context.extensions.depthTexture;
                        St.PREFER_ENV === ot.WEBGL_LEGACY && (e = null, n = null), e ? t.drawBuffers = function(t) {
                            return e.drawBuffersWEBGL(t)
                        } : (this.hasMRT = !1, t.drawBuffers = function() {}), n || (this.writeDepthTexture = !1)
                    } else this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES)
                }, t.prototype.bind = function(t, e, n) {
                    void 0 === n && (n = 0);
                    var r = this.gl;
                    if (t) {
                        var i = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
                        this.current !== t && (this.current = t, r.bindFramebuffer(r.FRAMEBUFFER, i.framebuffer)), i.mipLevel !== n && (t.dirtyId++, t.dirtyFormat++, i.mipLevel = n), i.dirtyId !== t.dirtyId && (i.dirtyId = t.dirtyId, i.dirtyFormat !== t.dirtyFormat ? (i.dirtyFormat = t.dirtyFormat, i.dirtySize = t.dirtySize, this.updateFramebuffer(t, n)) : i.dirtySize !== t.dirtySize && (i.dirtySize = t.dirtySize, this.resizeFramebuffer(t)));
                        for (var o = 0; o < t.colorTextures.length; o++) {
                            var s = t.colorTextures[o];
                            this.renderer.texture.unbind(s.parentTextureArray || s)
                        }
                        if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture), e) {
                            var a = e.width >> n,
                                l = e.height >> n,
                                u = a / e.width;
                            this.setViewport(e.x * u, e.y * u, a, l)
                        } else a = t.width >> n, l = t.height >> n, this.setViewport(0, 0, a, l)
                    } else this.current && (this.current = null, r.bindFramebuffer(r.FRAMEBUFFER, null)), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height)
                }, t.prototype.setViewport = function(t, e, n, r) {
                    var i = this.viewport;
                    t = Math.round(t), e = Math.round(e), n = Math.round(n), r = Math.round(r), i.width === n && i.height === r && i.x === t && i.y === e || (i.x = t, i.y = e, i.width = n, i.height = r, this.gl.viewport(t, e, n, r))
                }, Object.defineProperty(t.prototype, "size", {
                    get: function() {
                        return this.current ? {
                            x: 0,
                            y: 0,
                            width: this.current.width,
                            height: this.current.height
                        } : {
                            x: 0,
                            y: 0,
                            width: this.renderer.width,
                            height: this.renderer.height
                        }
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.clear = function(t, e, n, r, i) {
                    void 0 === i && (i = at.COLOR | at.DEPTH);
                    var o = this.gl;
                    o.clearColor(t, e, n, r), o.clear(i)
                }, t.prototype.initFramebuffer = function(t) {
                    var e = this.gl,
                        n = new sr(e.createFramebuffer());
                    return n.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = n, this.managedFramebuffers.push(t), t.disposeRunner.add(this), n
                }, t.prototype.resizeFramebuffer = function(t) {
                    var e = this.gl,
                        n = t.glFramebuffers[this.CONTEXT_UID];
                    n.msaaBuffer && (e.bindRenderbuffer(e.RENDERBUFFER, n.msaaBuffer), e.renderbufferStorageMultisample(e.RENDERBUFFER, n.multisample, e.RGBA8, t.width, t.height)), n.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, n.stencil), n.msaaBuffer ? e.renderbufferStorageMultisample(e.RENDERBUFFER, n.multisample, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height));
                    var r = t.colorTextures,
                        i = r.length;
                    e.drawBuffers || (i = Math.min(i, 1));
                    for (var o = 0; o < i; o++) {
                        var s = r[o],
                            a = s.parentTextureArray || s;
                        this.renderer.texture.bind(a, 0)
                    }
                    t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0)
                }, t.prototype.updateFramebuffer = function(t, e) {
                    var n = this.gl,
                        r = t.glFramebuffers[this.CONTEXT_UID],
                        i = t.colorTextures,
                        o = i.length;
                    n.drawBuffers || (o = Math.min(o, 1)), r.multisample > 1 && this.canMultisampleFramebuffer(t) ? (r.msaaBuffer = r.msaaBuffer || n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, r.msaaBuffer), n.renderbufferStorageMultisample(n.RENDERBUFFER, r.multisample, n.RGBA8, t.width, t.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, r.msaaBuffer)) : r.msaaBuffer && (n.deleteRenderbuffer(r.msaaBuffer), r.msaaBuffer = null, r.blitFramebuffer && (r.blitFramebuffer.dispose(), r.blitFramebuffer = null));
                    for (var s = [], a = 0; a < o; a++) {
                        var l = i[a],
                            u = l.parentTextureArray || l;
                        this.renderer.texture.bind(u, 0), 0 === a && r.msaaBuffer || (n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + a, l.target, u._glTextures[this.CONTEXT_UID].texture, e), s.push(n.COLOR_ATTACHMENT0 + a))
                    }
                    if (s.length > 1 && n.drawBuffers(s), t.depthTexture && this.writeDepthTexture) {
                        var h = t.depthTexture;
                        this.renderer.texture.bind(h, 0), n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, h._glTextures[this.CONTEXT_UID].texture, e)
                    }!t.stencil && !t.depth || t.depthTexture && this.writeDepthTexture ? r.stencil && (n.deleteRenderbuffer(r.stencil), r.stencil = null) : (r.stencil = r.stencil || n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, r.stencil), r.msaaBuffer ? n.renderbufferStorageMultisample(n.RENDERBUFFER, r.multisample, n.DEPTH24_STENCIL8, t.width, t.height) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, t.width, t.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, r.stencil))
                }, t.prototype.canMultisampleFramebuffer = function(t) {
                    return 1 !== this.renderer.context.webGLVersion && t.colorTextures.length <= 1 && !t.depthTexture
                }, t.prototype.detectSamples = function(t) {
                    var e = this.msaaSamples,
                        n = Et.NONE;
                    if (t <= 1 || null === e) return n;
                    for (var r = 0; r < e.length; r++)
                        if (e[r] <= t) {
                            n = e[r];
                            break
                        } return 1 === n && (n = Et.NONE), n
                }, t.prototype.blit = function(t, e, n) {
                    var r = this,
                        i = r.current,
                        o = r.renderer,
                        s = r.gl,
                        a = r.CONTEXT_UID;
                    if (2 === o.context.webGLVersion && i) {
                        var l = i.glFramebuffers[a];
                        if (l) {
                            if (!t) {
                                if (!l.msaaBuffer) return;
                                var u = i.colorTextures[0];
                                if (!u) return;
                                l.blitFramebuffer || (l.blitFramebuffer = new On(i.width, i.height), l.blitFramebuffer.addColorTexture(0, u)), (t = l.blitFramebuffer).colorTextures[0] !== u && (t.colorTextures[0] = u, t.dirtyId++, t.dirtyFormat++), t.width === i.width && t.height === i.height || (t.width = i.width, t.height = i.height, t.dirtyId++, t.dirtySize++)
                            }
                            e || ((e = ar).width = i.width, e.height = i.height), n || (n = e);
                            var h = e.width === n.width && e.height === n.height;
                            this.bind(t), s.bindFramebuffer(s.READ_FRAMEBUFFER, l.framebuffer), s.blitFramebuffer(e.left, e.top, e.right, e.bottom, n.left, n.top, n.right, n.bottom, s.COLOR_BUFFER_BIT, h ? s.NEAREST : s.LINEAR)
                        }
                    }
                }, t.prototype.disposeFramebuffer = function(t, e) {
                    var n = t.glFramebuffers[this.CONTEXT_UID],
                        r = this.gl;
                    if (n) {
                        delete t.glFramebuffers[this.CONTEXT_UID];
                        var i = this.managedFramebuffers.indexOf(t);
                        i >= 0 && this.managedFramebuffers.splice(i, 1), t.disposeRunner.remove(this), e || (r.deleteFramebuffer(n.framebuffer), n.msaaBuffer && r.deleteRenderbuffer(n.msaaBuffer), n.stencil && r.deleteRenderbuffer(n.stencil)), n.blitFramebuffer && n.blitFramebuffer.dispose()
                    }
                }, t.prototype.disposeAll = function(t) {
                    var e = this.managedFramebuffers;
                    this.managedFramebuffers = [];
                    for (var n = 0; n < e.length; n++) this.disposeFramebuffer(e[n], t)
                }, t.prototype.forceStencil = function() {
                    var t = this.current;
                    if (t) {
                        var e = t.glFramebuffers[this.CONTEXT_UID];
                        if (e && !e.stencil) {
                            t.stencil = !0;
                            var n = t.width,
                                r = t.height,
                                i = this.gl,
                                o = i.createRenderbuffer();
                            i.bindRenderbuffer(i.RENDERBUFFER, o), e.msaaBuffer ? i.renderbufferStorageMultisample(i.RENDERBUFFER, e.multisample, i.DEPTH24_STENCIL8, n, r) : i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, n, r), e.stencil = o, i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, o)
                        }
                    }
                }, t.prototype.reset = function() {
                    this.current = this.unknownFramebuffer, this.viewport = new ue
                }, t.prototype.destroy = function() {
                    this.renderer = null
                }, t
            }(),
            ur = {
                5126: 4,
                5123: 2,
                5121: 1
            },
            hr = function() {
                function t(t) {
                    this.renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {}
                }
                return t.prototype.contextChange = function() {
                    this.disposeAll(!0);
                    var t = this.gl = this.renderer.gl,
                        e = this.renderer.context;
                    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, 2 !== e.webGLVersion) {
                        var n = this.renderer.context.extensions.vertexArrayObject;
                        St.PREFER_ENV === ot.WEBGL_LEGACY && (n = null), n ? (t.createVertexArray = function() {
                            return n.createVertexArrayOES()
                        }, t.bindVertexArray = function(t) {
                            return n.bindVertexArrayOES(t)
                        }, t.deleteVertexArray = function(t) {
                            return n.deleteVertexArrayOES(t)
                        }) : (this.hasVao = !1, t.createVertexArray = function() {
                            return null
                        }, t.bindVertexArray = function() {
                            return null
                        }, t.deleteVertexArray = function() {
                            return null
                        })
                    }
                    if (2 !== e.webGLVersion) {
                        var r = t.getExtension("ANGLE_instanced_arrays");
                        r ? (t.vertexAttribDivisor = function(t, e) {
                            return r.vertexAttribDivisorANGLE(t, e)
                        }, t.drawElementsInstanced = function(t, e, n, i, o) {
                            return r.drawElementsInstancedANGLE(t, e, n, i, o)
                        }, t.drawArraysInstanced = function(t, e, n, i) {
                            return r.drawArraysInstancedANGLE(t, e, n, i)
                        }) : this.hasInstance = !1
                    }
                    this.canUseUInt32ElementIndex = 2 === e.webGLVersion || !!e.extensions.uint32ElementIndex
                }, t.prototype.bind = function(t, e) {
                    e = e || this.renderer.shader.shader;
                    var n = this.gl,
                        r = t.glVertexArrayObjects[this.CONTEXT_UID],
                        i = !1;
                    r || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = r = {}, i = !0);
                    var o = r[e.program.id] || this.initGeometryVao(t, e, i);
                    this._activeGeometry = t, this._activeVao !== o && (this._activeVao = o, this.hasVao ? n.bindVertexArray(o) : this.activateVao(t, e.program)), this.updateBuffers()
                }, t.prototype.reset = function() {
                    this.unbind()
                }, t.prototype.updateBuffers = function() {
                    for (var t = this._activeGeometry, e = this.renderer.buffer, n = 0; n < t.buffers.length; n++) {
                        var r = t.buffers[n];
                        e.update(r)
                    }
                }, t.prototype.checkCompatibility = function(t, e) {
                    var n = t.attributes,
                        r = e.attributeData;
                    for (var i in r)
                        if (!n[i]) throw new Error('shader and geometry incompatible, geometry missing the "' + i + '" attribute')
                }, t.prototype.getSignature = function(t, e) {
                    var n = t.attributes,
                        r = e.attributeData,
                        i = ["g", t.id];
                    for (var o in n) r[o] && i.push(o, r[o].location);
                    return i.join("-")
                }, t.prototype.initGeometryVao = function(t, e, n) {
                    void 0 === n && (n = !0);
                    var r = this.gl,
                        i = this.CONTEXT_UID,
                        o = this.renderer.buffer,
                        s = e.program;
                    s.glPrograms[i] || this.renderer.shader.generateProgram(e), this.checkCompatibility(t, s);
                    var a = this.getSignature(t, s),
                        l = t.glVertexArrayObjects[this.CONTEXT_UID],
                        u = l[a];
                    if (u) return l[s.id] = u, u;
                    var h = t.buffers,
                        c = t.attributes,
                        d = {},
                        p = {};
                    for (var f in h) d[f] = 0, p[f] = 0;
                    for (var f in c) !c[f].size && s.attributeData[f] ? c[f].size = s.attributeData[f].size : c[f].size || console.warn("PIXI Geometry attribute '" + f + "' size cannot be determined (likely the bound shader does not have the attribute)"), d[c[f].buffer] += c[f].size * ur[c[f].type];
                    for (var f in c) {
                        var m = c[f],
                            g = m.size;
                        void 0 === m.stride && (d[m.buffer] === g * ur[m.type] ? m.stride = 0 : m.stride = d[m.buffer]), void 0 === m.start && (m.start = p[m.buffer], p[m.buffer] += g * ur[m.type])
                    }
                    u = r.createVertexArray(), r.bindVertexArray(u);
                    for (var v = 0; v < h.length; v++) {
                        var _ = h[v];
                        o.bind(_), n && _._glBuffers[i].refCount++
                    }
                    return this.activateVao(t, s), this._activeVao = u, l[s.id] = u, l[a] = u, u
                }, t.prototype.disposeGeometry = function(t, e) {
                    var n;
                    if (this.managedGeometries[t.id]) {
                        delete this.managedGeometries[t.id];
                        var r = t.glVertexArrayObjects[this.CONTEXT_UID],
                            i = this.gl,
                            o = t.buffers,
                            s = null === (n = this.renderer) || void 0 === n ? void 0 : n.buffer;
                        if (t.disposeRunner.remove(this), r) {
                            if (s)
                                for (var a = 0; a < o.length; a++) {
                                    var l = o[a]._glBuffers[this.CONTEXT_UID];
                                    l && (l.refCount--, 0 !== l.refCount || e || s.dispose(o[a], e))
                                }
                            if (!e)
                                for (var u in r)
                                    if ("g" === u[0]) {
                                        var h = r[u];
                                        this._activeVao === h && this.unbind(), i.deleteVertexArray(h)
                                    } delete t.glVertexArrayObjects[this.CONTEXT_UID]
                        }
                    }
                }, t.prototype.disposeAll = function(t) {
                    for (var e = Object.keys(this.managedGeometries), n = 0; n < e.length; n++) this.disposeGeometry(this.managedGeometries[e[n]], t)
                }, t.prototype.activateVao = function(t, e) {
                    var n = this.gl,
                        r = this.CONTEXT_UID,
                        i = this.renderer.buffer,
                        o = t.buffers,
                        s = t.attributes;
                    t.indexBuffer && i.bind(t.indexBuffer);
                    var a = null;
                    for (var l in s) {
                        var u = s[l],
                            h = o[u.buffer],
                            c = h._glBuffers[r];
                        if (e.attributeData[l]) {
                            a !== c && (i.bind(h), a = c);
                            var d = e.attributeData[l].location;
                            if (n.enableVertexAttribArray(d), n.vertexAttribPointer(d, u.size, u.type || n.FLOAT, u.normalized, u.stride, u.start), u.instance) {
                                if (!this.hasInstance) throw new Error("geometry error, GPU Instancing is not supported on this device");
                                n.vertexAttribDivisor(d, 1)
                            }
                        }
                    }
                }, t.prototype.draw = function(t, e, n, r) {
                    var i = this.gl,
                        o = this._activeGeometry;
                    if (o.indexBuffer) {
                        var s = o.indexBuffer.data.BYTES_PER_ELEMENT,
                            a = 2 === s ? i.UNSIGNED_SHORT : i.UNSIGNED_INT;
                        2 === s || 4 === s && this.canUseUInt32ElementIndex ? o.instanced ? i.drawElementsInstanced(t, e || o.indexBuffer.data.length, a, (n || 0) * s, r || 1) : i.drawElements(t, e || o.indexBuffer.data.length, a, (n || 0) * s) : console.warn("unsupported index buffer type: uint32")
                    } else o.instanced ? i.drawArraysInstanced(t, n, e || o.getSize(), r || 1) : i.drawArrays(t, n, e || o.getSize());
                    return this
                }, t.prototype.unbind = function() {
                    this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null
                }, t.prototype.destroy = function() {
                    this.renderer = null
                }, t
            }(),
            cr = function() {
                function t(t) {
                    void 0 === t && (t = null), this.type = bt.NONE, this.autoDetect = !0, this.maskObject = t || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = St.FILTER_MULTISAMPLE, this.enabled = !0, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._target = null
                }
                return Object.defineProperty(t.prototype, "filter", {
                    get: function() {
                        return this._filters ? this._filters[0] : null
                    },
                    set: function(t) {
                        t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.reset = function() {
                    this.pooled && (this.maskObject = null, this.type = bt.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null
                }, t.prototype.copyCountersOrReset = function(t) {
                    t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null)
                }, t
            }();

        function dr(t, e, n) {
            var r = t.createShader(e);
            return t.shaderSource(r, n), t.compileShader(r), r
        }

        function pr(t, e) {
            var n = t.getShaderSource(e).split("\n").map((function(t, e) {
                    return e + ": " + t
                })),
                r = t.getShaderInfoLog(e),
                i = r.split("\n"),
                o = {},
                s = i.map((function(t) {
                    return parseFloat(t.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))
                })).filter((function(t) {
                    return !(!t || o[t] || (o[t] = !0, 0))
                })),
                a = [""];
            s.forEach((function(t) {
                n[t - 1] = "%c" + n[t - 1] + "%c", a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px")
            }));
            var l = n.join("\n");
            a[0] = l, console.error(r), console.groupCollapsed("click to view full shader code"), console.warn.apply(console, a), console.groupEnd()
        }

        function fr(t) {
            for (var e = new Array(t), n = 0; n < e.length; n++) e[n] = !1;
            return e
        }

        function mr(t, e) {
            switch (t) {
                case "float":
                    return 0;
                case "vec2":
                    return new Float32Array(2 * e);
                case "vec3":
                    return new Float32Array(3 * e);
                case "vec4":
                    return new Float32Array(4 * e);
                case "int":
                case "uint":
                case "sampler2D":
                case "sampler2DArray":
                    return 0;
                case "ivec2":
                    return new Int32Array(2 * e);
                case "ivec3":
                    return new Int32Array(3 * e);
                case "ivec4":
                    return new Int32Array(4 * e);
                case "uvec2":
                    return new Uint32Array(2 * e);
                case "uvec3":
                    return new Uint32Array(3 * e);
                case "uvec4":
                    return new Uint32Array(4 * e);
                case "bool":
                    return !1;
                case "bvec2":
                    return fr(2 * e);
                case "bvec3":
                    return fr(3 * e);
                case "bvec4":
                    return fr(4 * e);
                case "mat2":
                    return new Float32Array([1, 0, 0, 1]);
                case "mat3":
                    return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
                case "mat4":
                    return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
            }
            return null
        }
        var gr, vr = {},
            _r = vr;

        function yr(t, e, n) {
            if ("precision" !== t.substring(0, 9)) {
                var r = e;
                return e === xt.HIGH && n !== xt.HIGH && (r = xt.MEDIUM), "precision " + r + " float;\n" + t
            }
            return n !== xt.HIGH && "precision highp" === t.substring(0, 15) ? t.replace("precision highp", "precision mediump") : t
        }
        var xr = {
            float: 1,
            vec2: 2,
            vec3: 3,
            vec4: 4,
            int: 1,
            ivec2: 2,
            ivec3: 3,
            ivec4: 4,
            uint: 1,
            uvec2: 2,
            uvec3: 3,
            uvec4: 4,
            bool: 1,
            bvec2: 2,
            bvec3: 3,
            bvec4: 4,
            mat2: 4,
            mat3: 9,
            mat4: 16,
            sampler2D: 1
        };

        function br(t) {
            return xr[t]
        }
        var Er = null,
            Tr = {
                FLOAT: "float",
                FLOAT_VEC2: "vec2",
                FLOAT_VEC3: "vec3",
                FLOAT_VEC4: "vec4",
                INT: "int",
                INT_VEC2: "ivec2",
                INT_VEC3: "ivec3",
                INT_VEC4: "ivec4",
                UNSIGNED_INT: "uint",
                UNSIGNED_INT_VEC2: "uvec2",
                UNSIGNED_INT_VEC3: "uvec3",
                UNSIGNED_INT_VEC4: "uvec4",
                BOOL: "bool",
                BOOL_VEC2: "bvec2",
                BOOL_VEC3: "bvec3",
                BOOL_VEC4: "bvec4",
                FLOAT_MAT2: "mat2",
                FLOAT_MAT3: "mat3",
                FLOAT_MAT4: "mat4",
                SAMPLER_2D: "sampler2D",
                INT_SAMPLER_2D: "sampler2D",
                UNSIGNED_INT_SAMPLER_2D: "sampler2D",
                SAMPLER_CUBE: "samplerCube",
                INT_SAMPLER_CUBE: "samplerCube",
                UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
                SAMPLER_2D_ARRAY: "sampler2DArray",
                INT_SAMPLER_2D_ARRAY: "sampler2DArray",
                UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
            };

        function Sr(t, e) {
            if (!Er) {
                var n = Object.keys(Tr);
                Er = {};
                for (var r = 0; r < n.length; ++r) {
                    var i = n[r];
                    Er[t[i]] = Tr[i]
                }
            }
            return Er[e]
        }
        var wr, Mr = [{
                test: function(t) {
                    return "float" === t.type && 1 === t.size
                },
                code: function(t) {
                    return '\n            if(uv["' + t + '"] !== ud["' + t + '"].value)\n            {\n                ud["' + t + '"].value = uv["' + t + '"]\n                gl.uniform1f(ud["' + t + '"].location, uv["' + t + '"])\n            }\n            '
                }
            }, {
                test: function(t) {
                    return ("sampler2D" === t.type || "samplerCube" === t.type || "sampler2DArray" === t.type) && 1 === t.size && !t.isArray
                },
                code: function(t) {
                    return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + t + '"], t);\n\n            if(ud["' + t + '"].value !== t)\n            {\n                ud["' + t + '"].value = t;\n                gl.uniform1i(ud["' + t + '"].location, t);\n; // eslint-disable-line max-len\n            }'
                }
            }, {
                test: function(t, e) {
                    return "mat3" === t.type && 1 === t.size && void 0 !== e.a
                },
                code: function(t) {
                    return '\n            gl.uniformMatrix3fv(ud["' + t + '"].location, false, uv["' + t + '"].toArray(true));\n            '
                },
                codeUbo: function(t) {
                    return "\n                var " + t + "_matrix = uv." + t + ".toArray(true);\n\n                data[offset] = " + t + "_matrix[0];\n                data[offset+1] = " + t + "_matrix[1];\n                data[offset+2] = " + t + "_matrix[2];\n        \n                data[offset + 4] = " + t + "_matrix[3];\n                data[offset + 5] = " + t + "_matrix[4];\n                data[offset + 6] = " + t + "_matrix[5];\n        \n                data[offset + 8] = " + t + "_matrix[6];\n                data[offset + 9] = " + t + "_matrix[7];\n                data[offset + 10] = " + t + "_matrix[8];\n            "
                }
            }, {
                test: function(t, e) {
                    return "vec2" === t.type && 1 === t.size && void 0 !== e.x
                },
                code: function(t) {
                    return '\n                cv = ud["' + t + '"].value;\n                v = uv["' + t + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + t + '"].location, v.x, v.y);\n                }'
                },
                codeUbo: function(t) {
                    return "\n                v = uv." + t + ";\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            "
                }
            }, {
                test: function(t) {
                    return "vec2" === t.type && 1 === t.size
                },
                code: function(t) {
                    return '\n                cv = ud["' + t + '"].value;\n                v = uv["' + t + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + t + '"].location, v[0], v[1]);\n                }\n            '
                }
            }, {
                test: function(t, e) {
                    return "vec4" === t.type && 1 === t.size && void 0 !== e.width
                },
                code: function(t) {
                    return '\n                cv = ud["' + t + '"].value;\n                v = uv["' + t + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + t + '"].location, v.x, v.y, v.width, v.height)\n                }'
                },
                codeUbo: function(t) {
                    return "\n                    v = uv." + t + ";\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                "
                }
            }, {
                test: function(t) {
                    return "vec4" === t.type && 1 === t.size
                },
                code: function(t) {
                    return '\n                cv = ud["' + t + '"].value;\n                v = uv["' + t + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + t + '"].location, v[0], v[1], v[2], v[3])\n                }'
                }
            }],
            Ar = {
                float: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }",
                vec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }",
                vec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
                vec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }",
                int: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
                ivec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
                ivec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
                ivec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
                uint: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }",
                uvec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }",
                uvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }",
                uvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }",
                bool: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }",
                bvec2: "\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
                bvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
                bvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
                mat2: "gl.uniformMatrix2fv(location, false, v)",
                mat3: "gl.uniformMatrix3fv(location, false, v)",
                mat4: "gl.uniformMatrix4fv(location, false, v)",
                sampler2D: "gl.uniform1i(location, v)",
                samplerCube: "gl.uniform1i(location, v)",
                sampler2DArray: "gl.uniform1i(location, v)"
            },
            Rr = {
                float: "gl.uniform1fv(location, v)",
                vec2: "gl.uniform2fv(location, v)",
                vec3: "gl.uniform3fv(location, v)",
                vec4: "gl.uniform4fv(location, v)",
                mat4: "gl.uniformMatrix4fv(location, false, v)",
                mat3: "gl.uniformMatrix3fv(location, false, v)",
                mat2: "gl.uniformMatrix2fv(location, false, v)",
                int: "gl.uniform1iv(location, v)",
                ivec2: "gl.uniform2iv(location, v)",
                ivec3: "gl.uniform3iv(location, v)",
                ivec4: "gl.uniform4iv(location, v)",
                uint: "gl.uniform1uiv(location, v)",
                uvec2: "gl.uniform2uiv(location, v)",
                uvec3: "gl.uniform3uiv(location, v)",
                uvec4: "gl.uniform4uiv(location, v)",
                bool: "gl.uniform1iv(location, v)",
                bvec2: "gl.uniform2iv(location, v)",
                bvec3: "gl.uniform3iv(location, v)",
                bvec4: "gl.uniform4iv(location, v)",
                sampler2D: "gl.uniform1iv(location, v)",
                samplerCube: "gl.uniform1iv(location, v)",
                sampler2DArray: "gl.uniform1iv(location, v)"
            },
            Pr = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join("\n");

        function Ir(t) {
            for (var e = "", n = 0; n < t; ++n) n > 0 && (e += "\nelse "), n < t - 1 && (e += "if(test == " + n + ".0){}");
            return e
        }
        var Cr = 0,
            Or = {},
            Lr = function() {
                function t(e, n, r) {
                    void 0 === r && (r = "pixi-shader"), this.id = Cr++, this.vertexSrc = e || t.defaultVertexSrc, this.fragmentSrc = n || t.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), "#version" !== this.vertexSrc.substring(0, 8) && (r = r.replace(/\s+/g, "-"), Or[r] ? (Or[r]++, r += "-" + Or[r]) : Or[r] = 1, this.vertexSrc = "#define SHADER_NAME " + r + "\n" + this.vertexSrc, this.fragmentSrc = "#define SHADER_NAME " + r + "\n" + this.fragmentSrc, this.vertexSrc = yr(this.vertexSrc, St.PRECISION_VERTEX, xt.HIGH), this.fragmentSrc = yr(this.fragmentSrc, St.PRECISION_FRAGMENT, function() {
                        if (!gr) {
                            gr = xt.MEDIUM;
                            var t = function() {
                                if (_r === vr || _r && _r.isContextLost()) {
                                    var t = document.createElement("canvas"),
                                        e = void 0;
                                    St.PREFER_ENV >= ot.WEBGL2 && (e = t.getContext("webgl2", {})), e || ((e = t.getContext("webgl", {}) || t.getContext("experimental-webgl", {})) ? e.getExtension("WEBGL_draw_buffers") : e = null), _r = e
                                }
                                return _r
                            }();
                            if (t && t.getShaderPrecisionFormat) {
                                var e = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT);
                                gr = e.precision ? xt.HIGH : xt.MEDIUM
                            }
                        }
                        return gr
                    }())), this.glPrograms = {}, this.syncUniforms = null
                }
                return Object.defineProperty(t, "defaultVertexSrc", {
                    get: function() {
                        return "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n"
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t, "defaultFragmentSrc", {
                    get: function() {
                        return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}"
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.from = function(e, n, r) {
                    var i = e + n,
                        o = Qt[i];
                    return o || (Qt[i] = o = new t(e, n, r)), o
                }, t
            }(),
            Nr = function() {
                function t(t, e) {
                    this.uniformBindCount = 0, this.program = t, this.uniformGroup = e ? e instanceof Jn ? e : new Jn(e) : new Jn({})
                }
                return t.prototype.checkUniformExists = function(t, e) {
                    if (e.uniforms[t]) return !0;
                    for (var n in e.uniforms) {
                        var r = e.uniforms[n];
                        if (r.group && this.checkUniformExists(t, r)) return !0
                    }
                    return !1
                }, t.prototype.destroy = function() {
                    this.uniformGroup = null
                }, Object.defineProperty(t.prototype, "uniforms", {
                    get: function() {
                        return this.uniformGroup.uniforms
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.from = function(e, n, r) {
                    return new t(Lr.from(e, n), r)
                }, t
            }(),
            Dr = function() {
                function t() {
                    this.data = 0, this.blendMode = lt.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0
                }
                return Object.defineProperty(t.prototype, "blend", {
                    get: function() {
                        return !!(1 & this.data)
                    },
                    set: function(t) {
                        !!(1 & this.data) !== t && (this.data ^= 1)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "offsets", {
                    get: function() {
                        return !!(2 & this.data)
                    },
                    set: function(t) {
                        !!(2 & this.data) !== t && (this.data ^= 2)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "culling", {
                    get: function() {
                        return !!(4 & this.data)
                    },
                    set: function(t) {
                        !!(4 & this.data) !== t && (this.data ^= 4)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "depthTest", {
                    get: function() {
                        return !!(8 & this.data)
                    },
                    set: function(t) {
                        !!(8 & this.data) !== t && (this.data ^= 8)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "depthMask", {
                    get: function() {
                        return !!(32 & this.data)
                    },
                    set: function(t) {
                        !!(32 & this.data) !== t && (this.data ^= 32)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "clockwiseFrontFace", {
                    get: function() {
                        return !!(16 & this.data)
                    },
                    set: function(t) {
                        !!(16 & this.data) !== t && (this.data ^= 16)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "blendMode", {
                    get: function() {
                        return this._blendMode
                    },
                    set: function(t) {
                        this.blend = t !== lt.NONE, this._blendMode = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "polygonOffset", {
                    get: function() {
                        return this._polygonOffset
                    },
                    set: function(t) {
                        this.offsets = !!t, this._polygonOffset = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.toString = function() {
                    return "[@pixi/core:State blendMode=" + this.blendMode + " clockwiseFrontFace=" + this.clockwiseFrontFace + " culling=" + this.culling + " depthMask=" + this.depthMask + " polygonOffset=" + this.polygonOffset + "]"
                }, t.for2d = function() {
                    var e = new t;
                    return e.depthTest = !1, e.blend = !0, e
                }, t
            }(),
            Ur = function(t) {
                function e(n, r, i) {
                    var o = this,
                        s = Lr.from(n || e.defaultVertexSrc, r || e.defaultFragmentSrc);
                    return (o = t.call(this, s, i) || this).padding = 0, o.resolution = St.FILTER_RESOLUTION, o.multisample = St.FILTER_MULTISAMPLE, o.enabled = !0, o.autoFit = !0, o.state = new Dr, o
                }
                return mn(e, t), e.prototype.apply = function(t, e, n, r, i) {
                    t.applyFilter(this, e, n, r)
                }, Object.defineProperty(e.prototype, "blendMode", {
                    get: function() {
                        return this.state.blendMode
                    },
                    set: function(t) {
                        this.state.blendMode = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "resolution", {
                    get: function() {
                        return this._resolution
                    },
                    set: function(t) {
                        this._resolution = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "defaultVertexSrc", {
                    get: function() {
                        return "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n"
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, "defaultFragmentSrc", {
                    get: function() {
                        return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n"
                    },
                    enumerable: !1,
                    configurable: !0
                }), e
            }(Nr),
            Fr = new me,
            Br = function() {
                function t(t, e) {
                    this._texture = t, this.mapCoord = new me, this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = void 0 === e ? .5 : e, this.isSimple = !1
                }
                return Object.defineProperty(t.prototype, "texture", {
                    get: function() {
                        return this._texture
                    },
                    set: function(t) {
                        this._texture = t, this._textureID = -1
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.multiplyUvs = function(t, e) {
                    void 0 === e && (e = t);
                    for (var n = this.mapCoord, r = 0; r < t.length; r += 2) {
                        var i = t[r],
                            o = t[r + 1];
                        e[r] = i * n.a + o * n.c + n.tx, e[r + 1] = i * n.b + o * n.d + n.ty
                    }
                    return e
                }, t.prototype.update = function(t) {
                    var e = this._texture;
                    if (!e || !e.valid) return !1;
                    if (!t && this._textureID === e._updateID) return !1;
                    this._textureID = e._updateID, this._updateID++;
                    var n = e._uvs;
                    this.mapCoord.set(n.x1 - n.x0, n.y1 - n.y0, n.x3 - n.x0, n.y3 - n.y0, n.x0, n.y0);
                    var r = e.orig,
                        i = e.trim;
                    i && (Fr.set(r.width / i.width, 0, 0, r.height / i.height, -i.x / i.width, -i.y / i.height), this.mapCoord.append(Fr));
                    var o = e.baseTexture,
                        s = this.uClampFrame,
                        a = this.clampMargin / o.resolution,
                        l = this.clampOffset;
                    return s[0] = (e._frame.x + a + l) / o.width, s[1] = (e._frame.y + a + l) / o.height, s[2] = (e._frame.x + e._frame.width - a + l) / o.width, s[3] = (e._frame.y + e._frame.height - a + l) / o.height, this.uClampOffset[0] = l / o.realWidth, this.uClampOffset[1] = l / o.realHeight, this.isSimple = e._frame.width === o.width && e._frame.height === o.height && 0 === e.rotate, !0
                }, t
            }(),
            kr = function(t) {
                function e(e, n, r) {
                    var i = this,
                        o = null;
                    return "string" != typeof e && void 0 === n && void 0 === r && (o = e, e = void 0, n = void 0, r = void 0), (i = t.call(this, e || "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n", n || "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n", r) || this).maskSprite = o, i.maskMatrix = new me, i
                }
                return mn(e, t), Object.defineProperty(e.prototype, "maskSprite", {
                    get: function() {
                        return this._maskSprite
                    },
                    set: function(t) {
                        this._maskSprite = t, this._maskSprite && (this._maskSprite.renderable = !1)
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype.apply = function(t, e, n, r) {
                    var i = this._maskSprite,
                        o = i._texture;
                    o.valid && (o.uvMatrix || (o.uvMatrix = new Br(o, 0)), o.uvMatrix.update(), this.uniforms.npmAlpha = o.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = o, this.uniforms.otherMatrix = t.calculateSpriteMatrix(this.maskMatrix, i).prepend(o.uvMatrix.mapCoord), this.uniforms.alpha = i.worldAlpha, this.uniforms.maskClamp = o.uvMatrix.uClampFrame, t.applyFilter(this, e, n, r))
                }, e
            }(Ur),
            Gr = function() {
                function t(t) {
                    this.renderer = t, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0
                }
                return t.prototype.setMaskStack = function(t) {
                    this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t)
                }, t.prototype.push = function(t, e) {
                    var n = e;
                    if (!n.isMaskData) {
                        var r = this.maskDataPool.pop() || new cr;
                        r.pooled = !0, r.maskObject = e, n = r
                    }
                    var i = 0 !== this.maskStack.length ? this.maskStack[this.maskStack.length - 1] : null;
                    if (n.copyCountersOrReset(i), n.autoDetect && this.detect(n), n._target = t, n.type !== bt.SPRITE && this.maskStack.push(n), n.enabled) switch (n.type) {
                        case bt.SCISSOR:
                            this.renderer.scissor.push(n);
                            break;
                        case bt.STENCIL:
                            this.renderer.stencil.push(n);
                            break;
                        case bt.SPRITE:
                            n.copyCountersOrReset(null), this.pushSpriteMask(n)
                    }
                    n.type === bt.SPRITE && this.maskStack.push(n)
                }, t.prototype.pop = function(t) {
                    var e = this.maskStack.pop();
                    if (e && e._target === t) {
                        if (e.enabled) switch (e.type) {
                            case bt.SCISSOR:
                                this.renderer.scissor.pop();
                                break;
                            case bt.STENCIL:
                                this.renderer.stencil.pop(e.maskObject);
                                break;
                            case bt.SPRITE:
                                this.popSpriteMask(e)
                        }
                        if (e.reset(), e.pooled && this.maskDataPool.push(e), 0 !== this.maskStack.length) {
                            var n = this.maskStack[this.maskStack.length - 1];
                            n.type === bt.SPRITE && n._filters && (n._filters[0].maskSprite = n.maskObject)
                        }
                    }
                }, t.prototype.detect = function(t) {
                    t.maskObject.isSprite ? t.type = bt.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = bt.SCISSOR : t.type = bt.STENCIL
                }, t.prototype.pushSpriteMask = function(t) {
                    var e, n, r = t.maskObject,
                        i = t._target,
                        o = t._filters;
                    o || (o = this.alphaMaskPool[this.alphaMaskIndex]) || (o = this.alphaMaskPool[this.alphaMaskIndex] = [new kr]);
                    var s, a, l = this.renderer,
                        u = l.renderTexture;
                    if (u.current) {
                        var h = u.current;
                        s = t.resolution || h.resolution, a = null !== (e = t.multisample) && void 0 !== e ? e : h.multisample
                    } else s = t.resolution || l.resolution, a = null !== (n = t.multisample) && void 0 !== n ? n : l.multisample;
                    o[0].resolution = s, o[0].multisample = a, o[0].maskSprite = r;
                    var c = i.filterArea;
                    i.filterArea = r.getBounds(!0), l.filter.push(i, o), i.filterArea = c, t._filters || this.alphaMaskIndex++
                }, t.prototype.popSpriteMask = function(t) {
                    this.renderer.filter.pop(), t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null)
                }, t.prototype.destroy = function() {
                    this.renderer = null
                }, t
            }(),
            Hr = function() {
                function t(t) {
                    this.renderer = t, this.maskStack = [], this.glConst = 0
                }
                return t.prototype.getStackLength = function() {
                    return this.maskStack.length
                }, t.prototype.setMaskStack = function(t) {
                    var e = this.renderer.gl,
                        n = this.getStackLength();
                    this.maskStack = t;
                    var r = this.getStackLength();
                    r !== n && (0 === r ? e.disable(this.glConst) : (e.enable(this.glConst), this._useCurrent()))
                }, t.prototype._useCurrent = function() {}, t.prototype.destroy = function() {
                    this.renderer = null, this.maskStack = null
                }, t
            }(),
            zr = new me,
            Vr = function(t) {
                function e(e) {
                    var n = t.call(this, e) || this;
                    return n.glConst = WebGLRenderingContext.SCISSOR_TEST, n
                }
                return mn(e, t), e.prototype.getStackLength = function() {
                    var t = this.maskStack[this.maskStack.length - 1];
                    return t ? t._scissorCounter : 0
                }, e.prototype.calcScissorRect = function(t) {
                    if (!t._scissorRectLocal) {
                        var e = t._scissorRect,
                            n = t.maskObject,
                            r = this.renderer,
                            i = r.renderTexture;
                        n.renderable = !0;
                        var o = n.getBounds();
                        this.roundFrameToPixels(o, i.current ? i.current.resolution : r.resolution, i.sourceFrame, i.destinationFrame, r.projection.transform), n.renderable = !1, e && o.fit(e), t._scissorRectLocal = o
                    }
                }, e.isMatrixRotated = function(t) {
                    if (!t) return !1;
                    var e = t.a,
                        n = t.b,
                        r = t.c,
                        i = t.d;
                    return (Math.abs(n) > 1e-4 || Math.abs(r) > 1e-4) && (Math.abs(e) > 1e-4 || Math.abs(i) > 1e-4)
                }, e.prototype.testScissor = function(t) {
                    var n = t.maskObject;
                    if (!n.isFastRect || !n.isFastRect()) return !1;
                    if (e.isMatrixRotated(n.worldTransform)) return !1;
                    if (e.isMatrixRotated(this.renderer.projection.transform)) return !1;
                    this.calcScissorRect(t);
                    var r = t._scissorRectLocal;
                    return r.width > 0 && r.height > 0
                }, e.prototype.roundFrameToPixels = function(t, n, r, i, o) {
                    e.isMatrixRotated(o) || ((o = o ? zr.copyFrom(o) : zr.identity()).translate(-r.x, -r.y).scale(i.width / r.width, i.height / r.height).translate(i.x, i.y), this.renderer.filter.transformAABB(o, t), t.fit(i), t.x = Math.round(t.x * n), t.y = Math.round(t.y * n), t.width = Math.round(t.width * n), t.height = Math.round(t.height * n))
                }, e.prototype.push = function(t) {
                    t._scissorRectLocal || this.calcScissorRect(t);
                    var e = this.renderer.gl;
                    t._scissorRect || e.enable(e.SCISSOR_TEST), t._scissorCounter++, t._scissorRect = t._scissorRectLocal, this._useCurrent()
                }, e.prototype.pop = function() {
                    var t = this.renderer.gl;
                    this.getStackLength() > 0 ? this._useCurrent() : t.disable(t.SCISSOR_TEST)
                }, e.prototype._useCurrent = function() {
                    var t, e = this.maskStack[this.maskStack.length - 1]._scissorRect;
                    t = this.renderer.renderTexture.current ? e.y : this.renderer.height - e.height - e.y, this.renderer.gl.scissor(e.x, t, e.width, e.height)
                }, e
            }(Hr),
            Wr = function(t) {
                function e(e) {
                    var n = t.call(this, e) || this;
                    return n.glConst = WebGLRenderingContext.STENCIL_TEST, n
                }
                return mn(e, t), e.prototype.getStackLength = function() {
                    var t = this.maskStack[this.maskStack.length - 1];
                    return t ? t._stencilCounter : 0
                }, e.prototype.push = function(t) {
                    var e = t.maskObject,
                        n = this.renderer.gl,
                        r = t._stencilCounter;
                    0 === r && (this.renderer.framebuffer.forceStencil(), n.clearStencil(0), n.clear(n.STENCIL_BUFFER_BIT), n.enable(n.STENCIL_TEST)), t._stencilCounter++, n.colorMask(!1, !1, !1, !1), n.stencilFunc(n.EQUAL, r, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.INCR), e.renderable = !0, e.render(this.renderer), this.renderer.batch.flush(), e.renderable = !1, this._useCurrent()
                }, e.prototype.pop = function(t) {
                    var e = this.renderer.gl;
                    0 === this.getStackLength() ? e.disable(e.STENCIL_TEST) : (e.colorMask(!1, !1, !1, !1), e.stencilOp(e.KEEP, e.KEEP, e.DECR), t.renderable = !0, t.render(this.renderer), this.renderer.batch.flush(), t.renderable = !1, this._useCurrent())
                }, e.prototype._useCurrent = function() {
                    var t = this.renderer.gl;
                    t.colorMask(!0, !0, !0, !0), t.stencilFunc(t.EQUAL, this.getStackLength(), 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP)
                }, e
            }(Hr),
            Xr = function() {
                function t(t) {
                    this.renderer = t, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new me, this.transform = null
                }
                return t.prototype.update = function(t, e, n, r) {
                    this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = e || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, n, r), this.transform && this.projectionMatrix.append(this.transform);
                    var i = this.renderer;
                    i.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, i.globalUniforms.update(), i.shader.shader && i.shader.syncUniformGroup(i.shader.shader.uniforms.globals)
                }, t.prototype.calculateProjection = function(t, e, n, r) {
                    var i = this.projectionMatrix,
                        o = r ? -1 : 1;
                    i.identity(), i.a = 1 / e.width * 2, i.d = o * (1 / e.height * 2), i.tx = -1 - e.x * i.a, i.ty = -o - e.y * i.d
                }, t.prototype.setTransform = function(t) {}, t.prototype.destroy = function() {
                    this.renderer = null
                }, t
            }(),
            jr = new ue,
            Yr = new ue,
            qr = function() {
                function t(t) {
                    this.renderer = t, this.clearColor = t._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new ue, this.destinationFrame = new ue, this.viewportFrame = new ue
                }
                return t.prototype.bind = function(t, e, n) {
                    void 0 === t && (t = null);
                    var r, i, o, s = this.renderer;
                    this.current = t, t ? (o = (r = t.baseTexture).resolution, e || (jr.width = t.frame.width, jr.height = t.frame.height, e = jr), n || (Yr.x = t.frame.x, Yr.y = t.frame.y, Yr.width = e.width, Yr.height = e.height, n = Yr), i = r.framebuffer) : (o = s.resolution, e || (jr.width = s.screen.width, jr.height = s.screen.height, e = jr), n || ((n = jr).width = e.width, n.height = e.height));
                    var a = this.viewportFrame;
                    a.x = n.x * o, a.y = n.y * o, a.width = n.width * o, a.height = n.height * o, t || (a.y = s.view.height - (a.y + a.height)), a.ceil(), this.renderer.framebuffer.bind(i, a), this.renderer.projection.update(n, e, o, !i), t ? this.renderer.mask.setMaskStack(r.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e), this.destinationFrame.copyFrom(n)
                }, t.prototype.clear = function(t, e) {
                    t = this.current ? t || this.current.baseTexture.clearColor : t || this.clearColor;
                    var n = this.destinationFrame,
                        r = this.current ? this.current.baseTexture : this.renderer.screen,
                        i = n.width !== r.width || n.height !== r.height;
                    if (i) {
                        var o = this.viewportFrame,
                            s = o.x,
                            a = o.y,
                            l = o.width,
                            u = o.height;
                        s = Math.round(s), a = Math.round(a), l = Math.round(l), u = Math.round(u), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(s, a, l, u)
                    }
                    this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e), i && this.renderer.scissor.pop()
                }, t.prototype.resize = function() {
                    this.bind(null)
                }, t.prototype.reset = function() {
                    this.bind(null)
                }, t.prototype.destroy = function() {
                    this.renderer = null
                }, t
            }();

        function Zr(t, e, n, r, i) {
            n.buffer.update(i)
        }
        var Kr = {
                float: "\n        data[offset] = v;\n    ",
                vec2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ",
                vec3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ",
                vec4: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ",
                mat2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ",
                mat3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ",
                mat4: "\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    "
            },
            Jr = {
                float: 4,
                vec2: 8,
                vec3: 12,
                vec4: 16,
                int: 4,
                ivec2: 8,
                ivec3: 12,
                ivec4: 16,
                uint: 4,
                uvec2: 8,
                uvec3: 12,
                uvec4: 16,
                bool: 4,
                bvec2: 8,
                bvec3: 12,
                bvec4: 16,
                mat2: 32,
                mat3: 48,
                mat4: 64
            };
        var Qr = function() {
            function t(t, e) {
                this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {}
            }
            return t.prototype.destroy = function() {
                this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null
            }, t
        }();
        var $r = 0,
            ti = {
                textureCount: 0,
                uboCount: 0
            },
            ei = function() {
                function t(t) {
                    this.destroyed = !1, this.renderer = t, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = $r++
                }
                return t.prototype.systemCheck = function() {
                    if (! function() {
                            if ("boolean" == typeof wr) return wr;
                            try {
                                var t = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
                                wr = !0 === t({
                                    a: "b"
                                }, "a", "b")
                            } catch (t) {
                                wr = !1
                            }
                            return wr
                        }()) throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.")
                }, t.prototype.contextChange = function(t) {
                    this.gl = t, this.reset()
                }, t.prototype.bind = function(t, e) {
                    t.uniforms.globals = this.renderer.globalUniforms;
                    var n = t.program,
                        r = n.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t);
                    return this.shader = t, this.program !== n && (this.program = n, this.gl.useProgram(r.program)), e || (ti.textureCount = 0, ti.uboCount = 0, this.syncUniformGroup(t.uniformGroup, ti)), r
                }, t.prototype.setUniforms = function(t) {
                    var e = this.shader.program,
                        n = e.glPrograms[this.renderer.CONTEXT_UID];
                    e.syncUniforms(n.uniformData, t, this.renderer)
                }, t.prototype.syncUniformGroup = function(t, e) {
                    var n = this.getGlProgram();
                    t.static && t.dirtyId === n.uniformDirtyGroups[t.id] || (n.uniformDirtyGroups[t.id] = t.dirtyId, this.syncUniforms(t, n, e))
                }, t.prototype.syncUniforms = function(t, e, n) {
                    (t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t))(e.uniformData, t.uniforms, this.renderer, n)
                }, t.prototype.createSyncGroups = function(t) {
                    var e = this.getSignature(t, this.shader.program.uniformData, "u");
                    return this.cache[e] || (this.cache[e] = function(t, e) {
                        var n, r = ["\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    "];
                        for (var i in t.uniforms) {
                            var o = e[i];
                            if (o) {
                                for (var s = t.uniforms[i], a = !1, l = 0; l < Mr.length; l++)
                                    if (Mr[l].test(o, s)) {
                                        r.push(Mr[l].code(i, s)), a = !0;
                                        break
                                    } if (!a) {
                                    var u = (1 === o.size ? Ar : Rr)[o.type].replace("location", 'ud["' + i + '"].location');
                                    r.push('\n            cu = ud["' + i + '"];\n            cv = cu.value;\n            v = uv["' + i + '"];\n            ' + u + ";")
                                }
                            } else(null === (n = t.uniforms[i]) || void 0 === n ? void 0 : n.group) && (t.uniforms[i].ubo ? r.push("\n                        renderer.shader.syncUniformBufferGroup(uv." + i + ", '" + i + "');\n                    ") : r.push("\n                        renderer.shader.syncUniformGroup(uv." + i + ", syncData);\n                    "))
                        }
                        return new Function("ud", "uv", "renderer", "syncData", r.join("\n"))
                    }(t, this.shader.program.uniformData)), t.syncUniforms[this.shader.program.id] = this.cache[e], t.syncUniforms[this.shader.program.id]
                }, t.prototype.syncUniformBufferGroup = function(t, e) {
                    var n = this.getGlProgram();
                    if (!t.static || 0 !== t.dirtyId || !n.uniformGroups[t.id]) {
                        t.dirtyId = 0;
                        var r = n.uniformGroups[t.id] || this.createSyncBufferGroup(t, n, e);
                        t.buffer.update(), r(n.uniformData, t.uniforms, this.renderer, ti, t.buffer)
                    }
                    this.renderer.buffer.bindBufferBase(t.buffer, n.uniformBufferBindings[e])
                }, t.prototype.createSyncBufferGroup = function(t, e, n) {
                    var r = this.renderer.gl;
                    this.renderer.buffer.bind(t.buffer);
                    var i = this.gl.getUniformBlockIndex(e.program, n);
                    e.uniformBufferBindings[n] = this.shader.uniformBindCount, r.uniformBlockBinding(e.program, i, this.shader.uniformBindCount), this.shader.uniformBindCount++;
                    var o = this.getSignature(t, this.shader.program.uniformData, "ubo"),
                        s = this._uboCache[o];
                    if (s || (s = this._uboCache[o] = function(t, e) {
                            if (!t.autoManage) return {
                                size: 0,
                                syncFunc: Zr
                            };
                            for (var n = function(t) {
                                    for (var e = t.map((function(t) {
                                            return {
                                                data: t,
                                                offset: 0,
                                                dataLen: 0,
                                                dirty: 0
                                            }
                                        })), n = 0, r = 0, i = 0, o = 0; o < e.length; o++) {
                                        var s = e[o];
                                        if (n = Jr[s.data.type], s.data.size > 1 && (n = Math.max(n, 16) * s.data.size), s.dataLen = n, r % n != 0 && r < 16) {
                                            var a = r % n % 16;
                                            r += a, i += a
                                        }
                                        r + n > 16 ? (i = 16 * Math.ceil(i / 16), s.offset = i, i += n, r = n) : (s.offset = i, r += n, i += n)
                                    }
                                    return {
                                        uboElements: e,
                                        size: i = 16 * Math.ceil(i / 16)
                                    }
                                }(function(t, e) {
                                    var n = [];
                                    for (var r in t) e[r] && n.push(e[r]);
                                    return n.sort((function(t, e) {
                                        return t.index - e.index
                                    })), n
                                }(t.uniforms, e)), r = n.uboElements, i = n.size, o = ["\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    "], s = 0; s < r.length; s++) {
                                for (var a = r[s], l = t.uniforms[a.data.name], u = a.data.name, h = !1, c = 0; c < Mr.length; c++) {
                                    var d = Mr[c];
                                    if (d.codeUbo && d.test(a.data, l)) {
                                        o.push("offset = " + a.offset / 4 + ";", Mr[c].codeUbo(a.data.name, l)), h = !0;
                                        break
                                    }
                                }
                                if (!h)
                                    if (a.data.size > 1) {
                                        var p = br(a.data.type),
                                            f = Math.max(Jr[a.data.type] / 16, 1),
                                            m = p / f,
                                            g = (4 - m % 4) % 4;
                                        o.push("\n                cv = ud." + u + ".value;\n                v = uv." + u + ";\n                offset = " + a.offset / 4 + ";\n\n                t = 0;\n\n                for(var i=0; i < " + a.data.size * f + "; i++)\n                {\n                    for(var j = 0; j < " + m + "; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += " + g + ";\n                }\n\n                ")
                                    } else {
                                        var v = Kr[a.data.type];
                                        o.push("\n                cv = ud." + u + ".value;\n                v = uv." + u + ";\n                offset = " + a.offset / 4 + ";\n                " + v + ";\n                ")
                                    }
                            }
                            return o.push("\n       renderer.buffer.update(buffer);\n    "), {
                                size: i,
                                syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", o.join("\n"))
                            }
                        }(t, this.shader.program.uniformData)), t.autoManage) {
                        var a = new Float32Array(s.size / 4);
                        t.buffer.update(a)
                    }
                    return e.uniformGroups[t.id] = s.syncFunc, e.uniformGroups[t.id]
                }, t.prototype.getSignature = function(t, e, n) {
                    var r = t.uniforms,
                        i = [n + "-"];
                    for (var o in r) i.push(o), e[o] && i.push(e[o].type);
                    return i.join("-")
                }, t.prototype.getGlProgram = function() {
                    return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null
                }, t.prototype.generateProgram = function(t) {
                    var e = this.gl,
                        n = t.program,
                        r = function(t, e) {
                            var n = dr(t, t.VERTEX_SHADER, e.vertexSrc),
                                r = dr(t, t.FRAGMENT_SHADER, e.fragmentSrc),
                                i = t.createProgram();
                            if (t.attachShader(i, n), t.attachShader(i, r), t.linkProgram(i), t.getProgramParameter(i, t.LINK_STATUS) || function(t, e, n, r) {
                                    t.getProgramParameter(e, t.LINK_STATUS) || (t.getShaderParameter(n, t.COMPILE_STATUS) || pr(t, n), t.getShaderParameter(r, t.COMPILE_STATUS) || pr(t, r), console.error("PixiJS Error: Could not initialize shader."), "" !== t.getProgramInfoLog(e) && console.warn("PixiJS Warning: gl.getProgramInfoLog()", t.getProgramInfoLog(e)))
                                }(t, i, n, r), e.attributeData = function(t, e) {
                                    for (var n = {}, r = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), i = 0; i < r; i++) {
                                        var o = e.getActiveAttrib(t, i);
                                        if (0 !== o.name.indexOf("gl_")) {
                                            var s = Sr(e, o.type),
                                                a = {
                                                    type: s,
                                                    name: o.name,
                                                    size: br(s),
                                                    location: e.getAttribLocation(t, o.name)
                                                };
                                            n[o.name] = a
                                        }
                                    }
                                    return n
                                }(i, t), e.uniformData = function(t, e) {
                                    for (var n = {}, r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), i = 0; i < r; i++) {
                                        var o = e.getActiveUniform(t, i),
                                            s = o.name.replace(/\[.*?\]$/, ""),
                                            a = !!o.name.match(/\[.*?\]$/),
                                            l = Sr(e, o.type);
                                        n[s] = {
                                            name: s,
                                            index: i,
                                            type: l,
                                            size: o.size,
                                            isArray: a,
                                            value: mr(l, o.size)
                                        }
                                    }
                                    return n
                                }(i, t), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertexSrc)) {
                                var o = Object.keys(e.attributeData);
                                o.sort((function(t, e) {
                                    return t > e ? 1 : -1
                                }));
                                for (var s = 0; s < o.length; s++) e.attributeData[o[s]].location = s, t.bindAttribLocation(i, s, o[s]);
                                t.linkProgram(i)
                            }
                            t.deleteShader(n), t.deleteShader(r);
                            var a = {};
                            for (var s in e.uniformData) {
                                var l = e.uniformData[s];
                                a[s] = {
                                    location: t.getUniformLocation(i, s),
                                    value: mr(l.type, l.size)
                                }
                            }
                            return new Qr(i, a)
                        }(e, n);
                    return n.glPrograms[this.renderer.CONTEXT_UID] = r, r
                }, t.prototype.reset = function() {
                    this.program = null, this.shader = null
                }, t.prototype.destroy = function() {
                    this.renderer = null, this.destroyed = !0
                }, t
            }(),
            ni = function() {
                function t() {
                    this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = lt.NONE, this._blendEq = !1, this.map = [], this.map[0] = this.setBlend, this.map[1] = this.setOffset, this.map[2] = this.setCullFace, this.map[3] = this.setDepthTest, this.map[4] = this.setFrontFace, this.map[5] = this.setDepthMask, this.checks = [], this.defaultState = new Dr, this.defaultState.blend = !0
                }
                return t.prototype.contextChange = function(t) {
                    this.gl = t, this.blendModes = function(t, e) {
                        return void 0 === e && (e = []), e[lt.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[lt.ADD] = [t.ONE, t.ONE], e[lt.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[lt.SCREEN] = [t.ONE, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[lt.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[lt.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[lt.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[lt.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[lt.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[lt.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[lt.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[lt.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[lt.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[lt.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[lt.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[lt.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[lt.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[lt.NONE] = [0, 0], e[lt.NORMAL_NPM] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[lt.ADD_NPM] = [t.SRC_ALPHA, t.ONE, t.ONE, t.ONE], e[lt.SCREEN_NPM] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[lt.SRC_IN] = [t.DST_ALPHA, t.ZERO], e[lt.SRC_OUT] = [t.ONE_MINUS_DST_ALPHA, t.ZERO], e[lt.SRC_ATOP] = [t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA], e[lt.DST_OVER] = [t.ONE_MINUS_DST_ALPHA, t.ONE], e[lt.DST_IN] = [t.ZERO, t.SRC_ALPHA], e[lt.DST_OUT] = [t.ZERO, t.ONE_MINUS_SRC_ALPHA], e[lt.DST_ATOP] = [t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA], e[lt.XOR] = [t.ONE_MINUS_DST_ALPHA, t.ONE_MINUS_SRC_ALPHA], e[lt.SUBTRACT] = [t.ONE, t.ONE, t.ONE, t.ONE, t.FUNC_REVERSE_SUBTRACT, t.FUNC_ADD], e
                    }(t), this.set(this.defaultState), this.reset()
                }, t.prototype.set = function(t) {
                    if (t = t || this.defaultState, this.stateId !== t.data) {
                        for (var e = this.stateId ^ t.data, n = 0; e;) 1 & e && this.map[n].call(this, !!(t.data & 1 << n)), e >>= 1, n++;
                        this.stateId = t.data
                    }
                    for (n = 0; n < this.checks.length; n++) this.checks[n](this, t)
                }, t.prototype.forceState = function(t) {
                    t = t || this.defaultState;
                    for (var e = 0; e < this.map.length; e++) this.map[e].call(this, !!(t.data & 1 << e));
                    for (e = 0; e < this.checks.length; e++) this.checks[e](this, t);
                    this.stateId = t.data
                }, t.prototype.setBlend = function(e) {
                    this.updateCheck(t.checkBlendMode, e), this.gl[e ? "enable" : "disable"](this.gl.BLEND)
                }, t.prototype.setOffset = function(e) {
                    this.updateCheck(t.checkPolygonOffset, e), this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL)
                }, t.prototype.setDepthTest = function(t) {
                    this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST)
                }, t.prototype.setDepthMask = function(t) {
                    this.gl.depthMask(t)
                }, t.prototype.setCullFace = function(t) {
                    this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE)
                }, t.prototype.setFrontFace = function(t) {
                    this.gl.frontFace(this.gl[t ? "CW" : "CCW"])
                }, t.prototype.setBlendMode = function(t) {
                    if (t !== this.blendMode) {
                        this.blendMode = t;
                        var e = this.blendModes[t],
                            n = this.gl;
                        2 === e.length ? n.blendFunc(e[0], e[1]) : n.blendFuncSeparate(e[0], e[1], e[2], e[3]), 6 === e.length ? (this._blendEq = !0, n.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, n.blendEquationSeparate(n.FUNC_ADD, n.FUNC_ADD))
                    }
                }, t.prototype.setPolygonOffset = function(t, e) {
                    this.gl.polygonOffset(t, e)
                }, t.prototype.reset = function() {
                    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0)
                }, t.prototype.updateCheck = function(t, e) {
                    var n = this.checks.indexOf(t);
                    e && -1 === n ? this.checks.push(t) : e || -1 === n || this.checks.splice(n, 1)
                }, t.checkBlendMode = function(t, e) {
                    t.setBlendMode(e.blendMode)
                }, t.checkPolygonOffset = function(t, e) {
                    t.setPolygonOffset(1, e.polygonOffset)
                }, t.prototype.destroy = function() {
                    this.gl = null
                }, t
            }(),
            ri = function() {
                function t(t) {
                    this.renderer = t, this.count = 0, this.checkCount = 0, this.maxIdle = St.GC_MAX_IDLE, this.checkCountMax = St.GC_MAX_CHECK_COUNT, this.mode = St.GC_MODE
                }
                return t.prototype.postrender = function() {
                    this.renderer.renderingToScreen && (this.count++, this.mode !== yt.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())))
                }, t.prototype.run = function() {
                    for (var t = this.renderer.texture, e = t.managedTextures, n = !1, r = 0; r < e.length; r++) {
                        var i = e[r];
                        !i.framebuffer && this.count - i.touched > this.maxIdle && (t.destroyTexture(i, !0), e[r] = null, n = !0)
                    }
                    if (n) {
                        var o = 0;
                        for (r = 0; r < e.length; r++) null !== e[r] && (e[o++] = e[r]);
                        e.length = o
                    }
                }, t.prototype.unload = function(t) {
                    var e = this.renderer.texture,
                        n = t._texture;
                    n && !n.framebuffer && e.destroyTexture(n);
                    for (var r = t.children.length - 1; r >= 0; r--) this.unload(t.children[r])
                }, t.prototype.destroy = function() {
                    this.renderer = null
                }, t
            }(),
            ii = function(t) {
                this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = dt.UNSIGNED_BYTE, this.internalFormat = ht.RGBA, this.samplerType = 0
            },
            oi = function() {
                function t(t) {
                    this.renderer = t, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new xn, this.hasIntegerTextures = !1
                }
                return t.prototype.contextChange = function() {
                    var t = this.gl = this.renderer.gl;
                    this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = function(t) {
                        var e, n, r, i, o, s, a, l, u, h, c, d, p, f, m, g, v, _, y, x, b, E, T;
                        return "WebGL2RenderingContext" in globalThis && t instanceof globalThis.WebGL2RenderingContext ? ((e = {})[dt.UNSIGNED_BYTE] = ((n = {})[ht.RGBA] = t.RGBA8, n[ht.RGB] = t.RGB8, n[ht.RG] = t.RG8, n[ht.RED] = t.R8, n[ht.RGBA_INTEGER] = t.RGBA8UI, n[ht.RGB_INTEGER] = t.RGB8UI, n[ht.RG_INTEGER] = t.RG8UI, n[ht.RED_INTEGER] = t.R8UI, n[ht.ALPHA] = t.ALPHA, n[ht.LUMINANCE] = t.LUMINANCE, n[ht.LUMINANCE_ALPHA] = t.LUMINANCE_ALPHA, n), e[dt.BYTE] = ((r = {})[ht.RGBA] = t.RGBA8_SNORM, r[ht.RGB] = t.RGB8_SNORM, r[ht.RG] = t.RG8_SNORM, r[ht.RED] = t.R8_SNORM, r[ht.RGBA_INTEGER] = t.RGBA8I, r[ht.RGB_INTEGER] = t.RGB8I, r[ht.RG_INTEGER] = t.RG8I, r[ht.RED_INTEGER] = t.R8I, r), e[dt.UNSIGNED_SHORT] = ((i = {})[ht.RGBA_INTEGER] = t.RGBA16UI, i[ht.RGB_INTEGER] = t.RGB16UI, i[ht.RG_INTEGER] = t.RG16UI, i[ht.RED_INTEGER] = t.R16UI, i[ht.DEPTH_COMPONENT] = t.DEPTH_COMPONENT16, i), e[dt.SHORT] = ((o = {})[ht.RGBA_INTEGER] = t.RGBA16I, o[ht.RGB_INTEGER] = t.RGB16I, o[ht.RG_INTEGER] = t.RG16I, o[ht.RED_INTEGER] = t.R16I, o), e[dt.UNSIGNED_INT] = ((s = {})[ht.RGBA_INTEGER] = t.RGBA32UI, s[ht.RGB_INTEGER] = t.RGB32UI, s[ht.RG_INTEGER] = t.RG32UI, s[ht.RED_INTEGER] = t.R32UI, s[ht.DEPTH_COMPONENT] = t.DEPTH_COMPONENT24, s), e[dt.INT] = ((a = {})[ht.RGBA_INTEGER] = t.RGBA32I, a[ht.RGB_INTEGER] = t.RGB32I, a[ht.RG_INTEGER] = t.RG32I, a[ht.RED_INTEGER] = t.R32I, a), e[dt.FLOAT] = ((l = {})[ht.RGBA] = t.RGBA32F, l[ht.RGB] = t.RGB32F, l[ht.RG] = t.RG32F, l[ht.RED] = t.R32F, l[ht.DEPTH_COMPONENT] = t.DEPTH_COMPONENT32F, l), e[dt.HALF_FLOAT] = ((u = {})[ht.RGBA] = t.RGBA16F, u[ht.RGB] = t.RGB16F, u[ht.RG] = t.RG16F, u[ht.RED] = t.R16F, u), e[dt.UNSIGNED_SHORT_5_6_5] = ((h = {})[ht.RGB] = t.RGB565, h), e[dt.UNSIGNED_SHORT_4_4_4_4] = ((c = {})[ht.RGBA] = t.RGBA4, c), e[dt.UNSIGNED_SHORT_5_5_5_1] = ((d = {})[ht.RGBA] = t.RGB5_A1, d), e[dt.UNSIGNED_INT_2_10_10_10_REV] = ((p = {})[ht.RGBA] = t.RGB10_A2, p[ht.RGBA_INTEGER] = t.RGB10_A2UI, p), e[dt.UNSIGNED_INT_10F_11F_11F_REV] = ((f = {})[ht.RGB] = t.R11F_G11F_B10F, f), e[dt.UNSIGNED_INT_5_9_9_9_REV] = ((m = {})[ht.RGB] = t.RGB9_E5, m), e[dt.UNSIGNED_INT_24_8] = ((g = {})[ht.DEPTH_STENCIL] = t.DEPTH24_STENCIL8, g), e[dt.FLOAT_32_UNSIGNED_INT_24_8_REV] = ((v = {})[ht.DEPTH_STENCIL] = t.DEPTH32F_STENCIL8, v), T = e) : ((_ = {})[dt.UNSIGNED_BYTE] = ((y = {})[ht.RGBA] = t.RGBA, y[ht.RGB] = t.RGB, y[ht.ALPHA] = t.ALPHA, y[ht.LUMINANCE] = t.LUMINANCE, y[ht.LUMINANCE_ALPHA] = t.LUMINANCE_ALPHA, y), _[dt.UNSIGNED_SHORT_5_6_5] = ((x = {})[ht.RGB] = t.RGB, x), _[dt.UNSIGNED_SHORT_4_4_4_4] = ((b = {})[ht.RGBA] = t.RGBA, b), _[dt.UNSIGNED_SHORT_5_5_5_1] = ((E = {})[ht.RGBA] = t.RGBA, E), T = _), T
                    }(t);
                    var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
                    this.boundTextures.length = e;
                    for (var n = 0; n < e; n++) this.boundTextures[n] = null;
                    this.emptyTextures = {};
                    var r = new ii(t.createTexture());
                    for (t.bindTexture(t.TEXTURE_2D, r.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = r, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new ii(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture), n = 0; n < 6; n++) t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);
                    for (t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR), n = 0; n < this.boundTextures.length; n++) this.bind(null, n)
                }, t.prototype.bind = function(t, e) {
                    void 0 === e && (e = 0);
                    var n = this.gl;
                    if ((t = null == t ? void 0 : t.castToBaseTexture()) && t.valid && !t.parentTextureArray) {
                        t.touched = this.renderer.textureGC.count;
                        var r = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
                        this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e, n.activeTexture(n.TEXTURE0 + e)), n.bindTexture(t.target, r.texture)), r.dirtyId !== t.dirtyId && (this.currentLocation !== e && (this.currentLocation = e, n.activeTexture(n.TEXTURE0 + e)), this.updateTexture(t)), this.boundTextures[e] = t
                    } else this.currentLocation !== e && (this.currentLocation = e, n.activeTexture(n.TEXTURE0 + e)), n.bindTexture(n.TEXTURE_2D, this.emptyTextures[n.TEXTURE_2D].texture), this.boundTextures[e] = null
                }, t.prototype.reset = function() {
                    this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;
                    for (var t = 0; t < this.boundTextures.length; t++) this.boundTextures[t] = this.unknownTexture
                }, t.prototype.unbind = function(t) {
                    var e = this.gl,
                        n = this.boundTextures;
                    if (this._unknownBoundTextures) {
                        this._unknownBoundTextures = !1;
                        for (var r = 0; r < n.length; r++) n[r] === this.unknownTexture && this.bind(null, r)
                    }
                    for (r = 0; r < n.length; r++) n[r] === t && (this.currentLocation !== r && (e.activeTexture(e.TEXTURE0 + r), this.currentLocation = r), e.bindTexture(t.target, this.emptyTextures[t.target].texture), n[r] = null)
                }, t.prototype.ensureSamplerType = function(t) {
                    var e = this,
                        n = e.boundTextures,
                        r = e.hasIntegerTextures,
                        i = e.CONTEXT_UID;
                    if (r)
                        for (var o = t - 1; o >= 0; --o) {
                            var s = n[o];
                            s && s._glTextures[i].samplerType !== pt.FLOAT && this.renderer.texture.unbind(s)
                        }
                }, t.prototype.initTexture = function(t) {
                    var e = new ii(this.gl.createTexture());
                    return e.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = e, this.managedTextures.push(t), t.on("dispose", this.destroyTexture, this), e
                }, t.prototype.initTextureType = function(t, e) {
                    var n, r;
                    e.internalFormat = null !== (r = null === (n = this.internalFormats[t.type]) || void 0 === n ? void 0 : n[t.format]) && void 0 !== r ? r : t.format, 2 === this.webGLVersion && t.type === dt.HALF_FLOAT ? e.type = this.gl.HALF_FLOAT : e.type = t.type
                }, t.prototype.updateTexture = function(t) {
                    var e = t._glTextures[this.CONTEXT_UID];
                    if (e) {
                        var n = this.renderer;
                        if (this.initTextureType(t, e), t.resource && t.resource.upload(n, t, e)) e.samplerType !== pt.FLOAT && (this.hasIntegerTextures = !0);
                        else {
                            var r = t.realWidth,
                                i = t.realHeight,
                                o = n.gl;
                            (e.width !== r || e.height !== i || e.dirtyId < 0) && (e.width = r, e.height = i, o.texImage2D(t.target, 0, e.internalFormat, r, i, 0, t.format, e.type, null))
                        }
                        t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t), e.dirtyId = t.dirtyId
                    }
                }, t.prototype.destroyTexture = function(t, e) {
                    var n = this.gl;
                    if ((t = t.castToBaseTexture())._glTextures[this.CONTEXT_UID] && (this.unbind(t), n.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off("dispose", this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !e)) {
                        var r = this.managedTextures.indexOf(t); - 1 !== r && Xt(this.managedTextures, r, 1)
                    }
                }, t.prototype.updateTextureStyle = function(t) {
                    var e = t._glTextures[this.CONTEXT_UID];
                    e && (t.mipmap !== gt.POW2 && 2 === this.webGLVersion || t.isPowerOfTwo ? e.mipmap = t.mipmap >= 1 : e.mipmap = !1, 2 === this.webGLVersion || t.isPowerOfTwo ? e.wrapMode = t.wrapMode : e.wrapMode = mt.CLAMP, t.resource && t.resource.style(this.renderer, t, e) || this.setStyle(t, e), e.dirtyStyleId = t.dirtyStyleId)
                }, t.prototype.setStyle = function(t, e) {
                    var n = this.gl;
                    if (e.mipmap && t.mipmap !== gt.ON_MANUAL && n.generateMipmap(t.target), n.texParameteri(t.target, n.TEXTURE_WRAP_S, e.wrapMode), n.texParameteri(t.target, n.TEXTURE_WRAP_T, e.wrapMode), e.mipmap) {
                        n.texParameteri(t.target, n.TEXTURE_MIN_FILTER, t.scaleMode === ft.LINEAR ? n.LINEAR_MIPMAP_LINEAR : n.NEAREST_MIPMAP_NEAREST);
                        var r = this.renderer.context.extensions.anisotropicFiltering;
                        if (r && t.anisotropicLevel > 0 && t.scaleMode === ft.LINEAR) {
                            var i = Math.min(t.anisotropicLevel, n.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
                            n.texParameterf(t.target, r.TEXTURE_MAX_ANISOTROPY_EXT, i)
                        }
                    } else n.texParameteri(t.target, n.TEXTURE_MIN_FILTER, t.scaleMode === ft.LINEAR ? n.LINEAR : n.NEAREST);
                    n.texParameteri(t.target, n.TEXTURE_MAG_FILTER, t.scaleMode === ft.LINEAR ? n.LINEAR : n.NEAREST)
                }, t.prototype.destroy = function() {
                    this.renderer = null
                }, t
            }(),
            si = {
                __proto__: null,
                FilterSystem: er,
                BatchSystem: rr,
                ContextSystem: or,
                FramebufferSystem: lr,
                GeometrySystem: hr,
                MaskSystem: Gr,
                ScissorSystem: Vr,
                StencilSystem: Wr,
                ProjectionSystem: Xr,
                RenderTextureSystem: qr,
                ShaderSystem: ei,
                StateSystem: ni,
                TextureGCSystem: ri,
                TextureSystem: oi
            },
            ai = new me,
            li = function(t) {
                function e(e, n) {
                    void 0 === e && (e = st.UNKNOWN);
                    var r = t.call(this) || this;
                    return n = Object.assign({}, St.RENDER_OPTIONS, n), r.options = n, r.type = e, r.screen = new ue(0, 0, n.width, n.height), r.view = n.view || document.createElement("canvas"), r.resolution = n.resolution || St.RESOLUTION, r.useContextAlpha = n.useContextAlpha, r.autoDensity = !!n.autoDensity, r.preserveDrawingBuffer = n.preserveDrawingBuffer, r.clearBeforeRender = n.clearBeforeRender, r._backgroundColor = 0, r._backgroundColorRgba = [0, 0, 0, 1], r._backgroundColorString = "#000000", r.backgroundColor = n.backgroundColor || r._backgroundColor, r.backgroundAlpha = n.backgroundAlpha, void 0 !== n.transparent && (Kt("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead."), r.useContextAlpha = n.transparent, r.backgroundAlpha = n.transparent ? 0 : 1), r._lastObjectRendered = null, r.plugins = {}, r
                }
                return mn(e, t), e.prototype.initPlugins = function(t) {
                    for (var e in t) this.plugins[e] = new t[e](this)
                }, Object.defineProperty(e.prototype, "width", {
                    get: function() {
                        return this.view.width
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "height", {
                    get: function() {
                        return this.view.height
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype.resize = function(t, e) {
                    this.view.width = Math.round(t * this.resolution), this.view.height = Math.round(e * this.resolution);
                    var n = this.view.width / this.resolution,
                        r = this.view.height / this.resolution;
                    this.screen.width = n, this.screen.height = r, this.autoDensity && (this.view.style.width = n + "px", this.view.style.height = r + "px"), this.emit("resize", n, r)
                }, e.prototype.generateTexture = function(t, e, n, r) {
                    void 0 === e && (e = {}), "number" == typeof e && (Kt("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options."), e = {
                        scaleMode: e,
                        resolution: n,
                        region: r
                    });
                    var i = e.region,
                        o = function(t, e) {
                            var n = {};
                            for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
                            if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
                                var i = 0;
                                for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && (n[r[i]] = t[r[i]])
                            }
                            return n
                        }(e, ["region"]);
                    0 === (r = i || t.getLocalBounds(null, !0)).width && (r.width = 1), 0 === r.height && (r.height = 1);
                    var s = Bn.create(gn({
                        width: r.width,
                        height: r.height
                    }, o));
                    return ai.tx = -r.x, ai.ty = -r.y, this.render(t, {
                        renderTexture: s,
                        clear: !1,
                        transform: ai,
                        skipUpdateTransform: !!t.parent
                    }), s
                }, e.prototype.destroy = function(t) {
                    for (var e in this.plugins) this.plugins[e].destroy(), this.plugins[e] = null;
                    t && this.view.parentNode && this.view.parentNode.removeChild(this.view);
                    var n = this;
                    n.plugins = null, n.type = st.UNKNOWN, n.view = null, n.screen = null, n._tempDisplayObjectParent = null, n.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null
                }, Object.defineProperty(e.prototype, "backgroundColor", {
                    get: function() {
                        return this._backgroundColor
                    },
                    set: function(t) {
                        this._backgroundColor = t, this._backgroundColorString = Dt(t), Nt(t, this._backgroundColorRgba)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "backgroundAlpha", {
                    get: function() {
                        return this._backgroundColorRgba[3]
                    },
                    set: function(t) {
                        this._backgroundColorRgba[3] = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), e
            }(Mt()),
            ui = function(t) {
                this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0
            },
            hi = function() {
                function t(t) {
                    this.renderer = t, this.managedBuffers = {}, this.boundBufferBases = {}
                }
                return t.prototype.destroy = function() {
                    this.renderer = null
                }, t.prototype.contextChange = function() {
                    this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID
                }, t.prototype.bind = function(t) {
                    var e = this.gl,
                        n = this.CONTEXT_UID,
                        r = t._glBuffers[n] || this.createGLBuffer(t);
                    e.bindBuffer(t.type, r.buffer)
                }, t.prototype.bindBufferBase = function(t, e) {
                    var n = this.gl,
                        r = this.CONTEXT_UID;
                    if (this.boundBufferBases[e] !== t) {
                        var i = t._glBuffers[r] || this.createGLBuffer(t);
                        this.boundBufferBases[e] = t, n.bindBufferBase(n.UNIFORM_BUFFER, e, i.buffer)
                    }
                }, t.prototype.bindBufferRange = function(t, e, n) {
                    var r = this.gl,
                        i = this.CONTEXT_UID;
                    n = n || 0;
                    var o = t._glBuffers[i] || this.createGLBuffer(t);
                    r.bindBufferRange(r.UNIFORM_BUFFER, e || 0, o.buffer, 256 * n, 256)
                }, t.prototype.update = function(t) {
                    var e = this.gl,
                        n = this.CONTEXT_UID,
                        r = t._glBuffers[n];
                    if (t._updateID !== r.updateID)
                        if (r.updateID = t._updateID, e.bindBuffer(t.type, r.buffer), r.byteLength >= t.data.byteLength) e.bufferSubData(t.type, 0, t.data);
                        else {
                            var i = t.static ? e.STATIC_DRAW : e.DYNAMIC_DRAW;
                            r.byteLength = t.data.byteLength, e.bufferData(t.type, t.data, i)
                        }
                }, t.prototype.dispose = function(t, e) {
                    if (this.managedBuffers[t.id]) {
                        delete this.managedBuffers[t.id];
                        var n = t._glBuffers[this.CONTEXT_UID],
                            r = this.gl;
                        t.disposeRunner.remove(this), n && (e || r.deleteBuffer(n.buffer), delete t._glBuffers[this.CONTEXT_UID])
                    }
                }, t.prototype.disposeAll = function(t) {
                    for (var e = Object.keys(this.managedBuffers), n = 0; n < e.length; n++) this.dispose(this.managedBuffers[e[n]], t)
                }, t.prototype.createGLBuffer = function(t) {
                    var e = this.CONTEXT_UID,
                        n = this.gl;
                    return t._glBuffers[e] = new ui(n.createBuffer()), this.managedBuffers[t.id] = t, t.disposeRunner.add(this), t._glBuffers[e]
                }, t
            }(),
            ci = function(t) {
                function e(n) {
                    var r = t.call(this, st.WEBGL, n) || this;
                    return n = r.options, r.gl = null, r.CONTEXT_UID = 0, r.runners = {
                            destroy: new cn("destroy"),
                            contextChange: new cn("contextChange"),
                            reset: new cn("reset"),
                            update: new cn("update"),
                            postrender: new cn("postrender"),
                            prerender: new cn("prerender"),
                            resize: new cn("resize")
                        }, r.runners.contextChange.add(r), r.globalUniforms = new Jn({
                            projectionMatrix: new me
                        }, !0), r.addSystem(Gr, "mask").addSystem(or, "context").addSystem(ni, "state").addSystem(ei, "shader").addSystem(oi, "texture").addSystem(hi, "buffer").addSystem(hr, "geometry").addSystem(lr, "framebuffer").addSystem(Vr, "scissor").addSystem(Wr, "stencil").addSystem(Xr, "projection").addSystem(ri, "textureGC").addSystem(er, "filter").addSystem(qr, "renderTexture").addSystem(rr, "batch"), r.initPlugins(e.__plugins), r.multisample = void 0, n.context ? r.context.initFromContext(n.context) : r.context.initFromOptions({
                            alpha: !!r.useContextAlpha,
                            antialias: n.antialias,
                            premultipliedAlpha: r.useContextAlpha && "notMultiplied" !== r.useContextAlpha,
                            stencil: !0,
                            preserveDrawingBuffer: n.preserveDrawingBuffer,
                            powerPreference: r.options.powerPreference
                        }), r.renderingToScreen = !0,
                        function(t) {
                            var e;
                            if (!Ot) {
                                if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
                                    var n = ["\n %c %c %c PixiJS 6.3.0 - ✰ " + t + " ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ \n\n", "background: #ff66a5; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff66a5; background: #030307; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "background: #ffc3dc; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;"];
                                    (e = globalThis.console).log.apply(e, n)
                                } else globalThis.console && globalThis.console.log("PixiJS 6.3.0 - " + t + " - http://www.pixijs.com/");
                                Ot = !0
                            }
                        }(2 === r.context.webGLVersion ? "WebGL 2" : "WebGL 1"), r.resize(r.options.width, r.options.height), r
                }
                return mn(e, t), e.create = function(t) {
                    if (void 0 === Ct && (Ct = function() {
                            var t = {
                                stencil: !0,
                                failIfMajorPerformanceCaveat: St.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
                            };
                            try {
                                if (!globalThis.WebGLRenderingContext) return !1;
                                var e = document.createElement("canvas"),
                                    n = e.getContext("webgl", t) || e.getContext("experimental-webgl", t),
                                    r = !(!n || !n.getContextAttributes().stencil);
                                if (n) {
                                    var i = n.getExtension("WEBGL_lose_context");
                                    i && i.loseContext()
                                }
                                return n = null, r
                            } catch (t) {
                                return !1
                            }
                        }()), Ct) return new e(t);
                    throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.')
                }, e.prototype.contextChange = function() {
                    var t, e = this.gl;
                    if (1 === this.context.webGLVersion) {
                        var n = e.getParameter(e.FRAMEBUFFER_BINDING);
                        e.bindFramebuffer(e.FRAMEBUFFER, null), t = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.FRAMEBUFFER, n)
                    } else n = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), t = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, n);
                    t >= Et.HIGH ? this.multisample = Et.HIGH : t >= Et.MEDIUM ? this.multisample = Et.MEDIUM : t >= Et.LOW ? this.multisample = Et.LOW : this.multisample = Et.NONE
                }, e.prototype.addSystem = function(t, e) {
                    var n = new t(this);
                    if (this[e]) throw new Error('Whoops! The name "' + e + '" is already in use');
                    for (var r in this[e] = n, this.runners) this.runners[r].add(n);
                    return this
                }, e.prototype.render = function(t, e) {
                    var n, r, i, o;
                    if (e && (e instanceof Bn ? (Kt("6.0.0", "Renderer#render arguments changed, use options instead."), n = e, r = arguments[2], i = arguments[3], o = arguments[4]) : (n = e.renderTexture, r = e.clear, i = e.transform, o = e.skipUpdateTransform)), this.renderingToScreen = !n, this.runners.prerender.emit(), this.emit("prerender"), this.projection.transform = i, !this.context.isLost) {
                        if (n || (this._lastObjectRendered = t), !o) {
                            var s = t.enableTempParent();
                            t.updateTransform(), t.disableTempParent(s)
                        }
                        this.renderTexture.bind(n), this.batch.currentRenderer.start(), (void 0 !== r ? r : this.clearBeforeRender) && this.renderTexture.clear(), t.render(this), this.batch.currentRenderer.flush(), n && n.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit("postrender")
                    }
                }, e.prototype.generateTexture = function(e, n, r, i) {
                    void 0 === n && (n = {});
                    var o = t.prototype.generateTexture.call(this, e, n, r, i);
                    return this.framebuffer.blit(), o
                }, e.prototype.resize = function(e, n) {
                    t.prototype.resize.call(this, e, n), this.runners.resize.emit(this.screen.height, this.screen.width)
                }, e.prototype.reset = function() {
                    return this.runners.reset.emit(), this
                }, e.prototype.clear = function() {
                    this.renderTexture.bind(), this.renderTexture.clear()
                }, e.prototype.destroy = function(e) {
                    for (var n in this.runners.destroy.emit(), this.runners) this.runners[n].destroy();
                    t.prototype.destroy.call(this, e), this.gl = null
                }, Object.defineProperty(e.prototype, "extract", {
                    get: function() {
                        return Kt("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead."), this.plugins.extract
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.registerPlugin = function(t, n) {
                    e.__plugins = e.__plugins || {}, e.__plugins[t] = n
                }, e
            }(li),
            di = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n",
            pi = function() {
                this.texArray = null, this.blend = 0, this.type = ut.TRIANGLES, this.start = 0, this.size = 0, this.data = null
            },
            fi = function() {
                function t() {
                    this.elements = [], this.ids = [], this.count = 0
                }
                return t.prototype.clear = function() {
                    for (var t = 0; t < this.count; t++) this.elements[t] = null;
                    this.count = 0
                }, t
            }(),
            mi = function() {
                function t(t) {
                    "number" == typeof t ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData)
                }
                return Object.defineProperty(t.prototype, "int8View", {
                    get: function() {
                        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "uint8View", {
                    get: function() {
                        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "int16View", {
                    get: function() {
                        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "uint16View", {
                    get: function() {
                        return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "int32View", {
                    get: function() {
                        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.view = function(t) {
                    return this[t + "View"]
                }, t.prototype.destroy = function() {
                    this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null
                }, t.sizeOf = function(t) {
                    switch (t) {
                        case "int8":
                        case "uint8":
                            return 1;
                        case "int16":
                        case "uint16":
                            return 2;
                        case "int32":
                        case "uint32":
                        case "float32":
                            return 4;
                        default:
                            throw new Error(t + " isn't a valid view type")
                    }
                }, t
            }(),
            gi = function(t) {
                function e(e) {
                    var n = t.call(this, e) || this;
                    return n.shaderGenerator = null, n.geometryClass = null, n.vertexSize = null, n.state = Dr.for2d(), n.size = 4 * St.SPRITE_BATCH_SIZE, n._vertexCount = 0, n._indexCount = 0, n._bufferedElements = [], n._bufferedTextures = [], n._bufferSize = 0, n._shader = null, n._packedGeometries = [], n._packedGeometryPoolSize = 2, n._flushId = 0, n._aBuffers = {}, n._iBuffers = {}, n.MAX_TEXTURES = 1, n.renderer.on("prerender", n.onPrerender, n), e.runners.contextChange.add(n), n._dcIndex = 0, n._aIndex = 0, n._iIndex = 0, n._attributeBuffer = null, n._indexBuffer = null, n._tempBoundTextures = [], n
                }
                return mn(e, t), e.prototype.contextChange = function() {
                    var t = this.renderer.gl;
                    St.PREFER_ENV === ot.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), St.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = function(t, e) {
                        if (0 === t) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
                        for (var n = e.createShader(e.FRAGMENT_SHADER);;) {
                            var r = Pr.replace(/%forloop%/gi, Ir(t));
                            if (e.shaderSource(n, r), e.compileShader(n), e.getShaderParameter(n, e.COMPILE_STATUS)) break;
                            t = t / 2 | 0
                        }
                        return t
                    }(this.MAX_TEXTURES, t)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
                    for (var e = 0; e < this._packedGeometryPoolSize; e++) this._packedGeometries[e] = new this.geometryClass;
                    this.initFlushBuffers()
                }, e.prototype.initFlushBuffers = function() {
                    for (var t = e._drawCallPool, n = e._textureArrayPool, r = this.size / 4, i = Math.floor(r / this.MAX_TEXTURES) + 1; t.length < r;) t.push(new pi);
                    for (; n.length < i;) n.push(new fi);
                    for (var o = 0; o < this.MAX_TEXTURES; o++) this._tempBoundTextures[o] = null
                }, e.prototype.onPrerender = function() {
                    this._flushId = 0
                }, e.prototype.render = function(t) {
                    t._texture.valid && (this._vertexCount + t.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += t.vertexData.length / 2, this._indexCount += t.indices.length, this._bufferedTextures[this._bufferSize] = t._texture.baseTexture, this._bufferedElements[this._bufferSize++] = t)
                }, e.prototype.buildTexturesAndDrawCalls = function() {
                    var t = this._bufferedTextures,
                        n = this.MAX_TEXTURES,
                        r = e._textureArrayPool,
                        i = this.renderer.batch,
                        o = this._tempBoundTextures,
                        s = this.renderer.textureGC.count,
                        a = ++xn._globalBatch,
                        l = 0,
                        u = r[0],
                        h = 0;
                    i.copyBoundTextures(o, n);
                    for (var c = 0; c < this._bufferSize; ++c) {
                        var d = t[c];
                        t[c] = null, d._batchEnabled !== a && (u.count >= n && (i.boundArray(u, o, a, n), this.buildDrawCalls(u, h, c), h = c, u = r[++l], ++a), d._batchEnabled = a, d.touched = s, u.elements[u.count++] = d)
                    }
                    for (u.count > 0 && (i.boundArray(u, o, a, n), this.buildDrawCalls(u, h, this._bufferSize), ++l, ++a), c = 0; c < o.length; c++) o[c] = null;
                    xn._globalBatch = a
                }, e.prototype.buildDrawCalls = function(t, n, r) {
                    var i = this,
                        o = i._bufferedElements,
                        s = i._attributeBuffer,
                        a = i._indexBuffer,
                        l = i.vertexSize,
                        u = e._drawCallPool,
                        h = this._dcIndex,
                        c = this._aIndex,
                        d = this._iIndex,
                        p = u[h];
                    p.start = this._iIndex, p.texArray = t;
                    for (var f = n; f < r; ++f) {
                        var m = o[f],
                            g = m._texture.baseTexture,
                            v = Ft[g.alphaMode ? 1 : 0][m.blendMode];
                        o[f] = null, n < f && p.blend !== v && (p.size = d - p.start, n = f, (p = u[++h]).texArray = t, p.start = d), this.packInterleavedGeometry(m, s, a, c, d), c += m.vertexData.length / 2 * l, d += m.indices.length, p.blend = v
                    }
                    n < r && (p.size = d - p.start, ++h), this._dcIndex = h, this._aIndex = c, this._iIndex = d
                }, e.prototype.bindAndClearTexArray = function(t) {
                    for (var e = this.renderer.texture, n = 0; n < t.count; n++) e.bind(t.elements[n], t.ids[n]), t.elements[n] = null;
                    t.count = 0
                }, e.prototype.updateGeometry = function() {
                    var t = this,
                        e = t._packedGeometries,
                        n = t._attributeBuffer,
                        r = t._indexBuffer;
                    St.CAN_UPLOAD_SAME_BUFFER ? (e[this._flushId]._buffer.update(n.rawBinaryData), e[this._flushId]._indexBuffer.update(r), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, e[this._flushId] = new this.geometryClass), e[this._flushId]._buffer.update(n.rawBinaryData), e[this._flushId]._indexBuffer.update(r), this.renderer.geometry.bind(e[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++)
                }, e.prototype.drawBatches = function() {
                    for (var t = this._dcIndex, n = this.renderer, r = n.gl, i = n.state, o = e._drawCallPool, s = null, a = 0; a < t; a++) {
                        var l = o[a],
                            u = l.texArray,
                            h = l.type,
                            c = l.size,
                            d = l.start,
                            p = l.blend;
                        s !== u && (s = u, this.bindAndClearTexArray(u)), this.state.blendMode = p, i.set(this.state), r.drawElements(h, c, r.UNSIGNED_SHORT, 2 * d)
                    }
                }, e.prototype.flush = function() {
                    0 !== this._vertexCount && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0)
                }, e.prototype.start = function() {
                    this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), St.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId])
                }, e.prototype.stop = function() {
                    this.flush()
                }, e.prototype.destroy = function() {
                    for (var e = 0; e < this._packedGeometryPoolSize; e++) this._packedGeometries[e] && this._packedGeometries[e].destroy();
                    this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), t.prototype.destroy.call(this)
                }, e.prototype.getAttributeBuffer = function(t) {
                    var e = zt(Math.ceil(t / 8)),
                        n = Wt(e),
                        r = 8 * e;
                    this._aBuffers.length <= n && (this._iBuffers.length = n + 1);
                    var i = this._aBuffers[r];
                    return i || (this._aBuffers[r] = i = new mi(r * this.vertexSize * 4)), i
                }, e.prototype.getIndexBuffer = function(t) {
                    var e = zt(Math.ceil(t / 12)),
                        n = Wt(e),
                        r = 12 * e;
                    this._iBuffers.length <= n && (this._iBuffers.length = n + 1);
                    var i = this._iBuffers[n];
                    return i || (this._iBuffers[n] = i = new Uint16Array(r)), i
                }, e.prototype.packInterleavedGeometry = function(t, e, n, r, i) {
                    for (var o = e.uint32View, s = e.float32View, a = r / this.vertexSize, l = t.uvs, u = t.indices, h = t.vertexData, c = t._texture.baseTexture._batchLocation, d = Math.min(t.worldAlpha, 1), p = d < 1 && t._texture.baseTexture.alphaMode ? kt(t._tintRGB, d) : t._tintRGB + (255 * d << 24), f = 0; f < h.length; f += 2) s[r++] = h[f], s[r++] = h[f + 1], s[r++] = l[f], s[r++] = l[f + 1], o[r++] = p, s[r++] = c;
                    for (f = 0; f < u.length; f++) n[i++] = a + u[f]
                }, e._drawCallPool = [], e._textureArrayPool = [], e
            }(nr),
            vi = function() {
                function t(t, e) {
                    if (this.vertexSrc = t, this.fragTemplate = e, this.programCache = {}, this.defaultGroupCache = {}, e.indexOf("%count%") < 0) throw new Error('Fragment template must contain "%count%".');
                    if (e.indexOf("%forloop%") < 0) throw new Error('Fragment template must contain "%forloop%".')
                }
                return t.prototype.generateShader = function(t) {
                    if (!this.programCache[t]) {
                        for (var e = new Int32Array(t), n = 0; n < t; n++) e[n] = n;
                        this.defaultGroupCache[t] = Jn.from({
                            uSamplers: e
                        }, !0);
                        var r = this.fragTemplate;
                        r = (r = r.replace(/%count%/gi, "" + t)).replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new Lr(this.vertexSrc, r)
                    }
                    var i = {
                        tint: new Float32Array([1, 1, 1, 1]),
                        translationMatrix: new me,
                        default: this.defaultGroupCache[t]
                    };
                    return new Nr(this.programCache[t], i)
                }, t.prototype.generateSampleSrc = function(t) {
                    var e = "";
                    e += "\n", e += "\n";
                    for (var n = 0; n < t; n++) n > 0 && (e += "\nelse "), n < t - 1 && (e += "if(vTextureId < " + n + ".5)"), e += "\n{", e += "\n\tcolor = texture2D(uSamplers[" + n + "], vTextureCoord);", e += "\n}";
                    return (e += "\n") + "\n"
                }, t
            }(),
            _i = function(t) {
                function e(e) {
                    void 0 === e && (e = !1);
                    var n = t.call(this) || this;
                    return n._buffer = new zn(null, e, !1), n._indexBuffer = new zn(null, e, !0), n.addAttribute("aVertexPosition", n._buffer, 2, !1, dt.FLOAT).addAttribute("aTextureCoord", n._buffer, 2, !1, dt.FLOAT).addAttribute("aColor", n._buffer, 4, !0, dt.UNSIGNED_BYTE).addAttribute("aTextureId", n._buffer, 1, !0, dt.FLOAT).addIndex(n._indexBuffer), n
                }
                return mn(e, t), e
            }(Yn),
            yi = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n",
            xi = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n",
            bi = function() {
                function t() {}
                return t.create = function(t) {
                    var e = Object.assign({
                            vertex: yi,
                            fragment: xi,
                            geometryClass: _i,
                            vertexSize: 6
                        }, t),
                        n = e.vertex,
                        r = e.fragment,
                        i = e.vertexSize,
                        o = e.geometryClass;
                    return function(t) {
                        function e(e) {
                            var s = t.call(this, e) || this;
                            return s.shaderGenerator = new vi(n, r), s.geometryClass = o, s.vertexSize = i, s
                        }
                        return mn(e, t), e
                    }(gi)
                }, Object.defineProperty(t, "defaultVertexSrc", {
                    get: function() {
                        return yi
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t, "defaultFragmentTemplate", {
                    get: function() {
                        return xi
                    },
                    enumerable: !1,
                    configurable: !0
                }), t
            }().create(),
            Ei = {},
            Ti = function(t) {
                Object.defineProperty(Ei, t, {
                    get: function() {
                        return Kt("6.0.0", "PIXI.systems." + t + " has moved to PIXI." + t), In[t]
                    }
                })
            };
        for (var Si in In) Ti(Si);
        var wi = {},
            Mi = function(t) {
                Object.defineProperty(wi, t, {
                    get: function() {
                        return Kt("6.0.0", "PIXI.resources." + t + " has moved to PIXI." + t), si[t]
                    }
                })
            };
        for (var Si in si) Mi(Si);
        var Ai = function() {
                function t(e) {
                    var n = this;
                    this.stage = new Ke, e = Object.assign({
                        forceCanvas: !1
                    }, e), this.renderer = function(t) {
                        return ci.create(t)
                    }(e), t._plugins.forEach((function(t) {
                        t.init.call(n, e)
                    }))
                }
                return t.registerPlugin = function(e) {
                    t._plugins.push(e)
                }, t.prototype.render = function() {
                    this.renderer.render(this.stage)
                }, Object.defineProperty(t.prototype, "view", {
                    get: function() {
                        return this.renderer.view
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "screen", {
                    get: function() {
                        return this.renderer.screen
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.destroy = function(e, n) {
                    var r = this,
                        i = t._plugins.slice(0);
                    i.reverse(), i.forEach((function(t) {
                        t.destroy.call(r)
                    })), this.stage.destroy(n), this.stage = null, this.renderer.destroy(e), this.renderer = null
                }, t._plugins = [], t
            }(),
            Ri = function() {
                function t() {}
                return t.init = function(t) {
                    var e = this;
                    Object.defineProperty(this, "resizeTo", {
                        set: function(t) {
                            globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = t, t && (globalThis.addEventListener("resize", this.queueResize), this.resize())
                        },
                        get: function() {
                            return this._resizeTo
                        }
                    }), this.queueResize = function() {
                        e._resizeTo && (e.cancelResize(), e._resizeId = requestAnimationFrame((function() {
                            return e.resize()
                        })))
                    }, this.cancelResize = function() {
                        e._resizeId && (cancelAnimationFrame(e._resizeId), e._resizeId = null)
                    }, this.resize = function() {
                        if (e._resizeTo) {
                            var t, n;
                            if (e.cancelResize(), e._resizeTo === globalThis.window) t = globalThis.innerWidth, n = globalThis.innerHeight;
                            else {
                                var r = e._resizeTo;
                                t = r.clientWidth, n = r.clientHeight
                            }
                            e.renderer.resize(t, n)
                        }
                    }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null
                }, t.destroy = function() {
                    globalThis.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null
                }, t
            }();
        Ai.registerPlugin(Ri);
        var Pi = new ue,
            Ii = function() {
                function t(t) {
                    this.renderer = t
                }
                return t.prototype.image = function(t, e, n) {
                    var r = new Image;
                    return r.src = this.base64(t, e, n), r
                }, t.prototype.base64 = function(t, e, n) {
                    return this.canvas(t).toDataURL(e, n)
                }, t.prototype.canvas = function(e) {
                    var n, r, i, o = this.renderer,
                        s = !1,
                        a = !1;
                    e && (e instanceof Bn ? i = e : (i = this.renderer.generateTexture(e), a = !0)), i ? (n = i.baseTexture.resolution, r = i.frame, s = !1, o.renderTexture.bind(i)) : (n = this.renderer.resolution, s = !0, (r = Pi).width = this.renderer.width, r.height = this.renderer.height, o.renderTexture.bind(null));
                    var l = Math.floor(r.width * n + 1e-4),
                        u = Math.floor(r.height * n + 1e-4),
                        h = new ee(l, u, 1),
                        c = new Uint8Array(4 * l * u),
                        d = o.gl;
                    d.readPixels(r.x * n, r.y * n, l, u, d.RGBA, d.UNSIGNED_BYTE, c);
                    var p = h.context.getImageData(0, 0, l, u);
                    if (t.arrayPostDivide(c, p.data), h.context.putImageData(p, 0, 0), s) {
                        var f = new ee(h.width, h.height, 1);
                        f.context.scale(1, -1), f.context.drawImage(h.canvas, 0, -u), h.destroy(), h = f
                    }
                    return a && i.destroy(!0), h.canvas
                }, t.prototype.pixels = function(e) {
                    var n, r, i, o = this.renderer,
                        s = !1;
                    e && (e instanceof Bn ? i = e : (i = this.renderer.generateTexture(e), s = !0)), i ? (n = i.baseTexture.resolution, r = i.frame, o.renderTexture.bind(i)) : (n = o.resolution, (r = Pi).width = o.width, r.height = o.height, o.renderTexture.bind(null));
                    var a = r.width * n,
                        l = r.height * n,
                        u = new Uint8Array(4 * a * l),
                        h = o.gl;
                    return h.readPixels(r.x * n, r.y * n, a, l, h.RGBA, h.UNSIGNED_BYTE, u), s && i.destroy(!0), t.arrayPostDivide(u, u), u
                }, t.prototype.destroy = function() {
                    this.renderer = null
                }, t.arrayPostDivide = function(t, e) {
                    for (var n = 0; n < t.length; n += 4) {
                        var r = e[n + 3] = t[n + 3];
                        0 !== r ? (e[n] = Math.round(Math.min(255 * t[n] / r, 255)), e[n + 1] = Math.round(Math.min(255 * t[n + 1] / r, 255)), e[n + 2] = Math.round(Math.min(255 * t[n + 2] / r, 255))) : (e[n] = t[n], e[n + 1] = t[n + 1], e[n + 2] = t[n + 2])
                    }
                }, t
            }(),
            Ci = function() {
                function t(t, e, n) {
                    void 0 === e && (e = !1), this._fn = t, this._once = e, this._thisArg = n, this._next = this._prev = this._owner = null
                }
                return t.prototype.detach = function() {
                    return null !== this._owner && (this._owner.detach(this), !0)
                }, t
            }();

        function Oi(t, e) {
            return t._head ? (t._tail._next = e, e._prev = t._tail, t._tail = e) : (t._head = e, t._tail = e), e._owner = t, e
        }
        var Li = function() {
            function t() {
                this._head = this._tail = void 0
            }
            return t.prototype.handlers = function(t) {
                void 0 === t && (t = !1);
                var e = this._head;
                if (t) return !!e;
                for (var n = []; e;) n.push(e), e = e._next;
                return n
            }, t.prototype.has = function(t) {
                if (!(t instanceof Ci)) throw new Error("MiniSignal#has(): First arg must be a SignalBinding object.");
                return t._owner === this
            }, t.prototype.dispatch = function() {
                for (var t = arguments, e = [], n = 0; n < arguments.length; n++) e[n] = t[n];
                var r = this._head;
                if (!r) return !1;
                for (; r;) r._once && this.detach(r), r._fn.apply(r._thisArg, e), r = r._next;
                return !0
            }, t.prototype.add = function(t, e) {
                if (void 0 === e && (e = null), "function" != typeof t) throw new Error("MiniSignal#add(): First arg must be a Function.");
                return Oi(this, new Ci(t, !1, e))
            }, t.prototype.once = function(t, e) {
                if (void 0 === e && (e = null), "function" != typeof t) throw new Error("MiniSignal#once(): First arg must be a Function.");
                return Oi(this, new Ci(t, !0, e))
            }, t.prototype.detach = function(t) {
                if (!(t instanceof Ci)) throw new Error("MiniSignal#detach(): First arg must be a SignalBinding object.");
                return t._owner !== this || (t._prev && (t._prev._next = t._next), t._next && (t._next._prev = t._prev), t === this._head ? (this._head = t._next, null === t._next && (this._tail = null)) : t === this._tail && (this._tail = t._prev, this._tail._next = null), t._owner = null), this
            }, t.prototype.detachAll = function() {
                var t = this._head;
                if (!t) return this;
                for (this._head = this._tail = null; t;) t._owner = null, t = t._next;
                return this
            }, t
        }();

        function Ni(t, e) {
            e = e || {};
            for (var n = {
                    key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
                    q: {
                        name: "queryKey",
                        parser: /(?:^|&)([^&=]*)=?([^&]*)/g
                    },
                    parser: {
                        strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                        loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
                    }
                }, r = n.parser[e.strictMode ? "strict" : "loose"].exec(t), i = {}, o = 14; o--;) i[n.key[o]] = r[o] || "";
            return i[n.q.name] = {}, i[n.key[12]].replace(n.q.parser, (function(t, e, r) {
                e && (i[n.q.name][e] = r)
            })), i
        }
        var Di = !(!globalThis.XDomainRequest || "withCredentials" in new XMLHttpRequest),
            Ui = null;

        function Fi() {}

        function Bi(t, e, n) {
            e && 0 === e.indexOf(".") && (e = e.substring(1)), e && (t[e] = n)
        }

        function ki(t) {
            return t.toString().replace("object ", "")
        }
        var Gi = function() {
            function t(e, n, r) {
                if (this._dequeue = Fi, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = null, this._boundOnError = null, this._boundOnProgress = null, this._boundOnTimeout = null, this._boundXhrOnError = null, this._boundXhrOnTimeout = null, this._boundXhrOnAbort = null, this._boundXhrOnLoad = null, "string" != typeof e || "string" != typeof n) throw new Error("Both name and url are required for constructing a resource.");
                r = r || {}, this._flags = 0, this._setFlag(t.STATUS_FLAGS.DATA_URL, 0 === n.indexOf("data:")), this.name = e, this.url = n, this.extension = this._getExtension(), this.data = null, this.crossOrigin = !0 === r.crossOrigin ? "anonymous" : r.crossOrigin, this.timeout = r.timeout || 0, this.loadType = r.loadType || this._determineLoadType(), this.xhrType = r.xhrType, this.metadata = r.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = t.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = Fi, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new Li, this.onProgress = new Li, this.onComplete = new Li, this.onAfterMiddleware = new Li
            }
            return t.setExtensionLoadType = function(e, n) {
                Bi(t._loadTypeMap, e, n)
            }, t.setExtensionXhrType = function(e, n) {
                Bi(t._xhrTypeMap, e, n)
            }, Object.defineProperty(t.prototype, "isDataUrl", {
                get: function() {
                    return this._hasFlag(t.STATUS_FLAGS.DATA_URL)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, "isComplete", {
                get: function() {
                    return this._hasFlag(t.STATUS_FLAGS.COMPLETE)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, "isLoading", {
                get: function() {
                    return this._hasFlag(t.STATUS_FLAGS.LOADING)
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.complete = function() {
                this._clearEvents(), this._finish()
            }, t.prototype.abort = function(e) {
                if (!this.error) {
                    if (this.error = new Error(e), this._clearEvents(), this.xhr) this.xhr.abort();
                    else if (this.xdr) this.xdr.abort();
                    else if (this.data)
                        if (this.data.src) this.data.src = t.EMPTY_GIF;
                        else
                            for (; this.data.firstChild;) this.data.removeChild(this.data.firstChild);
                    this._finish()
                }
            }, t.prototype.load = function(e) {
                var n = this;
                if (!this.isLoading)
                    if (this.isComplete) e && setTimeout((function() {
                        return e(n)
                    }), 1);
                    else switch (e && this.onComplete.once(e), this._setFlag(t.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), !1 !== this.crossOrigin && "string" == typeof this.crossOrigin || (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {
                        case t.LOAD_TYPE.IMAGE:
                            this.type = t.TYPE.IMAGE, this._loadElement("image");
                            break;
                        case t.LOAD_TYPE.AUDIO:
                            this.type = t.TYPE.AUDIO, this._loadSourceElement("audio");
                            break;
                        case t.LOAD_TYPE.VIDEO:
                            this.type = t.TYPE.VIDEO, this._loadSourceElement("video");
                            break;
                        case t.LOAD_TYPE.XHR:
                        default:
                            Di && this.crossOrigin ? this._loadXdr() : this._loadXhr()
                    }
            }, t.prototype._hasFlag = function(t) {
                return 0 != (this._flags & t)
            }, t.prototype._setFlag = function(t, e) {
                this._flags = e ? this._flags | t : this._flags & ~t
            }, t.prototype._clearEvents = function() {
                clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener("error", this._boundOnError, !1), this.data.removeEventListener("load", this._boundComplete, !1), this.data.removeEventListener("progress", this._boundOnProgress, !1), this.data.removeEventListener("canplaythrough", this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener("error", this._boundXhrOnError, !1), this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, !1), this.xhr.removeEventListener("abort", this._boundXhrOnAbort, !1), this.xhr.removeEventListener("progress", this._boundOnProgress, !1), this.xhr.removeEventListener("load", this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null))
            }, t.prototype._finish = function() {
                if (this.isComplete) throw new Error("Complete called again for an already completed resource.");
                this._setFlag(t.STATUS_FLAGS.COMPLETE, !0), this._setFlag(t.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this)
            }, t.prototype._loadElement = function(t) {
                this.metadata.loadElement ? this.data = this.metadata.loadElement : "image" === t && void 0 !== globalThis.Image ? this.data = new Image : this.data = document.createElement(t), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout))
            }, t.prototype._loadSourceElement = function(t) {
                if (this.metadata.loadElement ? this.data = this.metadata.loadElement : "audio" === t && void 0 !== globalThis.Audio ? this.data = new Audio : this.data = document.createElement(t), null !== this.data) {
                    if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource)
                        if (navigator.isCocoonJS) this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
                        else if (Array.isArray(this.url))
                        for (var e = this.metadata.mimeType, n = 0; n < this.url.length; ++n) this.data.appendChild(this._createSource(t, this.url[n], Array.isArray(e) ? e[n] : e));
                    else e = this.metadata.mimeType, this.data.appendChild(this._createSource(t, this.url, Array.isArray(e) ? e[0] : e));
                    this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.data.addEventListener("canplaythrough", this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout))
                } else this.abort("Unsupported element: " + t)
            }, t.prototype._loadXhr = function() {
                "string" != typeof this.xhrType && (this.xhrType = this._determineXhrType());
                var e = this.xhr = new XMLHttpRequest;
                "use-credentials" === this.crossOrigin && (e.withCredentials = !0), e.open("GET", this.url, !0), e.timeout = this.timeout, this.xhrType === t.XHR_RESPONSE_TYPE.JSON || this.xhrType === t.XHR_RESPONSE_TYPE.DOCUMENT ? e.responseType = t.XHR_RESPONSE_TYPE.TEXT : e.responseType = this.xhrType, e.addEventListener("error", this._boundXhrOnError, !1), e.addEventListener("timeout", this._boundXhrOnTimeout, !1), e.addEventListener("abort", this._boundXhrOnAbort, !1), e.addEventListener("progress", this._boundOnProgress, !1), e.addEventListener("load", this._boundXhrOnLoad, !1), e.send()
            }, t.prototype._loadXdr = function() {
                "string" != typeof this.xhrType && (this.xhrType = this._determineXhrType());
                var t = this.xhr = new globalThis.XDomainRequest;
                t.timeout = this.timeout || 5e3, t.onerror = this._boundXhrOnError, t.ontimeout = this._boundXhrOnTimeout, t.onprogress = this._boundOnProgress, t.onload = this._boundXhrOnLoad, t.open("GET", this.url, !0), setTimeout((function() {
                    return t.send()
                }), 1)
            }, t.prototype._createSource = function(t, e, n) {
                n || (n = t + "/" + this._getExtension(e));
                var r = document.createElement("source");
                return r.src = e, r.type = n, r
            }, t.prototype._onError = function(t) {
                this.abort("Failed to load element using: " + t.target.nodeName)
            }, t.prototype._onProgress = function(t) {
                t && t.lengthComputable && this.onProgress.dispatch(this, t.loaded / t.total)
            }, t.prototype._onTimeout = function() {
                this.abort("Load timed out.")
            }, t.prototype._xhrOnError = function() {
                var t = this.xhr;
                this.abort(ki(t) + " Request failed. Status: " + t.status + ', text: "' + t.statusText + '"')
            }, t.prototype._xhrOnTimeout = function() {
                var t = this.xhr;
                this.abort(ki(t) + " Request timed out.")
            }, t.prototype._xhrOnAbort = function() {
                var t = this.xhr;
                this.abort(ki(t) + " Request was aborted by the user.")
            }, t.prototype._xhrOnLoad = function() {
                var e = this.xhr,
                    n = "",
                    r = void 0 === e.status ? 200 : e.status;
                if ("" !== e.responseType && "text" !== e.responseType && void 0 !== e.responseType || (n = e.responseText), 0 === r && (n.length > 0 || e.responseType === t.XHR_RESPONSE_TYPE.BUFFER) ? r = 200 : 1223 === r && (r = 204), 2 == (r / 100 | 0)) {
                    if (this.xhrType === t.XHR_RESPONSE_TYPE.TEXT) this.data = n, this.type = t.TYPE.TEXT;
                    else if (this.xhrType === t.XHR_RESPONSE_TYPE.JSON) try {
                        this.data = JSON.parse(n), this.type = t.TYPE.JSON
                    } catch (t) {
                        return void this.abort("Error trying to parse loaded json: " + t)
                    } else if (this.xhrType === t.XHR_RESPONSE_TYPE.DOCUMENT) try {
                        if (globalThis.DOMParser) {
                            var i = new DOMParser;
                            this.data = i.parseFromString(n, "text/xml")
                        } else {
                            var o = document.createElement("div");
                            o.innerHTML = n, this.data = o
                        }
                        this.type = t.TYPE.XML
                    } catch (t) {
                        return void this.abort("Error trying to parse loaded xml: " + t)
                    } else this.data = e.response || n;
                    this.complete()
                } else this.abort("[" + e.status + "] " + e.statusText + ": " + e.responseURL)
            }, t.prototype._determineCrossOrigin = function(t, e) {
                if (0 === t.indexOf("data:")) return "";
                if (globalThis.origin !== globalThis.location.origin) return "anonymous";
                e = e || globalThis.location, Ui || (Ui = document.createElement("a")), Ui.href = t;
                var n = Ni(Ui.href, {
                        strictMode: !0
                    }),
                    r = !n.port && "" === e.port || n.port === e.port,
                    i = n.protocol ? n.protocol + ":" : "";
                return n.host === e.hostname && r && i === e.protocol ? "" : "anonymous"
            }, t.prototype._determineXhrType = function() {
                return t._xhrTypeMap[this.extension] || t.XHR_RESPONSE_TYPE.TEXT
            }, t.prototype._determineLoadType = function() {
                return t._loadTypeMap[this.extension] || t.LOAD_TYPE.XHR
            }, t.prototype._getExtension = function(t) {
                void 0 === t && (t = this.url);
                var e = "";
                if (this.isDataUrl) {
                    var n = t.indexOf("/");
                    e = t.substring(n + 1, t.indexOf(";", n))
                } else {
                    var r = t.indexOf("?"),
                        i = t.indexOf("#"),
                        o = Math.min(r > -1 ? r : t.length, i > -1 ? i : t.length);
                    e = (t = t.substring(0, o)).substring(t.lastIndexOf(".") + 1)
                }
                return e.toLowerCase()
            }, t.prototype._getMimeFromXhrType = function(e) {
                switch (e) {
                    case t.XHR_RESPONSE_TYPE.BUFFER:
                        return "application/octet-binary";
                    case t.XHR_RESPONSE_TYPE.BLOB:
                        return "application/blob";
                    case t.XHR_RESPONSE_TYPE.DOCUMENT:
                        return "application/xml";
                    case t.XHR_RESPONSE_TYPE.JSON:
                        return "application/json";
                    case t.XHR_RESPONSE_TYPE.DEFAULT:
                    case t.XHR_RESPONSE_TYPE.TEXT:
                    default:
                        return "text/plain"
                }
            }, t
        }();

        function Hi() {}

        function zi(t) {
            return function() {
                for (var e = arguments, n = [], r = 0; r < arguments.length; r++) n[r] = e[r];
                if (null === t) throw new Error("Callback was already called.");
                var i = t;
                t = null, i.apply(this, n)
            }
        }! function(t) {
            var e, n, r, i;
            (i = t.STATUS_FLAGS || (t.STATUS_FLAGS = {}))[i.NONE = 0] = "NONE", i[i.DATA_URL = 1] = "DATA_URL", i[i.COMPLETE = 2] = "COMPLETE", i[i.LOADING = 4] = "LOADING", (r = t.TYPE || (t.TYPE = {}))[r.UNKNOWN = 0] = "UNKNOWN", r[r.JSON = 1] = "JSON", r[r.XML = 2] = "XML", r[r.IMAGE = 3] = "IMAGE", r[r.AUDIO = 4] = "AUDIO", r[r.VIDEO = 5] = "VIDEO", r[r.TEXT = 6] = "TEXT", (n = t.LOAD_TYPE || (t.LOAD_TYPE = {}))[n.XHR = 1] = "XHR", n[n.IMAGE = 2] = "IMAGE", n[n.AUDIO = 3] = "AUDIO", n[n.VIDEO = 4] = "VIDEO", (e = t.XHR_RESPONSE_TYPE || (t.XHR_RESPONSE_TYPE = {})).DEFAULT = "text", e.BUFFER = "arraybuffer", e.BLOB = "blob", e.DOCUMENT = "document", e.JSON = "json", e.TEXT = "text", t._loadTypeMap = {
                gif: t.LOAD_TYPE.IMAGE,
                png: t.LOAD_TYPE.IMAGE,
                bmp: t.LOAD_TYPE.IMAGE,
                jpg: t.LOAD_TYPE.IMAGE,
                jpeg: t.LOAD_TYPE.IMAGE,
                tif: t.LOAD_TYPE.IMAGE,
                tiff: t.LOAD_TYPE.IMAGE,
                webp: t.LOAD_TYPE.IMAGE,
                tga: t.LOAD_TYPE.IMAGE,
                svg: t.LOAD_TYPE.IMAGE,
                "svg+xml": t.LOAD_TYPE.IMAGE,
                mp3: t.LOAD_TYPE.AUDIO,
                ogg: t.LOAD_TYPE.AUDIO,
                wav: t.LOAD_TYPE.AUDIO,
                mp4: t.LOAD_TYPE.VIDEO,
                webm: t.LOAD_TYPE.VIDEO
            }, t._xhrTypeMap = {
                xhtml: t.XHR_RESPONSE_TYPE.DOCUMENT,
                html: t.XHR_RESPONSE_TYPE.DOCUMENT,
                htm: t.XHR_RESPONSE_TYPE.DOCUMENT,
                xml: t.XHR_RESPONSE_TYPE.DOCUMENT,
                tmx: t.XHR_RESPONSE_TYPE.DOCUMENT,
                svg: t.XHR_RESPONSE_TYPE.DOCUMENT,
                tsx: t.XHR_RESPONSE_TYPE.DOCUMENT,
                gif: t.XHR_RESPONSE_TYPE.BLOB,
                png: t.XHR_RESPONSE_TYPE.BLOB,
                bmp: t.XHR_RESPONSE_TYPE.BLOB,
                jpg: t.XHR_RESPONSE_TYPE.BLOB,
                jpeg: t.XHR_RESPONSE_TYPE.BLOB,
                tif: t.XHR_RESPONSE_TYPE.BLOB,
                tiff: t.XHR_RESPONSE_TYPE.BLOB,
                webp: t.XHR_RESPONSE_TYPE.BLOB,
                tga: t.XHR_RESPONSE_TYPE.BLOB,
                json: t.XHR_RESPONSE_TYPE.JSON,
                text: t.XHR_RESPONSE_TYPE.TEXT,
                txt: t.XHR_RESPONSE_TYPE.TEXT,
                ttf: t.XHR_RESPONSE_TYPE.BUFFER,
                otf: t.XHR_RESPONSE_TYPE.BUFFER
            }, t.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="
        }(Gi || (Gi = {}));
        var Vi = function(t, e) {
                this.data = t, this.callback = e
            },
            Wi = function() {
                function t(t, e) {
                    var n = this;
                    if (void 0 === e && (e = 1), this.workers = 0, this.saturated = Hi, this.unsaturated = Hi, this.empty = Hi, this.drain = Hi, this.error = Hi, this.started = !1, this.paused = !1, this._tasks = [], this._insert = function(t, e, r) {
                            if (r && "function" != typeof r) throw new Error("task callback must be a function");
                            if (n.started = !0, null == t && n.idle()) setTimeout((function() {
                                return n.drain()
                            }), 1);
                            else {
                                var i = new Vi(t, "function" == typeof r ? r : Hi);
                                e ? n._tasks.unshift(i) : n._tasks.push(i), setTimeout(n.process, 1)
                            }
                        }, this.process = function() {
                            for (; !n.paused && n.workers < n.concurrency && n._tasks.length;) {
                                var t = n._tasks.shift();
                                0 === n._tasks.length && n.empty(), n.workers += 1, n.workers === n.concurrency && n.saturated(), n._worker(t.data, zi(n._next(t)))
                            }
                        }, this._worker = t, 0 === e) throw new Error("Concurrency must not be zero");
                    this.concurrency = e, this.buffer = e / 4
                }
                return t.prototype._next = function(t) {
                    var e = this;
                    return function() {
                        for (var n = arguments, r = [], i = 0; i < arguments.length; i++) r[i] = n[i];
                        e.workers -= 1, t.callback.apply(t, r), null != r[0] && e.error(r[0], t.data), e.workers <= e.concurrency - e.buffer && e.unsaturated(), e.idle() && e.drain(), e.process()
                    }
                }, t.prototype.push = function(t, e) {
                    this._insert(t, !1, e)
                }, t.prototype.kill = function() {
                    this.workers = 0, this.drain = Hi, this.started = !1, this._tasks = []
                }, t.prototype.unshift = function(t, e) {
                    this._insert(t, !0, e)
                }, t.prototype.length = function() {
                    return this._tasks.length
                }, t.prototype.running = function() {
                    return this.workers
                }, t.prototype.idle = function() {
                    return this._tasks.length + this.workers === 0
                }, t.prototype.pause = function() {
                    !0 !== this.paused && (this.paused = !0)
                }, t.prototype.resume = function() {
                    if (!1 !== this.paused) {
                        this.paused = !1;
                        for (var t = 1; t <= this.concurrency; t++) this.process()
                    }
                }, t.eachSeries = function(t, e, n, r) {
                    var i = 0,
                        o = t.length;
                    ! function s(a) {
                        a || i === o ? n && n(a) : r ? setTimeout((function() {
                            e(t[i++], s)
                        }), 1) : e(t[i++], s)
                    }()
                }, t.queue = function(e, n) {
                    return new t(e, n)
                }, t
            }(),
            Xi = /(#[\w-]+)?$/,
            ji = function() {
                function t(e, n) {
                    var r = this;
                    void 0 === e && (e = ""), void 0 === n && (n = 10), this.progress = 0, this.loading = !1, this.defaultQueryString = "", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(t, e) {
                        return r._loadResource(t, e)
                    }, this.resources = {}, this.baseUrl = e, this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(t, e) {
                        return r._loadResource(t, e)
                    }, this._queue = Wi.queue(this._boundLoadResource, n), this._queue.pause(), this.resources = {}, this.onProgress = new Li, this.onError = new Li, this.onLoad = new Li, this.onStart = new Li, this.onComplete = new Li;
                    for (var i = 0; i < t._plugins.length; ++i) {
                        var o = t._plugins[i],
                            s = o.pre,
                            a = o.use;
                        s && this.pre(s), a && this.use(a)
                    }
                    this._protected = !1
                }
                return t.prototype._add = function(t, e, n, r) {
                    if (this.loading && (!n || !n.parentResource)) throw new Error("Cannot add resources while the loader is running.");
                    if (this.resources[t]) throw new Error('Resource named "' + t + '" already exists.');
                    if (e = this._prepareUrl(e), this.resources[t] = new Gi(t, e, n), "function" == typeof r && this.resources[t].onAfterMiddleware.once(r), this.loading) {
                        for (var i = n.parentResource, o = [], s = 0; s < i.children.length; ++s) i.children[s].isComplete || o.push(i.children[s]);
                        var a = i.progressChunk * (o.length + 1) / (o.length + 2);
                        for (i.children.push(this.resources[t]), i.progressChunk = a, s = 0; s < o.length; ++s) o[s].progressChunk = a;
                        this.resources[t].progressChunk = a
                    }
                    return this._queue.push(this.resources[t]), this
                }, t.prototype.pre = function(t) {
                    return this._beforeMiddleware.push(t), this
                }, t.prototype.use = function(t) {
                    return this._afterMiddleware.push(t), this
                }, t.prototype.reset = function() {
                    for (var t in this.progress = 0, this.loading = !1, this._queue.kill(), this._queue.pause(), this.resources) {
                        var e = this.resources[t];
                        e._onLoadBinding && e._onLoadBinding.detach(), e.isLoading && e.abort("loader reset")
                    }
                    return this.resources = {}, this
                }, t.prototype.load = function(t) {
                    if ("function" == typeof t && this.onComplete.once(t), this.loading) return this;
                    if (this._queue.idle()) this._onStart(), this._onComplete();
                    else {
                        for (var e = 100 / this._queue._tasks.length, n = 0; n < this._queue._tasks.length; ++n) this._queue._tasks[n].data.progressChunk = e;
                        this._onStart(), this._queue.resume()
                    }
                    return this
                }, Object.defineProperty(t.prototype, "concurrency", {
                    get: function() {
                        return this._queue.concurrency
                    },
                    set: function(t) {
                        this._queue.concurrency = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype._prepareUrl = function(t) {
                    var e, n = Ni(t, {
                        strictMode: !0
                    });
                    if (e = n.protocol || !n.path || 0 === t.indexOf("//") ? t : this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && "/" !== t.charAt(0) ? this.baseUrl + "/" + t : this.baseUrl + t, this.defaultQueryString) {
                        var r = Xi.exec(e)[0]; - 1 !== (e = e.slice(0, e.length - r.length)).indexOf("?") ? e += "&" + this.defaultQueryString : e += "?" + this.defaultQueryString, e += r
                    }
                    return e
                }, t.prototype._loadResource = function(t, e) {
                    var n = this;
                    t._dequeue = e, Wi.eachSeries(this._beforeMiddleware, (function(e, r) {
                        e.call(n, t, (function() {
                            r(t.isComplete ? {} : null)
                        }))
                    }), (function() {
                        t.isComplete ? n._onLoad(t) : (t._onLoadBinding = t.onComplete.once(n._onLoad, n), t.load())
                    }), !0)
                }, t.prototype._onStart = function() {
                    this.progress = 0, this.loading = !0, this.onStart.dispatch(this)
                }, t.prototype._onComplete = function() {
                    this.progress = 100, this.loading = !1, this.onComplete.dispatch(this, this.resources)
                }, t.prototype._onLoad = function(t) {
                    var e = this;
                    t._onLoadBinding = null, this._resourcesParsing.push(t), t._dequeue(), Wi.eachSeries(this._afterMiddleware, (function(n, r) {
                        n.call(e, t, r)
                    }), (function() {
                        t.onAfterMiddleware.dispatch(t), e.progress = Math.min(100, e.progress + t.progressChunk), e.onProgress.dispatch(e, t), t.error ? e.onError.dispatch(t.error, e, t) : e.onLoad.dispatch(e, t), e._resourcesParsing.splice(e._resourcesParsing.indexOf(t), 1), e._queue.idle() && 0 === e._resourcesParsing.length && e._onComplete()
                    }), !0)
                }, t.prototype.destroy = function() {
                    this._protected || this.reset()
                }, Object.defineProperty(t, "shared", {
                    get: function() {
                        var e = t._shared;
                        return e || ((e = new t)._protected = !0, t._shared = e), e
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.registerPlugin = function(e) {
                    return t._plugins.push(e), e.add && e.add(), t
                }, t._plugins = [], t
            }();
        ji.prototype.add = function(t, e, n, r) {
            if (Array.isArray(t)) {
                for (var i = 0; i < t.length; ++i) this.add(t[i]);
                return this
            }
            if ("object" == typeof t && (n = t, r = e || n.callback || n.onComplete, e = n.url, t = n.name || n.key || n.url), "string" != typeof e && (r = n, n = e, e = t), "string" != typeof e) throw new Error("No url passed to add resource to loader.");
            return "function" == typeof n && (r = n, n = null), this._add(t, e, n, r)
        };
        var Yi, qi, Zi = function() {
                function t() {}
                return t.init = function(t) {
                    t = Object.assign({
                        sharedLoader: !1
                    }, t), this.loader = t.sharedLoader ? ji.shared : new ji
                }, t.destroy = function() {
                    this.loader && (this.loader.destroy(), this.loader = null)
                }, t
            }(),
            Ki = function() {
                function t() {}
                return t.add = function() {
                    Gi.setExtensionLoadType("svg", Gi.LOAD_TYPE.XHR), Gi.setExtensionXhrType("svg", Gi.XHR_RESPONSE_TYPE.TEXT)
                }, t.use = function(t, e) {
                    if (!t.data || t.type !== Gi.TYPE.IMAGE && "svg" !== t.extension) e();
                    else {
                        var n = t.data,
                            r = t.url,
                            i = t.name,
                            o = t.metadata;
                        Un.fromLoader(n, r, i, o).then((function(n) {
                            t.texture = n, e()
                        })).catch(e)
                    }
                }, t
            }(),
            Ji = self.URL || self.webkitURL;
        ji.registerPlugin({
                use: function(t, e) {
                    if (t.data) {
                        if (t.xhr && t.xhrType === Gi.XHR_RESPONSE_TYPE.BLOB)
                            if (self.Blob && "string" != typeof t.data) {
                                if (0 === t.data.type.indexOf("image")) {
                                    var n = Ji.createObjectURL(t.data);
                                    return t.blob = t.data, t.data = new Image, t.data.src = n, t.type = Gi.TYPE.IMAGE, void(t.data.onload = function() {
                                        Ji.revokeObjectURL(n), t.data.onload = null, e()
                                    })
                                }
                            } else {
                                var r = t.xhr.getResponseHeader("content-type");
                                if (r && 0 === r.indexOf("image")) return t.data = new Image, t.data.src = "data:" + r + ";base64," + function(t) {
                                    for (var e = "", n = 0; n < t.length;) {
                                        for (var r = [0, 0, 0], i = [0, 0, 0, 0], o = 0; o < r.length; ++o) n < t.length ? r[o] = 255 & t.charCodeAt(n++) : r[o] = 0;
                                        switch (i[0] = r[0] >> 2, i[1] = (3 & r[0]) << 4 | r[1] >> 4, i[2] = (15 & r[1]) << 2 | r[2] >> 6, i[3] = 63 & r[2], n - (t.length - 1)) {
                                            case 2:
                                                i[3] = 64, i[2] = 64;
                                                break;
                                            case 1:
                                                i[3] = 64
                                        }
                                        for (o = 0; o < i.length; ++o) e += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(i[o])
                                    }
                                    return e
                                }(t.xhr.responseText), t.type = Gi.TYPE.IMAGE, void(t.data.onload = function() {
                                    t.data.onload = null, e()
                                })
                            } e()
                    } else e()
                }
            }), ji.registerPlugin(Ki),
            function(t) {
                t[t.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", t[t.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", t[t.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", t[t.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", t[t.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", t[t.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", t[t.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", t[t.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", t[t.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", t[t.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", t[t.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", t[t.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", t[t.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", t[t.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", t[t.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", t[t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", t[t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", t[t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", t[t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", t[t.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", t[t.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", t[t.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", t[t.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"
            }(qi || (qi = {}));
        var Qi = ((Yi = {})[qi.COMPRESSED_RGB_S3TC_DXT1_EXT] = .5, Yi[qi.COMPRESSED_RGBA_S3TC_DXT1_EXT] = .5, Yi[qi.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, Yi[qi.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, Yi[qi.COMPRESSED_SRGB_S3TC_DXT1_EXT] = .5, Yi[qi.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = .5, Yi[qi.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, Yi[qi.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, Yi[qi.COMPRESSED_R11_EAC] = .5, Yi[qi.COMPRESSED_SIGNED_R11_EAC] = .5, Yi[qi.COMPRESSED_RG11_EAC] = 1, Yi[qi.COMPRESSED_SIGNED_RG11_EAC] = 1, Yi[qi.COMPRESSED_RGB8_ETC2] = .5, Yi[qi.COMPRESSED_RGBA8_ETC2_EAC] = 1, Yi[qi.COMPRESSED_SRGB8_ETC2] = .5, Yi[qi.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, Yi[qi.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = .5, Yi[qi.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = .5, Yi[qi.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = .5, Yi[qi.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = .5, Yi[qi.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = .25, Yi[qi.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = .25, Yi[qi.COMPRESSED_RGB_ETC1_WEBGL] = .5, Yi[qi.COMPRESSED_RGB_ATC_WEBGL] = .5, Yi[qi.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, Yi[qi.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, Yi),
            $i = function(t, e) {
                return ($i = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(t, e) {
                        t.__proto__ = e
                    } || function(t, e) {
                        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
                    })(t, e)
            };

        function to(t, e) {
            function n() {
                this.constructor = t
            }
            $i(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
        }
        var eo, no, ro = function(t) {
                function e(n, r) {
                    var i = t.call(this, n, r) || this;
                    return i.format = r.format, i.levels = r.levels || 1, i._width = r.width, i._height = r.height, i._extension = e._formatToExtension(i.format), (r.levelBuffers || i.buffer) && (i._levelBuffers = r.levelBuffers || e._createLevelBuffers(n instanceof Uint8Array ? n : i.buffer.uint8View, i.format, i.levels, 4, 4, i.width, i.height)), i
                }
                return to(e, t), e.prototype.upload = function(t, e, n) {
                    var r = t.gl;
                    if (!t.context.extensions[this._extension]) throw new Error(this._extension + " textures are not supported on the current machine");
                    if (!this._levelBuffers) return !1;
                    for (var i = 0, o = this.levels; i < o; i++) {
                        var s = this._levelBuffers[i],
                            a = s.levelID,
                            l = s.levelWidth,
                            u = s.levelHeight,
                            h = s.levelBuffer;
                        r.compressedTexImage2D(r.TEXTURE_2D, a, this.format, l, u, 0, h)
                    }
                    return !0
                }, e.prototype.onBlobLoaded = function() {
                    this._levelBuffers = e._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height)
                }, e._formatToExtension = function(t) {
                    if (t >= 33776 && t <= 33779) return "s3tc";
                    if (t >= 37488 && t <= 37497) return "etc";
                    if (t >= 35840 && t <= 35843) return "pvrtc";
                    if (t >= 36196) return "etc1";
                    if (t >= 35986 && t <= 34798) return "atc";
                    throw new Error("Invalid (compressed) texture format given!")
                }, e._createLevelBuffers = function(t, e, n, r, i, o, s) {
                    for (var a = new Array(n), l = t.byteOffset, u = o, h = s, c = u + r - 1 & ~(r - 1), d = h + i - 1 & ~(i - 1), p = c * d * Qi[e], f = 0; f < n; f++) a[f] = {
                        levelID: f,
                        levelWidth: n > 1 ? u : c,
                        levelHeight: n > 1 ? h : d,
                        levelBuffer: new Uint8Array(t.buffer, l, p)
                    }, l += p, p = (c = (u = u >> 1 || 1) + r - 1 & ~(r - 1)) * (d = (h = h >> 1 || 1) + i - 1 & ~(i - 1)) * Qi[e];
                    return a
                }, e
            }(function(t) {
                function e(e, n) {
                    void 0 === n && (n = {
                        width: 1,
                        height: 1,
                        autoLoad: !0
                    });
                    var r, i, o = this;
                    return "string" == typeof e ? (r = e, i = new Uint8Array) : (r = null, i = e), (o = t.call(this, i, n) || this).origin = r, o.buffer = i ? new mi(i) : null, o.origin && !1 !== n.autoLoad && o.load(), i && i.length && (o.loaded = !0, o.onBlobLoaded(o.buffer.rawBinaryData)), o
                }
                return to(e, t), e.prototype.onBlobLoaded = function(t) {}, e.prototype.load = function() {
                    return t = this, void 0, n = function() {
                        var t;
                        return function(t, e) {
                            var n, r, i, o, s = {
                                label: 0,
                                sent: function() {
                                    if (1 & i[0]) throw i[1];
                                    return i[1]
                                },
                                trys: [],
                                ops: []
                            };
                            return o = {
                                next: a(0),
                                throw: a(1),
                                return: a(2)
                            }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
                                return this
                            }), o;

                            function a(o) {
                                return function(a) {
                                    return function(o) {
                                        if (n) throw new TypeError("Generator is already executing.");
                                        for (; s;) try {
                                            if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
                                            switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                                                case 0:
                                                case 1:
                                                    i = o;
                                                    break;
                                                case 4:
                                                    return s.label++, {
                                                        value: o[1],
                                                        done: !1
                                                    };
                                                case 5:
                                                    s.label++, r = o[1], o = [0];
                                                    continue;
                                                case 7:
                                                    o = s.ops.pop(), s.trys.pop();
                                                    continue;
                                                default:
                                                    if (!((i = (i = s.trys).length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                                                        s = 0;
                                                        continue
                                                    }
                                                    if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                                                        s.label = o[1];
                                                        break
                                                    }
                                                    if (6 === o[0] && s.label < i[1]) {
                                                        s.label = i[1], i = o;
                                                        break
                                                    }
                                                    if (i && s.label < i[2]) {
                                                        s.label = i[2], s.ops.push(o);
                                                        break
                                                    }
                                                    i[2] && s.ops.pop(), s.trys.pop();
                                                    continue
                                            }
                                            o = e.call(t, s)
                                        } catch (t) {
                                            o = [6, t], r = 0
                                        } finally {
                                            n = i = 0
                                        }
                                        if (5 & o[0]) throw o[1];
                                        return {
                                            value: o[0] ? o[1] : void 0,
                                            done: !0
                                        }
                                    }([o, a])
                                }
                            }
                        }(this, (function(e) {
                            switch (e.label) {
                                case 0:
                                    return [4, fetch(this.origin)];
                                case 1:
                                    return [4, e.sent().blob()];
                                case 2:
                                    return [4, e.sent().arrayBuffer()];
                                case 3:
                                    return t = e.sent(), this.data = new Uint32Array(t), this.buffer = new mi(t), this.loaded = !0, this.onBlobLoaded(t), this.update(), [2, this]
                            }
                        }))
                    }, new((e = Promise) || (e = Promise))((function(r, i) {
                        function o(t) {
                            try {
                                a(n.next(t))
                            } catch (t) {
                                i(t)
                            }
                        }

                        function s(t) {
                            try {
                                a(n.throw(t))
                            } catch (t) {
                                i(t)
                            }
                        }

                        function a(t) {
                            t.done ? r(t.value) : new e((function(e) {
                                e(t.value)
                            })).then(o, s)
                        }
                        a((n = n.apply(t, [])).next())
                    }));
                    var t, e, n
                }, e
            }(_n)),
            io = function() {
                function t() {}
                return t.use = function(e, n) {
                    var r = e.data;
                    if (e.type === Gi.TYPE.JSON && r && r.cacheID && r.textures) {
                        for (var i = r.textures, o = void 0, s = void 0, a = 0, l = i.length; a < l; a++) {
                            var u = i[a],
                                h = u.src,
                                c = u.format;
                            if (c || (s = h), t.textureFormats[c]) {
                                o = h;
                                break
                            }
                        }
                        if (!(o = o || s)) return void n(new Error("Cannot load compressed-textures in " + e.url + ", make sure you provide a fallback"));
                        if (o === e.url) return void n(new Error("URL of compressed texture cannot be the same as the manifest's URL"));
                        var d = {
                                crossOrigin: e.crossOrigin,
                                metadata: e.metadata.imageMetadata,
                                parentResource: e
                            },
                            p = It.resolve(e.url.replace(this.baseUrl, ""), o),
                            f = r.cacheID;
                        this.add(f, p, d, (function(t) {
                            if (t.error) n(t.error);
                            else {
                                var r = t.texture,
                                    i = void 0 === r ? null : r,
                                    o = t.textures,
                                    s = void 0 === o ? {} : o;
                                Object.assign(e, {
                                    texture: i,
                                    textures: s
                                }), n()
                            }
                        }))
                    } else n()
                }, t.add = function() {
                    var e = document.createElement("canvas").getContext("webgl");
                    if (e) {
                        var n = {
                            s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
                            s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
                            etc: e.getExtension("WEBGL_compressed_texture_etc"),
                            etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
                            pvrtc: e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                            atc: e.getExtension("WEBGL_compressed_texture_atc"),
                            astc: e.getExtension("WEBGL_compressed_texture_astc")
                        };
                        for (var r in t.textureExtensions = n, t.textureFormats = {}, n) {
                            var i = n[r];
                            i && Object.assign(t.textureFormats, Object.getPrototypeOf(i))
                        }
                    } else console.warn("WebGL not available for compressed textures. Silently failing.")
                }, t
            }();

        function oo(t, e, n) {
            var r = {
                textures: {},
                texture: null
            };
            return e ? (e.map((function(t) {
                return new Un(new xn(t, Object.assign({
                    mipmap: gt.OFF,
                    alphaMode: vt.NO_PREMULTIPLIED_ALPHA
                }, n)))
            })).forEach((function(e, n) {
                var i = e.baseTexture,
                    o = t + "-" + (n + 1);
                xn.addToCache(i, o), Un.addToCache(e, o), 0 === n && (xn.addToCache(i, t), Un.addToCache(e, t), r.texture = e), r.textures[o] = e
            })), r) : r
        }
        Gi.setExtensionXhrType("dds", Gi.XHR_RESPONSE_TYPE.BUFFER);
        var so, ao;
        ! function(t) {
            t[t.DXGI_FORMAT_UNKNOWN = 0] = "DXGI_FORMAT_UNKNOWN", t[t.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS", t[t.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT", t[t.DXGI_FORMAT_R32G32B32A32_UINT = 3] = "DXGI_FORMAT_R32G32B32A32_UINT", t[t.DXGI_FORMAT_R32G32B32A32_SINT = 4] = "DXGI_FORMAT_R32G32B32A32_SINT", t[t.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS", t[t.DXGI_FORMAT_R32G32B32_FLOAT = 6] = "DXGI_FORMAT_R32G32B32_FLOAT", t[t.DXGI_FORMAT_R32G32B32_UINT = 7] = "DXGI_FORMAT_R32G32B32_UINT", t[t.DXGI_FORMAT_R32G32B32_SINT = 8] = "DXGI_FORMAT_R32G32B32_SINT", t[t.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS", t[t.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT", t[t.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM", t[t.DXGI_FORMAT_R16G16B16A16_UINT = 12] = "DXGI_FORMAT_R16G16B16A16_UINT", t[t.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM", t[t.DXGI_FORMAT_R16G16B16A16_SINT = 14] = "DXGI_FORMAT_R16G16B16A16_SINT", t[t.DXGI_FORMAT_R32G32_TYPELESS = 15] = "DXGI_FORMAT_R32G32_TYPELESS", t[t.DXGI_FORMAT_R32G32_FLOAT = 16] = "DXGI_FORMAT_R32G32_FLOAT", t[t.DXGI_FORMAT_R32G32_UINT = 17] = "DXGI_FORMAT_R32G32_UINT", t[t.DXGI_FORMAT_R32G32_SINT = 18] = "DXGI_FORMAT_R32G32_SINT", t[t.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS", t[t.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT", t[t.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS", t[t.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT", t[t.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS", t[t.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM", t[t.DXGI_FORMAT_R10G10B10A2_UINT = 25] = "DXGI_FORMAT_R10G10B10A2_UINT", t[t.DXGI_FORMAT_R11G11B10_FLOAT = 26] = "DXGI_FORMAT_R11G11B10_FLOAT", t[t.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS", t[t.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM", t[t.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB", t[t.DXGI_FORMAT_R8G8B8A8_UINT = 30] = "DXGI_FORMAT_R8G8B8A8_UINT", t[t.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM", t[t.DXGI_FORMAT_R8G8B8A8_SINT = 32] = "DXGI_FORMAT_R8G8B8A8_SINT", t[t.DXGI_FORMAT_R16G16_TYPELESS = 33] = "DXGI_FORMAT_R16G16_TYPELESS", t[t.DXGI_FORMAT_R16G16_FLOAT = 34] = "DXGI_FORMAT_R16G16_FLOAT", t[t.DXGI_FORMAT_R16G16_UNORM = 35] = "DXGI_FORMAT_R16G16_UNORM", t[t.DXGI_FORMAT_R16G16_UINT = 36] = "DXGI_FORMAT_R16G16_UINT", t[t.DXGI_FORMAT_R16G16_SNORM = 37] = "DXGI_FORMAT_R16G16_SNORM", t[t.DXGI_FORMAT_R16G16_SINT = 38] = "DXGI_FORMAT_R16G16_SINT", t[t.DXGI_FORMAT_R32_TYPELESS = 39] = "DXGI_FORMAT_R32_TYPELESS", t[t.DXGI_FORMAT_D32_FLOAT = 40] = "DXGI_FORMAT_D32_FLOAT", t[t.DXGI_FORMAT_R32_FLOAT = 41] = "DXGI_FORMAT_R32_FLOAT", t[t.DXGI_FORMAT_R32_UINT = 42] = "DXGI_FORMAT_R32_UINT", t[t.DXGI_FORMAT_R32_SINT = 43] = "DXGI_FORMAT_R32_SINT", t[t.DXGI_FORMAT_R24G8_TYPELESS = 44] = "DXGI_FORMAT_R24G8_TYPELESS", t[t.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT", t[t.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS", t[t.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT", t[t.DXGI_FORMAT_R8G8_TYPELESS = 48] = "DXGI_FORMAT_R8G8_TYPELESS", t[t.DXGI_FORMAT_R8G8_UNORM = 49] = "DXGI_FORMAT_R8G8_UNORM", t[t.DXGI_FORMAT_R8G8_UINT = 50] = "DXGI_FORMAT_R8G8_UINT", t[t.DXGI_FORMAT_R8G8_SNORM = 51] = "DXGI_FORMAT_R8G8_SNORM", t[t.DXGI_FORMAT_R8G8_SINT = 52] = "DXGI_FORMAT_R8G8_SINT", t[t.DXGI_FORMAT_R16_TYPELESS = 53] = "DXGI_FORMAT_R16_TYPELESS", t[t.DXGI_FORMAT_R16_FLOAT = 54] = "DXGI_FORMAT_R16_FLOAT", t[t.DXGI_FORMAT_D16_UNORM = 55] = "DXGI_FORMAT_D16_UNORM", t[t.DXGI_FORMAT_R16_UNORM = 56] = "DXGI_FORMAT_R16_UNORM", t[t.DXGI_FORMAT_R16_UINT = 57] = "DXGI_FORMAT_R16_UINT", t[t.DXGI_FORMAT_R16_SNORM = 58] = "DXGI_FORMAT_R16_SNORM", t[t.DXGI_FORMAT_R16_SINT = 59] = "DXGI_FORMAT_R16_SINT", t[t.DXGI_FORMAT_R8_TYPELESS = 60] = "DXGI_FORMAT_R8_TYPELESS", t[t.DXGI_FORMAT_R8_UNORM = 61] = "DXGI_FORMAT_R8_UNORM", t[t.DXGI_FORMAT_R8_UINT = 62] = "DXGI_FORMAT_R8_UINT", t[t.DXGI_FORMAT_R8_SNORM = 63] = "DXGI_FORMAT_R8_SNORM", t[t.DXGI_FORMAT_R8_SINT = 64] = "DXGI_FORMAT_R8_SINT", t[t.DXGI_FORMAT_A8_UNORM = 65] = "DXGI_FORMAT_A8_UNORM", t[t.DXGI_FORMAT_R1_UNORM = 66] = "DXGI_FORMAT_R1_UNORM", t[t.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP", t[t.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM", t[t.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM", t[t.DXGI_FORMAT_BC1_TYPELESS = 70] = "DXGI_FORMAT_BC1_TYPELESS", t[t.DXGI_FORMAT_BC1_UNORM = 71] = "DXGI_FORMAT_BC1_UNORM", t[t.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB", t[t.DXGI_FORMAT_BC2_TYPELESS = 73] = "DXGI_FORMAT_BC2_TYPELESS", t[t.DXGI_FORMAT_BC2_UNORM = 74] = "DXGI_FORMAT_BC2_UNORM", t[t.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB", t[t.DXGI_FORMAT_BC3_TYPELESS = 76] = "DXGI_FORMAT_BC3_TYPELESS", t[t.DXGI_FORMAT_BC3_UNORM = 77] = "DXGI_FORMAT_BC3_UNORM", t[t.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB", t[t.DXGI_FORMAT_BC4_TYPELESS = 79] = "DXGI_FORMAT_BC4_TYPELESS", t[t.DXGI_FORMAT_BC4_UNORM = 80] = "DXGI_FORMAT_BC4_UNORM", t[t.DXGI_FORMAT_BC4_SNORM = 81] = "DXGI_FORMAT_BC4_SNORM", t[t.DXGI_FORMAT_BC5_TYPELESS = 82] = "DXGI_FORMAT_BC5_TYPELESS", t[t.DXGI_FORMAT_BC5_UNORM = 83] = "DXGI_FORMAT_BC5_UNORM", t[t.DXGI_FORMAT_BC5_SNORM = 84] = "DXGI_FORMAT_BC5_SNORM", t[t.DXGI_FORMAT_B5G6R5_UNORM = 85] = "DXGI_FORMAT_B5G6R5_UNORM", t[t.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM", t[t.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM", t[t.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM", t[t.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM", t[t.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS", t[t.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB", t[t.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS", t[t.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB", t[t.DXGI_FORMAT_BC6H_TYPELESS = 94] = "DXGI_FORMAT_BC6H_TYPELESS", t[t.DXGI_FORMAT_BC6H_UF16 = 95] = "DXGI_FORMAT_BC6H_UF16", t[t.DXGI_FORMAT_BC6H_SF16 = 96] = "DXGI_FORMAT_BC6H_SF16", t[t.DXGI_FORMAT_BC7_TYPELESS = 97] = "DXGI_FORMAT_BC7_TYPELESS", t[t.DXGI_FORMAT_BC7_UNORM = 98] = "DXGI_FORMAT_BC7_UNORM", t[t.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB", t[t.DXGI_FORMAT_AYUV = 100] = "DXGI_FORMAT_AYUV", t[t.DXGI_FORMAT_Y410 = 101] = "DXGI_FORMAT_Y410", t[t.DXGI_FORMAT_Y416 = 102] = "DXGI_FORMAT_Y416", t[t.DXGI_FORMAT_NV12 = 103] = "DXGI_FORMAT_NV12", t[t.DXGI_FORMAT_P010 = 104] = "DXGI_FORMAT_P010", t[t.DXGI_FORMAT_P016 = 105] = "DXGI_FORMAT_P016", t[t.DXGI_FORMAT_420_OPAQUE = 106] = "DXGI_FORMAT_420_OPAQUE", t[t.DXGI_FORMAT_YUY2 = 107] = "DXGI_FORMAT_YUY2", t[t.DXGI_FORMAT_Y210 = 108] = "DXGI_FORMAT_Y210", t[t.DXGI_FORMAT_Y216 = 109] = "DXGI_FORMAT_Y216", t[t.DXGI_FORMAT_NV11 = 110] = "DXGI_FORMAT_NV11", t[t.DXGI_FORMAT_AI44 = 111] = "DXGI_FORMAT_AI44", t[t.DXGI_FORMAT_IA44 = 112] = "DXGI_FORMAT_IA44", t[t.DXGI_FORMAT_P8 = 113] = "DXGI_FORMAT_P8", t[t.DXGI_FORMAT_A8P8 = 114] = "DXGI_FORMAT_A8P8", t[t.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM", t[t.DXGI_FORMAT_P208 = 116] = "DXGI_FORMAT_P208", t[t.DXGI_FORMAT_V208 = 117] = "DXGI_FORMAT_V208", t[t.DXGI_FORMAT_V408 = 118] = "DXGI_FORMAT_V408", t[t.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE", t[t.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE", t[t.DXGI_FORMAT_FORCE_UINT = 121] = "DXGI_FORMAT_FORCE_UINT"
        }(so || (so = {})),
        function(t) {
            t[t.DDS_DIMENSION_TEXTURE1D = 2] = "DDS_DIMENSION_TEXTURE1D", t[t.DDS_DIMENSION_TEXTURE2D = 3] = "DDS_DIMENSION_TEXTURE2D", t[t.DDS_DIMENSION_TEXTURE3D = 6] = "DDS_DIMENSION_TEXTURE3D"
        }(ao || (ao = {}));
        var lo, uo, ho, co = ((eo = {})[827611204] = qi.COMPRESSED_RGBA_S3TC_DXT1_EXT, eo[861165636] = qi.COMPRESSED_RGBA_S3TC_DXT3_EXT, eo[894720068] = qi.COMPRESSED_RGBA_S3TC_DXT5_EXT, eo),
            po = ((no = {})[so.DXGI_FORMAT_BC1_TYPELESS] = qi.COMPRESSED_RGBA_S3TC_DXT1_EXT, no[so.DXGI_FORMAT_BC1_UNORM] = qi.COMPRESSED_RGBA_S3TC_DXT1_EXT, no[so.DXGI_FORMAT_BC2_TYPELESS] = qi.COMPRESSED_RGBA_S3TC_DXT3_EXT, no[so.DXGI_FORMAT_BC2_UNORM] = qi.COMPRESSED_RGBA_S3TC_DXT3_EXT, no[so.DXGI_FORMAT_BC3_TYPELESS] = qi.COMPRESSED_RGBA_S3TC_DXT5_EXT, no[so.DXGI_FORMAT_BC3_UNORM] = qi.COMPRESSED_RGBA_S3TC_DXT5_EXT, no[so.DXGI_FORMAT_BC1_UNORM_SRGB] = qi.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, no[so.DXGI_FORMAT_BC2_UNORM_SRGB] = qi.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, no[so.DXGI_FORMAT_BC3_UNORM_SRGB] = qi.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, no),
            fo = function() {
                function t() {}
                return t.use = function(e, n) {
                    if ("dds" === e.extension && e.data) try {
                        Object.assign(e, oo(e.name || e.url, t.parse(e.data), e.metadata))
                    } catch (t) {
                        return void n(t)
                    }
                    n()
                }, t.parse = function(t) {
                    var e = new Uint32Array(t);
                    if (542327876 !== e[0]) throw new Error("Invalid DDS file magic word");
                    var n = new Uint32Array(t, 0, 124 / Uint32Array.BYTES_PER_ELEMENT),
                        r = n[3],
                        i = n[4],
                        o = n[7],
                        s = new Uint32Array(t, 19 * Uint32Array.BYTES_PER_ELEMENT, 32 / Uint32Array.BYTES_PER_ELEMENT),
                        a = s[1];
                    if (4 & a) {
                        var l = s[2];
                        if (808540228 !== l) {
                            var u = co[l],
                                h = new Uint8Array(t, 128);
                            return [new ro(h, {
                                format: u,
                                width: i,
                                height: r,
                                levels: o
                            })]
                        }
                        var c = new Uint32Array(e.buffer, 128, 20 / Uint32Array.BYTES_PER_ELEMENT),
                            d = c[0],
                            p = c[1],
                            f = c[2],
                            m = c[3],
                            g = po[d];
                        if (void 0 === g) throw new Error("DDSLoader cannot parse texture data with DXGI format " + d);
                        if (4 === f) throw new Error("DDSLoader does not support cubemap textures");
                        if (p === ao.DDS_DIMENSION_TEXTURE3D) throw new Error("DDSLoader does not supported 3D texture data");
                        var v = new Array;
                        if (1 === m) v.push(new Uint8Array(t, 148));
                        else {
                            for (var _ = Qi[g], y = 0, x = i, b = r, E = 0; E < o; E++) y += Math.max(1, x + 3 & -4) * Math.max(1, b + 3 & -4) * _, x >>>= 1, b >>>= 1;
                            var T = 148;
                            for (E = 0; E < m; E++) v.push(new Uint8Array(t, T, y)), T += y
                        }
                        return v.map((function(t) {
                            return new ro(t, {
                                format: g,
                                width: i,
                                height: r,
                                levels: o
                            })
                        }))
                    }
                    if (64 & a) throw new Error("DDSLoader does not support uncompressed texture data.");
                    if (512 & a) throw new Error("DDSLoader does not supported YUV uncompressed texture data.");
                    if (131072 & a) throw new Error("DDSLoader does not support single-channel (lumninance) texture data!");
                    if (2 & a) throw new Error("DDSLoader does not support single-channel (alpha) texture data!");
                    throw new Error("DDSLoader failed to load a texture file due to an unknown reason!")
                }, t
            }();
        Gi.setExtensionXhrType("ktx", Gi.XHR_RESPONSE_TYPE.BUFFER);
        var mo = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10],
            go = ((lo = {})[dt.UNSIGNED_BYTE] = 1, lo[dt.UNSIGNED_SHORT] = 2, lo[dt.INT] = 4, lo[dt.UNSIGNED_INT] = 4, lo[dt.FLOAT] = 4, lo[dt.HALF_FLOAT] = 8, lo),
            vo = ((uo = {})[ht.RGBA] = 4, uo[ht.RGB] = 3, uo[ht.RG] = 2, uo[ht.RED] = 1, uo[ht.LUMINANCE] = 1, uo[ht.LUMINANCE_ALPHA] = 2, uo[ht.ALPHA] = 1, uo),
            _o = ((ho = {})[dt.UNSIGNED_SHORT_4_4_4_4] = 2, ho[dt.UNSIGNED_SHORT_5_5_5_1] = 2, ho[dt.UNSIGNED_SHORT_5_6_5] = 2, ho),
            yo = function() {
                function t() {}
                return t.use = function(e, n) {
                    if ("ktx" === e.extension && e.data) try {
                        var r = e.name || e.url,
                            i = t.parse(r, e.data),
                            o = i.compressed,
                            s = i.uncompressed;
                        if (o) Object.assign(e, oo(r, o, e.metadata));
                        else if (s) {
                            var a = {};
                            s.forEach((function(t, e) {
                                var n = new Un(new xn(t.resource, {
                                        mipmap: gt.OFF,
                                        alphaMode: vt.NO_PREMULTIPLIED_ALPHA,
                                        type: t.type,
                                        format: t.format
                                    })),
                                    i = r + "-" + (e + 1);
                                xn.addToCache(n.baseTexture, i), Un.addToCache(n, i), 0 === e && (a[r] = n, xn.addToCache(n.baseTexture, r), Un.addToCache(n, r)), a[i] = n
                            })), Object.assign(e, {
                                textures: a
                            })
                        }
                    } catch (t) {
                        return void n(t)
                    }
                    n()
                }, t.parse = function(e, n) {
                    var r = new DataView(n);
                    if (!t.validate(e, r)) return null;
                    var i = 67305985 === r.getUint32(12, !0),
                        o = r.getUint32(16, i),
                        s = r.getUint32(24, i),
                        a = r.getUint32(28, i),
                        l = r.getUint32(36, i),
                        u = r.getUint32(40, i) || 1,
                        h = r.getUint32(44, i) || 1,
                        c = r.getUint32(48, i) || 1,
                        d = r.getUint32(52, i),
                        p = r.getUint32(56, i),
                        f = r.getUint32(60, i);
                    if (0 === u || 1 !== h) throw new Error("Only 2D textures are supported");
                    if (1 !== d) throw new Error("CubeTextures are not supported by KTXLoader yet!");
                    if (1 !== c) throw new Error("WebGL does not support array textures");
                    var m, g = l + 3 & -4,
                        v = u + 3 & -4,
                        _ = new Array(c),
                        y = l * u;
                    if (0 === o && (y = g * v), void 0 === (m = 0 !== o ? go[o] ? go[o] * vo[s] : _o[o] : Qi[a])) throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
                    for (var x = y * m, b = l, E = u, T = g, S = v, w = 64 + f, M = 0; M < p; M++) {
                        for (var A = r.getUint32(w, i), R = w + 4, P = 0; P < c; P++) {
                            var I = _[P];
                            I || (I = _[P] = new Array(p)), I[M] = {
                                levelID: M,
                                levelWidth: p > 1 || 0 !== o ? b : T,
                                levelHeight: p > 1 || 0 !== o ? E : S,
                                levelBuffer: new Uint8Array(n, R, x)
                            }, R += x
                        }
                        w = (w += A + 4) % 4 != 0 ? w + 4 - w % 4 : w, x = (T = (b = b >> 1 || 1) + 4 - 1 & -4) * (S = (E = E >> 1 || 1) + 4 - 1 & -4) * m
                    }
                    return 0 !== o ? {
                        uncompressed: _.map((function(e) {
                            var n = e[0].levelBuffer,
                                r = !1;
                            return o === dt.FLOAT ? n = new Float32Array(e[0].levelBuffer.buffer, e[0].levelBuffer.byteOffset, e[0].levelBuffer.byteLength / 4) : o === dt.UNSIGNED_INT ? (r = !0, n = new Uint32Array(e[0].levelBuffer.buffer, e[0].levelBuffer.byteOffset, e[0].levelBuffer.byteLength / 4)) : o === dt.INT && (r = !0, n = new Int32Array(e[0].levelBuffer.buffer, e[0].levelBuffer.byteOffset, e[0].levelBuffer.byteLength / 4)), {
                                resource: new _n(n, {
                                    width: e[0].levelWidth,
                                    height: e[0].levelHeight
                                }),
                                type: o,
                                format: r ? t.convertFormatToInteger(s) : s
                            }
                        }))
                    } : {
                        compressed: _.map((function(t) {
                            return new ro(null, {
                                format: a,
                                width: l,
                                height: u,
                                levels: p,
                                levelBuffers: t
                            })
                        }))
                    }
                }, t.validate = function(t, e) {
                    for (var n = 0; n < mo.length; n++)
                        if (e.getUint8(n) !== mo[n]) return console.error(t + " is not a valid *.ktx file!"), !1;
                    return !0
                }, t.convertFormatToInteger = function(t) {
                    switch (t) {
                        case ht.RGBA:
                            return ht.RGBA_INTEGER;
                        case ht.RGB:
                            return ht.RGB_INTEGER;
                        case ht.RG:
                            return ht.RG_INTEGER;
                        case ht.RED:
                            return ht.RED_INTEGER;
                        default:
                            return t
                    }
                }, t
            }(),
            xo = function(t, e) {
                return (xo = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(t, e) {
                        t.__proto__ = e
                    } || function(t, e) {
                        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
                    })(t, e)
            };

        function bo(t, e) {
            function n() {
                this.constructor = t
            }
            xo(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
        }! function(t) {
            function e(e, n, r, i) {
                void 0 === e && (e = 1500), void 0 === r && (r = 16384), void 0 === i && (i = !1);
                var o = t.call(this) || this;
                return r > 16384 && (r = 16384), o._properties = [!1, !0, !1, !1, !1], o._maxSize = e, o._batchSize = r, o._buffers = null, o._bufferUpdateIDs = [], o._updateID = 0, o.interactiveChildren = !1, o.blendMode = lt.NORMAL, o.autoResize = i, o.roundPixels = !0, o.baseTexture = null, o.setProperties(n), o._tint = 0, o.tintRgb = new Float32Array(4), o.tint = 16777215, o
            }
            bo(e, t), e.prototype.setProperties = function(t) {
                t && (this._properties[0] = "vertices" in t || "scale" in t ? !!t.vertices || !!t.scale : this._properties[0], this._properties[1] = "position" in t ? !!t.position : this._properties[1], this._properties[2] = "rotation" in t ? !!t.rotation : this._properties[2], this._properties[3] = "uvs" in t ? !!t.uvs : this._properties[3], this._properties[4] = "tint" in t || "alpha" in t ? !!t.tint || !!t.alpha : this._properties[4])
            }, e.prototype.updateTransform = function() {
                this.displayObjectUpdateTransform()
            }, Object.defineProperty(e.prototype, "tint", {
                get: function() {
                    return this._tint
                },
                set: function(t) {
                    this._tint = t, Nt(t, this.tintRgb)
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype.render = function(t) {
                var e = this;
                this.visible && !(this.worldAlpha <= 0) && this.children.length && this.renderable && (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", (function() {
                    return e.onChildrenChange(0)
                }))), t.batch.setObjectRenderer(t.plugins.particle), t.plugins.particle.render(this))
            }, e.prototype.onChildrenChange = function(t) {
                for (var e = Math.floor(t / this._batchSize); this._bufferUpdateIDs.length < e;) this._bufferUpdateIDs.push(0);
                this._bufferUpdateIDs[e] = ++this._updateID
            }, e.prototype.dispose = function() {
                if (this._buffers) {
                    for (var t = 0; t < this._buffers.length; ++t) this._buffers[t].destroy();
                    this._buffers = null
                }
            }, e.prototype.destroy = function(e) {
                t.prototype.destroy.call(this, e), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null
            }
        }(Ke);
        var Eo, To, So = function() {
                function t(t, e, n) {
                    this.geometry = new Yn, this.indexBuffer = null, this.size = n, this.dynamicProperties = [], this.staticProperties = [];
                    for (var r = 0; r < t.length; ++r) {
                        var i = t[r];
                        i = {
                            attributeName: i.attributeName,
                            size: i.size,
                            uploadFunction: i.uploadFunction,
                            type: i.type || dt.FLOAT,
                            offset: i.offset
                        }, e[r] ? this.dynamicProperties.push(i) : this.staticProperties.push(i)
                    }
                    this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers()
                }
                return t.prototype.initBuffers = function() {
                    var t = this.geometry,
                        e = 0;
                    this.indexBuffer = new zn(function(t, e) {
                        void 0 === e && (e = null);
                        var n = 6 * t;
                        if ((e = e || new Uint16Array(n)).length !== n) throw new Error("Out buffer length is incorrect, got " + e.length + " and expected " + n);
                        for (var r = 0, i = 0; r < n; r += 6, i += 4) e[r + 0] = i + 0, e[r + 1] = i + 1, e[r + 2] = i + 2, e[r + 3] = i + 0, e[r + 4] = i + 2, e[r + 5] = i + 3;
                        return e
                    }(this.size), !0, !0), t.addIndex(this.indexBuffer), this.dynamicStride = 0;
                    for (var n = 0; n < this.dynamicProperties.length; ++n)(s = this.dynamicProperties[n]).offset = e, e += s.size, this.dynamicStride += s.size;
                    var r = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
                    this.dynamicData = new Float32Array(r), this.dynamicDataUint32 = new Uint32Array(r), this.dynamicBuffer = new zn(this.dynamicData, !1, !1);
                    var i = 0;
                    for (this.staticStride = 0, n = 0; n < this.staticProperties.length; ++n)(s = this.staticProperties[n]).offset = i, i += s.size, this.staticStride += s.size;
                    var o = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
                    for (this.staticData = new Float32Array(o), this.staticDataUint32 = new Uint32Array(o), this.staticBuffer = new zn(this.staticData, !0, !1), n = 0; n < this.dynamicProperties.length; ++n) {
                        var s = this.dynamicProperties[n];
                        t.addAttribute(s.attributeName, this.dynamicBuffer, 0, s.type === dt.UNSIGNED_BYTE, s.type, 4 * this.dynamicStride, 4 * s.offset)
                    }
                    for (n = 0; n < this.staticProperties.length; ++n) s = this.staticProperties[n], t.addAttribute(s.attributeName, this.staticBuffer, 0, s.type === dt.UNSIGNED_BYTE, s.type, 4 * this.staticStride, 4 * s.offset)
                }, t.prototype.uploadDynamic = function(t, e, n) {
                    for (var r = 0; r < this.dynamicProperties.length; r++) {
                        var i = this.dynamicProperties[r];
                        i.uploadFunction(t, e, n, i.type === dt.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, i.offset)
                    }
                    this.dynamicBuffer._updateID++
                }, t.prototype.uploadStatic = function(t, e, n) {
                    for (var r = 0; r < this.staticProperties.length; r++) {
                        var i = this.staticProperties[r];
                        i.uploadFunction(t, e, n, i.type === dt.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, i.offset)
                    }
                    this.staticBuffer._updateID++
                }, t.prototype.destroy = function() {
                    this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy()
                }, t
            }(),
            wo = function(t) {
                function e(e) {
                    var n = t.call(this, e) || this;
                    return n.shader = null, n.properties = null, n.tempMatrix = new me, n.properties = [{
                        attributeName: "aVertexPosition",
                        size: 2,
                        uploadFunction: n.uploadVertices,
                        offset: 0
                    }, {
                        attributeName: "aPositionCoord",
                        size: 2,
                        uploadFunction: n.uploadPosition,
                        offset: 0
                    }, {
                        attributeName: "aRotation",
                        size: 1,
                        uploadFunction: n.uploadRotation,
                        offset: 0
                    }, {
                        attributeName: "aTextureCoord",
                        size: 2,
                        uploadFunction: n.uploadUvs,
                        offset: 0
                    }, {
                        attributeName: "aColor",
                        size: 1,
                        type: dt.UNSIGNED_BYTE,
                        uploadFunction: n.uploadTint,
                        offset: 0
                    }], n.shader = Nr.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n", "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}", {}), n.state = Dr.for2d(), n
                }
                return bo(e, t), e.prototype.render = function(t) {
                    var e = t.children,
                        n = t._maxSize,
                        r = t._batchSize,
                        i = this.renderer,
                        o = e.length;
                    if (0 !== o) {
                        o > n && !t.autoResize && (o = n);
                        var s = t._buffers;
                        s || (s = t._buffers = this.generateBuffers(t));
                        var a = e[0]._texture.baseTexture;
                        this.state.blendMode = Bt(t.blendMode, a.alphaMode), i.state.set(this.state);
                        var l, u, h, c, d = i.gl,
                            p = t.worldTransform.copyTo(this.tempMatrix);
                        p.prepend(i.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = p.toArray(!0), this.shader.uniforms.uColor = (l = t.tintRgb, u = t.worldAlpha, h = this.shader.uniforms.uColor, c = a.alphaMode, h = h || new Float32Array(4), c || void 0 === c ? (h[0] = l[0] * u, h[1] = l[1] * u, h[2] = l[2] * u) : (h[0] = l[0], h[1] = l[1], h[2] = l[2]), h[3] = u, h), this.shader.uniforms.uSampler = a, this.renderer.shader.bind(this.shader);
                        for (var f = !1, m = 0, g = 0; m < o; m += r, g += 1) {
                            var v = o - m;
                            v > r && (v = r), g >= s.length && s.push(this._generateOneMoreBuffer(t));
                            var _ = s[g];
                            _.uploadDynamic(e, m, v);
                            var y = t._bufferUpdateIDs[g] || 0;
                            (f = f || _._updateID < y) && (_._updateID = t._updateID, _.uploadStatic(e, m, v)), i.geometry.bind(_.geometry), d.drawElements(d.TRIANGLES, 6 * v, d.UNSIGNED_SHORT, 0)
                        }
                    }
                }, e.prototype.generateBuffers = function(t) {
                    for (var e = [], n = t._maxSize, r = t._batchSize, i = t._properties, o = 0; o < n; o += r) e.push(new So(this.properties, i, r));
                    return e
                }, e.prototype._generateOneMoreBuffer = function(t) {
                    var e = t._batchSize,
                        n = t._properties;
                    return new So(this.properties, n, e)
                }, e.prototype.uploadVertices = function(t, e, n, r, i, o) {
                    for (var s = 0, a = 0, l = 0, u = 0, h = 0; h < n; ++h) {
                        var c = t[e + h],
                            d = c._texture,
                            p = c.scale.x,
                            f = c.scale.y,
                            m = d.trim,
                            g = d.orig;
                        m ? (s = (a = m.x - c.anchor.x * g.width) + m.width, l = (u = m.y - c.anchor.y * g.height) + m.height) : (s = g.width * (1 - c.anchor.x), a = g.width * -c.anchor.x, l = g.height * (1 - c.anchor.y), u = g.height * -c.anchor.y), r[o] = a * p, r[o + 1] = u * f, r[o + i] = s * p, r[o + i + 1] = u * f, r[o + 2 * i] = s * p, r[o + 2 * i + 1] = l * f, r[o + 3 * i] = a * p, r[o + 3 * i + 1] = l * f, o += 4 * i
                    }
                }, e.prototype.uploadPosition = function(t, e, n, r, i, o) {
                    for (var s = 0; s < n; s++) {
                        var a = t[e + s].position;
                        r[o] = a.x, r[o + 1] = a.y, r[o + i] = a.x, r[o + i + 1] = a.y, r[o + 2 * i] = a.x, r[o + 2 * i + 1] = a.y, r[o + 3 * i] = a.x, r[o + 3 * i + 1] = a.y, o += 4 * i
                    }
                }, e.prototype.uploadRotation = function(t, e, n, r, i, o) {
                    for (var s = 0; s < n; s++) {
                        var a = t[e + s].rotation;
                        r[o] = a, r[o + i] = a, r[o + 2 * i] = a, r[o + 3 * i] = a, o += 4 * i
                    }
                }, e.prototype.uploadUvs = function(t, e, n, r, i, o) {
                    for (var s = 0; s < n; ++s) {
                        var a = t[e + s]._texture._uvs;
                        a ? (r[o] = a.x0, r[o + 1] = a.y0, r[o + i] = a.x1, r[o + i + 1] = a.y1, r[o + 2 * i] = a.x2, r[o + 2 * i + 1] = a.y2, r[o + 3 * i] = a.x3, r[o + 3 * i + 1] = a.y3, o += 4 * i) : (r[o] = 0, r[o + 1] = 0, r[o + i] = 0, r[o + i + 1] = 0, r[o + 2 * i] = 0, r[o + 2 * i + 1] = 0, r[o + 3 * i] = 0, r[o + 3 * i + 1] = 0, o += 4 * i)
                    }
                }, e.prototype.uploadTint = function(t, e, n, r, i, o) {
                    for (var s = 0; s < n; ++s) {
                        var a = t[e + s],
                            l = a._texture.baseTexture.alphaMode > 0,
                            u = a.alpha,
                            h = u < 1 && l ? kt(a._tintRGB, u) : a._tintRGB + (255 * u << 24);
                        r[o] = h, r[o + i] = h, r[o + 2 * i] = h, r[o + 3 * i] = h, o += 4 * i
                    }
                }, e.prototype.destroy = function() {
                    t.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null
                }, e
            }(nr);
        ! function(t) {
            t.MITER = "miter", t.BEVEL = "bevel", t.ROUND = "round"
        }(Eo || (Eo = {})),
        function(t) {
            t.BUTT = "butt", t.ROUND = "round", t.SQUARE = "square"
        }(To || (To = {}));
        var Mo = {
                adaptive: !0,
                maxLength: 10,
                minSegments: 8,
                maxSegments: 2048,
                epsilon: 1e-4,
                _segmentsCount: function(t, e) {
                    if (void 0 === e && (e = 20), !this.adaptive || !t || isNaN(t)) return e;
                    var n = Math.ceil(t / this.maxLength);
                    return n < this.minSegments ? n = this.minSegments : n > this.maxSegments && (n = this.maxSegments), n
                }
            },
            Ao = function() {
                function t() {
                    this.color = 16777215, this.alpha = 1, this.texture = Un.WHITE, this.matrix = null, this.visible = !1, this.reset()
                }
                return t.prototype.clone = function() {
                    var e = new t;
                    return e.color = this.color, e.alpha = this.alpha, e.texture = this.texture, e.matrix = this.matrix, e.visible = this.visible, e
                }, t.prototype.reset = function() {
                    this.color = 16777215, this.alpha = 1, this.texture = Un.WHITE, this.matrix = null, this.visible = !1
                }, t.prototype.destroy = function() {
                    this.texture = null, this.matrix = null
                }, t
            }(),
            Ro = function(t, e) {
                return (Ro = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(t, e) {
                        t.__proto__ = e
                    } || function(t, e) {
                        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
                    })(t, e)
            };

        function Po(t, e) {
            function n() {
                this.constructor = t
            }
            Ro(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
        }

        function Io(t, e) {
            var n, r;
            void 0 === e && (e = !1);
            var i = t.length;
            if (!(i < 6)) {
                for (var o = 0, s = 0, a = t[i - 2], l = t[i - 1]; s < i; s += 2) {
                    var u = t[s],
                        h = t[s + 1];
                    o += (u - a) * (h + l), a = u, l = h
                }
                if (!e && o > 0 || e && o <= 0) {
                    var c = i / 2;
                    for (s = c + c % 2; s < i; s += 2) {
                        var d = i - s - 2,
                            p = i - s - 1,
                            f = s,
                            m = s + 1;
                        n = [t[f], t[d]], t[d] = n[0], t[f] = n[1], r = [t[m], t[p]], t[p] = r[0], t[m] = r[1]
                    }
                }
            }
        }
        var Co = {
                build: function(t) {
                    t.points = t.shape.points.slice()
                },
                triangulate: function(t, e) {
                    var n = t.points,
                        r = t.holes,
                        i = e.points,
                        o = e.indices;
                    if (n.length >= 6) {
                        Io(n, !1);
                        for (var s = [], a = 0; a < r.length; a++) {
                            var l = r[a];
                            Io(l.points, !0), s.push(n.length / 2), n = n.concat(l.points)
                        }
                        var u = Rt()(n, s, 2);
                        if (!u) return;
                        var h = i.length / 2;
                        for (a = 0; a < u.length; a += 3) o.push(u[a] + h), o.push(u[a + 1] + h), o.push(u[a + 2] + h);
                        for (a = 0; a < n.length; a++) i.push(n[a])
                    }
                }
            },
            Oo = {
                build: function(t) {
                    var e, n, r, i, o, s, a = t.points;
                    if (t.type === re.CIRC) {
                        var l = t.shape;
                        e = l.x, n = l.y, o = s = l.radius, r = i = 0
                    } else if (t.type === re.ELIP) {
                        var u = t.shape;
                        e = u.x, n = u.y, o = u.width, s = u.height, r = i = 0
                    } else {
                        var h = t.shape,
                            c = h.width / 2,
                            d = h.height / 2;
                        e = h.x + c, n = h.y + d, r = c - (o = s = Math.max(0, Math.min(h.radius, Math.min(c, d)))), i = d - s
                    }
                    var p = Math.ceil(2.3 * Math.sqrt(o + s)),
                        f = 8 * p + (r ? 4 : 0) + (i ? 4 : 0);
                    if (a.length = f, 0 !== f) {
                        if (0 === p) return a.length = 8, a[0] = a[6] = e + r, a[1] = a[3] = n + i, a[2] = a[4] = e - r, void(a[5] = a[7] = n - i);
                        var m, g, v = 0,
                            _ = 4 * p + (r ? 2 : 0) + 2,
                            y = _,
                            x = f,
                            b = e + (m = r + o),
                            E = e - m,
                            T = n + (g = i);
                        if (a[v++] = b, a[v++] = T, a[--_] = T, a[--_] = E, i) {
                            var S = n - g;
                            a[y++] = E, a[y++] = S, a[--x] = S, a[--x] = b
                        }
                        for (var w = 1; w < p; w++) {
                            var M = Math.PI / 2 * (w / p);
                            b = e + (m = r + Math.cos(M) * o), E = e - m, T = n + (g = i + Math.sin(M) * s), S = n - g, a[v++] = b, a[v++] = T, a[--_] = T, a[--_] = E, a[y++] = E, a[y++] = S, a[--x] = S, a[--x] = b
                        }
                        b = e + (m = r), E = e - m, T = n + (g = i + s), S = n - g, a[v++] = b, a[v++] = T, a[--x] = S, a[--x] = b, r && (a[v++] = E, a[v++] = T, a[--x] = S, a[--x] = E)
                    }
                },
                triangulate: function(t, e) {
                    var n, r, i = t.points,
                        o = e.points,
                        s = e.indices,
                        a = o.length / 2,
                        l = a;
                    if (t.type !== re.RREC) {
                        var u = t.shape;
                        n = u.x, r = u.y
                    } else {
                        var h = t.shape;
                        n = h.x + h.width / 2, r = h.y + h.height / 2
                    }
                    var c = t.matrix;
                    o.push(t.matrix ? c.a * n + c.c * r + c.tx : n, t.matrix ? c.b * n + c.d * r + c.ty : r), a++, o.push(i[0], i[1]);
                    for (var d = 2; d < i.length; d += 2) o.push(i[d], i[d + 1]), s.push(a++, l, a);
                    s.push(l + 1, l, a)
                }
            };

        function Lo(t, e, n) {
            return t + (e - t) * n
        }

        function No(t, e, n, r, i, o, s) {
            void 0 === s && (s = []);
            for (var a = s, l = 0, u = 0, h = 0, c = 0, d = 0, p = 0, f = 0, m = 0; f <= 20; ++f) l = Lo(t, n, m = f / 20), u = Lo(e, r, m), h = Lo(n, i, m), c = Lo(r, o, m), d = Lo(l, h, m), p = Lo(u, c, m), 0 === f && a[a.length - 2] === d && a[a.length - 1] === p || a.push(d, p);
            return a
        }
        var Do = {
            build: function(t) {
                if (es.nextRoundedRectBehavior) Oo.build(t);
                else {
                    var e = t.shape,
                        n = t.points,
                        r = e.x,
                        i = e.y,
                        o = e.width,
                        s = e.height,
                        a = Math.max(0, Math.min(e.radius, Math.min(o, s) / 2));
                    n.length = 0, a ? (No(r, i + a, r, i, r + a, i, n), No(r + o - a, i, r + o, i, r + o, i + a, n), No(r + o, i + s - a, r + o, i + s, r + o - a, i + s, n), No(r + a, i + s, r, i + s, r, i + s - a, n)) : n.push(r, i, r + o, i, r + o, i + s, r, i + s)
                }
            },
            triangulate: function(t, e) {
                if (es.nextRoundedRectBehavior) Oo.triangulate(t, e);
                else {
                    for (var n = t.points, r = e.points, i = e.indices, o = r.length / 2, s = Rt()(n, null, 2), a = 0, l = s.length; a < l; a += 3) i.push(s[a] + o), i.push(s[a + 1] + o), i.push(s[a + 2] + o);
                    for (a = 0, l = n.length; a < l; a++) r.push(n[a], n[++a])
                }
            }
        };

        function Uo(t, e, n, r, i, o, s, a) {
            var l, u;
            s ? (l = r, u = -n) : (l = -r, u = n);
            var h = t - n * i + l,
                c = e - r * i + u,
                d = t + n * o + l,
                p = e + r * o + u;
            return a.push(h, c), a.push(d, p), 2
        }

        function Fo(t, e, n, r, i, o, s, a) {
            var l = n - t,
                u = r - e,
                h = Math.atan2(l, u),
                c = Math.atan2(i - t, o - e);
            a && h < c ? h += 2 * Math.PI : !a && h > c && (c += 2 * Math.PI);
            var d = h,
                p = c - h,
                f = Math.abs(p),
                m = Math.sqrt(l * l + u * u),
                g = 1 + (15 * f * Math.sqrt(m) / Math.PI >> 0),
                v = p / g;
            if (d += v, a) {
                s.push(t, e), s.push(n, r);
                for (var _ = 1, y = d; _ < g; _++, y += v) s.push(t, e), s.push(t + Math.sin(y) * m, e + Math.cos(y) * m);
                s.push(t, e), s.push(i, o)
            } else {
                for (s.push(n, r), s.push(t, e), _ = 1, y = d; _ < g; _++, y += v) s.push(t + Math.sin(y) * m, e + Math.cos(y) * m), s.push(t, e);
                s.push(i, o), s.push(t, e)
            }
            return 2 * g
        }

        function Bo(t, e) {
            t.lineStyle.native ? function(t, e) {
                var n = 0,
                    r = t.shape,
                    i = t.points || r.points,
                    o = r.type !== re.POLY || r.closeStroke;
                if (0 !== i.length) {
                    var s = e.points,
                        a = e.indices,
                        l = i.length / 2,
                        u = s.length / 2,
                        h = u;
                    for (s.push(i[0], i[1]), n = 1; n < l; n++) s.push(i[2 * n], i[2 * n + 1]), a.push(h, h + 1), h++;
                    o && a.push(h, u)
                }
            }(t, e) : function(t, e) {
                var n = t.shape,
                    r = t.points || n.points.slice(),
                    i = e.closePointEps;
                if (0 !== r.length) {
                    var o = t.lineStyle,
                        s = new ae(r[0], r[1]),
                        a = new ae(r[r.length - 2], r[r.length - 1]),
                        l = n.type !== re.POLY || n.closeStroke,
                        u = Math.abs(s.x - a.x) < i && Math.abs(s.y - a.y) < i;
                    if (l) {
                        r = r.slice(), u && (r.pop(), r.pop(), a.set(r[r.length - 2], r[r.length - 1]));
                        var h = .5 * (s.x + a.x),
                            c = .5 * (a.y + s.y);
                        r.unshift(h, c), r.push(h, c)
                    }
                    var d = e.points,
                        p = r.length / 2,
                        f = r.length,
                        m = d.length / 2,
                        g = o.width / 2,
                        v = g * g,
                        _ = o.miterLimit * o.miterLimit,
                        y = r[0],
                        x = r[1],
                        b = r[2],
                        E = r[3],
                        T = 0,
                        S = 0,
                        w = -(x - E),
                        M = y - b,
                        A = 0,
                        R = 0,
                        P = Math.sqrt(w * w + M * M);
                    w /= P, M /= P, w *= g, M *= g;
                    var I = o.alignment,
                        C = 2 * (1 - I),
                        O = 2 * I;
                    l || (o.cap === To.ROUND ? f += Fo(y - w * (C - O) * .5, x - M * (C - O) * .5, y - w * C, x - M * C, y + w * O, x + M * O, d, !0) + 2 : o.cap === To.SQUARE && (f += Uo(y, x, w, M, C, O, !0, d))), d.push(y - w * C, x - M * C), d.push(y + w * O, x + M * O);
                    for (var L = 1; L < p - 1; ++L) {
                        y = r[2 * (L - 1)], x = r[2 * (L - 1) + 1], b = r[2 * L], E = r[2 * L + 1], T = r[2 * (L + 1)], S = r[2 * (L + 1) + 1], w = -(x - E), M = y - b, w /= P = Math.sqrt(w * w + M * M), M /= P, w *= g, M *= g, A = -(E - S), R = b - T, A /= P = Math.sqrt(A * A + R * R), R /= P, A *= g, R *= g;
                        var N = b - y,
                            D = x - E,
                            U = b - T,
                            F = S - E,
                            B = D * U - F * N,
                            k = B < 0;
                        if (Math.abs(B) < .1) d.push(b - w * C, E - M * C), d.push(b + w * O, E + M * O);
                        else {
                            var G = (-w + y) * (-M + E) - (-w + b) * (-M + x),
                                H = (-A + T) * (-R + E) - (-A + b) * (-R + S),
                                z = (N * H - U * G) / B,
                                V = (F * G - D * H) / B,
                                W = (z - b) * (z - b) + (V - E) * (V - E),
                                X = b + (z - b) * C,
                                j = E + (V - E) * C,
                                Y = b - (z - b) * O,
                                q = E - (V - E) * O,
                                Z = k ? C : O;
                            W <= Math.min(N * N + D * D, U * U + F * F) + Z * Z * v ? o.join === Eo.BEVEL || W / v > _ ? (k ? (d.push(X, j), d.push(b + w * O, E + M * O), d.push(X, j), d.push(b + A * O, E + R * O)) : (d.push(b - w * C, E - M * C), d.push(Y, q), d.push(b - A * C, E - R * C), d.push(Y, q)), f += 2) : o.join === Eo.ROUND ? k ? (d.push(X, j), d.push(b + w * O, E + M * O), f += Fo(b, E, b + w * O, E + M * O, b + A * O, E + R * O, d, !0) + 4, d.push(X, j), d.push(b + A * O, E + R * O)) : (d.push(b - w * C, E - M * C), d.push(Y, q), f += Fo(b, E, b - w * C, E - M * C, b - A * C, E - R * C, d, !1) + 4, d.push(b - A * C, E - R * C), d.push(Y, q)) : (d.push(X, j), d.push(Y, q)) : (d.push(b - w * C, E - M * C), d.push(b + w * O, E + M * O), o.join === Eo.BEVEL || W / v > _ || (o.join === Eo.ROUND ? f += k ? Fo(b, E, b + w * O, E + M * O, b + A * O, E + R * O, d, !0) + 2 : Fo(b, E, b - w * C, E - M * C, b - A * C, E - R * C, d, !1) + 2 : (k ? (d.push(Y, q), d.push(Y, q)) : (d.push(X, j), d.push(X, j)), f += 2)), d.push(b - A * C, E - R * C), d.push(b + A * O, E + R * O), f += 2)
                        }
                    }
                    y = r[2 * (p - 2)], x = r[2 * (p - 2) + 1], b = r[2 * (p - 1)], w = -(x - (E = r[2 * (p - 1) + 1])), M = y - b, w /= P = Math.sqrt(w * w + M * M), M /= P, w *= g, M *= g, d.push(b - w * C, E - M * C), d.push(b + w * O, E + M * O), l || (o.cap === To.ROUND ? f += Fo(b - w * (C - O) * .5, E - M * (C - O) * .5, b - w * C, E - M * C, b + w * O, E + M * O, d, !1) + 2 : o.cap === To.SQUARE && (f += Uo(b, E, w, M, C, O, !1, d)));
                    var K = e.indices,
                        J = Mo.epsilon * Mo.epsilon;
                    for (L = m; L < f + m - 2; ++L) y = d[2 * L], x = d[2 * L + 1], b = d[2 * (L + 1)], E = d[2 * (L + 1) + 1], T = d[2 * (L + 2)], S = d[2 * (L + 2) + 1], Math.abs(y * (E - S) + b * (S - x) + T * (x - E)) < J || K.push(L, L + 1, L + 2)
                }
            }(t, e)
        }
        var ko, Go, Ho = function() {
                function t() {}
                return t.curveTo = function(t, e, n, r, i, o) {
                    var s = o[o.length - 2],
                        a = o[o.length - 1] - e,
                        l = s - t,
                        u = r - e,
                        h = n - t,
                        c = Math.abs(a * h - l * u);
                    if (c < 1e-8 || 0 === i) return o[o.length - 2] === t && o[o.length - 1] === e || o.push(t, e), null;
                    var d = a * a + l * l,
                        p = u * u + h * h,
                        f = a * u + l * h,
                        m = i * Math.sqrt(d) / c,
                        g = i * Math.sqrt(p) / c,
                        v = m * f / d,
                        _ = g * f / p,
                        y = m * h + g * l,
                        x = m * u + g * a,
                        b = l * (g + v),
                        E = a * (g + v),
                        T = h * (m + _),
                        S = u * (m + _);
                    return {
                        cx: y + t,
                        cy: x + e,
                        radius: i,
                        startAngle: Math.atan2(E - x, b - y),
                        endAngle: Math.atan2(S - x, T - y),
                        anticlockwise: l * u > h * a
                    }
                }, t.arc = function(t, e, n, r, i, o, s, a, l) {
                    for (var u = s - o, h = Mo._segmentsCount(Math.abs(u) * i, 40 * Math.ceil(Math.abs(u) / ie)), c = u / (2 * h), d = 2 * c, p = Math.cos(c), f = Math.sin(c), m = h - 1, g = m % 1 / m, v = 0; v <= m; ++v) {
                        var _ = c + o + d * (v + g * v),
                            y = Math.cos(_),
                            x = -Math.sin(_);
                        l.push((p * y + f * x) * i + n, (p * -x + f * y) * i + r)
                    }
                }, t
            }(),
            zo = function() {
                function t() {}
                return t.curveLength = function(t, e, n, r, i, o, s, a) {
                    for (var l = 0, u = 0, h = 0, c = 0, d = 0, p = 0, f = 0, m = 0, g = 0, v = 0, _ = 0, y = t, x = e, b = 1; b <= 10; ++b) v = y - (m = (f = (p = (d = 1 - (u = b / 10)) * d) * d) * t + 3 * p * u * n + 3 * d * (h = u * u) * i + (c = h * u) * s), _ = x - (g = f * e + 3 * p * u * r + 3 * d * h * o + c * a), y = m, x = g, l += Math.sqrt(v * v + _ * _);
                    return l
                }, t.curveTo = function(e, n, r, i, o, s, a) {
                    var l = a[a.length - 2],
                        u = a[a.length - 1];
                    a.length -= 2;
                    var h = Mo._segmentsCount(t.curveLength(l, u, e, n, r, i, o, s)),
                        c = 0,
                        d = 0,
                        p = 0,
                        f = 0,
                        m = 0;
                    a.push(l, u);
                    for (var g = 1, v = 0; g <= h; ++g) p = (d = (c = 1 - (v = g / h)) * c) * c, m = (f = v * v) * v, a.push(p * l + 3 * d * v * e + 3 * c * f * r + m * o, p * u + 3 * d * v * n + 3 * c * f * i + m * s)
                }, t
            }(),
            Vo = function() {
                function t() {}
                return t.curveLength = function(t, e, n, r, i, o) {
                    var s = t - 2 * n + i,
                        a = e - 2 * r + o,
                        l = 2 * n - 2 * t,
                        u = 2 * r - 2 * e,
                        h = 4 * (s * s + a * a),
                        c = 4 * (s * l + a * u),
                        d = l * l + u * u,
                        p = 2 * Math.sqrt(h + c + d),
                        f = Math.sqrt(h),
                        m = 2 * h * f,
                        g = 2 * Math.sqrt(d),
                        v = c / f;
                    return (m * p + f * c * (p - g) + (4 * d * h - c * c) * Math.log((2 * f + v + p) / (v + g))) / (4 * m)
                }, t.curveTo = function(e, n, r, i, o) {
                    for (var s = o[o.length - 2], a = o[o.length - 1], l = Mo._segmentsCount(t.curveLength(s, a, e, n, r, i)), u = 0, h = 0, c = 1; c <= l; ++c) {
                        var d = c / l;
                        u = s + (e - s) * d, h = a + (n - a) * d, o.push(u + (e + (r - e) * d - u) * d, h + (n + (i - n) * d - h) * d)
                    }
                }, t
            }(),
            Wo = function() {
                function t() {
                    this.reset()
                }
                return t.prototype.begin = function(t, e, n) {
                    this.reset(), this.style = t, this.start = e, this.attribStart = n
                }, t.prototype.end = function(t, e) {
                    this.attribSize = e - this.attribStart, this.size = t - this.start
                }, t.prototype.reset = function() {
                    this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0
                }, t
            }(),
            Xo = ((ko = {})[re.POLY] = Co, ko[re.CIRC] = Oo, ko[re.ELIP] = Oo, ko[re.RECT] = {
                build: function(t) {
                    var e = t.shape,
                        n = e.x,
                        r = e.y,
                        i = e.width,
                        o = e.height,
                        s = t.points;
                    s.length = 0, s.push(n, r, n + i, r, n + i, r + o, n, r + o)
                },
                triangulate: function(t, e) {
                    var n = t.points,
                        r = e.points,
                        i = r.length / 2;
                    r.push(n[0], n[1], n[2], n[3], n[6], n[7], n[4], n[5]), e.indices.push(i, i + 1, i + 2, i + 1, i + 2, i + 3)
                }
            }, ko[re.RREC] = Do, ko),
            jo = [],
            Yo = [],
            qo = function() {
                function t(t, e, n, r) {
                    void 0 === e && (e = null), void 0 === n && (n = null), void 0 === r && (r = null), this.points = [], this.holes = [], this.shape = t, this.lineStyle = n, this.fillStyle = e, this.matrix = r, this.type = t.type
                }
                return t.prototype.clone = function() {
                    return new t(this.shape, this.fillStyle, this.lineStyle, this.matrix)
                }, t.prototype.destroy = function() {
                    this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null
                }, t
            }(),
            Zo = new ae,
            Ko = new we,
            Jo = function(t) {
                function e() {
                    var e = t.call(this) || this;
                    return e.closePointEps = 1e-4, e.boundsPadding = 0, e.uvsFloat32 = null, e.indicesUint16 = null, e.batchable = !1, e.points = [], e.colors = [], e.uvs = [], e.indices = [], e.textureIds = [], e.graphicsData = [], e.drawCalls = [], e.batchDirty = -1, e.batches = [], e.dirty = 0, e.cacheDirty = -1, e.clearDirty = 0, e.shapeIndex = 0, e._bounds = new we, e.boundsDirty = -1, e
                }
                return Po(e, t), Object.defineProperty(e.prototype, "bounds", {
                    get: function() {
                        return this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype.invalidate = function() {
                    this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
                    for (var t = 0; t < this.drawCalls.length; t++) this.drawCalls[t].texArray.clear(), Yo.push(this.drawCalls[t]);
                    for (this.drawCalls.length = 0, t = 0; t < this.batches.length; t++) {
                        var e = this.batches[t];
                        e.reset(), jo.push(e)
                    }
                    this.batches.length = 0
                }, e.prototype.clear = function() {
                    return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this
                }, e.prototype.drawShape = function(t, e, n, r) {
                    void 0 === e && (e = null), void 0 === n && (n = null), void 0 === r && (r = null);
                    var i = new qo(t, e, n, r);
                    return this.graphicsData.push(i), this.dirty++, this
                }, e.prototype.drawHole = function(t, e) {
                    if (void 0 === e && (e = null), !this.graphicsData.length) return null;
                    var n = new qo(t, null, null, e),
                        r = this.graphicsData[this.graphicsData.length - 1];
                    return n.lineStyle = r.lineStyle, r.holes.push(n), this.dirty++, this
                }, e.prototype.destroy = function() {
                    t.prototype.destroy.call(this);
                    for (var e = 0; e < this.graphicsData.length; ++e) this.graphicsData[e].destroy();
                    this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null
                }, e.prototype.containsPoint = function(t) {
                    for (var e = this.graphicsData, n = 0; n < e.length; ++n) {
                        var r = e[n];
                        if (r.fillStyle.visible && r.shape && (r.matrix ? r.matrix.applyInverse(t, Zo) : Zo.copyFrom(t), r.shape.contains(Zo.x, Zo.y))) {
                            var i = !1;
                            if (r.holes)
                                for (var o = 0; o < r.holes.length; o++)
                                    if (r.holes[o].shape.contains(Zo.x, Zo.y)) {
                                        i = !0;
                                        break
                                    } if (!i) return !0
                        }
                    }
                    return !1
                }, e.prototype.updateBatches = function(t) {
                    if (this.graphicsData.length) {
                        if (this.validateBatching()) {
                            this.cacheDirty = this.dirty;
                            var e = this.uvs,
                                n = this.graphicsData,
                                r = null,
                                i = null;
                            this.batches.length > 0 && (i = (r = this.batches[this.batches.length - 1]).style);
                            for (var o = this.shapeIndex; o < n.length; o++) {
                                this.shapeIndex++;
                                var s = n[o],
                                    a = s.fillStyle,
                                    l = s.lineStyle;
                                Xo[s.type].build(s), s.matrix && this.transformPoints(s.points, s.matrix), (a.visible || l.visible) && this.processHoles(s.holes);
                                for (var u = 0; u < 2; u++) {
                                    var h = 0 === u ? a : l;
                                    if (h.visible) {
                                        var c = h.texture.baseTexture,
                                            d = this.indices.length,
                                            p = this.points.length / 2;
                                        c.wrapMode = mt.REPEAT, 0 === u ? this.processFill(s) : this.processLine(s);
                                        var f = this.points.length / 2 - p;
                                        0 !== f && (r && !this._compareStyles(i, h) && (r.end(d, p), r = null), r || ((r = jo.pop() || new Wo).begin(h, d, p), this.batches.push(r), i = h), this.addUvs(this.points, e, h.texture, p, f, h.matrix))
                                    }
                                }
                            }
                            var m = this.indices.length,
                                g = this.points.length / 2;
                            if (r && r.end(m, g), 0 !== this.batches.length) {
                                if (this.indicesUint16 && this.indices.length === this.indicesUint16.length) this.indicesUint16.set(this.indices);
                                else {
                                    var v = g > 65535 && t;
                                    this.indicesUint16 = v ? new Uint32Array(this.indices) : new Uint16Array(this.indices)
                                }
                                this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls()
                            } else this.batchable = !0
                        }
                    } else this.batchable = !0
                }, e.prototype._compareStyles = function(t, e) {
                    return !(!t || !e) && t.texture.baseTexture === e.texture.baseTexture && t.color + t.alpha === e.color + e.alpha && !!t.native == !!e.native
                }, e.prototype.validateBatching = function() {
                    if (this.dirty === this.cacheDirty || !this.graphicsData.length) return !1;
                    for (var t = 0, e = this.graphicsData.length; t < e; t++) {
                        var n = this.graphicsData[t],
                            r = n.fillStyle,
                            i = n.lineStyle;
                        if (r && !r.texture.baseTexture.valid) return !1;
                        if (i && !i.texture.baseTexture.valid) return !1
                    }
                    return !0
                }, e.prototype.packBatches = function() {
                    this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
                    for (var t = this.batches, e = 0, n = t.length; e < n; e++)
                        for (var r = t[e], i = 0; i < r.size; i++) {
                            var o = r.start + i;
                            this.indicesUint16[o] = this.indicesUint16[o] - r.attribStart
                        }
                }, e.prototype.isBatchable = function() {
                    if (this.points.length > 131070) return !1;
                    for (var t = this.batches, n = 0; n < t.length; n++)
                        if (t[n].style.native) return !1;
                    return this.points.length < 2 * e.BATCHABLE_SIZE
                }, e.prototype.buildDrawCalls = function() {
                    for (var t = ++xn._globalBatch, e = 0; e < this.drawCalls.length; e++) this.drawCalls[e].texArray.clear(), Yo.push(this.drawCalls[e]);
                    this.drawCalls.length = 0;
                    var n = this.colors,
                        r = this.textureIds,
                        i = Yo.pop();
                    i || ((i = new pi).texArray = new fi), i.texArray.count = 0, i.start = 0, i.size = 0, i.type = ut.TRIANGLES;
                    var o = 0,
                        s = null,
                        a = 0,
                        l = !1,
                        u = ut.TRIANGLES,
                        h = 0;
                    for (this.drawCalls.push(i), e = 0; e < this.batches.length; e++) {
                        var c = this.batches[e],
                            d = c.style,
                            p = d.texture.baseTexture;
                        l !== !!d.native && (u = (l = !!d.native) ? ut.LINES : ut.TRIANGLES, s = null, o = 8, t++), s !== p && (s = p, p._batchEnabled !== t && (8 === o && (t++, o = 0, i.size > 0 && ((i = Yo.pop()) || ((i = new pi).texArray = new fi), this.drawCalls.push(i)), i.start = h, i.size = 0, i.texArray.count = 0, i.type = u), p.touched = 1, p._batchEnabled = t, p._batchLocation = o, p.wrapMode = mt.REPEAT, i.texArray.elements[i.texArray.count++] = p, o++)), i.size += c.size, h += c.size, a = p._batchLocation, this.addColors(n, d.color, d.alpha, c.attribSize, c.attribStart), this.addTextureIds(r, a, c.attribSize, c.attribStart)
                    }
                    xn._globalBatch = t, this.packAttributes()
                }, e.prototype.packAttributes = function() {
                    for (var t = this.points, e = this.uvs, n = this.colors, r = this.textureIds, i = new ArrayBuffer(3 * t.length * 4), o = new Float32Array(i), s = new Uint32Array(i), a = 0, l = 0; l < t.length / 2; l++) o[a++] = t[2 * l], o[a++] = t[2 * l + 1], o[a++] = e[2 * l], o[a++] = e[2 * l + 1], s[a++] = n[l], o[a++] = r[l];
                    this._buffer.update(i), this._indexBuffer.update(this.indicesUint16)
                }, e.prototype.processFill = function(t) {
                    t.holes.length ? Co.triangulate(t, this) : Xo[t.type].triangulate(t, this)
                }, e.prototype.processLine = function(t) {
                    Bo(t, this);
                    for (var e = 0; e < t.holes.length; e++) Bo(t.holes[e], this)
                }, e.prototype.processHoles = function(t) {
                    for (var e = 0; e < t.length; e++) {
                        var n = t[e];
                        Xo[n.type].build(n), n.matrix && this.transformPoints(n.points, n.matrix)
                    }
                }, e.prototype.calculateBounds = function() {
                    var t = this._bounds,
                        e = Ko,
                        n = me.IDENTITY;
                    this._bounds.clear(), e.clear();
                    for (var r = 0; r < this.graphicsData.length; r++) {
                        var i = this.graphicsData[r],
                            o = i.shape,
                            s = i.type,
                            a = i.lineStyle,
                            l = i.matrix || me.IDENTITY,
                            u = 0;
                        if (a && a.visible && (u = a.width * Math.max(0, a.alignment)), n !== l && (e.isEmpty() || (t.addBoundsMatrix(e, n), e.clear()), n = l), s === re.RECT || s === re.RREC) {
                            var h = o;
                            e.addFramePad(h.x, h.y, h.x + h.width, h.y + h.height, u, u)
                        } else if (s === re.CIRC) {
                            var c = o;
                            e.addFramePad(c.x, c.y, c.x, c.y, c.radius + u, c.radius + u)
                        } else if (s === re.ELIP) {
                            var d = o;
                            e.addFramePad(d.x, d.y, d.x, d.y, d.width + u, d.height + u)
                        } else {
                            var p = o;
                            t.addVerticesMatrix(n, p.points, 0, p.points.length, u, u)
                        }
                    }
                    e.isEmpty() || t.addBoundsMatrix(e, n), t.pad(this.boundsPadding, this.boundsPadding)
                }, e.prototype.transformPoints = function(t, e) {
                    for (var n = 0; n < t.length / 2; n++) {
                        var r = t[2 * n],
                            i = t[2 * n + 1];
                        t[2 * n] = e.a * r + e.c * i + e.tx, t[2 * n + 1] = e.b * r + e.d * i + e.ty
                    }
                }, e.prototype.addColors = function(t, e, n, r, i) {
                    void 0 === i && (i = 0);
                    var o = kt((e >> 16) + (65280 & e) + ((255 & e) << 16), n);
                    t.length = Math.max(t.length, i + r);
                    for (var s = 0; s < r; s++) t[i + s] = o
                }, e.prototype.addTextureIds = function(t, e, n, r) {
                    void 0 === r && (r = 0), t.length = Math.max(t.length, r + n);
                    for (var i = 0; i < n; i++) t[r + i] = e
                }, e.prototype.addUvs = function(t, e, n, r, i, o) {
                    void 0 === o && (o = null);
                    for (var s = 0, a = e.length, l = n.frame; s < i;) {
                        var u = t[2 * (r + s)],
                            h = t[2 * (r + s) + 1];
                        if (o) {
                            var c = o.a * u + o.c * h + o.tx;
                            h = o.b * u + o.d * h + o.ty, u = c
                        }
                        s++, e.push(u / l.width, h / l.height)
                    }
                    var d = n.baseTexture;
                    (l.width < d.width || l.height < d.height) && this.adjustUvs(e, n, a, i)
                }, e.prototype.adjustUvs = function(t, e, n, r) {
                    for (var i = e.baseTexture, o = 1e-6, s = n + 2 * r, a = e.frame, l = a.width / i.width, u = a.height / i.height, h = a.x / a.width, c = a.y / a.height, d = Math.floor(t[n] + o), p = Math.floor(t[n + 1] + o), f = n + 2; f < s; f += 2) d = Math.min(d, Math.floor(t[f] + o)), p = Math.min(p, Math.floor(t[f + 1] + o));
                    for (h -= d, c -= p, f = n; f < s; f += 2) t[f] = (t[f] + h) * l, t[f + 1] = (t[f + 1] + c) * u
                }, e.BATCHABLE_SIZE = 100, e
            }(_i),
            Qo = function(t) {
                function e() {
                    var e = null !== t && t.apply(this, arguments) || this;
                    return e.width = 0, e.alignment = .5, e.native = !1, e.cap = To.BUTT, e.join = Eo.MITER, e.miterLimit = 10, e
                }
                return Po(e, t), e.prototype.clone = function() {
                    var t = new e;
                    return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t.width = this.width, t.alignment = this.alignment, t.native = this.native, t.cap = this.cap, t.join = this.join, t.miterLimit = this.miterLimit, t
                }, e.prototype.reset = function() {
                    t.prototype.reset.call(this), this.color = 0, this.alignment = .5, this.width = 0, this.native = !1
                }, e
            }(Ao),
            $o = new Float32Array(3),
            ts = {},
            es = function(t) {
                function e(e) {
                    void 0 === e && (e = null);
                    var n = t.call(this) || this;
                    return n.shader = null, n.pluginName = "batch", n.currentPath = null, n.batches = [], n.batchTint = -1, n.batchDirty = -1, n.vertexData = null, n._fillStyle = new Ao, n._lineStyle = new Qo, n._matrix = null, n._holeMode = !1, n.state = Dr.for2d(), n._geometry = e || new Jo, n._geometry.refCount++, n._transformID = -1, n.tint = 16777215, n.blendMode = lt.NORMAL, n
                }
                return Po(e, t), Object.defineProperty(e.prototype, "geometry", {
                    get: function() {
                        return this._geometry
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype.clone = function() {
                    return this.finishPoly(), new e(this._geometry)
                }, Object.defineProperty(e.prototype, "blendMode", {
                    get: function() {
                        return this.state.blendMode
                    },
                    set: function(t) {
                        this.state.blendMode = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "tint", {
                    get: function() {
                        return this._tint
                    },
                    set: function(t) {
                        this._tint = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "fill", {
                    get: function() {
                        return this._fillStyle
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "line", {
                    get: function() {
                        return this._lineStyle
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype.lineStyle = function(t, e, n, r, i) {
                    return void 0 === t && (t = null), void 0 === e && (e = 0), void 0 === n && (n = 1), void 0 === r && (r = .5), void 0 === i && (i = !1), "number" == typeof t && (t = {
                        width: t,
                        color: e,
                        alpha: n,
                        alignment: r,
                        native: i
                    }), this.lineTextureStyle(t)
                }, e.prototype.lineTextureStyle = function(t) {
                    t = Object.assign({
                        width: 0,
                        texture: Un.WHITE,
                        color: t && t.texture ? 16777215 : 0,
                        alpha: 1,
                        matrix: null,
                        alignment: .5,
                        native: !1,
                        cap: To.BUTT,
                        join: Eo.MITER,
                        miterLimit: 10
                    }, t), this.currentPath && this.startPoly();
                    var e = t.width > 0 && t.alpha > 0;
                    return e ? (t.matrix && (t.matrix = t.matrix.clone(), t.matrix.invert()), Object.assign(this._lineStyle, {
                        visible: e
                    }, t)) : this._lineStyle.reset(), this
                }, e.prototype.startPoly = function() {
                    if (this.currentPath) {
                        var t = this.currentPath.points,
                            e = this.currentPath.points.length;
                        e > 2 && (this.drawShape(this.currentPath), this.currentPath = new de, this.currentPath.closeStroke = !1, this.currentPath.points.push(t[e - 2], t[e - 1]))
                    } else this.currentPath = new de, this.currentPath.closeStroke = !1
                }, e.prototype.finishPoly = function() {
                    this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0)
                }, e.prototype.moveTo = function(t, e) {
                    return this.startPoly(), this.currentPath.points[0] = t, this.currentPath.points[1] = e, this
                }, e.prototype.lineTo = function(t, e) {
                    this.currentPath || this.moveTo(0, 0);
                    var n = this.currentPath.points,
                        r = n[n.length - 2],
                        i = n[n.length - 1];
                    return r === t && i === e || n.push(t, e), this
                }, e.prototype._initCurve = function(t, e) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), this.currentPath ? 0 === this.currentPath.points.length && (this.currentPath.points = [t, e]) : this.moveTo(t, e)
                }, e.prototype.quadraticCurveTo = function(t, e, n, r) {
                    this._initCurve();
                    var i = this.currentPath.points;
                    return 0 === i.length && this.moveTo(0, 0), Vo.curveTo(t, e, n, r, i), this
                }, e.prototype.bezierCurveTo = function(t, e, n, r, i, o) {
                    return this._initCurve(), zo.curveTo(t, e, n, r, i, o, this.currentPath.points), this
                }, e.prototype.arcTo = function(t, e, n, r, i) {
                    this._initCurve(t, e);
                    var o = this.currentPath.points,
                        s = Ho.curveTo(t, e, n, r, i, o);
                    if (s) {
                        var a = s.cx,
                            l = s.cy,
                            u = s.radius,
                            h = s.startAngle,
                            c = s.endAngle,
                            d = s.anticlockwise;
                        this.arc(a, l, u, h, c, d)
                    }
                    return this
                }, e.prototype.arc = function(t, e, n, r, i, o) {
                    if (void 0 === o && (o = !1), r === i) return this;
                    if (!o && i <= r ? i += ie : o && r <= i && (r += ie), 0 == i - r) return this;
                    var s = t + Math.cos(r) * n,
                        a = e + Math.sin(r) * n,
                        l = this._geometry.closePointEps,
                        u = this.currentPath ? this.currentPath.points : null;
                    if (u) {
                        var h = Math.abs(u[u.length - 2] - s),
                            c = Math.abs(u[u.length - 1] - a);
                        h < l && c < l || u.push(s, a)
                    } else this.moveTo(s, a), u = this.currentPath.points;
                    return Ho.arc(s, a, t, e, n, r, i, o, u), this
                }, e.prototype.beginFill = function(t, e) {
                    return void 0 === t && (t = 0), void 0 === e && (e = 1), this.beginTextureFill({
                        texture: Un.WHITE,
                        color: t,
                        alpha: e
                    })
                }, e.prototype.beginTextureFill = function(t) {
                    t = Object.assign({
                        texture: Un.WHITE,
                        color: 16777215,
                        alpha: 1,
                        matrix: null
                    }, t), this.currentPath && this.startPoly();
                    var e = t.alpha > 0;
                    return e ? (t.matrix && (t.matrix = t.matrix.clone(), t.matrix.invert()), Object.assign(this._fillStyle, {
                        visible: e
                    }, t)) : this._fillStyle.reset(), this
                }, e.prototype.endFill = function() {
                    return this.finishPoly(), this._fillStyle.reset(), this
                }, e.prototype.drawRect = function(t, e, n, r) {
                    return this.drawShape(new ue(t, e, n, r))
                }, e.prototype.drawRoundedRect = function(t, e, n, r, i) {
                    return this.drawShape(new pe(t, e, n, r, i))
                }, e.prototype.drawCircle = function(t, e, n) {
                    return this.drawShape(new he(t, e, n))
                }, e.prototype.drawEllipse = function(t, e, n, r) {
                    return this.drawShape(new ce(t, e, n, r))
                }, e.prototype.drawPolygon = function() {
                    for (var t, e = arguments, n = [], r = 0; r < arguments.length; r++) n[r] = e[r];
                    var i = !0,
                        o = n[0];
                    o.points ? (i = o.closeStroke, t = o.points) : t = Array.isArray(n[0]) ? n[0] : n;
                    var s = new de(t);
                    return s.closeStroke = i, this.drawShape(s), this
                }, e.prototype.drawShape = function(t) {
                    return this._holeMode ? this._geometry.drawHole(t, this._matrix) : this._geometry.drawShape(t, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this
                }, e.prototype.clear = function() {
                    return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this
                }, e.prototype.isFastRect = function() {
                    var t = this._geometry.graphicsData;
                    return !(1 !== t.length || t[0].shape.type !== re.RECT || t[0].matrix || t[0].holes.length || t[0].lineStyle.visible && t[0].lineStyle.width)
                }, e.prototype._render = function(t) {
                    this.finishPoly();
                    var e = this._geometry,
                        n = t.context.supports.uint32Indices;
                    e.updateBatches(n), e.batchable ? (this.batchDirty !== e.batchDirty && this._populateBatches(), this._renderBatched(t)) : (t.batch.flush(), this._renderDirect(t))
                }, e.prototype._populateBatches = function() {
                    var t = this._geometry,
                        e = this.blendMode,
                        n = t.batches.length;
                    this.batchTint = -1, this._transformID = -1, this.batchDirty = t.batchDirty, this.batches.length = n, this.vertexData = new Float32Array(t.points);
                    for (var r = 0; r < n; r++) {
                        var i = t.batches[r],
                            o = i.style.color,
                            s = new Float32Array(this.vertexData.buffer, 4 * i.attribStart * 2, 2 * i.attribSize),
                            a = new Float32Array(t.uvsFloat32.buffer, 4 * i.attribStart * 2, 2 * i.attribSize),
                            l = {
                                vertexData: s,
                                blendMode: e,
                                indices: new Uint16Array(t.indicesUint16.buffer, 2 * i.start, i.size),
                                uvs: a,
                                _batchRGB: Nt(o),
                                _tintRGB: o,
                                _texture: i.style.texture,
                                alpha: i.style.alpha,
                                worldAlpha: 1
                            };
                        this.batches[r] = l
                    }
                }, e.prototype._renderBatched = function(t) {
                    if (this.batches.length) {
                        t.batch.setObjectRenderer(t.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
                        for (var e = 0, n = this.batches.length; e < n; e++) {
                            var r = this.batches[e];
                            r.worldAlpha = this.worldAlpha * r.alpha, t.plugins[this.pluginName].render(r)
                        }
                    }
                }, e.prototype._renderDirect = function(t) {
                    var e = this._resolveDirectShader(t),
                        n = this._geometry,
                        r = this.tint,
                        i = this.worldAlpha,
                        o = e.uniforms,
                        s = n.drawCalls;
                    o.translationMatrix = this.transform.worldTransform, o.tint[0] = (r >> 16 & 255) / 255 * i, o.tint[1] = (r >> 8 & 255) / 255 * i, o.tint[2] = (255 & r) / 255 * i, o.tint[3] = i, t.shader.bind(e), t.geometry.bind(n, e), t.state.set(this.state);
                    for (var a = 0, l = s.length; a < l; a++) this._renderDrawCallDirect(t, n.drawCalls[a])
                }, e.prototype._renderDrawCallDirect = function(t, e) {
                    for (var n = e.texArray, r = e.type, i = e.size, o = e.start, s = n.count, a = 0; a < s; a++) t.texture.bind(n.elements[a], a);
                    t.geometry.draw(r, i, o)
                }, e.prototype._resolveDirectShader = function(t) {
                    var e = this.shader,
                        n = this.pluginName;
                    if (!e) {
                        if (!ts[n]) {
                            for (var r = t.plugins.batch.MAX_TEXTURES, i = new Int32Array(r), o = 0; o < r; o++) i[o] = o;
                            var s = {
                                    tint: new Float32Array([1, 1, 1, 1]),
                                    translationMatrix: new me,
                                    default: Jn.from({
                                        uSamplers: i
                                    }, !0)
                                },
                                a = t.plugins[n]._shader.program;
                            ts[n] = new Nr(a, s)
                        }
                        e = ts[n]
                    }
                    return e
                }, e.prototype._calculateBounds = function() {
                    this.finishPoly();
                    var t = this._geometry;
                    if (t.graphicsData.length) {
                        var e = t.bounds,
                            n = e.minX,
                            r = e.minY,
                            i = e.maxX,
                            o = e.maxY;
                        this._bounds.addFrame(this.transform, n, r, i, o)
                    }
                }, e.prototype.containsPoint = function(t) {
                    return this.worldTransform.applyInverse(t, e._TEMP_POINT), this._geometry.containsPoint(e._TEMP_POINT)
                }, e.prototype.calculateTints = function() {
                    if (this.batchTint !== this.tint) {
                        this.batchTint = this.tint;
                        for (var t = Nt(this.tint, $o), e = 0; e < this.batches.length; e++) {
                            var n = this.batches[e],
                                r = n._batchRGB,
                                i = (t[0] * r[0] * 255 << 16) + (t[1] * r[1] * 255 << 8) + (0 | t[2] * r[2] * 255);
                            n._tintRGB = (i >> 16) + (65280 & i) + ((255 & i) << 16)
                        }
                    }
                }, e.prototype.calculateVertices = function() {
                    var t = this.transform._worldID;
                    if (this._transformID !== t) {
                        this._transformID = t;
                        for (var e = this.transform.worldTransform, n = e.a, r = e.b, i = e.c, o = e.d, s = e.tx, a = e.ty, l = this._geometry.points, u = this.vertexData, h = 0, c = 0; c < l.length; c += 2) {
                            var d = l[c],
                                p = l[c + 1];
                            u[h++] = n * d + i * p + s, u[h++] = o * p + r * d + a
                        }
                    }
                }, e.prototype.closePath = function() {
                    var t = this.currentPath;
                    return t && (t.closeStroke = !0, this.finishPoly()), this
                }, e.prototype.setMatrix = function(t) {
                    return this._matrix = t, this
                }, e.prototype.beginHole = function() {
                    return this.finishPoly(), this._holeMode = !0, this
                }, e.prototype.endHole = function() {
                    return this.finishPoly(), this._holeMode = !1, this
                }, e.prototype.destroy = function(e) {
                    this._geometry.refCount--, 0 === this._geometry.refCount && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, t.prototype.destroy.call(this, e)
                }, e.nextRoundedRectBehavior = !1, e._TEMP_POINT = new ae, e
            }(Ke),
            ns = function(t, e) {
                return (ns = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(t, e) {
                        t.__proto__ = e
                    } || function(t, e) {
                        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
                    })(t, e)
            },
            rs = new ae,
            is = new Uint16Array([0, 1, 2, 0, 2, 3]),
            os = function(t) {
                function e(e) {
                    var n = t.call(this) || this;
                    return n._anchor = new fe(n._onAnchorUpdate, n, e ? e.defaultAnchor.x : 0, e ? e.defaultAnchor.y : 0), n._texture = null, n._width = 0, n._height = 0, n._tint = null, n._tintRGB = null, n.tint = 16777215, n.blendMode = lt.NORMAL, n._cachedTint = 16777215, n.uvs = null, n.texture = e || Un.EMPTY, n.vertexData = new Float32Array(8), n.vertexTrimmedData = null, n._transformID = -1, n._textureID = -1, n._transformTrimmedID = -1, n._textureTrimmedID = -1, n.indices = is, n.pluginName = "batch", n.isSprite = !0, n._roundPixels = St.ROUND_PIXELS, n
                }
                return function(t, e) {
                    function n() {
                        this.constructor = t
                    }
                    ns(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
                }(e, t), e.prototype._onTextureUpdate = function() {
                    this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = jt(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = jt(this.scale.y) * this._height / this._texture.orig.height)
                }, e.prototype._onAnchorUpdate = function() {
                    this._transformID = -1, this._transformTrimmedID = -1
                }, e.prototype.calculateVertices = function() {
                    var t = this._texture;
                    if (this._transformID !== this.transform._worldID || this._textureID !== t._updateID) {
                        this._textureID !== t._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = t._updateID;
                        var e = this.transform.worldTransform,
                            n = e.a,
                            r = e.b,
                            i = e.c,
                            o = e.d,
                            s = e.tx,
                            a = e.ty,
                            l = this.vertexData,
                            u = t.trim,
                            h = t.orig,
                            c = this._anchor,
                            d = 0,
                            p = 0,
                            f = 0,
                            m = 0;
                        if (u ? (d = (p = u.x - c._x * h.width) + u.width, f = (m = u.y - c._y * h.height) + u.height) : (d = (p = -c._x * h.width) + h.width, f = (m = -c._y * h.height) + h.height), l[0] = n * p + i * m + s, l[1] = o * m + r * p + a, l[2] = n * d + i * m + s, l[3] = o * m + r * d + a, l[4] = n * d + i * f + s, l[5] = o * f + r * d + a, l[6] = n * p + i * f + s, l[7] = o * f + r * p + a, this._roundPixels)
                            for (var g = St.RESOLUTION, v = 0; v < l.length; ++v) l[v] = Math.round((l[v] * g | 0) / g)
                    }
                }, e.prototype.calculateTrimmedVertices = function() {
                    if (this.vertexTrimmedData) {
                        if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) return
                    } else this.vertexTrimmedData = new Float32Array(8);
                    this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
                    var t = this._texture,
                        e = this.vertexTrimmedData,
                        n = t.orig,
                        r = this._anchor,
                        i = this.transform.worldTransform,
                        o = i.a,
                        s = i.b,
                        a = i.c,
                        l = i.d,
                        u = i.tx,
                        h = i.ty,
                        c = -r._x * n.width,
                        d = c + n.width,
                        p = -r._y * n.height,
                        f = p + n.height;
                    e[0] = o * c + a * p + u, e[1] = l * p + s * c + h, e[2] = o * d + a * p + u, e[3] = l * p + s * d + h, e[4] = o * d + a * f + u, e[5] = l * f + s * d + h, e[6] = o * c + a * f + u, e[7] = l * f + s * c + h
                }, e.prototype._render = function(t) {
                    this.calculateVertices(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this)
                }, e.prototype._calculateBounds = function() {
                    var t = this._texture.trim,
                        e = this._texture.orig;
                    !t || t.width === e.width && t.height === e.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData))
                }, e.prototype.getLocalBounds = function(e) {
                    return 0 === this.children.length ? (this._localBounds || (this._localBounds = new we), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new ue), e = this._localBoundsRect), this._localBounds.getRectangle(e)) : t.prototype.getLocalBounds.call(this, e)
                }, e.prototype.containsPoint = function(t) {
                    this.worldTransform.applyInverse(t, rs);
                    var e = this._texture.orig.width,
                        n = this._texture.orig.height,
                        r = -e * this.anchor.x,
                        i = 0;
                    return rs.x >= r && rs.x < r + e && (i = -n * this.anchor.y, rs.y >= i && rs.y < i + n)
                }, e.prototype.destroy = function(e) {
                    if (t.prototype.destroy.call(this, e), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null, "boolean" == typeof e ? e : e && e.texture) {
                        var n = "boolean" == typeof e ? e : e && e.baseTexture;
                        this._texture.destroy(!!n)
                    }
                    this._texture = null
                }, e.from = function(t, n) {
                    return new e(t instanceof Un ? t : Un.from(t, n))
                }, Object.defineProperty(e.prototype, "roundPixels", {
                    get: function() {
                        return this._roundPixels
                    },
                    set: function(t) {
                        this._roundPixels !== t && (this._transformID = -1), this._roundPixels = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "width", {
                    get: function() {
                        return Math.abs(this.scale.x) * this._texture.orig.width
                    },
                    set: function(t) {
                        var e = jt(this.scale.x) || 1;
                        this.scale.x = e * t / this._texture.orig.width, this._width = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "height", {
                    get: function() {
                        return Math.abs(this.scale.y) * this._texture.orig.height
                    },
                    set: function(t) {
                        var e = jt(this.scale.y) || 1;
                        this.scale.y = e * t / this._texture.orig.height, this._height = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "anchor", {
                    get: function() {
                        return this._anchor
                    },
                    set: function(t) {
                        this._anchor.copyFrom(t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "tint", {
                    get: function() {
                        return this._tint
                    },
                    set: function(t) {
                        this._tint = t, this._tintRGB = (t >> 16) + (65280 & t) + ((255 & t) << 16)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "texture", {
                    get: function() {
                        return this._texture
                    },
                    set: function(t) {
                        this._texture !== t && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = t || Un.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, t && (t.baseTexture.valid ? this._onTextureUpdate() : t.once("update", this._onTextureUpdate, this)))
                    },
                    enumerable: !1,
                    configurable: !0
                }), e
            }(Ke),
            ss = function(t, e) {
                return (ss = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(t, e) {
                        t.__proto__ = e
                    } || function(t, e) {
                        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
                    })(t, e)
            };
        ! function(t) {
            t[t.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", t[t.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL"
        }(Go || (Go = {}));
        var as = {
                align: "left",
                breakWords: !1,
                dropShadow: !1,
                dropShadowAlpha: 1,
                dropShadowAngle: Math.PI / 6,
                dropShadowBlur: 0,
                dropShadowColor: "black",
                dropShadowDistance: 5,
                fill: "black",
                fillGradientType: Go.LINEAR_VERTICAL,
                fillGradientStops: [],
                fontFamily: "Arial",
                fontSize: 26,
                fontStyle: "normal",
                fontVariant: "normal",
                fontWeight: "normal",
                letterSpacing: 0,
                lineHeight: 0,
                lineJoin: "miter",
                miterLimit: 10,
                padding: 0,
                stroke: "black",
                strokeThickness: 0,
                textBaseline: "alphabetic",
                trim: !1,
                whiteSpace: "pre",
                wordWrap: !1,
                wordWrapWidth: 100,
                leading: 0
            },
            ls = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"],
            us = function() {
                function t(t) {
                    this.styleID = 0, this.reset(), ds(this, t, t)
                }
                return t.prototype.clone = function() {
                    var e = {};
                    return ds(e, this, as), new t(e)
                }, t.prototype.reset = function() {
                    ds(this, as, as)
                }, Object.defineProperty(t.prototype, "align", {
                    get: function() {
                        return this._align
                    },
                    set: function(t) {
                        this._align !== t && (this._align = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "breakWords", {
                    get: function() {
                        return this._breakWords
                    },
                    set: function(t) {
                        this._breakWords !== t && (this._breakWords = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "dropShadow", {
                    get: function() {
                        return this._dropShadow
                    },
                    set: function(t) {
                        this._dropShadow !== t && (this._dropShadow = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "dropShadowAlpha", {
                    get: function() {
                        return this._dropShadowAlpha
                    },
                    set: function(t) {
                        this._dropShadowAlpha !== t && (this._dropShadowAlpha = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "dropShadowAngle", {
                    get: function() {
                        return this._dropShadowAngle
                    },
                    set: function(t) {
                        this._dropShadowAngle !== t && (this._dropShadowAngle = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "dropShadowBlur", {
                    get: function() {
                        return this._dropShadowBlur
                    },
                    set: function(t) {
                        this._dropShadowBlur !== t && (this._dropShadowBlur = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "dropShadowColor", {
                    get: function() {
                        return this._dropShadowColor
                    },
                    set: function(t) {
                        var e = cs(t);
                        this._dropShadowColor !== e && (this._dropShadowColor = e, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "dropShadowDistance", {
                    get: function() {
                        return this._dropShadowDistance
                    },
                    set: function(t) {
                        this._dropShadowDistance !== t && (this._dropShadowDistance = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "fill", {
                    get: function() {
                        return this._fill
                    },
                    set: function(t) {
                        var e = cs(t);
                        this._fill !== e && (this._fill = e, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "fillGradientType", {
                    get: function() {
                        return this._fillGradientType
                    },
                    set: function(t) {
                        this._fillGradientType !== t && (this._fillGradientType = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "fillGradientStops", {
                    get: function() {
                        return this._fillGradientStops
                    },
                    set: function(t) {
                        (function(t, e) {
                            if (!Array.isArray(t) || !Array.isArray(e)) return !1;
                            if (t.length !== e.length) return !1;
                            for (var n = 0; n < t.length; ++n)
                                if (t[n] !== e[n]) return !1;
                            return !0
                        })(this._fillGradientStops, t) || (this._fillGradientStops = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "fontFamily", {
                    get: function() {
                        return this._fontFamily
                    },
                    set: function(t) {
                        this.fontFamily !== t && (this._fontFamily = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "fontSize", {
                    get: function() {
                        return this._fontSize
                    },
                    set: function(t) {
                        this._fontSize !== t && (this._fontSize = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "fontStyle", {
                    get: function() {
                        return this._fontStyle
                    },
                    set: function(t) {
                        this._fontStyle !== t && (this._fontStyle = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "fontVariant", {
                    get: function() {
                        return this._fontVariant
                    },
                    set: function(t) {
                        this._fontVariant !== t && (this._fontVariant = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "fontWeight", {
                    get: function() {
                        return this._fontWeight
                    },
                    set: function(t) {
                        this._fontWeight !== t && (this._fontWeight = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "letterSpacing", {
                    get: function() {
                        return this._letterSpacing
                    },
                    set: function(t) {
                        this._letterSpacing !== t && (this._letterSpacing = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "lineHeight", {
                    get: function() {
                        return this._lineHeight
                    },
                    set: function(t) {
                        this._lineHeight !== t && (this._lineHeight = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "leading", {
                    get: function() {
                        return this._leading
                    },
                    set: function(t) {
                        this._leading !== t && (this._leading = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "lineJoin", {
                    get: function() {
                        return this._lineJoin
                    },
                    set: function(t) {
                        this._lineJoin !== t && (this._lineJoin = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "miterLimit", {
                    get: function() {
                        return this._miterLimit
                    },
                    set: function(t) {
                        this._miterLimit !== t && (this._miterLimit = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "padding", {
                    get: function() {
                        return this._padding
                    },
                    set: function(t) {
                        this._padding !== t && (this._padding = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "stroke", {
                    get: function() {
                        return this._stroke
                    },
                    set: function(t) {
                        var e = cs(t);
                        this._stroke !== e && (this._stroke = e, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "strokeThickness", {
                    get: function() {
                        return this._strokeThickness
                    },
                    set: function(t) {
                        this._strokeThickness !== t && (this._strokeThickness = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "textBaseline", {
                    get: function() {
                        return this._textBaseline
                    },
                    set: function(t) {
                        this._textBaseline !== t && (this._textBaseline = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "trim", {
                    get: function() {
                        return this._trim
                    },
                    set: function(t) {
                        this._trim !== t && (this._trim = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "whiteSpace", {
                    get: function() {
                        return this._whiteSpace
                    },
                    set: function(t) {
                        this._whiteSpace !== t && (this._whiteSpace = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "wordWrap", {
                    get: function() {
                        return this._wordWrap
                    },
                    set: function(t) {
                        this._wordWrap !== t && (this._wordWrap = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "wordWrapWidth", {
                    get: function() {
                        return this._wordWrapWidth
                    },
                    set: function(t) {
                        this._wordWrapWidth !== t && (this._wordWrapWidth = t, this.styleID++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.toFontString = function() {
                    var t = "number" == typeof this.fontSize ? this.fontSize + "px" : this.fontSize,
                        e = this.fontFamily;
                    Array.isArray(this.fontFamily) || (e = this.fontFamily.split(","));
                    for (var n = e.length - 1; n >= 0; n--) {
                        var r = e[n].trim();
                        !/([\"\'])[^\'\"]+\1/.test(r) && ls.indexOf(r) < 0 && (r = '"' + r + '"'), e[n] = r
                    }
                    return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + t + " " + e.join(",")
                }, t
            }();

        function hs(t) {
            return "number" == typeof t ? Dt(t) : ("string" == typeof t && 0 === t.indexOf("0x") && (t = t.replace("0x", "#")), t)
        }

        function cs(t) {
            if (Array.isArray(t)) {
                for (var e = 0; e < t.length; ++e) t[e] = hs(t[e]);
                return t
            }
            return hs(t)
        }

        function ds(t, e, n) {
            for (var r in n) Array.isArray(e[r]) ? t[r] = e[r].slice() : t[r] = e[r]
        }
        var ps = function() {
                function t(t, e, n, r, i, o, s, a, l) {
                    this.text = t, this.style = e, this.width = n, this.height = r, this.lines = i, this.lineWidths = o, this.lineHeight = s, this.maxLineWidth = a, this.fontProperties = l
                }
                return t.measureText = function(e, n, r, i) {
                    void 0 === i && (i = t._canvas), r = null == r ? n.wordWrap : r;
                    var o = n.toFontString(),
                        s = t.measureFont(o);
                    0 === s.fontSize && (s.fontSize = n.fontSize, s.ascent = n.fontSize);
                    var a = i.getContext("2d");
                    a.font = o;
                    for (var l = (r ? t.wordWrap(e, n, i) : e).split(/(?:\r\n|\r|\n)/), u = new Array(l.length), h = 0, c = 0; c < l.length; c++) {
                        var d = a.measureText(l[c]).width + (l[c].length - 1) * n.letterSpacing;
                        u[c] = d, h = Math.max(h, d)
                    }
                    var p = h + n.strokeThickness;
                    n.dropShadow && (p += n.dropShadowDistance);
                    var f = n.lineHeight || s.fontSize + n.strokeThickness,
                        m = Math.max(f, s.fontSize + n.strokeThickness) + (l.length - 1) * (f + n.leading);
                    return n.dropShadow && (m += n.dropShadowDistance), new t(e, n, p, m, l, u, f + n.leading, h, s)
                }, t.wordWrap = function(e, n, r) {
                    void 0 === r && (r = t._canvas);
                    for (var i = r.getContext("2d"), o = 0, s = "", a = "", l = Object.create(null), u = n.letterSpacing, h = n.whiteSpace, c = t.collapseSpaces(h), d = t.collapseNewlines(h), p = !c, f = n.wordWrapWidth + u, m = t.tokenize(e), g = 0; g < m.length; g++) {
                        var v = m[g];
                        if (t.isNewline(v)) {
                            if (!d) {
                                a += t.addLine(s), p = !c, s = "", o = 0;
                                continue
                            }
                            v = " "
                        }
                        if (c) {
                            var _ = t.isBreakingSpace(v),
                                y = t.isBreakingSpace(s[s.length - 1]);
                            if (_ && y) continue
                        }
                        var x = t.getFromCache(v, u, l, i);
                        if (x > f)
                            if ("" !== s && (a += t.addLine(s), s = "", o = 0), t.canBreakWords(v, n.breakWords))
                                for (var b = t.wordWrapSplit(v), E = 0; E < b.length; E++) {
                                    for (var T = b[E], S = 1; b[E + S];) {
                                        var w = b[E + S],
                                            M = T[T.length - 1];
                                        if (t.canBreakChars(M, w, v, E, n.breakWords)) break;
                                        T += w, S++
                                    }
                                    E += T.length - 1;
                                    var A = t.getFromCache(T, u, l, i);
                                    A + o > f && (a += t.addLine(s), p = !1, s = "", o = 0), s += T, o += A
                                } else {
                                    s.length > 0 && (a += t.addLine(s), s = "", o = 0);
                                    var R = g === m.length - 1;
                                    a += t.addLine(v, !R), p = !1, s = "", o = 0
                                } else x + o > f && (p = !1, a += t.addLine(s), s = "", o = 0), (s.length > 0 || !t.isBreakingSpace(v) || p) && (s += v, o += x)
                    }
                    return a + t.addLine(s, !1)
                }, t.addLine = function(e, n) {
                    return void 0 === n && (n = !0), e = t.trimRight(e), n ? e + "\n" : e
                }, t.getFromCache = function(t, e, n, r) {
                    var i = n[t];
                    if ("number" != typeof i) {
                        var o = t.length * e;
                        i = r.measureText(t).width + o, n[t] = i
                    }
                    return i
                }, t.collapseSpaces = function(t) {
                    return "normal" === t || "pre-line" === t
                }, t.collapseNewlines = function(t) {
                    return "normal" === t
                }, t.trimRight = function(e) {
                    if ("string" != typeof e) return "";
                    for (var n = e.length - 1; n >= 0; n--) {
                        var r = e[n];
                        if (!t.isBreakingSpace(r)) break;
                        e = e.slice(0, -1)
                    }
                    return e
                }, t.isNewline = function(e) {
                    return "string" == typeof e && t._newlines.indexOf(e.charCodeAt(0)) >= 0
                }, t.isBreakingSpace = function(e, n) {
                    return "string" == typeof e && t._breakingSpaces.indexOf(e.charCodeAt(0)) >= 0
                }, t.tokenize = function(e) {
                    var n = [],
                        r = "";
                    if ("string" != typeof e) return n;
                    for (var i = 0; i < e.length; i++) {
                        var o = e[i],
                            s = e[i + 1];
                        t.isBreakingSpace(o, s) || t.isNewline(o) ? ("" !== r && (n.push(r), r = ""), n.push(o)) : r += o
                    }
                    return "" !== r && n.push(r), n
                }, t.canBreakWords = function(t, e) {
                    return e
                }, t.canBreakChars = function(t, e, n, r, i) {
                    return !0
                }, t.wordWrapSplit = function(t) {
                    return t.split("")
                }, t.measureFont = function(e) {
                    if (t._fonts[e]) return t._fonts[e];
                    var n = {
                            ascent: 0,
                            descent: 0,
                            fontSize: 0
                        },
                        r = t._canvas,
                        i = t._context;
                    i.font = e;
                    var o = t.METRICS_STRING + t.BASELINE_SYMBOL,
                        s = Math.ceil(i.measureText(o).width),
                        a = Math.ceil(i.measureText(t.BASELINE_SYMBOL).width),
                        l = Math.ceil(t.HEIGHT_MULTIPLIER * a);
                    a = a * t.BASELINE_MULTIPLIER | 0, r.width = s, r.height = l, i.fillStyle = "#f00", i.fillRect(0, 0, s, l), i.font = e, i.textBaseline = "alphabetic", i.fillStyle = "#000", i.fillText(o, 0, a);
                    var u = i.getImageData(0, 0, s, l).data,
                        h = u.length,
                        c = 4 * s,
                        d = 0,
                        p = 0,
                        f = !1;
                    for (d = 0; d < a; ++d) {
                        for (var m = 0; m < c; m += 4)
                            if (255 !== u[p + m]) {
                                f = !0;
                                break
                            } if (f) break;
                        p += c
                    }
                    for (n.ascent = a - d, p = h - c, f = !1, d = l; d > a; --d) {
                        for (m = 0; m < c; m += 4)
                            if (255 !== u[p + m]) {
                                f = !0;
                                break
                            } if (f) break;
                        p -= c
                    }
                    return n.descent = d - a, n.fontSize = n.ascent + n.descent, t._fonts[e] = n, n
                }, t.clearMetrics = function(e) {
                    void 0 === e && (e = ""), e ? delete t._fonts[e] : t._fonts = {}
                }, t
            }(),
            fs = function() {
                try {
                    var t = new OffscreenCanvas(0, 0),
                        e = t.getContext("2d");
                    return e && e.measureText ? t : document.createElement("canvas")
                } catch (t) {
                    return document.createElement("canvas")
                }
            }();
        fs.width = fs.height = 10, ps._canvas = fs, ps._context = fs.getContext("2d"), ps._fonts = {}, ps.METRICS_STRING = "|ÉqÅ", ps.BASELINE_SYMBOL = "M", ps.BASELINE_MULTIPLIER = 1.4, ps.HEIGHT_MULTIPLIER = 2, ps._newlines = [10, 13], ps._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
        var ms = {
                texture: !0,
                children: !1,
                baseTexture: !0
            },
            gs = function(t) {
                function e(e, n, r) {
                    var i = this,
                        o = !1;
                    r || (r = document.createElement("canvas"), o = !0), r.width = 3, r.height = 3;
                    var s = Un.from(r);
                    return s.orig = new ue, s.trim = new ue, (i = t.call(this, s) || this)._ownCanvas = o, i.canvas = r, i.context = i.canvas.getContext("2d"), i._resolution = St.RESOLUTION, i._autoResolution = !0, i._text = null, i._style = null, i._styleListener = null, i._font = "", i.text = e, i.style = n, i.localStyleID = -1, i
                }
                return function(t, e) {
                    function n() {
                        this.constructor = t
                    }
                    ss(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
                }(e, t), e.prototype.updateText = function(t) {
                    var n = this._style;
                    if (this.localStyleID !== n.styleID && (this.dirty = !0, this.localStyleID = n.styleID), this.dirty || !t) {
                        this._font = this._style.toFontString();
                        var r, i, o = this.context,
                            s = ps.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas),
                            a = s.width,
                            l = s.height,
                            u = s.lines,
                            h = s.lineHeight,
                            c = s.lineWidths,
                            d = s.maxLineWidth,
                            p = s.fontProperties;
                        this.canvas.width = Math.ceil(Math.ceil(Math.max(1, a) + 2 * n.padding) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, l) + 2 * n.padding) * this._resolution), o.scale(this._resolution, this._resolution), o.clearRect(0, 0, this.canvas.width, this.canvas.height), o.font = this._font, o.lineWidth = n.strokeThickness, o.textBaseline = n.textBaseline, o.lineJoin = n.lineJoin, o.miterLimit = n.miterLimit;
                        for (var f = n.dropShadow ? 2 : 1, m = 0; m < f; ++m) {
                            var g = n.dropShadow && 0 === m,
                                v = g ? Math.ceil(Math.max(1, l) + 2 * n.padding) : 0,
                                _ = v * this._resolution;
                            if (g) {
                                o.fillStyle = "black", o.strokeStyle = "black";
                                var y = n.dropShadowColor,
                                    x = Nt("number" == typeof y ? y : Ut(y)),
                                    b = n.dropShadowBlur * this._resolution,
                                    E = n.dropShadowDistance * this._resolution;
                                o.shadowColor = "rgba(" + 255 * x[0] + "," + 255 * x[1] + "," + 255 * x[2] + "," + n.dropShadowAlpha + ")", o.shadowBlur = b, o.shadowOffsetX = Math.cos(n.dropShadowAngle) * E, o.shadowOffsetY = Math.sin(n.dropShadowAngle) * E + _
                            } else o.fillStyle = this._generateFillStyle(n, u, s), o.strokeStyle = n.stroke, o.shadowColor = "black", o.shadowBlur = 0, o.shadowOffsetX = 0, o.shadowOffsetY = 0;
                            var T = (h - p.fontSize) / 2;
                            (!e.nextLineHeightBehavior || h - p.fontSize < 0) && (T = 0);
                            for (var S = 0; S < u.length; S++) r = n.strokeThickness / 2, i = n.strokeThickness / 2 + S * h + p.ascent + T, "right" === n.align ? r += d - c[S] : "center" === n.align && (r += (d - c[S]) / 2), n.stroke && n.strokeThickness && this.drawLetterSpacing(u[S], r + n.padding, i + n.padding - v, !0), n.fill && this.drawLetterSpacing(u[S], r + n.padding, i + n.padding - v)
                        }
                        this.updateTexture()
                    }
                }, e.prototype.drawLetterSpacing = function(t, n, r, i) {
                    void 0 === i && (i = !1);
                    var o = this._style.letterSpacing,
                        s = e.experimentalLetterSpacing && ("letterSpacing" in CanvasRenderingContext2D.prototype || "textLetterSpacing" in CanvasRenderingContext2D.prototype);
                    if (0 === o || s) return s && (this.context.letterSpacing = o, this.context.textLetterSpacing = o), void(i ? this.context.strokeText(t, n, r) : this.context.fillText(t, n, r));
                    for (var a = n, l = Array.from ? Array.from(t) : t.split(""), u = this.context.measureText(t).width, h = 0, c = 0; c < l.length; ++c) {
                        var d = l[c];
                        i ? this.context.strokeText(d, a, r) : this.context.fillText(d, a, r);
                        for (var p = "", f = c + 1; f < l.length; ++f) p += l[f];
                        a += u - (h = this.context.measureText(p).width) + o, u = h
                    }
                }, e.prototype.updateTexture = function() {
                    var t = this.canvas;
                    if (this._style.trim) {
                        var e = function(t) {
                            var e, n, r, i = t.width,
                                o = t.height,
                                s = t.getContext("2d"),
                                a = s.getImageData(0, 0, i, o).data,
                                l = a.length,
                                u = {
                                    top: null,
                                    left: null,
                                    right: null,
                                    bottom: null
                                },
                                h = null;
                            for (e = 0; e < l; e += 4) 0 !== a[e + 3] && (n = e / 4 % i, r = ~~(e / 4 / i), null === u.top && (u.top = r), (null === u.left || n < u.left) && (u.left = n), (null === u.right || u.right < n) && (u.right = n + 1), (null === u.bottom || u.bottom < r) && (u.bottom = r));
                            return null !== u.top && (i = u.right - u.left, o = u.bottom - u.top + 1, h = s.getImageData(u.left, u.top, i, o)), {
                                height: o,
                                width: i,
                                data: h
                            }
                        }(t);
                        e.data && (t.width = e.width, t.height = e.height, this.context.putImageData(e.data, 0, 0))
                    }
                    var n = this._texture,
                        r = this._style,
                        i = r.trim ? 0 : r.padding,
                        o = n.baseTexture;
                    n.trim.width = n._frame.width = t.width / this._resolution, n.trim.height = n._frame.height = t.height / this._resolution, n.trim.x = -i, n.trim.y = -i, n.orig.width = n._frame.width - 2 * i, n.orig.height = n._frame.height - 2 * i, this._onTextureUpdate(), o.setRealSize(t.width, t.height, this._resolution), n.updateUvs(), this._recursivePostUpdateTransform(), this.dirty = !1
                }, e.prototype._render = function(e) {
                    this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), t.prototype._render.call(this, e)
                }, e.prototype.getLocalBounds = function(e) {
                    return this.updateText(!0), t.prototype.getLocalBounds.call(this, e)
                }, e.prototype._calculateBounds = function() {
                    this.updateText(!0), this.calculateVertices(), this._bounds.addQuad(this.vertexData)
                }, e.prototype._generateFillStyle = function(t, e, n) {
                    var r, i = t.fill;
                    if (!Array.isArray(i)) return i;
                    if (1 === i.length) return i[0];
                    var o = t.dropShadow ? t.dropShadowDistance : 0,
                        s = t.padding || 0,
                        a = this.canvas.width / this._resolution - o - 2 * s,
                        l = this.canvas.height / this._resolution - o - 2 * s,
                        u = i.slice(),
                        h = t.fillGradientStops.slice();
                    if (!h.length)
                        for (var c = u.length + 1, d = 1; d < c; ++d) h.push(d / c);
                    if (u.unshift(i[0]), h.unshift(0), u.push(i[i.length - 1]), h.push(1), t.fillGradientType === Go.LINEAR_VERTICAL) {
                        r = this.context.createLinearGradient(a / 2, s, a / 2, l + s);
                        var p = n.fontProperties.fontSize + t.strokeThickness;
                        for (d = 0; d < e.length; d++) {
                            var f = n.lineHeight * (d - 1) + p,
                                m = n.lineHeight * d,
                                g = m;
                            d > 0 && f > m && (g = (m + f) / 2);
                            var v = m + p,
                                _ = n.lineHeight * (d + 1),
                                y = v;
                            d + 1 < e.length && _ < v && (y = (v + _) / 2);
                            for (var x = (y - g) / l, b = 0; b < u.length; b++) {
                                var E;
                                E = "number" == typeof h[b] ? h[b] : b / u.length;
                                var T = Math.min(1, Math.max(0, g / l + E * x));
                                T = Number(T.toFixed(5)), r.addColorStop(T, u[b])
                            }
                        }
                    } else {
                        r = this.context.createLinearGradient(s, l / 2, a + s, l / 2);
                        var S = u.length + 1,
                            w = 1;
                        for (d = 0; d < u.length; d++) {
                            var M;
                            M = "number" == typeof h[d] ? h[d] : w / S, r.addColorStop(M, u[d]), w++
                        }
                    }
                    return r
                }, e.prototype.destroy = function(e) {
                    "boolean" == typeof e && (e = {
                        children: e
                    }), e = Object.assign({}, ms, e), t.prototype.destroy.call(this, e), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null
                }, Object.defineProperty(e.prototype, "width", {
                    get: function() {
                        return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width
                    },
                    set: function(t) {
                        this.updateText(!0);
                        var e = jt(this.scale.x) || 1;
                        this.scale.x = e * t / this._texture.orig.width, this._width = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "height", {
                    get: function() {
                        return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height
                    },
                    set: function(t) {
                        this.updateText(!0);
                        var e = jt(this.scale.y) || 1;
                        this.scale.y = e * t / this._texture.orig.height, this._height = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "style", {
                    get: function() {
                        return this._style
                    },
                    set: function(t) {
                        t = t || {}, this._style = t instanceof us ? t : new us(t), this.localStyleID = -1, this.dirty = !0
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "text", {
                    get: function() {
                        return this._text
                    },
                    set: function(t) {
                        t = String(null == t ? "" : t), this._text !== t && (this._text = t, this.dirty = !0)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "resolution", {
                    get: function() {
                        return this._resolution
                    },
                    set: function(t) {
                        this._autoResolution = !1, this._resolution !== t && (this._resolution = t, this.dirty = !0)
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.nextLineHeightBehavior = !1, e.experimentalLetterSpacing = !1, e
            }(os);
        St.UPLOADS_PER_FRAME = 4;
        var vs = function(t, e) {
                return (vs = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(t, e) {
                        t.__proto__ = e
                    } || function(t, e) {
                        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
                    })(t, e)
            },
            _s = function() {
                function t(t) {
                    this.maxItemsPerFrame = t, this.itemsLeft = 0
                }
                return t.prototype.beginFrame = function() {
                    this.itemsLeft = this.maxItemsPerFrame
                }, t.prototype.allowedToUpload = function() {
                    return this.itemsLeft-- > 0
                }, t
            }();

        function ys(t, e) {
            var n = !1;
            if (t && t._textures && t._textures.length)
                for (var r = 0; r < t._textures.length; r++)
                    if (t._textures[r] instanceof Un) {
                        var i = t._textures[r].baseTexture; - 1 === e.indexOf(i) && (e.push(i), n = !0)
                    } return n
        }

        function xs(t, e) {
            if (t.baseTexture instanceof xn) {
                var n = t.baseTexture;
                return -1 === e.indexOf(n) && e.push(n), !0
            }
            return !1
        }

        function bs(t, e) {
            if (t._texture && t._texture instanceof Un) {
                var n = t._texture.baseTexture;
                return -1 === e.indexOf(n) && e.push(n), !0
            }
            return !1
        }

        function Es(t, e) {
            return e instanceof gs && (e.updateText(!0), !0)
        }

        function Ts(t, e) {
            if (e instanceof us) {
                var n = e.toFontString();
                return ps.measureFont(n), !0
            }
            return !1
        }

        function Ss(t, e) {
            if (t instanceof gs) {
                -1 === e.indexOf(t.style) && e.push(t.style), -1 === e.indexOf(t) && e.push(t);
                var n = t._texture.baseTexture;
                return -1 === e.indexOf(n) && e.push(n), !0
            }
            return !1
        }

        function ws(t, e) {
            return t instanceof us && (-1 === e.indexOf(t) && e.push(t), !0)
        }

        function Ms(t, e) {
            return e instanceof xn && (e._glTextures[t.CONTEXT_UID] || t.texture.bind(e), !0)
        }

        function As(t, e) {
            if (!(e instanceof es)) return !1;
            var n = e.geometry;
            e.finishPoly(), n.updateBatches();
            for (var r = n.batches, i = 0; i < r.length; i++) {
                var o = r[i].style.texture;
                o && Ms(t, o.baseTexture)
            }
            return n.batchable || t.geometry.bind(n, e._resolveDirectShader(t)), !0
        }

        function Rs(t, e) {
            return t instanceof es && (e.push(t), !0)
        }
        var Ps = function(t) {
                function e(e) {
                    var n = t.call(this, e) || this;
                    return n.uploadHookHelper = n.renderer, n.registerFindHook(Rs), n.registerUploadHook(Ms), n.registerUploadHook(As), n
                }
                return function(t, e) {
                    function n() {
                        this.constructor = t
                    }
                    vs(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
                }(e, t), e
            }(function() {
                function t(t) {
                    var e = this;
                    this.limiter = new _s(St.UPLOADS_PER_FRAME), this.renderer = t, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = function() {
                        e.queue && e.prepareItems()
                    }, this.registerFindHook(Ss), this.registerFindHook(ws), this.registerFindHook(ys), this.registerFindHook(xs), this.registerFindHook(bs), this.registerUploadHook(Es), this.registerUploadHook(Ts)
                }
                return t.prototype.upload = function(t, e) {
                    "function" == typeof t && (e = t, t = null), t && this.add(t), this.queue.length ? (e && this.completes.push(e), this.ticking || (this.ticking = !0, tn.system.addOnce(this.tick, this, Je.UTILITY))) : e && e()
                }, t.prototype.tick = function() {
                    setTimeout(this.delayedTick, 0)
                }, t.prototype.prepareItems = function() {
                    for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload();) {
                        var t = this.queue[0],
                            e = !1;
                        if (t && !t._destroyed)
                            for (var n = 0, r = this.uploadHooks.length; n < r; n++)
                                if (this.uploadHooks[n](this.uploadHookHelper, t)) {
                                    this.queue.shift(), e = !0;
                                    break
                                } e || this.queue.shift()
                    }
                    if (this.queue.length) tn.system.addOnce(this.tick, this, Je.UTILITY);
                    else {
                        this.ticking = !1;
                        var i = this.completes.slice(0);
                        for (this.completes.length = 0, n = 0, r = i.length; n < r; n++) i[n]()
                    }
                }, t.prototype.registerFindHook = function(t) {
                    return t && this.addHooks.push(t), this
                }, t.prototype.registerUploadHook = function(t) {
                    return t && this.uploadHooks.push(t), this
                }, t.prototype.add = function(t) {
                    for (var e = 0, n = this.addHooks.length; e < n && !this.addHooks[e](t, this.queue); e++);
                    if (t instanceof Ke)
                        for (e = t.children.length - 1; e >= 0; e--) this.add(t.children[e]);
                    return this
                }, t.prototype.destroy = function() {
                    this.ticking && tn.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null
                }, t
            }()),
            Is = (function() {
                function t(t) {
                    this.maxMilliseconds = t, this.frameStart = 0
                }
                t.prototype.beginFrame = function() {
                    this.frameStart = Date.now()
                }, t.prototype.allowedToUpload = function() {
                    return Date.now() - this.frameStart < this.maxMilliseconds
                }
            }(), function() {
                function t(t, e, n) {
                    void 0 === n && (n = null), this._texture = t instanceof Un ? t : null, this.baseTexture = t instanceof xn ? t : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = e;
                    var r = this.baseTexture.resource;
                    this.resolution = this._updateResolution(n || (r ? r.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null
                }
                return t.prototype._updateResolution = function(t) {
                    void 0 === t && (t = null);
                    var e = this.data.meta.scale,
                        n = ne(t, null);
                    return null === n && (n = void 0 !== e ? parseFloat(e) : 1), 1 !== n && this.baseTexture.setResolution(n), n
                }, t.prototype.parse = function(e) {
                    this._batchIndex = 0, this._callback = e, this._frameKeys.length <= t.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch()
                }, t.prototype._processFrames = function(e) {
                    for (var n = e, r = t.BATCH_SIZE; n - e < r && n < this._frameKeys.length;) {
                        var i = this._frameKeys[n],
                            o = this._frames[i],
                            s = o.frame;
                        if (s) {
                            var a, l = null,
                                u = !1 !== o.trimmed && o.sourceSize ? o.sourceSize : o.frame,
                                h = new ue(0, 0, Math.floor(u.w) / this.resolution, Math.floor(u.h) / this.resolution);
                            a = o.rotated ? new ue(Math.floor(s.x) / this.resolution, Math.floor(s.y) / this.resolution, Math.floor(s.h) / this.resolution, Math.floor(s.w) / this.resolution) : new ue(Math.floor(s.x) / this.resolution, Math.floor(s.y) / this.resolution, Math.floor(s.w) / this.resolution, Math.floor(s.h) / this.resolution), !1 !== o.trimmed && o.spriteSourceSize && (l = new ue(Math.floor(o.spriteSourceSize.x) / this.resolution, Math.floor(o.spriteSourceSize.y) / this.resolution, Math.floor(s.w) / this.resolution, Math.floor(s.h) / this.resolution)), this.textures[i] = new Un(this.baseTexture, a, h, l, o.rotated ? 2 : 0, o.anchor), Un.addToCache(this.textures[i], i)
                        }
                        n++
                    }
                }, t.prototype._processAnimations = function() {
                    var t = this.data.animations || {};
                    for (var e in t) {
                        this.animations[e] = [];
                        for (var n = 0; n < t[e].length; n++) {
                            var r = t[e][n];
                            this.animations[e].push(this.textures[r])
                        }
                    }
                }, t.prototype._parseComplete = function() {
                    var t = this._callback;
                    this._callback = null, this._batchIndex = 0, t.call(this, this.textures)
                }, t.prototype._nextBatch = function() {
                    var e = this;
                    this._processFrames(this._batchIndex * t.BATCH_SIZE), this._batchIndex++, setTimeout((function() {
                        e._batchIndex * t.BATCH_SIZE < e._frameKeys.length ? e._nextBatch() : (e._processAnimations(), e._parseComplete())
                    }), 0)
                }, t.prototype.destroy = function(t) {
                    var e;
                    for (var n in void 0 === t && (t = !1), this.textures) this.textures[n].destroy();
                    this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && (null === (e = this._texture) || void 0 === e || e.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null
                }, t.BATCH_SIZE = 1e3, t
            }()),
            Cs = function() {
                function t() {}
                return t.use = function(e, n) {
                    var r, i, o = this,
                        s = e.name + "_image";
                    if (e.data && e.type === Gi.TYPE.JSON && e.data.frames && !o.resources[s]) {
                        var a = null === (i = null === (r = e.data) || void 0 === r ? void 0 : r.meta) || void 0 === i ? void 0 : i.related_multi_packs;
                        if (Array.isArray(a))
                            for (var l = function(t) {
                                    if ("string" != typeof t) return "continue";
                                    var n = t.replace(".json", ""),
                                        r = It.resolve(e.url.replace(o.baseUrl, ""), t);
                                    if (o.resources[n] || Object.values(o.resources).some((function(t) {
                                            return It.format(It.parse(t.url)) === r
                                        }))) return "continue";
                                    var i = {
                                        crossOrigin: e.crossOrigin,
                                        loadType: Gi.LOAD_TYPE.XHR,
                                        xhrType: Gi.XHR_RESPONSE_TYPE.JSON,
                                        parentResource: e,
                                        metadata: e.metadata
                                    };
                                    o.add(n, r, i)
                                }, u = 0, h = a; u < h.length; u++) l(h[u]);
                        var c = {
                                crossOrigin: e.crossOrigin,
                                metadata: e.metadata.imageMetadata,
                                parentResource: e
                            },
                            d = t.getResourcePath(e, o.baseUrl);
                        o.add(s, d, c, (function(t) {
                            if (t.error) n(t.error);
                            else {
                                var r = new Is(t.texture, e.data, e.url);
                                r.parse((function() {
                                    e.spritesheet = r, e.textures = r.textures, n()
                                }))
                            }
                        }))
                    } else n()
                }, t.getResourcePath = function(t, e) {
                    return t.isDataUrl ? t.data.meta.image : It.resolve(t.url.replace(e, ""), t.data.meta.image)
                }, t
            }(),
            Os = function(t, e) {
                return (Os = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(t, e) {
                        t.__proto__ = e
                    } || function(t, e) {
                        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
                    })(t, e)
            };

        function Ls(t, e) {
            function n() {
                this.constructor = t
            }
            Os(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
        }
        var Ns = new ae,
            Ds = (function(t) {
                function e(e, n, r) {
                    void 0 === n && (n = 100), void 0 === r && (r = 100);
                    var i = t.call(this, e) || this;
                    return i.tileTransform = new Se, i._width = n, i._height = r, i.uvMatrix = i.texture.uvMatrix || new Br(e), i.pluginName = "tilingSprite", i.uvRespectAnchor = !1, i
                }
                Ls(e, t), Object.defineProperty(e.prototype, "clampMargin", {
                    get: function() {
                        return this.uvMatrix.clampMargin
                    },
                    set: function(t) {
                        this.uvMatrix.clampMargin = t, this.uvMatrix.update(!0)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "tileScale", {
                    get: function() {
                        return this.tileTransform.scale
                    },
                    set: function(t) {
                        this.tileTransform.scale.copyFrom(t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "tilePosition", {
                    get: function() {
                        return this.tileTransform.position
                    },
                    set: function(t) {
                        this.tileTransform.position.copyFrom(t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype._onTextureUpdate = function() {
                    this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215
                }, e.prototype._render = function(t) {
                    var e = this._texture;
                    e && e.valid && (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this))
                }, e.prototype._calculateBounds = function() {
                    var t = this._width * -this._anchor._x,
                        e = this._height * -this._anchor._y,
                        n = this._width * (1 - this._anchor._x),
                        r = this._height * (1 - this._anchor._y);
                    this._bounds.addFrame(this.transform, t, e, n, r)
                }, e.prototype.getLocalBounds = function(e) {
                    return 0 === this.children.length ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new ue), e = this._localBoundsRect), this._bounds.getRectangle(e)) : t.prototype.getLocalBounds.call(this, e)
                }, e.prototype.containsPoint = function(t) {
                    this.worldTransform.applyInverse(t, Ns);
                    var e = this._width,
                        n = this._height,
                        r = -e * this.anchor._x;
                    if (Ns.x >= r && Ns.x < r + e) {
                        var i = -n * this.anchor._y;
                        if (Ns.y >= i && Ns.y < i + n) return !0
                    }
                    return !1
                }, e.prototype.destroy = function(e) {
                    t.prototype.destroy.call(this, e), this.tileTransform = null, this.uvMatrix = null
                }, e.from = function(t, n) {
                    return new e(t instanceof Un ? t : Un.from(t, n), n.width, n.height)
                }, Object.defineProperty(e.prototype, "width", {
                    get: function() {
                        return this._width
                    },
                    set: function(t) {
                        this._width = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "height", {
                    get: function() {
                        return this._height
                    },
                    set: function(t) {
                        this._height = t
                    },
                    enumerable: !1,
                    configurable: !0
                })
            }(os), "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n"),
            Us = new me,
            Fs = function(t) {
                function e(e) {
                    var n = t.call(this, e) || this;
                    return e.runners.contextChange.add(n), n.quad = new Zn, n.state = Dr.for2d(), n
                }
                return Ls(e, t), e.prototype.contextChange = function() {
                    var t = this.renderer,
                        e = {
                            globals: t.globalUniforms
                        };
                    this.simpleShader = Nr.from(Ds, "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n", e), this.shader = t.context.webGLVersion > 1 ? Nr.from("#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n", "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n", e) : Nr.from(Ds, "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n", e)
                }, e.prototype.render = function(t) {
                    var e = this.renderer,
                        n = this.quad,
                        r = n.vertices;
                    r[0] = r[6] = t._width * -t.anchor.x, r[1] = r[3] = t._height * -t.anchor.y, r[2] = r[4] = t._width * (1 - t.anchor.x), r[5] = r[7] = t._height * (1 - t.anchor.y);
                    var i = t.uvRespectAnchor ? t.anchor.x : 0,
                        o = t.uvRespectAnchor ? t.anchor.y : 0;
                    (r = n.uvs)[0] = r[6] = -i, r[1] = r[3] = -o, r[2] = r[4] = 1 - i, r[5] = r[7] = 1 - o, n.invalidate();
                    var s = t._texture,
                        a = s.baseTexture,
                        l = t.tileTransform.localTransform,
                        u = t.uvMatrix,
                        h = a.isPowerOfTwo && s.frame.width === a.width && s.frame.height === a.height;
                    h && (a._glTextures[e.CONTEXT_UID] ? h = a.wrapMode !== mt.CLAMP : a.wrapMode === mt.CLAMP && (a.wrapMode = mt.REPEAT));
                    var c = h ? this.simpleShader : this.shader,
                        d = s.width,
                        p = s.height,
                        f = t._width,
                        m = t._height;
                    Us.set(l.a * d / f, l.b * d / m, l.c * p / f, l.d * p / m, l.tx / f, l.ty / m), Us.invert(), h ? Us.prepend(u.mapCoord) : (c.uniforms.uMapCoord = u.mapCoord.toArray(!0), c.uniforms.uClampFrame = u.uClampFrame, c.uniforms.uClampOffset = u.uClampOffset), c.uniforms.uTransform = Us.toArray(!0), c.uniforms.uColor = Gt(t.tint, t.worldAlpha, c.uniforms.uColor, a.alphaMode), c.uniforms.translationMatrix = t.transform.worldTransform.toArray(!0), c.uniforms.uSampler = s, e.shader.bind(c), e.geometry.bind(n), this.state.blendMode = Bt(t.blendMode, a.alphaMode), e.state.set(this.state), e.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0)
                }, e
            }(nr),
            Bs = function(t, e) {
                return (Bs = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(t, e) {
                        t.__proto__ = e
                    } || function(t, e) {
                        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
                    })(t, e)
            };

        function ks(t, e) {
            function n() {
                this.constructor = t
            }
            Bs(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
        }
        var Gs = function() {
                function t(t, e) {
                    this.uvBuffer = t, this.uvMatrix = e, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0
                }
                return t.prototype.update = function(t) {
                    if (t || this._bufferUpdateId !== this.uvBuffer._updateID || this._textureUpdateId !== this.uvMatrix._updateID) {
                        this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
                        var e = this.uvBuffer.data;
                        this.data && this.data.length === e.length || (this.data = new Float32Array(e.length)), this.uvMatrix.multiplyUvs(e, this.data), this._updateID++
                    }
                }, t
            }(),
            Hs = new ae,
            zs = new de,
            Vs = function(t) {
                function e(e, n, r, i) {
                    void 0 === i && (i = ut.TRIANGLES);
                    var o = t.call(this) || this;
                    return o.geometry = e, o.shader = n, o.state = r || Dr.for2d(), o.drawMode = i, o.start = 0, o.size = 0, o.uvs = null, o.indices = null, o.vertexData = new Float32Array(1), o.vertexDirty = -1, o._transformID = -1, o._roundPixels = St.ROUND_PIXELS, o.batchUvs = null, o
                }
                return ks(e, t), Object.defineProperty(e.prototype, "geometry", {
                    get: function() {
                        return this._geometry
                    },
                    set: function(t) {
                        this._geometry !== t && (this._geometry && (this._geometry.refCount--, 0 === this._geometry.refCount && this._geometry.dispose()), this._geometry = t, this._geometry && this._geometry.refCount++, this.vertexDirty = -1)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "uvBuffer", {
                    get: function() {
                        return this.geometry.buffers[1]
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "verticesBuffer", {
                    get: function() {
                        return this.geometry.buffers[0]
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "material", {
                    get: function() {
                        return this.shader
                    },
                    set: function(t) {
                        this.shader = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "blendMode", {
                    get: function() {
                        return this.state.blendMode
                    },
                    set: function(t) {
                        this.state.blendMode = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "roundPixels", {
                    get: function() {
                        return this._roundPixels
                    },
                    set: function(t) {
                        this._roundPixels !== t && (this._transformID = -1), this._roundPixels = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "tint", {
                    get: function() {
                        return "tint" in this.shader ? this.shader.tint : null
                    },
                    set: function(t) {
                        this.shader.tint = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "texture", {
                    get: function() {
                        return "texture" in this.shader ? this.shader.texture : null
                    },
                    set: function(t) {
                        this.shader.texture = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype._render = function(t) {
                    var n = this.geometry.buffers[0].data;
                    this.shader.batchable && this.drawMode === ut.TRIANGLES && n.length < 2 * e.BATCHABLE_SIZE ? this._renderToBatch(t) : this._renderDefault(t)
                }, e.prototype._renderDefault = function(t) {
                    var e = this.shader;
                    e.alpha = this.worldAlpha, e.update && e.update(), t.batch.flush(), e.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), t.shader.bind(e), t.state.set(this.state), t.geometry.bind(this.geometry, e), t.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount)
                }, e.prototype._renderToBatch = function(t) {
                    var e = this.geometry,
                        n = this.shader;
                    n.uvMatrix && (n.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = e.indexBuffer.data, this._tintRGB = n._tintRGB, this._texture = n.texture;
                    var r = this.material.pluginName;
                    t.batch.setObjectRenderer(t.plugins[r]), t.plugins[r].render(this)
                }, e.prototype.calculateVertices = function() {
                    var t = this.geometry.buffers[0],
                        e = t.data,
                        n = t._updateID;
                    if (n !== this.vertexDirty || this._transformID !== this.transform._worldID) {
                        this._transformID = this.transform._worldID, this.vertexData.length !== e.length && (this.vertexData = new Float32Array(e.length));
                        for (var r = this.transform.worldTransform, i = r.a, o = r.b, s = r.c, a = r.d, l = r.tx, u = r.ty, h = this.vertexData, c = 0; c < h.length / 2; c++) {
                            var d = e[2 * c],
                                p = e[2 * c + 1];
                            h[2 * c] = i * d + s * p + l, h[2 * c + 1] = o * d + a * p + u
                        }
                        if (this._roundPixels) {
                            var f = St.RESOLUTION;
                            for (c = 0; c < h.length; ++c) h[c] = Math.round((h[c] * f | 0) / f)
                        }
                        this.vertexDirty = n
                    }
                }, e.prototype.calculateUvs = function() {
                    var t = this.geometry.buffers[1],
                        e = this.shader;
                    e.uvMatrix.isSimple ? this.uvs = t.data : (this.batchUvs || (this.batchUvs = new Gs(t, e.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data)
                }, e.prototype._calculateBounds = function() {
                    this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length)
                }, e.prototype.containsPoint = function(t) {
                    if (!this.getBounds().contains(t.x, t.y)) return !1;
                    this.worldTransform.applyInverse(t, Hs);
                    for (var e = this.geometry.getBuffer("aVertexPosition").data, n = zs.points, r = this.geometry.getIndex().data, i = r.length, o = 4 === this.drawMode ? 3 : 1, s = 0; s + 2 < i; s += o) {
                        var a = 2 * r[s],
                            l = 2 * r[s + 1],
                            u = 2 * r[s + 2];
                        if (n[0] = e[a], n[1] = e[a + 1], n[2] = e[l], n[3] = e[l + 1], n[4] = e[u], n[5] = e[u + 1], zs.contains(Hs.x, Hs.y)) return !0
                    }
                    return !1
                }, e.prototype.destroy = function(e) {
                    t.prototype.destroy.call(this, e), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null
                }, e.BATCHABLE_SIZE = 100, e
            }(Ke),
            Ws = function(t) {
                function e(e, n) {
                    var r = this,
                        i = {
                            uSampler: e,
                            alpha: 1,
                            uTextureMatrix: me.IDENTITY,
                            uColor: new Float32Array([1, 1, 1, 1])
                        };
                    return (n = Object.assign({
                        tint: 16777215,
                        alpha: 1,
                        pluginName: "batch"
                    }, n)).uniforms && Object.assign(i, n.uniforms), (r = t.call(this, n.program || Lr.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n", "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n"), i) || this)._colorDirty = !1, r.uvMatrix = new Br(e), r.batchable = void 0 === n.program, r.pluginName = n.pluginName, r.tint = n.tint, r.alpha = n.alpha, r
                }
                return ks(e, t), Object.defineProperty(e.prototype, "texture", {
                    get: function() {
                        return this.uniforms.uSampler
                    },
                    set: function(t) {
                        this.uniforms.uSampler !== t && (this.uniforms.uSampler = t, this.uvMatrix.texture = t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "alpha", {
                    get: function() {
                        return this._alpha
                    },
                    set: function(t) {
                        t !== this._alpha && (this._alpha = t, this._colorDirty = !0)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "tint", {
                    get: function() {
                        return this._tint
                    },
                    set: function(t) {
                        t !== this._tint && (this._tint = t, this._tintRGB = (t >> 16) + (65280 & t) + ((255 & t) << 16), this._colorDirty = !0)
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype.update = function() {
                    if (this._colorDirty) {
                        this._colorDirty = !1;
                        var t = this.texture.baseTexture;
                        Gt(this._tint, this._alpha, this.uniforms.uColor, t.alphaMode)
                    }
                    this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord)
                }, e
            }(Nr),
            Xs = function(t) {
                function e(e, n, r) {
                    var i = t.call(this) || this,
                        o = new zn(e),
                        s = new zn(n, !0),
                        a = new zn(r, !0, !0);
                    return i.addAttribute("aVertexPosition", o, 2, !1, dt.FLOAT).addAttribute("aTextureCoord", s, 2, !1, dt.FLOAT).addIndex(a), i._updateId = -1, i
                }
                return ks(e, t), Object.defineProperty(e.prototype, "vertexDirtyId", {
                    get: function() {
                        return this.buffers[0]._updateID
                    },
                    enumerable: !1,
                    configurable: !0
                }), e
            }(Yn),
            js = function(t, e) {
                return (js = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(t, e) {
                        t.__proto__ = e
                    } || function(t, e) {
                        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
                    })(t, e)
            },
            Ys = function() {
                this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = []
            },
            qs = function() {
                function t() {}
                return t.test = function(t) {
                    return "string" == typeof t && 0 === t.indexOf("info face=")
                }, t.parse = function(t) {
                    var e = t.match(/^[a-z]+\s+.+$/gm),
                        n = {
                            info: [],
                            common: [],
                            page: [],
                            char: [],
                            chars: [],
                            kerning: [],
                            kernings: [],
                            distanceField: []
                        };
                    for (var r in e) {
                        var i = e[r].match(/^[a-z]+/gm)[0],
                            o = e[r].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),
                            s = {};
                        for (var a in o) {
                            var l = o[a].split("="),
                                u = l[0],
                                h = l[1].replace(/"/gm, ""),
                                c = parseFloat(h),
                                d = isNaN(c) ? h : c;
                            s[u] = d
                        }
                        n[i].push(s)
                    }
                    var p = new Ys;
                    return n.info.forEach((function(t) {
                        return p.info.push({
                            face: t.face,
                            size: parseInt(t.size, 10)
                        })
                    })), n.common.forEach((function(t) {
                        return p.common.push({
                            lineHeight: parseInt(t.lineHeight, 10)
                        })
                    })), n.page.forEach((function(t) {
                        return p.page.push({
                            id: parseInt(t.id, 10),
                            file: t.file
                        })
                    })), n.char.forEach((function(t) {
                        return p.char.push({
                            id: parseInt(t.id, 10),
                            page: parseInt(t.page, 10),
                            x: parseInt(t.x, 10),
                            y: parseInt(t.y, 10),
                            width: parseInt(t.width, 10),
                            height: parseInt(t.height, 10),
                            xoffset: parseInt(t.xoffset, 10),
                            yoffset: parseInt(t.yoffset, 10),
                            xadvance: parseInt(t.xadvance, 10)
                        })
                    })), n.kerning.forEach((function(t) {
                        return p.kerning.push({
                            first: parseInt(t.first, 10),
                            second: parseInt(t.second, 10),
                            amount: parseInt(t.amount, 10)
                        })
                    })), n.distanceField.forEach((function(t) {
                        return p.distanceField.push({
                            distanceRange: parseInt(t.distanceRange, 10),
                            fieldType: t.fieldType
                        })
                    })), p
                }, t
            }(),
            Zs = function() {
                function t() {}
                return t.test = function(t) {
                    return t instanceof XMLDocument && t.getElementsByTagName("page").length && null !== t.getElementsByTagName("info")[0].getAttribute("face")
                }, t.parse = function(t) {
                    for (var e = new Ys, n = t.getElementsByTagName("info"), r = t.getElementsByTagName("common"), i = t.getElementsByTagName("page"), o = t.getElementsByTagName("char"), s = t.getElementsByTagName("kerning"), a = t.getElementsByTagName("distanceField"), l = 0; l < n.length; l++) e.info.push({
                        face: n[l].getAttribute("face"),
                        size: parseInt(n[l].getAttribute("size"), 10)
                    });
                    for (l = 0; l < r.length; l++) e.common.push({
                        lineHeight: parseInt(r[l].getAttribute("lineHeight"), 10)
                    });
                    for (l = 0; l < i.length; l++) e.page.push({
                        id: parseInt(i[l].getAttribute("id"), 10) || 0,
                        file: i[l].getAttribute("file")
                    });
                    for (l = 0; l < o.length; l++) {
                        var u = o[l];
                        e.char.push({
                            id: parseInt(u.getAttribute("id"), 10),
                            page: parseInt(u.getAttribute("page"), 10) || 0,
                            x: parseInt(u.getAttribute("x"), 10),
                            y: parseInt(u.getAttribute("y"), 10),
                            width: parseInt(u.getAttribute("width"), 10),
                            height: parseInt(u.getAttribute("height"), 10),
                            xoffset: parseInt(u.getAttribute("xoffset"), 10),
                            yoffset: parseInt(u.getAttribute("yoffset"), 10),
                            xadvance: parseInt(u.getAttribute("xadvance"), 10)
                        })
                    }
                    for (l = 0; l < s.length; l++) e.kerning.push({
                        first: parseInt(s[l].getAttribute("first"), 10),
                        second: parseInt(s[l].getAttribute("second"), 10),
                        amount: parseInt(s[l].getAttribute("amount"), 10)
                    });
                    for (l = 0; l < a.length; l++) e.distanceField.push({
                        fieldType: a[l].getAttribute("fieldType"),
                        distanceRange: parseInt(a[l].getAttribute("distanceRange"), 10)
                    });
                    return e
                }, t
            }(),
            Ks = function() {
                function t() {}
                return t.test = function(t) {
                    if ("string" == typeof t && t.indexOf("<font>") > -1) {
                        var e = (new globalThis.DOMParser).parseFromString(t, "text/xml");
                        return Zs.test(e)
                    }
                    return !1
                }, t.parse = function(t) {
                    var e = (new globalThis.DOMParser).parseFromString(t, "text/xml");
                    return Zs.parse(e)
                }, t
            }(),
            Js = [qs, Zs, Ks];

        function Qs(t) {
            for (var e = 0; e < Js.length; e++)
                if (Js[e].test(t)) return Js[e];
            return null
        }

        function $s(t, e, n, r, i, o, s) {
            var a = n.text,
                l = n.fontProperties;
            e.translate(r, i), e.scale(o, o);
            var u = s.strokeThickness / 2,
                h = -s.strokeThickness / 2;
            if (e.font = s.toFontString(), e.lineWidth = s.strokeThickness, e.textBaseline = s.textBaseline, e.lineJoin = s.lineJoin, e.miterLimit = s.miterLimit, e.fillStyle = function(t, e, n, r, i, o) {
                    var s, a = n.fill;
                    if (!Array.isArray(a)) return a;
                    if (1 === a.length) return a[0];
                    var l = n.dropShadow ? n.dropShadowDistance : 0,
                        u = n.padding || 0,
                        h = t.width / r - l - 2 * u,
                        c = t.height / r - l - 2 * u,
                        d = a.slice(),
                        p = n.fillGradientStops.slice();
                    if (!p.length)
                        for (var f = d.length + 1, m = 1; m < f; ++m) p.push(m / f);
                    if (d.unshift(a[0]), p.unshift(0), d.push(a[a.length - 1]), p.push(1), n.fillGradientType === Go.LINEAR_VERTICAL) {
                        s = e.createLinearGradient(h / 2, u, h / 2, c + u);
                        var g = 0,
                            v = (o.fontProperties.fontSize + n.strokeThickness) / c;
                        for (m = 0; m < i.length; m++)
                            for (var _ = o.lineHeight * m, y = 0; y < d.length; y++) {
                                var x = _ / c + ("number" == typeof p[y] ? p[y] : y / d.length) * v,
                                    b = Math.max(g, x);
                                b = Math.min(b, 1), s.addColorStop(b, d[y]), g = b
                            }
                    } else {
                        s = e.createLinearGradient(u, c / 2, h + u, c / 2);
                        var E = d.length + 1,
                            T = 1;
                        for (m = 0; m < d.length; m++) {
                            var S;
                            S = "number" == typeof p[m] ? p[m] : T / E, s.addColorStop(S, d[m]), T++
                        }
                    }
                    return s
                }(t, e, s, o, [a], n), e.strokeStyle = s.stroke, s.dropShadow) {
                var c = s.dropShadowColor,
                    d = Nt("number" == typeof c ? c : Ut(c)),
                    p = s.dropShadowBlur * o,
                    f = s.dropShadowDistance * o;
                e.shadowColor = "rgba(" + 255 * d[0] + "," + 255 * d[1] + "," + 255 * d[2] + "," + s.dropShadowAlpha + ")", e.shadowBlur = p, e.shadowOffsetX = Math.cos(s.dropShadowAngle) * f, e.shadowOffsetY = Math.sin(s.dropShadowAngle) * f
            } else e.shadowColor = "black", e.shadowBlur = 0, e.shadowOffsetX = 0, e.shadowOffsetY = 0;
            s.stroke && s.strokeThickness && e.strokeText(a, u, h + n.lineHeight - l.descent), s.fill && e.fillText(a, u, h + n.lineHeight - l.descent), e.setTransform(1, 0, 0, 1, 0, 0), e.fillStyle = "rgba(0, 0, 0, 0)"
        }

        function ta(t) {
            return Array.from ? Array.from(t) : t.split("")
        }

        function ea(t) {
            return t.codePointAt ? t.codePointAt(0) : t.charCodeAt(0)
        }
        var na = function() {
                function t(t, e, n) {
                    var r, i, o = t.info[0],
                        s = t.common[0],
                        a = t.page[0],
                        l = t.distanceField[0],
                        u = ne(a.file),
                        h = {};
                    this._ownsTextures = n, this.font = o.face, this.size = o.size, this.lineHeight = s.lineHeight / u, this.chars = {}, this.pageTextures = h;
                    for (var c = 0; c < t.page.length; c++) {
                        var d = t.page[c],
                            p = d.id,
                            f = d.file;
                        h[p] = e instanceof Array ? e[c] : e[f], (null == l ? void 0 : l.fieldType) && "none" !== l.fieldType && (h[p].baseTexture.alphaMode = vt.NO_PREMULTIPLIED_ALPHA)
                    }
                    for (c = 0; c < t.char.length; c++) {
                        var m = t.char[c],
                            g = (p = m.id, m.page),
                            v = t.char[c],
                            _ = v.x,
                            y = v.y,
                            x = v.width,
                            b = v.height,
                            E = v.xoffset,
                            T = v.yoffset,
                            S = v.xadvance;
                        y /= u, x /= u, b /= u, E /= u, T /= u, S /= u;
                        var w = new ue((_ /= u) + h[g].frame.x / u, y + h[g].frame.y / u, x, b);
                        this.chars[p] = {
                            xOffset: E,
                            yOffset: T,
                            xAdvance: S,
                            kerning: {},
                            texture: new Un(h[g].baseTexture, w),
                            page: g
                        }
                    }
                    for (c = 0; c < t.kerning.length; c++) {
                        var M = t.kerning[c],
                            A = M.first,
                            R = M.second,
                            P = M.amount;
                        A /= u, R /= u, P /= u, this.chars[R] && (this.chars[R].kerning[A] = P)
                    }
                    this.distanceFieldRange = null == l ? void 0 : l.distanceRange, this.distanceFieldType = null !== (i = null === (r = null == l ? void 0 : l.fieldType) || void 0 === r ? void 0 : r.toLowerCase()) && void 0 !== i ? i : "none"
                }
                return t.prototype.destroy = function() {
                    for (var t in this.chars) this.chars[t].texture.destroy(), this.chars[t].texture = null;
                    for (var t in this.pageTextures) this._ownsTextures && this.pageTextures[t].destroy(!0), this.pageTextures[t] = null;
                    this.chars = null, this.pageTextures = null
                }, t.install = function(e, n, r) {
                    var i;
                    if (e instanceof Ys) i = e;
                    else {
                        var o = Qs(e);
                        if (!o) throw new Error("Unrecognized data format for font.");
                        i = o.parse(e)
                    }
                    n instanceof Un && (n = [n]);
                    var s = new t(i, n, r);
                    return t.available[s.font] = s, s
                }, t.uninstall = function(e) {
                    var n = t.available[e];
                    if (!n) throw new Error("No font found named '" + e + "'");
                    n.destroy(), delete t.available[e]
                }, t.from = function(e, n, r) {
                    if (!e) throw new Error("[BitmapFont] Property `name` is required.");
                    var i = Object.assign({}, t.defaultOptions, r),
                        o = i.chars,
                        s = i.padding,
                        a = i.resolution,
                        l = i.textureWidth,
                        u = i.textureHeight,
                        h = function(t) {
                            "string" == typeof t && (t = [t]);
                            for (var e = [], n = 0, r = t.length; n < r; n++) {
                                var i = t[n];
                                if (Array.isArray(i)) {
                                    if (2 !== i.length) throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + i.length + ".");
                                    var o = i[0].charCodeAt(0),
                                        s = i[1].charCodeAt(0);
                                    if (s < o) throw new Error("[BitmapFont]: Invalid character range.");
                                    for (var a = o, l = s; a <= l; a++) e.push(String.fromCharCode(a))
                                } else e.push.apply(e, ta(i))
                            }
                            if (0 === e.length) throw new Error("[BitmapFont]: Empty set when resolving characters.");
                            return e
                        }(o),
                        c = n instanceof us ? n : new us(n),
                        d = l,
                        p = new Ys;
                    p.info[0] = {
                        face: c.fontFamily,
                        size: c.fontSize
                    }, p.common[0] = {
                        lineHeight: c.fontSize
                    };
                    for (var f, m, g, v = 0, _ = 0, y = 0, x = [], b = 0; b < h.length; b++) {
                        f || ((f = document.createElement("canvas")).width = l, f.height = u, m = f.getContext("2d"), g = new xn(f, {
                            resolution: a
                        }), x.push(new Un(g)), p.page.push({
                            id: x.length - 1,
                            file: ""
                        }));
                        var E = ps.measureText(h[b], c, !1, f),
                            T = E.width,
                            S = Math.ceil(E.height),
                            w = Math.ceil(("italic" === c.fontStyle ? 2 : 1) * T);
                        if (_ >= u - S * a) {
                            if (0 === _) throw new Error("[BitmapFont] textureHeight " + u + "px is too small for " + c.fontSize + "px fonts");
                            --b, f = null, m = null, g = null, _ = 0, v = 0, y = 0
                        } else if (y = Math.max(S + E.fontProperties.descent, y), w * a + v >= d) --b, _ += y * a, _ = Math.ceil(_), v = 0, y = 0;
                        else {
                            $s(f, m, E, v, _, a, c);
                            var M = ea(E.text);
                            p.char.push({
                                id: M,
                                page: x.length - 1,
                                x: v / a,
                                y: _ / a,
                                width: w,
                                height: S,
                                xoffset: 0,
                                yoffset: 0,
                                xadvance: Math.ceil(T - (c.dropShadow ? c.dropShadowDistance : 0) - (c.stroke ? c.strokeThickness : 0))
                            }), v += (w + 2 * s) * a, v = Math.ceil(v)
                        }
                    }
                    b = 0;
                    for (var A = h.length; b < A; b++)
                        for (var R = h[b], P = 0; P < A; P++) {
                            var I = h[P],
                                C = m.measureText(R).width,
                                O = m.measureText(I).width,
                                L = m.measureText(R + I).width - (C + O);
                            L && p.kerning.push({
                                first: ea(R),
                                second: ea(I),
                                amount: L
                            })
                        }
                    var N = new t(p, x, !0);
                    return void 0 !== t.available[e] && t.uninstall(e), t.available[e] = N, N
                }, t.ALPHA = [
                    ["a", "z"],
                    ["A", "Z"], " "
                ], t.NUMERIC = [
                    ["0", "9"]
                ], t.ALPHANUMERIC = [
                    ["a", "z"],
                    ["A", "Z"],
                    ["0", "9"], " "
                ], t.ASCII = [
                    [" ", "~"]
                ], t.defaultOptions = {
                    resolution: 1,
                    textureWidth: 512,
                    textureHeight: 512,
                    padding: 4,
                    chars: t.ALPHANUMERIC
                }, t.available = {}, t
            }(),
            ra = [],
            ia = [],
            oa = [],
            sa = (function(t) {
                function e(n, r) {
                    void 0 === r && (r = {});
                    var i = t.call(this) || this;
                    i._tint = 16777215;
                    var o = Object.assign({}, e.styleDefaults, r),
                        s = o.align,
                        a = o.tint,
                        l = o.maxWidth,
                        u = o.letterSpacing,
                        h = o.fontName,
                        c = o.fontSize;
                    if (!na.available[h]) throw new Error('Missing BitmapFont "' + h + '"');
                    return i._activePagesMeshData = [], i._textWidth = 0, i._textHeight = 0, i._align = s, i._tint = a, i._fontName = h, i._fontSize = c || na.available[h].size, i._text = n, i._maxWidth = l, i._maxLineHeight = 0, i._letterSpacing = u, i._anchor = new fe((function() {
                        i.dirty = !0
                    }), i, 0, 0), i._roundPixels = St.ROUND_PIXELS, i.dirty = !0, i._textureCache = {}, i
                }(function(t, e) {
                    function n() {
                        this.constructor = t
                    }
                    js(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
                })(e, t), e.prototype.updateText = function() {
                    for (var t, e = na.available[this._fontName], n = this._fontSize / e.size, r = new ae, i = [], o = [], s = [], a = ta(this._text.replace(/(?:\r\n|\r)/g, "\n") || " "), l = this._maxWidth * e.size / this._fontSize, u = "none" === e.distanceFieldType ? ra : ia, h = null, c = 0, d = 0, p = 0, f = -1, m = 0, g = 0, v = 0, _ = 0, y = 0; y < a.length; y++) {
                        var x = ea(G = a[y]);
                        if (/(?:\s)/.test(G) && (f = y, m = c, _++), "\r" !== G && "\n" !== G) {
                            var b = e.chars[x];
                            if (b) {
                                h && b.kerning[h] && (r.x += b.kerning[h]);
                                var E = oa.pop() || {
                                    texture: Un.EMPTY,
                                    line: 0,
                                    charCode: 0,
                                    prevSpaces: 0,
                                    position: new ae
                                };
                                E.texture = b.texture, E.line = p, E.charCode = x, E.position.x = r.x + b.xOffset + this._letterSpacing / 2, E.position.y = r.y + b.yOffset, E.prevSpaces = _, i.push(E), c = E.position.x + Math.max(b.xAdvance, b.texture.orig.width), r.x += b.xAdvance + this._letterSpacing, v = Math.max(v, b.yOffset + b.texture.height), h = x, -1 !== f && l > 0 && r.x > l && (Xt(i, 1 + f - ++g, 1 + y - f), y = f, f = -1, o.push(m), s.push(i.length > 0 ? i[i.length - 1].prevSpaces : 0), d = Math.max(d, m), p++, r.x = 0, r.y += e.lineHeight, h = null, _ = 0)
                            }
                        } else o.push(c), s.push(-1), d = Math.max(d, c), ++p, ++g, r.x = 0, r.y += e.lineHeight, h = null, _ = 0
                    }
                    var T = a[a.length - 1];
                    "\r" !== T && "\n" !== T && (/(?:\s)/.test(T) && (c = m), o.push(c), d = Math.max(d, c), s.push(-1));
                    var S = [];
                    for (y = 0; y <= p; y++) {
                        var w = 0;
                        "right" === this._align ? w = d - o[y] : "center" === this._align ? w = (d - o[y]) / 2 : "justify" === this._align && (w = s[y] < 0 ? 0 : (d - o[y]) / s[y]), S.push(w)
                    }
                    var M = i.length,
                        A = {},
                        R = [],
                        P = this._activePagesMeshData;
                    for (y = 0; y < P.length; y++) u.push(P[y]);
                    for (y = 0; y < M; y++) {
                        var I = (z = i[y].texture).baseTexture.uid;
                        if (!A[I]) {
                            if (!(Z = u.pop())) {
                                var C = new Xs,
                                    O = void 0,
                                    L = void 0;
                                "none" === e.distanceFieldType ? (O = new Ws(Un.EMPTY), L = lt.NORMAL) : (O = new Ws(Un.EMPTY, {
                                    program: Lr.from("// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n", "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r\n\r\n}\r\n"),
                                    uniforms: {
                                        uFWidth: 0
                                    }
                                }), L = lt.NORMAL_NPM);
                                var N = new Vs(C, O);
                                N.blendMode = L, Z = {
                                    index: 0,
                                    indexCount: 0,
                                    vertexCount: 0,
                                    uvsCount: 0,
                                    total: 0,
                                    mesh: N,
                                    vertices: null,
                                    uvs: null,
                                    indices: null
                                }
                            }
                            Z.index = 0, Z.indexCount = 0, Z.vertexCount = 0, Z.uvsCount = 0, Z.total = 0;
                            var D = this._textureCache;
                            D[I] = D[I] || new Un(z.baseTexture), Z.mesh.texture = D[I], Z.mesh.tint = this._tint, R.push(Z), A[I] = Z
                        }
                        A[I].total++
                    }
                    for (y = 0; y < P.length; y++) - 1 === R.indexOf(P[y]) && this.removeChild(P[y].mesh);
                    for (y = 0; y < R.length; y++) R[y].mesh.parent !== this && this.addChild(R[y].mesh);
                    for (var y in this._activePagesMeshData = R, A) {
                        var U = (Z = A[y]).total;
                        if (!((null === (t = Z.indices) || void 0 === t ? void 0 : t.length) > 6 * U) || Z.vertices.length < 2 * Vs.BATCHABLE_SIZE) Z.vertices = new Float32Array(8 * U), Z.uvs = new Float32Array(8 * U), Z.indices = new Uint16Array(6 * U);
                        else
                            for (var F = Z.total, B = Z.vertices, k = 4 * F * 2; k < B.length; k++) B[k] = 0;
                        Z.mesh.size = 6 * U
                    }
                    for (y = 0; y < M; y++) {
                        var G, H = (G = i[y]).position.x + S[G.line] * ("justify" === this._align ? G.prevSpaces : 1);
                        this._roundPixels && (H = Math.round(H));
                        var z, V = H * n,
                            W = G.position.y * n,
                            X = A[(z = G.texture).baseTexture.uid],
                            j = z.frame,
                            Y = z._uvs,
                            q = X.index++;
                        X.indices[6 * q + 0] = 0 + 4 * q, X.indices[6 * q + 1] = 1 + 4 * q, X.indices[6 * q + 2] = 2 + 4 * q, X.indices[6 * q + 3] = 0 + 4 * q, X.indices[6 * q + 4] = 2 + 4 * q, X.indices[6 * q + 5] = 3 + 4 * q, X.vertices[8 * q + 0] = V, X.vertices[8 * q + 1] = W, X.vertices[8 * q + 2] = V + j.width * n, X.vertices[8 * q + 3] = W, X.vertices[8 * q + 4] = V + j.width * n, X.vertices[8 * q + 5] = W + j.height * n, X.vertices[8 * q + 6] = V, X.vertices[8 * q + 7] = W + j.height * n, X.uvs[8 * q + 0] = Y.x0, X.uvs[8 * q + 1] = Y.y0, X.uvs[8 * q + 2] = Y.x1, X.uvs[8 * q + 3] = Y.y1, X.uvs[8 * q + 4] = Y.x2, X.uvs[8 * q + 5] = Y.y2, X.uvs[8 * q + 6] = Y.x3, X.uvs[8 * q + 7] = Y.y3
                    }
                    for (var y in this._textWidth = d * n, this._textHeight = (r.y + e.lineHeight) * n, A) {
                        var Z = A[y];
                        if (0 !== this.anchor.x || 0 !== this.anchor.y)
                            for (var K = 0, J = this._textWidth * this.anchor.x, Q = this._textHeight * this.anchor.y, $ = 0; $ < Z.total; $++) Z.vertices[K++] -= J, Z.vertices[K++] -= Q, Z.vertices[K++] -= J, Z.vertices[K++] -= Q, Z.vertices[K++] -= J, Z.vertices[K++] -= Q, Z.vertices[K++] -= J, Z.vertices[K++] -= Q;
                        this._maxLineHeight = v * n;
                        var tt = Z.mesh.geometry.getBuffer("aVertexPosition"),
                            et = Z.mesh.geometry.getBuffer("aTextureCoord"),
                            nt = Z.mesh.geometry.getIndex();
                        tt.data = Z.vertices, et.data = Z.uvs, nt.data = Z.indices, tt.update(), et.update(), nt.update()
                    }
                    for (y = 0; y < i.length; y++) oa.push(i[y])
                }, e.prototype.updateTransform = function() {
                    this.validate(), this.containerUpdateTransform()
                }, e.prototype._render = function(e) {
                    var n = na.available[this._fontName],
                        r = n.distanceFieldRange,
                        i = n.distanceFieldType,
                        o = n.size;
                    if ("none" !== i)
                        for (var s = this.worldTransform, a = s.a, l = s.b, u = s.c, h = s.d, c = Math.sqrt(a * a + l * l), d = Math.sqrt(u * u + h * h), p = (Math.abs(c) + Math.abs(d)) / 2, f = this._fontSize / o, m = 0, g = this._activePagesMeshData; m < g.length; m++) g[m].mesh.shader.uniforms.uFWidth = p * r * f * e.resolution;
                    t.prototype._render.call(this, e)
                }, e.prototype.getLocalBounds = function() {
                    return this.validate(), t.prototype.getLocalBounds.call(this)
                }, e.prototype.validate = function() {
                    this.dirty && (this.updateText(), this.dirty = !1)
                }, Object.defineProperty(e.prototype, "tint", {
                    get: function() {
                        return this._tint
                    },
                    set: function(t) {
                        if (this._tint !== t) {
                            this._tint = t;
                            for (var e = 0; e < this._activePagesMeshData.length; e++) this._activePagesMeshData[e].mesh.tint = t
                        }
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "align", {
                    get: function() {
                        return this._align
                    },
                    set: function(t) {
                        this._align !== t && (this._align = t, this.dirty = !0)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "fontName", {
                    get: function() {
                        return this._fontName
                    },
                    set: function(t) {
                        if (!na.available[t]) throw new Error('Missing BitmapFont "' + t + '"');
                        this._fontName !== t && (this._fontName = t, this.dirty = !0)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "fontSize", {
                    get: function() {
                        return this._fontSize
                    },
                    set: function(t) {
                        this._fontSize !== t && (this._fontSize = t, this.dirty = !0)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "anchor", {
                    get: function() {
                        return this._anchor
                    },
                    set: function(t) {
                        "number" == typeof t ? this._anchor.set(t) : this._anchor.copyFrom(t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "text", {
                    get: function() {
                        return this._text
                    },
                    set: function(t) {
                        t = String(null == t ? "" : t), this._text !== t && (this._text = t, this.dirty = !0)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "maxWidth", {
                    get: function() {
                        return this._maxWidth
                    },
                    set: function(t) {
                        this._maxWidth !== t && (this._maxWidth = t, this.dirty = !0)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "maxLineHeight", {
                    get: function() {
                        return this.validate(), this._maxLineHeight
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "textWidth", {
                    get: function() {
                        return this.validate(), this._textWidth
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "letterSpacing", {
                    get: function() {
                        return this._letterSpacing
                    },
                    set: function(t) {
                        this._letterSpacing !== t && (this._letterSpacing = t, this.dirty = !0)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "roundPixels", {
                    get: function() {
                        return this._roundPixels
                    },
                    set: function(t) {
                        t !== this._roundPixels && (this._roundPixels = t, this.dirty = !0)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "textHeight", {
                    get: function() {
                        return this.validate(), this._textHeight
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype.destroy = function(e) {
                    var n = this._textureCache;
                    for (var r in n) n[r].destroy(), delete n[r];
                    this._textureCache = null, t.prototype.destroy.call(this, e)
                }, e.styleDefaults = {
                    align: "left",
                    tint: 16777215,
                    maxWidth: 0,
                    letterSpacing: 0
                }
            }(Ke), function() {
                function t() {}
                return t.add = function() {
                    Gi.setExtensionXhrType("fnt", Gi.XHR_RESPONSE_TYPE.TEXT)
                }, t.use = function(e, n) {
                    var r = Qs(e.data);
                    if (r)
                        for (var i = t.getBaseUrl(this, e), o = r.parse(e.data), s = {}, a = function(t) {
                                s[t.metadata.pageFile] = t.texture, Object.keys(s).length === o.page.length && (e.bitmapFont = na.install(o, s, !0), n())
                            }, l = 0; l < o.page.length; ++l) {
                            var u = o.page[l].file,
                                h = i + u,
                                c = !1;
                            for (var d in this.resources) {
                                var p = this.resources[d];
                                if (p.url === h) {
                                    p.metadata.pageFile = u, p.texture ? a(p) : p.onAfterMiddleware.add(a), c = !0;
                                    break
                                }
                            }
                            if (!c) {
                                var f = {
                                    crossOrigin: e.crossOrigin,
                                    loadType: Gi.LOAD_TYPE.IMAGE,
                                    metadata: Object.assign({
                                        pageFile: u
                                    }, e.metadata.imageMetadata),
                                    parentResource: e
                                };
                                this.add(h, f, a)
                            }
                        } else n()
                }, t.getBaseUrl = function(e, n) {
                    var r = n.isDataUrl ? "" : t.dirname(n.url);
                    return n.isDataUrl && ("." === r && (r = ""), e.baseUrl && r && "/" === e.baseUrl.charAt(e.baseUrl.length - 1) && (r += "/")), (r = r.replace(e.baseUrl, "")) && "/" !== r.charAt(r.length - 1) && (r += "/"), r
                }, t.dirname = function(t) {
                    var e = t.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
                    return e === t ? "." : "" === e ? "/" : e
                }, t
            }()),
            aa = function(t, e) {
                return (aa = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(t, e) {
                        t.__proto__ = e
                    } || function(t, e) {
                        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
                    })(t, e)
            };
        ! function(t) {
            function e(e) {
                void 0 === e && (e = 1);
                var n = t.call(this, "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}", "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n", {
                    uAlpha: 1
                }) || this;
                return n.alpha = e, n
            }(function(t, e) {
                function n() {
                    this.constructor = t
                }
                aa(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
            })(e, t), Object.defineProperty(e.prototype, "alpha", {
                get: function() {
                    return this.uniforms.uAlpha
                },
                set: function(t) {
                    this.uniforms.uAlpha = t
                },
                enumerable: !1,
                configurable: !0
            })
        }(Ur);
        var la = function(t, e) {
            return (la = Object.setPrototypeOf || {
                    __proto__: []
                }
                instanceof Array && function(t, e) {
                    t.__proto__ = e
                } || function(t, e) {
                    for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
                })(t, e)
        };

        function ua(t, e) {
            function n() {
                this.constructor = t
            }
            la(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
        }
        var ha, ca, da, pa, fa, ma, ga, va, _a, ya, xa, ba, Ea, Ta, Sa, wa, Ma, Aa, Ra, Pa = {
                5: [.153388, .221461, .250301],
                7: [.071303, .131514, .189879, .214607],
                9: [.028532, .067234, .124009, .179044, .20236],
                11: [.0093, .028002, .065984, .121703, .175713, .198596],
                13: [.002406, .009255, .027867, .065666, .121117, .174868, .197641],
                15: [489e-6, .002403, .009246, .02784, .065602, .120999, .174697, .197448]
            },
            Ia = ["varying vec2 vBlurTexCoords[%size%];", "uniform sampler2D uSampler;", "void main(void)", "{", "    gl_FragColor = vec4(0.0);", "    %blur%", "}"].join("\n");
        ! function(t) {
            t[t.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t[t.WEBGL = 1] = "WEBGL", t[t.WEBGL2 = 2] = "WEBGL2"
        }(ha || (ha = {})),
        function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.WEBGL = 1] = "WEBGL", t[t.CANVAS = 2] = "CANVAS"
        }(ca || (ca = {})),
        function(t) {
            t[t.COLOR = 16384] = "COLOR", t[t.DEPTH = 256] = "DEPTH", t[t.STENCIL = 1024] = "STENCIL"
        }(da || (da = {})),
        function(t) {
            t[t.NORMAL = 0] = "NORMAL", t[t.ADD = 1] = "ADD", t[t.MULTIPLY = 2] = "MULTIPLY", t[t.SCREEN = 3] = "SCREEN", t[t.OVERLAY = 4] = "OVERLAY", t[t.DARKEN = 5] = "DARKEN", t[t.LIGHTEN = 6] = "LIGHTEN", t[t.COLOR_DODGE = 7] = "COLOR_DODGE", t[t.COLOR_BURN = 8] = "COLOR_BURN", t[t.HARD_LIGHT = 9] = "HARD_LIGHT", t[t.SOFT_LIGHT = 10] = "SOFT_LIGHT", t[t.DIFFERENCE = 11] = "DIFFERENCE", t[t.EXCLUSION = 12] = "EXCLUSION", t[t.HUE = 13] = "HUE", t[t.SATURATION = 14] = "SATURATION", t[t.COLOR = 15] = "COLOR", t[t.LUMINOSITY = 16] = "LUMINOSITY", t[t.NORMAL_NPM = 17] = "NORMAL_NPM", t[t.ADD_NPM = 18] = "ADD_NPM", t[t.SCREEN_NPM = 19] = "SCREEN_NPM", t[t.NONE = 20] = "NONE", t[t.SRC_OVER = 0] = "SRC_OVER", t[t.SRC_IN = 21] = "SRC_IN", t[t.SRC_OUT = 22] = "SRC_OUT", t[t.SRC_ATOP = 23] = "SRC_ATOP", t[t.DST_OVER = 24] = "DST_OVER", t[t.DST_IN = 25] = "DST_IN", t[t.DST_OUT = 26] = "DST_OUT", t[t.DST_ATOP = 27] = "DST_ATOP", t[t.ERASE = 26] = "ERASE", t[t.SUBTRACT = 28] = "SUBTRACT", t[t.XOR = 29] = "XOR"
        }(pa || (pa = {})),
        function(t) {
            t[t.POINTS = 0] = "POINTS", t[t.LINES = 1] = "LINES", t[t.LINE_LOOP = 2] = "LINE_LOOP", t[t.LINE_STRIP = 3] = "LINE_STRIP", t[t.TRIANGLES = 4] = "TRIANGLES", t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN"
        }(fa || (fa = {})),
        function(t) {
            t[t.RGBA = 6408] = "RGBA", t[t.RGB = 6407] = "RGB", t[t.RG = 33319] = "RG", t[t.RED = 6403] = "RED", t[t.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t[t.RGB_INTEGER = 36248] = "RGB_INTEGER", t[t.RG_INTEGER = 33320] = "RG_INTEGER", t[t.RED_INTEGER = 36244] = "RED_INTEGER", t[t.ALPHA = 6406] = "ALPHA", t[t.LUMINANCE = 6409] = "LUMINANCE", t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL"
        }(ma || (ma = {})),
        function(t) {
            t[t.TEXTURE_2D = 3553] = "TEXTURE_2D", t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z"
        }(ga || (ga = {})),
        function(t) {
            t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t[t.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t[t.BYTE = 5120] = "BYTE", t[t.SHORT = 5122] = "SHORT", t[t.INT = 5124] = "INT", t[t.FLOAT = 5126] = "FLOAT", t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t[t.HALF_FLOAT = 36193] = "HALF_FLOAT"
        }(va || (va = {})),
        function(t) {
            t[t.FLOAT = 0] = "FLOAT", t[t.INT = 1] = "INT", t[t.UINT = 2] = "UINT"
        }(_a || (_a = {})),
        function(t) {
            t[t.NEAREST = 0] = "NEAREST", t[t.LINEAR = 1] = "LINEAR"
        }(ya || (ya = {})),
        function(t) {
            t[t.CLAMP = 33071] = "CLAMP", t[t.REPEAT = 10497] = "REPEAT", t[t.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT"
        }(xa || (xa = {})),
        function(t) {
            t[t.OFF = 0] = "OFF", t[t.POW2 = 1] = "POW2", t[t.ON = 2] = "ON", t[t.ON_MANUAL = 3] = "ON_MANUAL"
        }(ba || (ba = {})),
        function(t) {
            t[t.NPM = 0] = "NPM", t[t.UNPACK = 1] = "UNPACK", t[t.PMA = 2] = "PMA", t[t.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t[t.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t[t.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t[t.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA"
        }(Ea || (Ea = {})),
        function(t) {
            t[t.NO = 0] = "NO", t[t.YES = 1] = "YES", t[t.AUTO = 2] = "AUTO", t[t.BLEND = 0] = "BLEND", t[t.CLEAR = 1] = "CLEAR", t[t.BLIT = 2] = "BLIT"
        }(Ta || (Ta = {})),
        function(t) {
            t[t.AUTO = 0] = "AUTO", t[t.MANUAL = 1] = "MANUAL"
        }(Sa || (Sa = {})),
        function(t) {
            t.LOW = "lowp", t.MEDIUM = "mediump", t.HIGH = "highp"
        }(wa || (wa = {})),
        function(t) {
            t[t.NONE = 0] = "NONE", t[t.SCISSOR = 1] = "SCISSOR", t[t.STENCIL = 2] = "STENCIL", t[t.SPRITE = 3] = "SPRITE"
        }(Ma || (Ma = {})),
        function(t) {
            t[t.NONE = 0] = "NONE", t[t.LOW = 2] = "LOW", t[t.MEDIUM = 4] = "MEDIUM", t[t.HIGH = 8] = "HIGH"
        }(Aa || (Aa = {})),
        function(t) {
            t[t.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t[t.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t[t.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER"
        }(Ra || (Ra = {}));
        var Ca = function(t) {
                function e(e, n, r, i, o) {
                    void 0 === n && (n = 8), void 0 === r && (r = 4), void 0 === i && (i = St.FILTER_RESOLUTION), void 0 === o && (o = 5);
                    var s = this,
                        a = function(t, e) {
                            var n, r = Math.ceil(t / 2),
                                i = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }",
                                o = "";
                            n = e ? "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
                            for (var s = 0; s < t; s++) {
                                var a = n.replace("%index%", s.toString());
                                o += a = a.replace("%sampleIndex%", s - (r - 1) + ".0"), o += "\n"
                            }
                            return (i = i.replace("%blur%", o)).replace("%size%", t.toString())
                        }(o, e),
                        l = function(t) {
                            for (var e, n = Pa[t], r = n.length, i = Ia, o = "", s = 0; s < t; s++) {
                                var a = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;".replace("%index%", s.toString());
                                e = s, s >= r && (e = t - s - 1), o += a = a.replace("%value%", n[e].toString()), o += "\n"
                            }
                            return (i = i.replace("%blur%", o)).replace("%size%", t.toString())
                        }(o);
                    return (s = t.call(this, a, l) || this).horizontal = e, s.resolution = i, s._quality = 0, s.quality = r, s.blur = n, s
                }
                return ua(e, t), e.prototype.apply = function(t, e, n, r) {
                    if (n ? this.horizontal ? this.uniforms.strength = 1 / n.width * (n.width / e.width) : this.uniforms.strength = 1 / n.height * (n.height / e.height) : this.horizontal ? this.uniforms.strength = 1 / t.renderer.width * (t.renderer.width / e.width) : this.uniforms.strength = 1 / t.renderer.height * (t.renderer.height / e.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, 1 === this.passes) t.applyFilter(this, e, n, r);
                    else {
                        var i = t.getFilterTexture(),
                            o = t.renderer,
                            s = e,
                            a = i;
                        this.state.blend = !1, t.applyFilter(this, s, a, Ta.CLEAR);
                        for (var l = 1; l < this.passes - 1; l++) {
                            t.bindAndClear(s, Ta.BLIT), this.uniforms.uSampler = a;
                            var u = a;
                            a = s, s = u, o.shader.bind(this), o.geometry.draw(5)
                        }
                        this.state.blend = !0, t.applyFilter(this, a, n, r), t.returnFilterTexture(i)
                    }
                }, Object.defineProperty(e.prototype, "blur", {
                    get: function() {
                        return this.strength
                    },
                    set: function(t) {
                        this.padding = 1 + 2 * Math.abs(t), this.strength = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "quality", {
                    get: function() {
                        return this._quality
                    },
                    set: function(t) {
                        this._quality = t, this.passes = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), e
            }(Ur),
            Oa = (function(t) {
                function e(e, n, r, i) {
                    void 0 === e && (e = 8), void 0 === n && (n = 4), void 0 === r && (r = St.FILTER_RESOLUTION), void 0 === i && (i = 5);
                    var o = t.call(this) || this;
                    return o.blurXFilter = new Ca(!0, e, n, r, i), o.blurYFilter = new Ca(!1, e, n, r, i), o.resolution = r, o.quality = n, o.blur = e, o.repeatEdgePixels = !1, o
                }
                ua(e, t), e.prototype.apply = function(t, e, n, r) {
                    var i = Math.abs(this.blurXFilter.strength),
                        o = Math.abs(this.blurYFilter.strength);
                    if (i && o) {
                        var s = t.getFilterTexture();
                        this.blurXFilter.apply(t, e, s, Ta.CLEAR), this.blurYFilter.apply(t, s, n, r), t.returnFilterTexture(s)
                    } else o ? this.blurYFilter.apply(t, e, n, r) : this.blurXFilter.apply(t, e, n, r)
                }, e.prototype.updatePadding = function() {
                    this._repeatEdgePixels ? this.padding = 0 : this.padding = 2 * Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength))
                }, Object.defineProperty(e.prototype, "blur", {
                    get: function() {
                        return this.blurXFilter.blur
                    },
                    set: function(t) {
                        this.blurXFilter.blur = this.blurYFilter.blur = t, this.updatePadding()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "quality", {
                    get: function() {
                        return this.blurXFilter.quality
                    },
                    set: function(t) {
                        this.blurXFilter.quality = this.blurYFilter.quality = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "blurX", {
                    get: function() {
                        return this.blurXFilter.blur
                    },
                    set: function(t) {
                        this.blurXFilter.blur = t, this.updatePadding()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "blurY", {
                    get: function() {
                        return this.blurYFilter.blur
                    },
                    set: function(t) {
                        this.blurYFilter.blur = t, this.updatePadding()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "blendMode", {
                    get: function() {
                        return this.blurYFilter.blendMode
                    },
                    set: function(t) {
                        this.blurYFilter.blendMode = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "repeatEdgePixels", {
                    get: function() {
                        return this._repeatEdgePixels
                    },
                    set: function(t) {
                        this._repeatEdgePixels = t, this.updatePadding()
                    },
                    enumerable: !1,
                    configurable: !0
                })
            }(Ur), function(t, e) {
                return (Oa = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(t, e) {
                        t.__proto__ = e
                    } || function(t, e) {
                        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
                    })(t, e)
            }),
            La = function(t) {
                function e() {
                    var e = this,
                        n = {
                            m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]),
                            uAlpha: 1
                        };
                    return (e = t.call(this, di, "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n", n) || this).alpha = 1, e
                }
                return function(t, e) {
                    function n() {
                        this.constructor = t
                    }
                    Oa(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
                }(e, t), e.prototype._loadMatrix = function(t, e) {
                    void 0 === e && (e = !1);
                    var n = t;
                    e && (this._multiply(n, this.uniforms.m, t), n = this._colorMatrix(n)), this.uniforms.m = n
                }, e.prototype._multiply = function(t, e, n) {
                    return t[0] = e[0] * n[0] + e[1] * n[5] + e[2] * n[10] + e[3] * n[15], t[1] = e[0] * n[1] + e[1] * n[6] + e[2] * n[11] + e[3] * n[16], t[2] = e[0] * n[2] + e[1] * n[7] + e[2] * n[12] + e[3] * n[17], t[3] = e[0] * n[3] + e[1] * n[8] + e[2] * n[13] + e[3] * n[18], t[4] = e[0] * n[4] + e[1] * n[9] + e[2] * n[14] + e[3] * n[19] + e[4], t[5] = e[5] * n[0] + e[6] * n[5] + e[7] * n[10] + e[8] * n[15], t[6] = e[5] * n[1] + e[6] * n[6] + e[7] * n[11] + e[8] * n[16], t[7] = e[5] * n[2] + e[6] * n[7] + e[7] * n[12] + e[8] * n[17], t[8] = e[5] * n[3] + e[6] * n[8] + e[7] * n[13] + e[8] * n[18], t[9] = e[5] * n[4] + e[6] * n[9] + e[7] * n[14] + e[8] * n[19] + e[9], t[10] = e[10] * n[0] + e[11] * n[5] + e[12] * n[10] + e[13] * n[15], t[11] = e[10] * n[1] + e[11] * n[6] + e[12] * n[11] + e[13] * n[16], t[12] = e[10] * n[2] + e[11] * n[7] + e[12] * n[12] + e[13] * n[17], t[13] = e[10] * n[3] + e[11] * n[8] + e[12] * n[13] + e[13] * n[18], t[14] = e[10] * n[4] + e[11] * n[9] + e[12] * n[14] + e[13] * n[19] + e[14], t[15] = e[15] * n[0] + e[16] * n[5] + e[17] * n[10] + e[18] * n[15], t[16] = e[15] * n[1] + e[16] * n[6] + e[17] * n[11] + e[18] * n[16], t[17] = e[15] * n[2] + e[16] * n[7] + e[17] * n[12] + e[18] * n[17], t[18] = e[15] * n[3] + e[16] * n[8] + e[17] * n[13] + e[18] * n[18], t[19] = e[15] * n[4] + e[16] * n[9] + e[17] * n[14] + e[18] * n[19] + e[19], t
                }, e.prototype._colorMatrix = function(t) {
                    var e = new Float32Array(t);
                    return e[4] /= 255, e[9] /= 255, e[14] /= 255, e[19] /= 255, e
                }, e.prototype.brightness = function(t, e) {
                    var n = [t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 1, 0];
                    this._loadMatrix(n, e)
                }, e.prototype.tint = function(t, e) {
                    var n = [(t >> 16 & 255) / 255, 0, 0, 0, 0, 0, (t >> 8 & 255) / 255, 0, 0, 0, 0, 0, (255 & t) / 255, 0, 0, 0, 0, 0, 1, 0];
                    this._loadMatrix(n, e)
                }, e.prototype.greyscale = function(t, e) {
                    var n = [t, t, t, 0, 0, t, t, t, 0, 0, t, t, t, 0, 0, 0, 0, 0, 1, 0];
                    this._loadMatrix(n, e)
                }, e.prototype.blackAndWhite = function(t) {
                    this._loadMatrix([.3, .6, .1, 0, 0, .3, .6, .1, 0, 0, .3, .6, .1, 0, 0, 0, 0, 0, 1, 0], t)
                }, e.prototype.hue = function(t, e) {
                    t = (t || 0) / 180 * Math.PI;
                    var n = Math.cos(t),
                        r = Math.sin(t),
                        i = 1 / 3,
                        o = (0, Math.sqrt)(i),
                        s = [n + (1 - n) * i, i * (1 - n) - o * r, i * (1 - n) + o * r, 0, 0, i * (1 - n) + o * r, n + i * (1 - n), i * (1 - n) - o * r, 0, 0, i * (1 - n) - o * r, i * (1 - n) + o * r, n + i * (1 - n), 0, 0, 0, 0, 0, 1, 0];
                    this._loadMatrix(s, e)
                }, e.prototype.contrast = function(t, e) {
                    var n = (t || 0) + 1,
                        r = -.5 * (n - 1),
                        i = [n, 0, 0, 0, r, 0, n, 0, 0, r, 0, 0, n, 0, r, 0, 0, 0, 1, 0];
                    this._loadMatrix(i, e)
                }, e.prototype.saturate = function(t, e) {
                    void 0 === t && (t = 0);
                    var n = 2 * t / 3 + 1,
                        r = -.5 * (n - 1),
                        i = [n, r, r, 0, 0, r, n, r, 0, 0, r, r, n, 0, 0, 0, 0, 0, 1, 0];
                    this._loadMatrix(i, e)
                }, e.prototype.desaturate = function() {
                    this.saturate(-1)
                }, e.prototype.negative = function(t) {
                    this._loadMatrix([-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0], t)
                }, e.prototype.sepia = function(t) {
                    this._loadMatrix([.393, .7689999, .18899999, 0, 0, .349, .6859999, .16799999, 0, 0, .272, .5339999, .13099999, 0, 0, 0, 0, 0, 1, 0], t)
                }, e.prototype.technicolor = function(t) {
                    this._loadMatrix([1.9125277891456083, -.8545344976951645, -.09155508482755585, 0, 11.793603434377337, -.3087833385928097, 1.7658908555458428, -.10601743074722245, 0, -70.35205161461398, -.231103377548616, -.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0], t)
                }, e.prototype.polaroid = function(t) {
                    this._loadMatrix([1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0], t)
                }, e.prototype.toBGR = function(t) {
                    this._loadMatrix([0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], t)
                }, e.prototype.kodachrome = function(t) {
                    this._loadMatrix([1.1285582396593525, -.3967382283601348, -.03992559172921793, 0, 63.72958762196502, -.16404339962244616, 1.0835251566291304, -.05498805115633132, 0, 24.732407896706203, -.16786010706155763, -.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0], t)
                }, e.prototype.browni = function(t) {
                    this._loadMatrix([.5997023498159715, .34553243048391263, -.2708298674538042, 0, 47.43192855600873, -.037703249837783157, .8609577587992641, .15059552388459913, 0, -36.96841498319127, .24113635128153335, -.07441037908422492, .44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0], t)
                }, e.prototype.vintage = function(t) {
                    this._loadMatrix([.6279345635605994, .3202183420819367, -.03965408211312453, 0, 9.651285835294123, .02578397704808868, .6441188644374771, .03259127616149294, 0, 7.462829176470591, .0466055556782719, -.0851232987247891, .5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0], t)
                }, e.prototype.colorTone = function(t, e, n, r, i) {
                    var o = ((n = n || 16770432) >> 16 & 255) / 255,
                        s = (n >> 8 & 255) / 255,
                        a = (255 & n) / 255,
                        l = ((r = r || 3375104) >> 16 & 255) / 255,
                        u = (r >> 8 & 255) / 255,
                        h = (255 & r) / 255,
                        c = [.3, .59, .11, 0, 0, o, s, a, t = t || .2, 0, l, u, h, e = e || .15, 0, o - l, s - u, a - h, 0, 0];
                    this._loadMatrix(c, i)
                }, e.prototype.night = function(t, e) {
                    var n = [-2 * (t = t || .1), -t, 0, 0, 0, -t, 0, t, 0, 0, 0, t, 2 * t, 0, 0, 0, 0, 0, 1, 0];
                    this._loadMatrix(n, e)
                }, e.prototype.predator = function(t, e) {
                    var n = [11.224130630493164 * t, -4.794486999511719 * t, -2.8746118545532227 * t, 0 * t, .40342438220977783 * t, -3.6330697536468506 * t, 9.193157196044922 * t, -2.951810836791992 * t, 0 * t, -1.316135048866272 * t, -3.2184197902679443 * t, -4.2375030517578125 * t, 7.476448059082031 * t, 0 * t, .8044459223747253 * t, 0, 0, 0, 1, 0];
                    this._loadMatrix(n, e)
                }, e.prototype.lsd = function(t) {
                    this._loadMatrix([2, -.4, .5, 0, 0, -.5, 2, -.4, 0, 0, -.4, -.5, 3, 0, 0, 0, 0, 0, 1, 0], t)
                }, e.prototype.reset = function() {
                    this._loadMatrix([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], !1)
                }, Object.defineProperty(e.prototype, "matrix", {
                    get: function() {
                        return this.uniforms.m
                    },
                    set: function(t) {
                        this.uniforms.m = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "alpha", {
                    get: function() {
                        return this.uniforms.uAlpha
                    },
                    set: function(t) {
                        this.uniforms.uAlpha = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), e
            }(Ur);
        La.prototype.grayscale = La.prototype.greyscale;
        var Na = function(t, e) {
            return (Na = Object.setPrototypeOf || {
                    __proto__: []
                }
                instanceof Array && function(t, e) {
                    t.__proto__ = e
                } || function(t, e) {
                    for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
                })(t, e)
        };
        ! function(t) {
            function e(e, n) {
                var r = this,
                    i = new me;
                return e.renderable = !1, (r = t.call(this, "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n", "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n", {
                    mapSampler: e._texture,
                    filterMatrix: i,
                    scale: {
                        x: 1,
                        y: 1
                    },
                    rotation: new Float32Array([1, 0, 0, 1])
                }) || this).maskSprite = e, r.maskMatrix = i, null == n && (n = 20), r.scale = new ae(n, n), r
            }(function(t, e) {
                function n() {
                    this.constructor = t
                }
                Na(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
            })(e, t), e.prototype.apply = function(t, e, n, r) {
                this.uniforms.filterMatrix = t.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
                var i = this.maskSprite.worldTransform,
                    o = Math.sqrt(i.a * i.a + i.b * i.b),
                    s = Math.sqrt(i.c * i.c + i.d * i.d);
                0 !== o && 0 !== s && (this.uniforms.rotation[0] = i.a / o, this.uniforms.rotation[1] = i.b / o, this.uniforms.rotation[2] = i.c / s, this.uniforms.rotation[3] = i.d / s), t.applyFilter(this, e, n, r)
            }, Object.defineProperty(e.prototype, "map", {
                get: function() {
                    return this.uniforms.mapSampler
                },
                set: function(t) {
                    this.uniforms.mapSampler = t
                },
                enumerable: !1,
                configurable: !0
            })
        }(Ur);
        var Da, Ua = function(t, e) {
            return (Ua = Object.setPrototypeOf || {
                    __proto__: []
                }
                instanceof Array && function(t, e) {
                    t.__proto__ = e
                } || function(t, e) {
                    for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
                })(t, e)
        };
        (function(t, e) {
            function n() {
                this.constructor = t
            }
            Ua(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
        })((function() {
            return Da.call(this, "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n", 'varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputSize;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it\'s\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n') || this
        }), Da = Ur);
        var Fa, Ba, ka, Ga, Ha, za, Va, Wa, Xa, ja, Ya, qa, Za, Ka, Ja, Qa, $a, tl, el, nl = function(t, e) {
            return (nl = Object.setPrototypeOf || {
                    __proto__: []
                }
                instanceof Array && function(t, e) {
                    t.__proto__ = e
                } || function(t, e) {
                    for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
                })(t, e)
        };
        ! function(t) {
            function e(e, n) {
                void 0 === e && (e = .5), void 0 === n && (n = Math.random());
                var r = t.call(this, di, "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n", {
                    uNoise: 0,
                    uSeed: 0
                }) || this;
                return r.noise = e, r.seed = n, r
            }(function(t, e) {
                function n() {
                    this.constructor = t
                }
                nl(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
            })(e, t), Object.defineProperty(e.prototype, "noise", {
                get: function() {
                    return this.uniforms.uNoise
                },
                set: function(t) {
                    this.uniforms.uNoise = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, "seed", {
                get: function() {
                    return this.uniforms.uSeed
                },
                set: function(t) {
                    this.uniforms.uSeed = t
                },
                enumerable: !1,
                configurable: !0
            })
        }(Ur),
        function(t) {
            t[t.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t[t.WEBGL = 1] = "WEBGL", t[t.WEBGL2 = 2] = "WEBGL2"
        }(Fa || (Fa = {})),
        function(t) {
            t[t.UNKNOWN = 0] = "UNKNOWN", t[t.WEBGL = 1] = "WEBGL", t[t.CANVAS = 2] = "CANVAS"
        }(Ba || (Ba = {})),
        function(t) {
            t[t.COLOR = 16384] = "COLOR", t[t.DEPTH = 256] = "DEPTH", t[t.STENCIL = 1024] = "STENCIL"
        }(ka || (ka = {})),
        function(t) {
            t[t.NORMAL = 0] = "NORMAL", t[t.ADD = 1] = "ADD", t[t.MULTIPLY = 2] = "MULTIPLY", t[t.SCREEN = 3] = "SCREEN", t[t.OVERLAY = 4] = "OVERLAY", t[t.DARKEN = 5] = "DARKEN", t[t.LIGHTEN = 6] = "LIGHTEN", t[t.COLOR_DODGE = 7] = "COLOR_DODGE", t[t.COLOR_BURN = 8] = "COLOR_BURN", t[t.HARD_LIGHT = 9] = "HARD_LIGHT", t[t.SOFT_LIGHT = 10] = "SOFT_LIGHT", t[t.DIFFERENCE = 11] = "DIFFERENCE", t[t.EXCLUSION = 12] = "EXCLUSION", t[t.HUE = 13] = "HUE", t[t.SATURATION = 14] = "SATURATION", t[t.COLOR = 15] = "COLOR", t[t.LUMINOSITY = 16] = "LUMINOSITY", t[t.NORMAL_NPM = 17] = "NORMAL_NPM", t[t.ADD_NPM = 18] = "ADD_NPM", t[t.SCREEN_NPM = 19] = "SCREEN_NPM", t[t.NONE = 20] = "NONE", t[t.SRC_OVER = 0] = "SRC_OVER", t[t.SRC_IN = 21] = "SRC_IN", t[t.SRC_OUT = 22] = "SRC_OUT", t[t.SRC_ATOP = 23] = "SRC_ATOP", t[t.DST_OVER = 24] = "DST_OVER", t[t.DST_IN = 25] = "DST_IN", t[t.DST_OUT = 26] = "DST_OUT", t[t.DST_ATOP = 27] = "DST_ATOP", t[t.ERASE = 26] = "ERASE", t[t.SUBTRACT = 28] = "SUBTRACT", t[t.XOR = 29] = "XOR"
        }(Ga || (Ga = {})),
        function(t) {
            t[t.POINTS = 0] = "POINTS", t[t.LINES = 1] = "LINES", t[t.LINE_LOOP = 2] = "LINE_LOOP", t[t.LINE_STRIP = 3] = "LINE_STRIP", t[t.TRIANGLES = 4] = "TRIANGLES", t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN"
        }(Ha || (Ha = {})),
        function(t) {
            t[t.RGBA = 6408] = "RGBA", t[t.RGB = 6407] = "RGB", t[t.RG = 33319] = "RG", t[t.RED = 6403] = "RED", t[t.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t[t.RGB_INTEGER = 36248] = "RGB_INTEGER", t[t.RG_INTEGER = 33320] = "RG_INTEGER", t[t.RED_INTEGER = 36244] = "RED_INTEGER", t[t.ALPHA = 6406] = "ALPHA", t[t.LUMINANCE = 6409] = "LUMINANCE", t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL"
        }(za || (za = {})),
        function(t) {
            t[t.TEXTURE_2D = 3553] = "TEXTURE_2D", t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z"
        }(Va || (Va = {})),
        function(t) {
            t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t[t.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t[t.BYTE = 5120] = "BYTE", t[t.SHORT = 5122] = "SHORT", t[t.INT = 5124] = "INT", t[t.FLOAT = 5126] = "FLOAT", t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t[t.HALF_FLOAT = 36193] = "HALF_FLOAT"
        }(Wa || (Wa = {})),
        function(t) {
            t[t.FLOAT = 0] = "FLOAT", t[t.INT = 1] = "INT", t[t.UINT = 2] = "UINT"
        }(Xa || (Xa = {})),
        function(t) {
            t[t.NEAREST = 0] = "NEAREST", t[t.LINEAR = 1] = "LINEAR"
        }(ja || (ja = {})),
        function(t) {
            t[t.CLAMP = 33071] = "CLAMP", t[t.REPEAT = 10497] = "REPEAT", t[t.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT"
        }(Ya || (Ya = {})),
        function(t) {
            t[t.OFF = 0] = "OFF", t[t.POW2 = 1] = "POW2", t[t.ON = 2] = "ON", t[t.ON_MANUAL = 3] = "ON_MANUAL"
        }(qa || (qa = {})),
        function(t) {
            t[t.NPM = 0] = "NPM", t[t.UNPACK = 1] = "UNPACK", t[t.PMA = 2] = "PMA", t[t.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t[t.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t[t.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t[t.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA"
        }(Za || (Za = {})),
        function(t) {
            t[t.NO = 0] = "NO", t[t.YES = 1] = "YES", t[t.AUTO = 2] = "AUTO", t[t.BLEND = 0] = "BLEND", t[t.CLEAR = 1] = "CLEAR", t[t.BLIT = 2] = "BLIT"
        }(Ka || (Ka = {})),
        function(t) {
            t[t.AUTO = 0] = "AUTO", t[t.MANUAL = 1] = "MANUAL"
        }(Ja || (Ja = {})),
        function(t) {
            t.LOW = "lowp", t.MEDIUM = "mediump", t.HIGH = "highp"
        }(Qa || (Qa = {})),
        function(t) {
            t[t.NONE = 0] = "NONE", t[t.SCISSOR = 1] = "SCISSOR", t[t.STENCIL = 2] = "STENCIL", t[t.SPRITE = 3] = "SPRITE"
        }($a || ($a = {})),
        function(t) {
            t[t.NONE = 0] = "NONE", t[t.LOW = 2] = "LOW", t[t.MEDIUM = 4] = "MEDIUM", t[t.HIGH = 8] = "HIGH"
        }(tl || (tl = {})),
        function(t) {
            t[t.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t[t.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t[t.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER"
        }(el || (el = {}));
        var rl = new me;
        Ye.prototype._cacheAsBitmap = !1, Ye.prototype._cacheData = null, Ye.prototype._cacheAsBitmapResolution = null, Ye.prototype._cacheAsBitmapMultisample = tl.NONE;
        var il = function() {
            this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null
        };
        Object.defineProperties(Ye.prototype, {
            cacheAsBitmapResolution: {
                get: function() {
                    return this._cacheAsBitmapResolution
                },
                set: function(t) {
                    t !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = t, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0))
                }
            },
            cacheAsBitmapMultisample: {
                get: function() {
                    return this._cacheAsBitmapMultisample
                },
                set: function(t) {
                    t !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = t, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0))
                }
            },
            cacheAsBitmap: {
                get: function() {
                    return this._cacheAsBitmap
                },
                set: function(t) {
                    var e;
                    this._cacheAsBitmap !== t && (this._cacheAsBitmap = t, t ? (this._cacheData || (this._cacheData = new il), (e = this._cacheData).originalRender = this.render, e.originalRenderCanvas = this.renderCanvas, e.originalUpdateTransform = this.updateTransform, e.originalCalculateBounds = this.calculateBounds, e.originalGetLocalBounds = this.getLocalBounds, e.originalDestroy = this.destroy, e.originalContainsPoint = this.containsPoint, e.originalMask = this._mask, e.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : ((e = this._cacheData).sprite && this._destroyCachedDisplayObject(), this.render = e.originalRender, this.renderCanvas = e.originalRenderCanvas, this.calculateBounds = e.originalCalculateBounds, this.getLocalBounds = e.originalGetLocalBounds, this.destroy = e.originalDestroy, this.updateTransform = e.originalUpdateTransform, this.containsPoint = e.originalContainsPoint, this._mask = e.originalMask, this.filterArea = e.originalFilterArea))
                }
            }
        }), Ye.prototype._renderCached = function(t) {
            !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t))
        }, Ye.prototype._initCachedDisplayObject = function(t) {
            var e;
            if (!this._cacheData || !this._cacheData.sprite) {
                var n = this.alpha;
                this.alpha = 1, t.batch.flush();
                var r = this.getLocalBounds(null, !0).clone();
                if (this.filters && this.filters.length) {
                    var i = this.filters[0].padding;
                    r.pad(i)
                }
                r.ceil(St.RESOLUTION);
                var o = t.renderTexture.current,
                    s = t.renderTexture.sourceFrame.clone(),
                    a = t.renderTexture.destinationFrame.clone(),
                    l = t.projection.transform,
                    u = Bn.create({
                        width: r.width,
                        height: r.height,
                        resolution: this.cacheAsBitmapResolution || t.resolution,
                        multisample: null !== (e = this.cacheAsBitmapMultisample) && void 0 !== e ? e : t.multisample
                    }),
                    h = "cacheAsBitmap_" + qt();
                this._cacheData.textureCacheId = h, xn.addToCache(u.baseTexture, h), Un.addToCache(u, h);
                var c = this.transform.localTransform.copyTo(rl).invert().translate(-r.x, -r.y);
                this.render = this._cacheData.originalRender, t.render(this, {
                    renderTexture: u,
                    clear: !0,
                    transform: c,
                    skipUpdateTransform: !1
                }), t.framebuffer.blit(), t.projection.transform = l, t.renderTexture.bind(o, s, a), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = n;
                var d = new os(u);
                d.transform.worldTransform = this.transform.worldTransform, d.anchor.x = -r.x / r.width, d.anchor.y = -r.y / r.height, d.alpha = n, d._bounds = this._bounds, this._cacheData.sprite = d, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = d.containsPoint.bind(d)
            }
        }, Ye.prototype._renderCachedCanvas = function(t) {
            !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t))
        }, Ye.prototype._initCachedDisplayObjectCanvas = function(t) {
            if (!this._cacheData || !this._cacheData.sprite) {
                var e = this.getLocalBounds(null, !0),
                    n = this.alpha;
                this.alpha = 1;
                var r = t.context,
                    i = t._projTransform;
                e.ceil(St.RESOLUTION);
                var o = Bn.create({
                        width: e.width,
                        height: e.height
                    }),
                    s = "cacheAsBitmap_" + qt();
                this._cacheData.textureCacheId = s, xn.addToCache(o.baseTexture, s), Un.addToCache(o, s);
                var a = rl;
                this.transform.localTransform.copyTo(a), a.invert(), a.tx -= e.x, a.ty -= e.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, {
                    renderTexture: o,
                    clear: !0,
                    transform: a,
                    skipUpdateTransform: !1
                }), t.context = r, t._projTransform = i, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = n;
                var l = new os(o);
                l.transform.worldTransform = this.transform.worldTransform, l.anchor.x = -e.x / e.width, l.anchor.y = -e.y / e.height, l.alpha = n, l._bounds = this._bounds, this._cacheData.sprite = l, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = l.containsPoint.bind(l)
            }
        }, Ye.prototype._calculateCachedBounds = function() {
            this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID
        }, Ye.prototype._getCachedLocalBounds = function() {
            return this._cacheData.sprite.getLocalBounds(null)
        }, Ye.prototype._destroyCachedDisplayObject = function() {
            this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, xn.removeFromCache(this._cacheData.textureCacheId), Un.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null
        }, Ye.prototype._cacheAsBitmapDestroy = function(t) {
            this.cacheAsBitmap = !1, this.destroy(t)
        }, Ye.prototype.name = null, Ke.prototype.getChildByName = function(t, e) {
            for (var n = 0, r = this.children.length; n < r; n++)
                if (this.children[n].name === t) return this.children[n];
            if (e)
                for (n = 0, r = this.children.length; n < r; n++)
                    if (this.children[n].getChildByName) {
                        var i = this.children[n].getChildByName(t, !0);
                        if (i) return i
                    } return null
        }, Ye.prototype.getGlobalPosition = function(t, e) {
            return void 0 === t && (t = new ae), void 0 === e && (e = !1), this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x, t.y = this.position.y), t
        };
        var ol = function(t, e) {
            return (ol = Object.setPrototypeOf || {
                    __proto__: []
                }
                instanceof Array && function(t, e) {
                    t.__proto__ = e
                } || function(t, e) {
                    for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
                })(t, e)
        };

        function sl(t, e) {
            function n() {
                this.constructor = t
            }
            ol(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
        }
        var al = function(t) {
                function e(e, n, r, i) {
                    void 0 === e && (e = 100), void 0 === n && (n = 100), void 0 === r && (r = 10), void 0 === i && (i = 10);
                    var o = t.call(this) || this;
                    return o.segWidth = r, o.segHeight = i, o.width = e, o.height = n, o.build(), o
                }
                return sl(e, t), e.prototype.build = function() {
                    for (var t = this.segWidth * this.segHeight, e = [], n = [], r = [], i = this.segWidth - 1, o = this.segHeight - 1, s = this.width / i, a = this.height / o, l = 0; l < t; l++) {
                        var u = l % this.segWidth,
                            h = l / this.segWidth | 0;
                        e.push(u * s, h * a), n.push(u / i, h / o)
                    }
                    var c = i * o;
                    for (l = 0; l < c; l++) {
                        var d = l % i,
                            p = l / i | 0,
                            f = p * this.segWidth + d,
                            m = p * this.segWidth + d + 1,
                            g = (p + 1) * this.segWidth + d,
                            v = (p + 1) * this.segWidth + d + 1;
                        r.push(f, m, g, m, v, g)
                    }
                    this.buffers[0].data = new Float32Array(e), this.buffers[1].data = new Float32Array(n), this.indexBuffer.data = new Uint16Array(r), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update()
                }, e
            }(Xs),
            ll = function(t) {
                function e(e, n, r) {
                    void 0 === e && (e = 200), void 0 === r && (r = 0);
                    var i = t.call(this, new Float32Array(4 * n.length), new Float32Array(4 * n.length), new Uint16Array(6 * (n.length - 1))) || this;
                    return i.points = n, i._width = e, i.textureScale = r, i.build(), i
                }
                return sl(e, t), Object.defineProperty(e.prototype, "width", {
                    get: function() {
                        return this._width
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype.build = function() {
                    var t = this.points;
                    if (t) {
                        var e = this.getBuffer("aVertexPosition"),
                            n = this.getBuffer("aTextureCoord"),
                            r = this.getIndex();
                        if (!(t.length < 1)) {
                            e.data.length / 4 !== t.length && (e.data = new Float32Array(4 * t.length), n.data = new Float32Array(4 * t.length), r.data = new Uint16Array(6 * (t.length - 1)));
                            var i = n.data,
                                o = r.data;
                            i[0] = 0, i[1] = 0, i[2] = 0, i[3] = 1;
                            for (var s = 0, a = t[0], l = this._width * this.textureScale, u = t.length, h = 0; h < u; h++) {
                                var c = 4 * h;
                                if (this.textureScale > 0) {
                                    var d = a.x - t[h].x,
                                        p = a.y - t[h].y,
                                        f = Math.sqrt(d * d + p * p);
                                    a = t[h], s += f / l
                                } else s = h / (u - 1);
                                i[c] = s, i[c + 1] = 0, i[c + 2] = s, i[c + 3] = 1
                            }
                            var m = 0;
                            for (h = 0; h < u - 1; h++) c = 2 * h, o[m++] = c, o[m++] = c + 1, o[m++] = c + 2, o[m++] = c + 2, o[m++] = c + 1, o[m++] = c + 3;
                            n.update(), r.update(), this.updateVertices()
                        }
                    }
                }, e.prototype.updateVertices = function() {
                    var t = this.points;
                    if (!(t.length < 1)) {
                        for (var e, n = t[0], r = 0, i = 0, o = this.buffers[0].data, s = t.length, a = 0; a < s; a++) {
                            var l = t[a],
                                u = 4 * a;
                            i = -((e = a < t.length - 1 ? t[a + 1] : l).x - n.x), r = e.y - n.y;
                            var h = Math.sqrt(r * r + i * i),
                                c = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
                            r /= h, i /= h, r *= c, i *= c, o[u] = l.x + r, o[u + 1] = l.y + i, o[u + 2] = l.x - r, o[u + 3] = l.y - i, n = l
                        }
                        this.buffers[0].update()
                    }
                }, e.prototype.update = function() {
                    this.textureScale > 0 ? this.build() : this.updateVertices()
                }, e
            }(Xs),
            ul = (function(t) {
                function e(e, n, r) {
                    void 0 === r && (r = 0);
                    var i = this,
                        o = new ll(e.height, n, r),
                        s = new Ws(e);
                    return r > 0 && (e.baseTexture.wrapMode = mt.REPEAT), (i = t.call(this, o, s) || this).autoUpdate = !0, i
                }
                sl(e, t), e.prototype._render = function(e) {
                    var n = this.geometry;
                    (this.autoUpdate || n._width !== this.shader.texture.height) && (n._width = this.shader.texture.height, n.update()), t.prototype._render.call(this, e)
                }
            }(Vs), function(t) {
                function e(e, n, r) {
                    var i = this,
                        o = new al(e.width, e.height, n, r),
                        s = new Ws(Un.WHITE);
                    return (i = t.call(this, o, s) || this).texture = e, i.autoResize = !0, i
                }
                return sl(e, t), e.prototype.textureUpdated = function() {
                    this._textureID = this.shader.texture._updateID;
                    var t = this.geometry,
                        e = this.shader.texture,
                        n = e.width,
                        r = e.height;
                    !this.autoResize || t.width === n && t.height === r || (t.width = this.shader.texture.width, t.height = this.shader.texture.height, t.build())
                }, Object.defineProperty(e.prototype, "texture", {
                    get: function() {
                        return this.shader.texture
                    },
                    set: function(t) {
                        this.shader.texture !== t && (this.shader.texture = t, this._textureID = -1, t.baseTexture.valid ? this.textureUpdated() : t.once("update", this.textureUpdated, this))
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype._render = function(e) {
                    this._textureID !== this.shader.texture._updateID && this.textureUpdated(), t.prototype._render.call(this, e)
                }, e.prototype.destroy = function(e) {
                    this.shader.texture.off("update", this.textureUpdated, this), t.prototype.destroy.call(this, e)
                }, e
            }(Vs)),
            hl = (function(t) {
                function e(e, n, r, i, o) {
                    void 0 === e && (e = Un.EMPTY);
                    var s = this,
                        a = new Xs(n, r, i);
                    a.getBuffer("aVertexPosition").static = !1;
                    var l = new Ws(e);
                    return (s = t.call(this, a, l, null, o) || this).autoUpdate = !0, s
                }
                sl(e, t), Object.defineProperty(e.prototype, "vertices", {
                    get: function() {
                        return this.geometry.getBuffer("aVertexPosition").data
                    },
                    set: function(t) {
                        this.geometry.getBuffer("aVertexPosition").data = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype._render = function(e) {
                    this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), t.prototype._render.call(this, e)
                }
            }(Vs), function(t) {
                function e(e, n, r, i, o) {
                    void 0 === n && (n = 10), void 0 === r && (r = 10), void 0 === i && (i = 10), void 0 === o && (o = 10);
                    var s = t.call(this, Un.WHITE, 4, 4) || this;
                    return s._origWidth = e.orig.width, s._origHeight = e.orig.height, s._width = s._origWidth, s._height = s._origHeight, s._leftWidth = n, s._rightWidth = i, s._topHeight = r, s._bottomHeight = o, s.texture = e, s
                }
                sl(e, t), e.prototype.textureUpdated = function() {
                    this._textureID = this.shader.texture._updateID, this._refresh()
                }, Object.defineProperty(e.prototype, "vertices", {
                    get: function() {
                        return this.geometry.getBuffer("aVertexPosition").data
                    },
                    set: function(t) {
                        this.geometry.getBuffer("aVertexPosition").data = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype.updateHorizontalVertices = function() {
                    var t = this.vertices,
                        e = this._getMinScale();
                    t[9] = t[11] = t[13] = t[15] = this._topHeight * e, t[17] = t[19] = t[21] = t[23] = this._height - this._bottomHeight * e, t[25] = t[27] = t[29] = t[31] = this._height
                }, e.prototype.updateVerticalVertices = function() {
                    var t = this.vertices,
                        e = this._getMinScale();
                    t[2] = t[10] = t[18] = t[26] = this._leftWidth * e, t[4] = t[12] = t[20] = t[28] = this._width - this._rightWidth * e, t[6] = t[14] = t[22] = t[30] = this._width
                }, e.prototype._getMinScale = function() {
                    var t = this._leftWidth + this._rightWidth,
                        e = this._width > t ? 1 : this._width / t,
                        n = this._topHeight + this._bottomHeight,
                        r = this._height > n ? 1 : this._height / n;
                    return Math.min(e, r)
                }, Object.defineProperty(e.prototype, "width", {
                    get: function() {
                        return this._width
                    },
                    set: function(t) {
                        this._width = t, this._refresh()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "height", {
                    get: function() {
                        return this._height
                    },
                    set: function(t) {
                        this._height = t, this._refresh()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "leftWidth", {
                    get: function() {
                        return this._leftWidth
                    },
                    set: function(t) {
                        this._leftWidth = t, this._refresh()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "rightWidth", {
                    get: function() {
                        return this._rightWidth
                    },
                    set: function(t) {
                        this._rightWidth = t, this._refresh()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "topHeight", {
                    get: function() {
                        return this._topHeight
                    },
                    set: function(t) {
                        this._topHeight = t, this._refresh()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "bottomHeight", {
                    get: function() {
                        return this._bottomHeight
                    },
                    set: function(t) {
                        this._bottomHeight = t, this._refresh()
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype._refresh = function() {
                    var t = this.texture,
                        e = this.geometry.buffers[1].data;
                    this._origWidth = t.orig.width, this._origHeight = t.orig.height;
                    var n = 1 / this._origWidth,
                        r = 1 / this._origHeight;
                    e[0] = e[8] = e[16] = e[24] = 0, e[1] = e[3] = e[5] = e[7] = 0, e[6] = e[14] = e[22] = e[30] = 1, e[25] = e[27] = e[29] = e[31] = 1, e[2] = e[10] = e[18] = e[26] = n * this._leftWidth, e[4] = e[12] = e[20] = e[28] = 1 - n * this._rightWidth, e[9] = e[11] = e[13] = e[15] = r * this._topHeight, e[17] = e[19] = e[21] = e[23] = 1 - r * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update()
                }
            }(ul), function(t, e) {
                return (hl = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(t, e) {
                        t.__proto__ = e
                    } || function(t, e) {
                        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
                    })(t, e)
            });
        ! function(t) {
            function e(e, n) {
                void 0 === n && (n = !0);
                var r = t.call(this, e[0] instanceof Un ? e[0] : e[0].texture) || this;
                return r._textures = null, r._durations = null, r._autoUpdate = n, r._isConnectedToTicker = !1, r.animationSpeed = 1, r.loop = !0, r.updateAnchor = !1, r.onComplete = null, r.onFrameChange = null, r.onLoop = null, r._currentTime = 0, r._playing = !1, r._previousFrame = null, r.textures = e, r
            }(function(t, e) {
                function n() {
                    this.constructor = t
                }
                hl(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
            })(e, t), e.prototype.stop = function() {
                this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (tn.shared.remove(this.update, this), this._isConnectedToTicker = !1))
            }, e.prototype.play = function() {
                this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (tn.shared.add(this.update, this, Je.HIGH), this._isConnectedToTicker = !0))
            }, e.prototype.gotoAndStop = function(t) {
                this.stop();
                var e = this.currentFrame;
                this._currentTime = t, e !== this.currentFrame && this.updateTexture()
            }, e.prototype.gotoAndPlay = function(t) {
                var e = this.currentFrame;
                this._currentTime = t, e !== this.currentFrame && this.updateTexture(), this.play()
            }, e.prototype.update = function(t) {
                if (this._playing) {
                    var e = this.animationSpeed * t,
                        n = this.currentFrame;
                    if (null !== this._durations) {
                        var r = this._currentTime % 1 * this._durations[this.currentFrame];
                        for (r += e / 60 * 1e3; r < 0;) this._currentTime--, r += this._durations[this.currentFrame];
                        var i = Math.sign(this.animationSpeed * t);
                        for (this._currentTime = Math.floor(this._currentTime); r >= this._durations[this.currentFrame];) r -= this._durations[this.currentFrame] * i, this._currentTime += i;
                        this._currentTime += r / this._durations[this.currentFrame]
                    } else this._currentTime += e;
                    this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : n !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < n || this.animationSpeed < 0 && this.currentFrame > n) && this.onLoop(), this.updateTexture())
                }
            }, e.prototype.updateTexture = function() {
                var t = this.currentFrame;
                this._previousFrame !== t && (this._previousFrame = t, this._texture = this._textures[t], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame))
            }, e.prototype.destroy = function(e) {
                this.stop(), t.prototype.destroy.call(this, e), this.onComplete = null, this.onFrameChange = null, this.onLoop = null
            }, e.fromFrames = function(t) {
                for (var n = [], r = 0; r < t.length; ++r) n.push(Un.from(t[r]));
                return new e(n)
            }, e.fromImages = function(t) {
                for (var n = [], r = 0; r < t.length; ++r) n.push(Un.from(t[r]));
                return new e(n)
            }, Object.defineProperty(e.prototype, "totalFrames", {
                get: function() {
                    return this._textures.length
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, "textures", {
                get: function() {
                    return this._textures
                },
                set: function(t) {
                    if (t[0] instanceof Un) this._textures = t, this._durations = null;
                    else {
                        this._textures = [], this._durations = [];
                        for (var e = 0; e < t.length; e++) this._textures.push(t[e].texture), this._durations.push(t[e].time)
                    }
                    this._previousFrame = null, this.gotoAndStop(0), this.updateTexture()
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, "currentFrame", {
                get: function() {
                    var t = Math.floor(this._currentTime) % this._textures.length;
                    return t < 0 && (t += this._textures.length), t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, "playing", {
                get: function() {
                    return this._playing
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, "autoUpdate", {
                get: function() {
                    return this._autoUpdate
                },
                set: function(t) {
                    t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (tn.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (tn.shared.add(this.update, this), this._isConnectedToTicker = !0))
                },
                enumerable: !1,
                configurable: !0
            })
        }(os), ci.registerPlugin("accessibility", Qe), ci.registerPlugin("extract", Ii), ci.registerPlugin("interaction", hn), ci.registerPlugin("particle", wo), ci.registerPlugin("prepare", Ps), ci.registerPlugin("batch", bi), ci.registerPlugin("tilingSprite", Fs), ji.registerPlugin(sa), ji.registerPlugin(io), ji.registerPlugin(fo), ji.registerPlugin(yo), ji.registerPlugin(Cs), Ai.registerPlugin(en), Ai.registerPlugin(Zi);
        var cl = function(t) {
                return t = Number(t), (isNaN(t) || void 0 === t) && (t = 0), t
            },
            dl = function(t) {
                return t * Math.PI / 180
            },
            pl = function(t) {
                return 180 * t / Math.PI
            },
            fl = function(t) {
                return Math.round(10 * t) / 10
            };

        function ml(t) {
            return (ml = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function gl(t, e) {
            for (var n = 0; n < e.length; n++) {
                var r = e[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function vl(t, e) {
            return (vl = Object.setPrototypeOf || function(t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function _l(t, e) {
            if (e && ("object" === ml(e) || "function" == typeof e)) return e;
            if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            return yl(t)
        }

        function yl(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }

        function xl(t) {
            return (xl = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            })(t)
        }
        var bl = function(t) {
                var e = Math.abs(t - Math.PI);
                e >= Math.PI && (e -= 2 * Math.PI);
                var n = fl(pl(Math.abs(e)));
                return "".concat(n, "°")
            },
            El = function(e) {
                ! function(t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            writable: !0,
                            configurable: !0
                        }
                    }), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), e && vl(t, e)
                }(a, e);
                var n, r, i, o, s = (i = a, o = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                    } catch (t) {
                        return !1
                    }
                }(), function() {
                    var t, e = xl(i);
                    if (o) {
                        var n = xl(this).constructor;
                        t = Reflect.construct(e, arguments, n)
                    } else t = e.apply(this, arguments);
                    return _l(this, t)
                });

                function a(t) {
                    var e;
                    return function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, a), (e = s.call(this, t)).state = {
                        isHoveringOnEarth: !1,
                        isHoveringOnMoon: !1
                    }, e.resources = {}, e.orbitCenter = new ae(740, 460), e.start = e.start.bind(yl(e)), e.stop = e.stop.bind(yl(e)), e.animate = e.animate.bind(yl(e)), e.onDragStart = e.onDragStart.bind(yl(e)), e.onDragEnd = e.onDragEnd.bind(yl(e)), e.onEarthMove = e.onEarthMove.bind(yl(e)), e.onMoonMove = e.onMoonMove.bind(yl(e)), e
                }
                return n = a, (r = [{
                    key: "render",
                    value: function() {
                        var e = this;
                        return t.createElement("div", {
                            className: "MainView",
                            ref: function(t) {
                                e.el = t
                            }
                        })
                    }
                }, {
                    key: "componentDidMount",
                    value: function() {
                        this.app = new Ai({
                            width: 1200,
                            height: 920,
                            antialias: !0,
                            sharedTicker: !0
                        }), this.el.appendChild(this.app.view), this.drawText(), this.drawArrows(), this.drawOrbit(), this.angle = this.drawAngle(), this.angleText = this.drawAngleText(this.props.moonAngle), this.app.loader.add("moon", "img/moon.svg").add("earth", "img/earth.svg").add("avatar", "img/white-stickfigure.svg").add("highlight", "img/circle-highlight.svg").add("timeCompass", "img/time-compass.svg");
                        var t = this;
                        this.app.loader.load((function(e, n) {
                            t.resources = n, t.moonContainer = t.drawMoon(n.moon, n.highlight), t.moonContainer.on("pointerdown", t.onDragStart).on("touchstart", t.onDragStart).on("pointerup", t.onDragEnd).on("pointerupoutside", t.onDragEnd).on("touchend", t.onDragEnd).on("touchendoutside", t.onDragEnd).on("pointermove", t.onMoonMove).on("touchmove", t.onMoonMove), t.earth = t.drawEarth(n.earth, n.avatar, n.highlight), t.earth.on("pointerdown", t.onDragStart).on("touchstart", t.onDragStart).on("pointerup", t.onDragEnd).on("pointerupoutside", t.onDragEnd).on("touchend", t.onDragEnd).on("touchendoutside", t.onDragEnd).on("pointermove", t.onEarthMove).on("touchmove", t.onEarthMove), t.timeCompass = t.drawTimeCompass(n.timeCompass), t.start()
                        }))
                    }
                }, {
                    key: "componentWillUnmount",
                    value: function() {
                        this.app.stop()
                    }
                }, {
                    key: "componentDidUpdate",
                    value: function(t) {
                        t.showLunarLandmark !== this.props.showLunarLandmark && (this.landmark.visible = this.props.showLunarLandmark), this.props.showAngle && t.moonAngle !== this.props.moonAngle && (this.updateAngle(this.angle, this.props.moonAngle), this.updateAngleText(this.angleText, this.props.moonAngle)), t.showAngle !== this.props.showAngle && (this.props.showAngle && (this.updateAngle(this.angle, this.props.moonAngle), this.updateAngleText(this.angleText, this.props.moonAngle)), this.angle.visible = this.props.showAngle, this.angleText.visible = this.props.showAngle)
                    }
                }, {
                    key: "start",
                    value: function() {
                        this.frameId || (this.frameId = requestAnimationFrame(this.animate))
                    }
                }, {
                    key: "stop",
                    value: function() {
                        cancelAnimationFrame(this.frameId)
                    }
                }, {
                    key: "animate",
                    value: function() {
                        this.moonContainer.position = this.getMoonPos(this.props.moonAngle);
                        var t = this;
                        this.moonContainer.children.filter((function(t) {
                            return "moonObj" === t.name || "landmark" === t.name
                        })).forEach((function(e) {
                            e.rotation = -t.props.moonAngle
                        })), this.state.isHoveringOnMoon || this.draggingMoon ? this.moonHighlight.visible = !0 : this.moonHighlight.visible = !1, this.earth.rotation = -this.props.observerAngle + dl(90), this.state.isHoveringOnEarth || this.draggingEarth ? this.earthHighlight.visible = !0 : this.earthHighlight.visible = !1, this.props.showTimeTickmarks ? this.timeCompass.visible = !0 : this.timeCompass.visible = !1, this.frameId = requestAnimationFrame(this.animate)
                    }
                }, {
                    key: "drawOrbit",
                    value: function() {
                        var t = new es;
                        t.lineStyle(2, 16777215), t.drawCircle(this.orbitCenter.x, this.orbitCenter.y, 400), this.app.stage.addChild(t)
                    }
                }, {
                    key: "drawAngle",
                    value: function() {
                        var t = new es;
                        return t.visible = !1, this.updateAngle(t, this.props.moonAngle), this.app.stage.addChild(t), t
                    }
                }, {
                    key: "drawAngleText",
                    value: function(t) {
                        var e = bl(-t),
                            n = new gs(e, {
                                fontFamily: "Arial",
                                fontSize: 32,
                                fontWeight: "bold",
                                fill: 16769088,
                                align: "center"
                            });
                        return n.visible = !1, n.position.x = this.orbitCenter.x - 360, n.position.y = this.orbitCenter.y - 340, this.updateAngleText(n, this.props.moonAngle), this.app.stage.addChild(n), n
                    }
                }, {
                    key: "updateAngle",
                    value: function(t, e) {
                        t.clear(), t.moveTo(this.orbitCenter.x, this.orbitCenter.y), t.lineStyle(6, 16769088), t.beginFill(16769536, .7), t.arc(this.orbitCenter.x, this.orbitCenter.y, 400, Math.PI, -e, e < 0 && e > -Math.PI), t.lineTo(this.orbitCenter.x, this.orbitCenter.y), t.lineTo(340, 460)
                    }
                }, {
                    key: "updateAngleText",
                    value: function(t, e) {
                        t.text = bl(-e)
                    }
                }, {
                    key: "drawTimeCompass",
                    value: function(t) {
                        var e = new os(t.texture);
                        return e.name = "timeCompass", e.width = 656, e.height = 416, e.position = this.orbitCenter, e.anchor.set(.5), e.visible = !1, this.app.stage.addChild(e), e
                    }
                }, {
                    key: "drawMoon",
                    value: function(t, e) {
                        var n = this.getMoonPos(this.props.moonAngle),
                            r = new Ke;
                        r.name = "moon", r.buttonMode = !0, r.interactive = !0, r.position = n, r.position = this.orbitCenter;
                        var i = new os(e.texture);
                        i.visible = !1, i.width = 60, i.height = 60, i.anchor.set(.5), this.moonHighlight = i, r.addChild(i);
                        var o = new os(t.texture);
                        o.name = "moonObj", o.width = 40, o.height = 40, o.anchor.set(.5), r.addChild(o);
                        var s = new es;
                        s.name = "landmark", s.visible = !1, s.lineStyle(4, 16750079), s.moveTo(-20, 0), s.lineTo(-40, 0), this.landmark = s, r.addChild(this.landmark);
                        var a = new es;
                        return a.beginFill(0), a.alpha = .7, a.arc(0, 0, 20, dl(-90), dl(90)), r.addChild(a), this.app.stage.addChild(r), r
                    }
                }, {
                    key: "drawEarth",
                    value: function(t, e, n) {
                        var r = new Ke;
                        r.pivot = this.orbitCenter, r.name = "earth", r.buttonMode = !0, r.interactive = !0, r.position = this.orbitCenter, r.rotation = -this.props.observerAngle + dl(90);
                        var i = new os(n.texture);
                        i.visible = !1, i.width = 180, i.height = 180, i.position = this.orbitCenter, i.anchor.set(.5), this.earthHighlight = i, r.addChild(i);
                        var o = new os(t.texture);
                        o.width = 140, o.height = 140, o.position = this.orbitCenter, o.anchor.set(.5), o.rotation = -.9, r.addChild(o);
                        var s = new os(e.texture);
                        s.width = 48.6, s.height = 22.95, s.position = this.orbitCenter, s.position.x -= 84, s.anchor.set(.5), r.addChild(s), this.app.stage.addChild(r);
                        var a = new es;
                        return a.beginFill(0), a.alpha = .7, a.arc(this.orbitCenter.x, this.orbitCenter.y, 70, -Math.PI / 2, Math.PI / 2), this.app.stage.addChild(a), r
                    }
                }, {
                    key: "drawText",
                    value: function() {
                        var t = new gs("Sunlight", {
                            fontFamily: "Arial",
                            fontSize: 56,
                            fontWeight: "bold",
                            fill: 16777088,
                            align: "center"
                        });
                        t.rotation = dl(-90), t.position.x = 28, t.position.y = 540, this.app.stage.addChild(t)
                    }
                }, {
                    key: "drawArrows",
                    value: function() {
                        for (var t = 1; t < 8; t++) {
                            var e = new es;
                            e.lineStyle(4, 16777088), e.moveTo(120, 2 * (50 * t + 30)), e.lineTo(240, 2 * (50 * t + 30));
                            var n = (new es).beginFill(16777088).drawPolygon([220, 2 * (50 * t + 26), 220, 2 * (50 * t + 34), 246, 2 * (50 * t + 30)]);
                            this.app.stage.addChild(e), this.app.stage.addChild(n)
                        }
                    }
                }, {
                    key: "onDragStart",
                    value: function(t) {
                        this.props.stopAnimation(), this.data = t.data, this.dragStartPos = this.data.getLocalPosition(this.app.stage), this.dragStartAngle = this.props.observerAngle, "earth" === t.target.name ? this.draggingEarth = !0 : "moon" === t.target.name && (this.draggingMoon = !0)
                    }
                }, {
                    key: "onDragEnd",
                    value: function() {
                        this.draggingEarth = !1, this.draggingMoon = !1, this.data = null
                    }
                }, {
                    key: "onEarthMove",
                    value: function(t) {
                        if (!t.target || "earth" !== t.target.name || this.state.isHoveringOnEarth || this.draggingMoon || this.setState({
                                isHoveringOnEarth: !0
                            }), !t.target && this.state.isHoveringOnEarth && this.setState({
                                isHoveringOnEarth: !1
                            }), this.draggingEarth) {
                            var e = this.data.getLocalPosition(this.app.stage),
                                n = Math.atan2(e.y - this.orbitCenter.y, e.x - this.orbitCenter.x),
                                r = Math.atan2(this.dragStartPos.y - this.orbitCenter.y, this.dragStartPos.x - this.orbitCenter.x) + Math.PI / 2;
                            this.props.onObserverAngleUpdate(-n + r + (this.dragStartAngle - Math.PI / 2))
                        }
                    }
                }, {
                    key: "onMoonMove",
                    value: function(t) {
                        if (!t.target || "moon" !== t.target.name || this.state.isHoveringOnMoon || this.draggingEarth || this.setState({
                                isHoveringOnMoon: !0
                            }), !t.target && this.state.isHoveringOnMoon && this.setState({
                                isHoveringOnMoon: !1
                            }), this.draggingMoon) {
                            var e = this.data.getLocalPosition(this.app.stage),
                                n = Math.atan2(e.y - this.orbitCenter.y, e.x - this.orbitCenter.x);
                            this.props.onMoonAngleUpdate(-n)
                        }
                    }
                }, {
                    key: "getMoonPos",
                    value: function(t) {
                        return new ae(400 * Math.cos(-t) + this.orbitCenter.x, 400 * Math.sin(-t) + this.orbitCenter.y)
                    }
                }]) && gl(n.prototype, r), Object.defineProperty(n, "prototype", {
                    writable: !1
                }), a
            }(t.Component);

        function Tl(t) {
            return (Tl = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function Sl(t, e) {
            for (var n = 0; n < e.length; n++) {
                var r = e[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function wl(t, e) {
            return (wl = Object.setPrototypeOf || function(t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function Ml(t, e) {
            if (e && ("object" === Tl(e) || "function" == typeof e)) return e;
            if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            return function(t) {
                if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t
            }(t)
        }

        function Al(t) {
            return (Al = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            })(t)
        }
        El.propTypes = {
            observerAngle: i().number.isRequired,
            moonAngle: i().number.isRequired,
            onObserverAngleUpdate: i().func.isRequired,
            onMoonAngleUpdate: i().func.isRequired,
            showAngle: i().bool.isRequired,
            showTimeTickmarks: i().bool.isRequired,
            showLunarLandmark: i().bool.isRequired,
            stopAnimation: i().func.isRequired
        };
        var Rl = function(e) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), Object.defineProperty(t, "prototype", {
                    writable: !1
                }), e && wl(t, e)
            }(a, e);
            var n, r, i, o, s = (i = a, o = function() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                } catch (t) {
                    return !1
                }
            }(), function() {
                var t, e = Al(i);
                if (o) {
                    var n = Al(this).constructor;
                    t = Reflect.construct(e, arguments, n)
                } else t = e.apply(this, arguments);
                return Ml(this, t)
            });

            function a(t) {
                var e;
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, a), (e = s.call(this, t)).id = "MoonPhaseView", e.moon = null, e.radius = 100.5, e.center = new ae(114, 107.5), e
            }
            return n = a, (r = [{
                key: "render",
                value: function() {
                    var e, n, r, i, o, s, a, l = this,
                        u = (e = this.props.moonAngle, n = pl(e), Math.abs(n - 180) < 5 || Math.abs(n + 180) < 5 ? 180 : Math.abs(n) < 6 ? 0 : Math.abs(n + 168) < 6 ? -168 : Math.abs(n + 156) < 6 ? -156 : Math.abs(n + 144) < 6 ? -144 : Math.abs(n + 132) < 6 ? -132 : Math.abs(n + 120) < 6 ? -120 : Math.abs(n + 108) < 6 ? -108 : Math.abs(n + 96) < 6 ? -96 : Math.abs(n + 84) < 6 ? -84 : Math.abs(n + 72) < 6 ? -72 : Math.abs(n + 60) < 6 ? -60 : Math.abs(n + 48) < 6 ? -48 : Math.abs(n + 36) < 6 ? -36 : Math.abs(n + 24) < 6 ? -24 : Math.abs(n + 12) < 6 ? -12 : Math.abs(n - 168) < 6 ? 168 : Math.abs(n - 156) < 6 ? 156 : Math.abs(n - 144) < 6 ? 144 : Math.abs(n - 132) < 6 ? 132 : Math.abs(n - 120) < 6 ? 120 : Math.abs(n - 108) < 6 ? 108 : Math.abs(n - 96) < 6 ? 96 : Math.abs(n - 84) < 6 ? 84 : Math.abs(n - 72) < 6 ? 72 : Math.abs(n - 60) < 6 ? 60 : Math.abs(n - 48) < 6 ? 48 : Math.abs(n - 36) < 6 ? 36 : Math.abs(n - 24) < 6 ? 24 : Math.abs(n - 12) < 6 ? 12 : null),
                        h = Math.round(function(t) {
                            return (t + Math.PI) / (2 * Math.PI / 708.734136)
                        }(this.props.moonAngle));
                    return t.createElement("div", null, t.createElement("div", {
                        style: {
                            visibility: this.props.isHidden ? "hidden" : "visible"
                        }
                    }, t.createElement("select", {
                        className: "form-control form-control-sm",
                        onChange: this.onMoonAngleUpdate.bind(this),
                        value: u
                    }, 
                    t.createElement("option", {value: 180}, "Amavasya"),   
                    t.createElement("option", {value: -168}, "Prathama"),
                    t.createElement("option", {value: -156}, "Dvitiya"),
                    t.createElement("option", {value: -144}, "Tritiya"), 
                    t.createElement("option", {value: -132}, "chaturthi"),
                    t.createElement("option", {value: -120}, "Panchami"),
                    t.createElement("option", {value: -108}, "Shashti"),
                    t.createElement("option", {value: -96}, "saptami"),
                    t.createElement("option", {value: -84}, "Ashtami"),
                    t.createElement("option", {value: -72}, "Navami"),
                    t.createElement("option", {value: -60}, "Dashami"),
                    t.createElement("option", {value: -48}, "Ekadashi"),
                    t.createElement("option", {value: -36}, "Dwadashi"),
                    t.createElement("option", {value: -24}, "Trayodashi"),
                    t.createElement("option", {value: -12}, "Chaturdashi"),
                    t.createElement("option", {value: 0}, "Poornami"), 
                    
                    t.createElement("option", {value: 168}, "Krishna-Prathama"),
                    t.createElement("option", {value: 156}, "Krishna-Dvitiya"),
                    t.createElement("option", {value: 144}, "Krishna-Tritiya"), 
                    t.createElement("option", {value: 132}, "Krishna-chaturthi"),
                    t.createElement("option", {value: 120}, "Krishna-Panchami"),
                    t.createElement("option", {value: 108}, "Krishna-Shashti"),
                    t.createElement("option", {value: 96}, "Krishna-saptami"),
                    t.createElement("option", {value: 84}, "Krishna-Ashtami"),
                    t.createElement("option", {value: 72}, "Krishna-Navami"),
                    t.createElement("option", {value: 60}, "Krishna-Dashami"),
                    t.createElement("option", {value: 48}, "Krishna-Ekadashi"),
                    t.createElement("option", {value: 36}, "Krishna-Dwadashi"),
                    t.createElement("option", {value: 24}, "Krishna-Trayodashi"),
                    t.createElement("option", {value: 12}, "Krishna-Chaturdashi")),

                    
                    t.createElement("div", {
                        className: "mt-1",
                        ref: function(t) {
                            l.el = t
                        }
                    }), t.createElement("div", {
                        className: "text-center"
                    }, fl(function(t) {return (1 - Math.cos(t)) / 2 * 100} (this.props.moonAngle - Math.PI))  ,  "% illuminated"), t.createElement("div", {
                        className: "text-center"
                    }, "Time since new moon:"), t.createElement("div", {
                        className: "text-center"
                    }, (r = h, s = 1 === (i = Math.floor(r / 24)) ? "" : "s", a = 1 == (o = r % 24) ? "" : "s", i ? "".concat(i, " day").concat(s, ", ").concat(o, " hour").concat(a) : "".concat(o, " hour").concat(a)))), t.createElement("div", {
                        className: "text-right"
                    }, t.createElement("button", {
                        type: "button",
                        onClick: this.props.onHideShowToggle,
                        className: "btn btn-primary btn-sm"
                    }, this.props.isHidden ? "Show" : "Hide")))
                }
            }, {
                key: "componentDidMount",
                value: function() {
                    var t = this;
                    this.app = new Ai({
                        width: 2 * this.center.x,
                        height: 2 * this.center.y
                    }), this.el.appendChild(this.app.view), this.app.loader.add("moon", "img/moon.png"), this.app.loader.load((function(e, n) {
                        t.moon = n.moon, t.draw()
                    }))
                }
            }, {
                key: "componentDidUpdate",
                value: function(t) {
                    t.moonAngle !== this.props.moonAngle && this.drawPhase(this.leftShade, this.rightShade, this.convertPhase(this.props.moonAngle)), t.showLunarLandmark !== this.props.showLunarLandmark && (this.lunarLandmark.visible = this.props.showLunarLandmark)
                }
            }, {
                key: "draw",
                value: function() {
                    this.drawMoon(this.app), this.drawShades(this.app), this.drawPhase(this.leftShade, this.rightShade, this.convertPhase(this.props.moonAngle)), this.drawLunarLandmark(this.app)
                }
            }, {
                key: "drawMoon",
                value: function(t) {
                    var e = new os(this.moon.texture);
                    t.stage.addChild(e)
                }
            }, {
                key: "drawShades",
                value: function(t) {
                    this.leftShade = new es, this.leftShade.pivot = this.center, this.rightShade = new es, this.rightShade.pivot = this.center, this.leftShade.beginFill(0, .7), this.leftShade.arc(2 * this.center.x, 2 * this.center.y, this.radius, Math.PI / 2, -Math.PI / 2), this.leftShade.endFill(), t.stage.addChild(this.leftShade), this.rightShade.beginFill(0, .7), this.rightShade.arc(2 * this.center.x, 2 * this.center.y, this.radius, -Math.PI / 2, Math.PI / 2), this.rightShade.endFill(), t.stage.addChild(this.rightShade);
                    var e = new os(this.moon.texture);
                    e.visible = !1, t.stage.addChild(e), this.hiddenMoon = e
                }
            }, {
                key: "drawPhase",
                value: function(t, e, n) {
                    if (n <= .5) {
                        var r = 1 - 4 * n;
                        t.scale.x = 1, t.position.x = 0, e.scale.x = r, e.position.x = this.center.x - r * this.center.x, n > .25 ? (this.hiddenMoon.mask = this.rightShade, this.hiddenMoon.visible = !0) : (this.hiddenMoon.mask = null, this.hiddenMoon.visible = !1)
                    } else {
                        var i = 4 * -n + 3;
                        e.scale.x = 1, e.position.x = 0, n < .75 ? (this.hiddenMoon.mask = this.leftShade, this.hiddenMoon.visible = !0, t.scale.x = -i, t.position.x = this.center.x - -i * this.center.x) : (this.hiddenMoon.mask = null, this.hiddenMoon.visible = !1, t.scale.x = -i, t.position.x = this.center.x - -i * this.center.x, e.scale.x = 1, e.position.x = 0)
                    }
                }
            }, {
                key: "convertPhase",
                value: function(t) {
                    var e = (t - Math.PI) / (2 * Math.PI);
                    return e > 1 ? 0 : e < 0 ? e + 1 : e
                }
            }, {
                key: "drawLunarLandmark",
                value: function(t) {
                    var e = new es;
                    e.lineStyle(1, 0), e.beginFill(16750079), e.drawCircle(this.center.x, this.center.y, 8), e.visible = this.props.showLunarLandmark, t.stage.addChild(e), this.lunarLandmark = e
                }
            }, {
                key: "onMoonAngleUpdate",
                value: function(t) {
                    this.props.onMoonAngleUpdate(dl(cl(t.target.value)))
                }
            }]) && Sl(n.prototype, r), Object.defineProperty(n, "prototype", {
                writable: !1
            }), a
        }(t.Component);
        Rl.propTypes = {
            moonAngle: i().number.isRequired,
            onMoonAngleUpdate: i().func.isRequired,
            showLunarLandmark: i().bool.isRequired,
            isHidden: i().bool.isRequired,
            onHideShowToggle: i().func.isRequired
        };
        const Pl = 100,
            Il = 301,
            Cl = 302,
            Ol = 306,
            Ll = 1e3,
            Nl = 1001,
            Dl = 1002,
            Ul = 1003,
            Fl = 1006,
            Bl = 1008,
            kl = 1009,
            Gl = 1012,
            Hl = 1014,
            zl = 1015,
            Vl = 1016,
            Wl = 1020,
            Xl = 1023,
            jl = 1026,
            Yl = 1027,
            ql = 33776,
            Zl = 33777,
            Kl = 33778,
            Jl = 33779,
            Ql = 2300,
            $l = 2301,
            tu = 2302,
            eu = 2400,
            nu = 2401,
            ru = 2402,
            iu = 3e3,
            ou = 3001,
            su = "srgb",
            au = "srgb-linear",
            lu = 7680,
            uu = 35044,
            hu = 35048,
            cu = "300 es",
            du = 1035;
        class pu {
            addEventListener(t, e) {
                void 0 === this._listeners && (this._listeners = {});
                const n = this._listeners;
                void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
            }
            hasEventListener(t, e) {
                if (void 0 === this._listeners) return !1;
                const n = this._listeners;
                return void 0 !== n[t] && -1 !== n[t].indexOf(e)
            }
            removeEventListener(t, e) {
                if (void 0 === this._listeners) return;
                const n = this._listeners[t];
                if (void 0 !== n) {
                    const t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
                }
            }
            dispatchEvent(t) {
                if (void 0 === this._listeners) return;
                const e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this;
                    const n = e.slice(0);
                    for (let e = 0, r = n.length; e < r; e++) n[e].call(this, t);
                    t.target = null
                }
            }
        }
        const fu = [];
        for (let t = 0; t < 256; t++) fu[t] = (t < 16 ? "0" : "") + t.toString(16);
        let mu = 1234567;
        const gu = Math.PI / 180,
            vu = 180 / Math.PI;

        function _u() {
            const t = 4294967295 * Math.random() | 0,
                e = 4294967295 * Math.random() | 0,
                n = 4294967295 * Math.random() | 0,
                r = 4294967295 * Math.random() | 0;
            return (fu[255 & t] + fu[t >> 8 & 255] + fu[t >> 16 & 255] + fu[t >> 24 & 255] + "-" + fu[255 & e] + fu[e >> 8 & 255] + "-" + fu[e >> 16 & 15 | 64] + fu[e >> 24 & 255] + "-" + fu[63 & n | 128] + fu[n >> 8 & 255] + "-" + fu[n >> 16 & 255] + fu[n >> 24 & 255] + fu[255 & r] + fu[r >> 8 & 255] + fu[r >> 16 & 255] + fu[r >> 24 & 255]).toLowerCase()
        }

        function yu(t, e, n) {
            return Math.max(e, Math.min(n, t))
        }

        function xu(t, e) {
            return (t % e + e) % e
        }

        function bu(t, e, n) {
            return (1 - n) * t + n * e
        }

        function Eu(t) {
            return 0 == (t & t - 1) && 0 !== t
        }

        function Tu(t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        }
        var Su = Object.freeze({
            __proto__: null,
            DEG2RAD: gu,
            RAD2DEG: vu,
            generateUUID: _u,
            clamp: yu,
            euclideanModulo: xu,
            mapLinear: function(t, e, n, r, i) {
                return r + (t - e) * (i - r) / (n - e)
            },
            inverseLerp: function(t, e, n) {
                return t !== e ? (n - t) / (e - t) : 0
            },
            lerp: bu,
            damp: function(t, e, n, r) {
                return bu(t, e, 1 - Math.exp(-n * r))
            },
            pingpong: function(t, e = 1) {
                return e - Math.abs(xu(t, 2 * e) - e)
            },
            smoothstep: function(t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
            },
            smootherstep: function(t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
            },
            randInt: function(t, e) {
                return t + Math.floor(Math.random() * (e - t + 1))
            },
            randFloat: function(t, e) {
                return t + Math.random() * (e - t)
            },
            randFloatSpread: function(t) {
                return t * (.5 - Math.random())
            },
            seededRandom: function(t) {
                void 0 !== t && (mu = t);
                let e = mu += 1831565813;
                return e = Math.imul(e ^ e >>> 15, 1 | e), e ^= e + Math.imul(e ^ e >>> 7, 61 | e), ((e ^ e >>> 14) >>> 0) / 4294967296
            },
            degToRad: function(t) {
                return t * gu
            },
            radToDeg: function(t) {
                return t * vu
            },
            isPowerOfTwo: Eu,
            ceilPowerOfTwo: function(t) {
                return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
            },
            floorPowerOfTwo: Tu,
            setQuaternionFromProperEuler: function(t, e, n, r, i) {
                const o = Math.cos,
                    s = Math.sin,
                    a = o(n / 2),
                    l = s(n / 2),
                    u = o((e + r) / 2),
                    h = s((e + r) / 2),
                    c = o((e - r) / 2),
                    d = s((e - r) / 2),
                    p = o((r - e) / 2),
                    f = s((r - e) / 2);
                switch (i) {
                    case "XYX":
                        t.set(a * h, l * c, l * d, a * u);
                        break;
                    case "YZY":
                        t.set(l * d, a * h, l * c, a * u);
                        break;
                    case "ZXZ":
                        t.set(l * c, l * d, a * h, a * u);
                        break;
                    case "XZX":
                        t.set(a * h, l * f, l * p, a * u);
                        break;
                    case "YXY":
                        t.set(l * p, a * h, l * f, a * u);
                        break;
                    case "ZYZ":
                        t.set(l * f, l * p, a * h, a * u);
                        break;
                    default:
                        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
                }
            },
            normalize: function(t, e) {
                switch (e.constructor) {
                    case Float32Array:
                        return t;
                    case Uint16Array:
                        return Math.round(65535 * t);
                    case Uint8Array:
                        return Math.round(255 * t);
                    case Int16Array:
                        return Math.round(32767 * t);
                    case Int8Array:
                        return Math.round(127 * t);
                    default:
                        throw new Error("Invalid component type.")
                }
            },
            denormalize: function(t, e) {
                switch (e.constructor) {
                    case Float32Array:
                        return t;
                    case Uint16Array:
                        return t / 65535;
                    case Uint8Array:
                        return t / 255;
                    case Int16Array:
                        return Math.max(t / 32767, -1);
                    case Int8Array:
                        return Math.max(t / 127, -1);
                    default:
                        throw new Error("Invalid component type.")
                }
            }
        });
        class wu {
            constructor(t = 0, e = 0) {
                this.x = t, this.y = e
            }
            get width() {
                return this.x
            }
            set width(t) {
                this.x = t
            }
            get height() {
                return this.y
            }
            set height(t) {
                this.y = t
            }
            set(t, e) {
                return this.x = t, this.y = e, this
            }
            setScalar(t) {
                return this.x = t, this.y = t, this
            }
            setX(t) {
                return this.x = t, this
            }
            setY(t) {
                return this.y = t, this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y)
            }
            copy(t) {
                return this.x = t.x, this.y = t.y, this
            }
            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
            }
            addScalar(t) {
                return this.x += t, this.y += t, this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this
            }
            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
            }
            subScalar(t) {
                return this.x -= t, this.y -= t, this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this
            }
            multiply(t) {
                return this.x *= t.x, this.y *= t.y, this
            }
            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this
            }
            divide(t) {
                return this.x /= t.x, this.y /= t.y, this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            applyMatrix3(t) {
                const e = this.x,
                    n = this.y,
                    r = t.elements;
                return this.x = r[0] * e + r[3] * n + r[6], this.y = r[1] * e + r[4] * n + r[7], this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y
            }
            cross(t) {
                return this.x * t.y - this.y * t.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x,
                    n = this.y - t.y;
                return e * e + n * n
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y
            }
            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t
            }
            fromBufferAttribute(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
            }
            rotateAround(t, e) {
                const n = Math.cos(e),
                    r = Math.sin(e),
                    i = this.x - t.x,
                    o = this.y - t.y;
                return this.x = i * n - o * r + t.x, this.y = i * r + o * n + t.y, this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this
            }*[Symbol.iterator]() {
                yield this.x, yield this.y
            }
        }
        wu.prototype.isVector2 = !0;
        class Mu {
            constructor() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }
            set(t, e, n, r, i, o, s, a, l) {
                const u = this.elements;
                return u[0] = t, u[1] = r, u[2] = s, u[3] = e, u[4] = i, u[5] = a, u[6] = n, u[7] = o, u[8] = l, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            }
            copy(t) {
                const e = this.elements,
                    n = t.elements;
                return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
            }
            setFromMatrix4(t) {
                const e = t.elements;
                return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
            }
            multiply(t) {
                return this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements,
                    r = e.elements,
                    i = this.elements,
                    o = n[0],
                    s = n[3],
                    a = n[6],
                    l = n[1],
                    u = n[4],
                    h = n[7],
                    c = n[2],
                    d = n[5],
                    p = n[8],
                    f = r[0],
                    m = r[3],
                    g = r[6],
                    v = r[1],
                    _ = r[4],
                    y = r[7],
                    x = r[2],
                    b = r[5],
                    E = r[8];
                return i[0] = o * f + s * v + a * x, i[3] = o * m + s * _ + a * b, i[6] = o * g + s * y + a * E, i[1] = l * f + u * v + h * x, i[4] = l * m + u * _ + h * b, i[7] = l * g + u * y + h * E, i[2] = c * f + d * v + p * x, i[5] = c * m + d * _ + p * b, i[8] = c * g + d * y + p * E, this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
            }
            determinant() {
                const t = this.elements,
                    e = t[0],
                    n = t[1],
                    r = t[2],
                    i = t[3],
                    o = t[4],
                    s = t[5],
                    a = t[6],
                    l = t[7],
                    u = t[8];
                return e * o * u - e * s * l - n * i * u + n * s * a + r * i * l - r * o * a
            }
            invert() {
                const t = this.elements,
                    e = t[0],
                    n = t[1],
                    r = t[2],
                    i = t[3],
                    o = t[4],
                    s = t[5],
                    a = t[6],
                    l = t[7],
                    u = t[8],
                    h = u * o - s * l,
                    c = s * a - u * i,
                    d = l * i - o * a,
                    p = e * h + n * c + r * d;
                if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const f = 1 / p;
                return t[0] = h * f, t[1] = (r * l - u * n) * f, t[2] = (s * n - r * o) * f, t[3] = c * f, t[4] = (u * e - r * a) * f, t[5] = (r * i - s * e) * f, t[6] = d * f, t[7] = (n * a - l * e) * f, t[8] = (o * e - n * i) * f, this
            }
            transpose() {
                let t;
                const e = this.elements;
                return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
            }
            getNormalMatrix(t) {
                return this.setFromMatrix4(t).invert().transpose()
            }
            transposeIntoArray(t) {
                const e = this.elements;
                return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
            }
            setUvTransform(t, e, n, r, i, o, s) {
                const a = Math.cos(i),
                    l = Math.sin(i);
                return this.set(n * a, n * l, -n * (a * o + l * s) + o + t, -r * l, r * a, -r * (-l * o + a * s) + s + e, 0, 0, 1), this
            }
            scale(t, e) {
                const n = this.elements;
                return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
            }
            rotate(t) {
                const e = Math.cos(t),
                    n = Math.sin(t),
                    r = this.elements,
                    i = r[0],
                    o = r[3],
                    s = r[6],
                    a = r[1],
                    l = r[4],
                    u = r[7];
                return r[0] = e * i + n * a, r[3] = e * o + n * l, r[6] = e * s + n * u, r[1] = -n * i + e * a, r[4] = -n * o + e * l, r[7] = -n * s + e * u, this
            }
            translate(t, e) {
                const n = this.elements;
                return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
            }
            equals(t) {
                const e = this.elements,
                    n = t.elements;
                for (let t = 0; t < 9; t++)
                    if (e[t] !== n[t]) return !1;
                return !0
            }
            fromArray(t, e = 0) {
                for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
                return this
            }
            toArray(t = [], e = 0) {
                const n = this.elements;
                return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
            }
            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
        }

        function Au(t) {
            for (let e = t.length - 1; e >= 0; --e)
                if (t[e] > 65535) return !0;
            return !1
        }

        function Ru(t) {
            return document.createElementNS("http://www.w3.org/1999/xhtml", t)
        }

        function Pu(t) {
            return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
        }

        function Iu(t) {
            return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
        }
        Mu.prototype.isMatrix3 = !0, Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
        const Cu = {
                [su]: {
                    [au]: Pu
                },
                [au]: {
                    [su]: Iu
                }
            },
            Ou = {
                legacyMode: !0,
                get workingColorSpace() {
                    return au
                },
                set workingColorSpace(t) {
                    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
                },
                convert: function(t, e, n) {
                    if (this.legacyMode || e === n || !e || !n) return t;
                    if (Cu[e] && void 0 !== Cu[e][n]) {
                        const r = Cu[e][n];
                        return t.r = r(t.r), t.g = r(t.g), t.b = r(t.b), t
                    }
                    throw new Error("Unsupported color space conversion.")
                },
                fromWorkingColorSpace: function(t, e) {
                    return this.convert(t, this.workingColorSpace, e)
                },
                toWorkingColorSpace: function(t, e) {
                    return this.convert(t, e, this.workingColorSpace)
                }
            },
            Lu = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            },
            Nu = {
                r: 0,
                g: 0,
                b: 0
            },
            Du = {
                h: 0,
                s: 0,
                l: 0
            },
            Uu = {
                h: 0,
                s: 0,
                l: 0
            };

        function Fu(t, e, n) {
            return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
        }

        function Bu(t, e) {
            return e.r = t.r, e.g = t.g, e.b = t.b, e
        }
        class ku {
            constructor(t, e, n) {
                return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
            }
            set(t) {
                return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
            }
            setScalar(t) {
                return this.r = t, this.g = t, this.b = t, this
            }
            setHex(t, e = "srgb") {
                return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, Ou.toWorkingColorSpace(this, e), this
            }
            setRGB(t, e, n, r = "srgb-linear") {
                return this.r = t, this.g = e, this.b = n, Ou.toWorkingColorSpace(this, r), this
            }
            setHSL(t, e, n, r = "srgb-linear") {
                if (t = xu(t, 1), e = yu(e, 0, 1), n = yu(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
                else {
                    const r = n <= .5 ? n * (1 + e) : n + e - n * e,
                        i = 2 * n - r;
                    this.r = Fu(i, r, t + 1 / 3), this.g = Fu(i, r, t), this.b = Fu(i, r, t - 1 / 3)
                }
                return Ou.toWorkingColorSpace(this, r), this
            }
            setStyle(t, e = "srgb") {
                function n(e) {
                    void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                }
                let r;
                if (r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
                    let t;
                    const i = r[1],
                        o = r[2];
                    switch (i) {
                        case "rgb":
                        case "rgba":
                            if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, Ou.toWorkingColorSpace(this, e), n(t[4]), this;
                            if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, Ou.toWorkingColorSpace(this, e), n(t[4]), this;
                            break;
                        case "hsl":
                        case "hsla":
                            if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) {
                                const r = parseFloat(t[1]) / 360,
                                    i = parseInt(t[2], 10) / 100,
                                    o = parseInt(t[3], 10) / 100;
                                return n(t[4]), this.setHSL(r, i, o, e)
                            }
                    }
                } else if (r = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                    const t = r[1],
                        n = t.length;
                    if (3 === n) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, Ou.toWorkingColorSpace(this, e), this;
                    if (6 === n) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, Ou.toWorkingColorSpace(this, e), this
                }
                return t && t.length > 0 ? this.setColorName(t, e) : this
            }
            setColorName(t, e = "srgb") {
                const n = Lu[t.toLowerCase()];
                return void 0 !== n ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t), this
            }
            clone() {
                return new this.constructor(this.r, this.g, this.b)
            }
            copy(t) {
                return this.r = t.r, this.g = t.g, this.b = t.b, this
            }
            copySRGBToLinear(t) {
                return this.r = Pu(t.r), this.g = Pu(t.g), this.b = Pu(t.b), this
            }
            copyLinearToSRGB(t) {
                return this.r = Iu(t.r), this.g = Iu(t.g), this.b = Iu(t.b), this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this), this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this), this
            }
            getHex(t = "srgb") {
                return Ou.fromWorkingColorSpace(Bu(this, Nu), t), yu(255 * Nu.r, 0, 255) << 16 ^ yu(255 * Nu.g, 0, 255) << 8 ^ yu(255 * Nu.b, 0, 255) << 0
            }
            getHexString(t = "srgb") {
                return ("000000" + this.getHex(t).toString(16)).slice(-6)
            }
            getHSL(t, e = "srgb-linear") {
                Ou.fromWorkingColorSpace(Bu(this, Nu), e);
                const n = Nu.r,
                    r = Nu.g,
                    i = Nu.b,
                    o = Math.max(n, r, i),
                    s = Math.min(n, r, i);
                let a, l;
                const u = (s + o) / 2;
                if (s === o) a = 0, l = 0;
                else {
                    const t = o - s;
                    switch (l = u <= .5 ? t / (o + s) : t / (2 - o - s), o) {
                        case n:
                            a = (r - i) / t + (r < i ? 6 : 0);
                            break;
                        case r:
                            a = (i - n) / t + 2;
                            break;
                        case i:
                            a = (n - r) / t + 4
                    }
                    a /= 6
                }
                return t.h = a, t.s = l, t.l = u, t
            }
            getRGB(t, e = "srgb-linear") {
                return Ou.fromWorkingColorSpace(Bu(this, Nu), e), t.r = Nu.r, t.g = Nu.g, t.b = Nu.b, t
            }
            getStyle(t = "srgb") {
                return Ou.fromWorkingColorSpace(Bu(this, Nu), t), t !== su ? `color(${t} ${Nu.r} ${Nu.g} ${Nu.b})` : `rgb(${255*Nu.r|0},${255*Nu.g|0},${255*Nu.b|0})`
            }
            offsetHSL(t, e, n) {
                return this.getHSL(Du), Du.h += t, Du.s += e, Du.l += n, this.setHSL(Du.h, Du.s, Du.l), this
            }
            add(t) {
                return this.r += t.r, this.g += t.g, this.b += t.b, this
            }
            addColors(t, e) {
                return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
            }
            addScalar(t) {
                return this.r += t, this.g += t, this.b += t, this
            }
            sub(t) {
                return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
            }
            multiply(t) {
                return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
            }
            multiplyScalar(t) {
                return this.r *= t, this.g *= t, this.b *= t, this
            }
            lerp(t, e) {
                return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
            }
            lerpColors(t, e, n) {
                return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
            }
            lerpHSL(t, e) {
                this.getHSL(Du), t.getHSL(Uu);
                const n = bu(Du.h, Uu.h, e),
                    r = bu(Du.s, Uu.s, e),
                    i = bu(Du.l, Uu.l, e);
                return this.setHSL(n, r, i), this
            }
            equals(t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            }
            fromArray(t, e = 0) {
                return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
            }
            fromBufferAttribute(t, e) {
                return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
            }
            toJSON() {
                return this.getHex()
            }
        }
        let Gu;
        ku.NAMES = Lu, ku.prototype.isColor = !0, ku.prototype.r = 1, ku.prototype.g = 1, ku.prototype.b = 1;
        class Hu {
            static getDataURL(t) {
                if (/^data:/i.test(t.src)) return t.src;
                if ("undefined" == typeof HTMLCanvasElement) return t.src;
                let e;
                if (t instanceof HTMLCanvasElement) e = t;
                else {
                    void 0 === Gu && (Gu = Ru("canvas")), Gu.width = t.width, Gu.height = t.height;
                    const n = Gu.getContext("2d");
                    t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = Gu
                }
                return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
            }
            static sRGBToLinear(t) {
                if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                    const e = Ru("canvas");
                    e.width = t.width, e.height = t.height;
                    const n = e.getContext("2d");
                    n.drawImage(t, 0, 0, t.width, t.height);
                    const r = n.getImageData(0, 0, t.width, t.height),
                        i = r.data;
                    for (let t = 0; t < i.length; t++) i[t] = 255 * Pu(i[t] / 255);
                    return n.putImageData(r, 0, 0), e
                }
                if (t.data) {
                    const e = t.data.slice(0);
                    for (let t = 0; t < e.length; t++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * Pu(e[t] / 255)) : e[t] = Pu(e[t]);
                    return {
                        data: e,
                        width: t.width,
                        height: t.height
                    }
                }
                return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t
            }
        }
        class zu {
            constructor(t = null) {
                this.uuid = _u(), this.data = t, this.version = 0
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
                const n = {
                        uuid: this.uuid,
                        url: ""
                    },
                    r = this.data;
                if (null !== r) {
                    let t;
                    if (Array.isArray(r)) {
                        t = [];
                        for (let e = 0, n = r.length; e < n; e++) r[e].isDataTexture ? t.push(Vu(r[e].image)) : t.push(Vu(r[e]))
                    } else t = Vu(r);
                    n.url = t
                }
                return e || (t.images[this.uuid] = n), n
            }
        }

        function Vu(t) {
            return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? Hu.getDataURL(t) : t.data ? {
                data: Array.prototype.slice.call(t.data),
                width: t.width,
                height: t.height,
                type: t.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
        }
        zu.prototype.isSource = !0;
        let Wu = 0;
        class Xu extends pu {
            constructor(t = Xu.DEFAULT_IMAGE, e = Xu.DEFAULT_MAPPING, n = 1001, r = 1001, i = 1006, o = 1008, s = 1023, a = 1009, l = 1, u = 3e3) {
                super(), Object.defineProperty(this, "id", {
                    value: Wu++
                }), this.uuid = _u(), this.name = "", this.source = new zu(t), this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = r, this.magFilter = i, this.minFilter = o, this.anisotropy = l, this.format = s, this.internalFormat = null, this.type = a, this.offset = new wu(0, 0), this.repeat = new wu(1, 1), this.center = new wu(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Mu, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = u, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
            }
            get image() {
                return this.source.data
            }
            set image(t) {
                this.source.data = t
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                const n = {
                    metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    image: this.source.toJSON(t).uuid,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                return "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(t) {
                if (300 !== this.mapping) return t;
                if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                    case Ll:
                        t.x = t.x - Math.floor(t.x);
                        break;
                    case Nl:
                        t.x = t.x < 0 ? 0 : 1;
                        break;
                    case Dl:
                        1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                }
                if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                    case Ll:
                        t.y = t.y - Math.floor(t.y);
                        break;
                    case Nl:
                        t.y = t.y < 0 ? 0 : 1;
                        break;
                    case Dl:
                        1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                }
                return this.flipY && (t.y = 1 - t.y), t
            }
            set needsUpdate(t) {
                !0 === t && (this.version++, this.source.needsUpdate = !0)
            }
        }
        Xu.DEFAULT_IMAGE = null, Xu.DEFAULT_MAPPING = 300, Xu.prototype.isTexture = !0;
        class ju {
            constructor(t = 0, e = 0, n = 0, r = 1) {
                this.x = t, this.y = e, this.z = n, this.w = r
            }
            get width() {
                return this.z
            }
            set width(t) {
                this.z = t
            }
            get height() {
                return this.w
            }
            set height(t) {
                this.w = t
            }
            set(t, e, n, r) {
                return this.x = t, this.y = e, this.z = n, this.w = r, this
            }
            setScalar(t) {
                return this.x = t, this.y = t, this.z = t, this.w = t, this
            }
            setX(t) {
                return this.x = t, this
            }
            setY(t) {
                return this.y = t, this
            }
            setZ(t) {
                return this.z = t, this
            }
            setW(t) {
                return this.w = t, this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    case 3:
                        this.w = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z, this.w)
            }
            copy(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
            }
            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
            }
            addScalar(t) {
                return this.x += t, this.y += t, this.z += t, this.w += t, this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
            }
            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
            }
            subScalar(t) {
                return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
            }
            multiply(t) {
                return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
            }
            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
            }
            applyMatrix4(t) {
                const e = this.x,
                    n = this.y,
                    r = this.z,
                    i = this.w,
                    o = t.elements;
                return this.x = o[0] * e + o[4] * n + o[8] * r + o[12] * i, this.y = o[1] * e + o[5] * n + o[9] * r + o[13] * i, this.z = o[2] * e + o[6] * n + o[10] * r + o[14] * i, this.w = o[3] * e + o[7] * n + o[11] * r + o[15] * i, this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            setAxisAngleFromQuaternion(t) {
                this.w = 2 * Math.acos(t.w);
                const e = Math.sqrt(1 - t.w * t.w);
                return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
            }
            setAxisAngleFromRotationMatrix(t) {
                let e, n, r, i;
                const o = .01,
                    s = .1,
                    a = t.elements,
                    l = a[0],
                    u = a[4],
                    h = a[8],
                    c = a[1],
                    d = a[5],
                    p = a[9],
                    f = a[2],
                    m = a[6],
                    g = a[10];
                if (Math.abs(u - c) < o && Math.abs(h - f) < o && Math.abs(p - m) < o) {
                    if (Math.abs(u + c) < s && Math.abs(h + f) < s && Math.abs(p + m) < s && Math.abs(l + d + g - 3) < s) return this.set(1, 0, 0, 0), this;
                    e = Math.PI;
                    const t = (l + 1) / 2,
                        a = (d + 1) / 2,
                        v = (g + 1) / 2,
                        _ = (u + c) / 4,
                        y = (h + f) / 4,
                        x = (p + m) / 4;
                    return t > a && t > v ? t < o ? (n = 0, r = .707106781, i = .707106781) : (n = Math.sqrt(t), r = _ / n, i = y / n) : a > v ? a < o ? (n = .707106781, r = 0, i = .707106781) : (r = Math.sqrt(a), n = _ / r, i = x / r) : v < o ? (n = .707106781, r = .707106781, i = 0) : (i = Math.sqrt(v), n = y / i, r = x / i), this.set(n, r, i, e), this
                }
                let v = Math.sqrt((m - p) * (m - p) + (h - f) * (h - f) + (c - u) * (c - u));
                return Math.abs(v) < .001 && (v = 1), this.x = (m - p) / v, this.y = (h - f) / v, this.z = (c - u) / v, this.w = Math.acos((l + d + g - 1) / 2), this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            }
            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
            }
            fromBufferAttribute(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
            }*[Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z, yield this.w
            }
        }
        ju.prototype.isVector4 = !0;
        class Yu extends pu {
            constructor(t, e, n = {}) {
                super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new ju(0, 0, t, e), this.scissorTest = !1, this.viewport = new ju(0, 0, t, e);
                const r = {
                    width: t,
                    height: e,
                    depth: 1
                };
                this.texture = new Xu(r, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : Fl, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null, this.samples = void 0 !== n.samples ? n.samples : 0
            }
            setSize(t, e, n = 1) {
                this.width === t && this.height === e && this.depth === n || (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.isRenderTargetTexture = !0, this.texture.image = Object.assign({}, t.texture.image), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        Yu.prototype.isWebGLRenderTarget = !0;
        class qu extends Xu {
            constructor(t = null, e = 1, n = 1, r = 1) {
                super(null), this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: r
                }, this.magFilter = Ul, this.minFilter = Ul, this.wrapR = Nl, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }
        qu.prototype.isDataArrayTexture = !0, class extends Yu {
            constructor(t, e, n) {
                super(t, e), this.depth = n, this.texture = new qu(null, t, e, n), this.texture.isRenderTargetTexture = !0
            }
        }.prototype.isWebGLArrayRenderTarget = !0;
        class Zu extends Xu {
            constructor(t = null, e = 1, n = 1, r = 1) {
                super(null), this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: r
                }, this.magFilter = Ul, this.minFilter = Ul, this.wrapR = Nl, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }
        Zu.prototype.isData3DTexture = !0, class extends Yu {
            constructor(t, e, n) {
                super(t, e), this.depth = n, this.texture = new Zu(null, t, e, n), this.texture.isRenderTargetTexture = !0
            }
        }.prototype.isWebGL3DRenderTarget = !0, class extends Yu {
            constructor(t, e, n, r = {}) {
                super(t, e, r);
                const i = this.texture;
                this.texture = [];
                for (let t = 0; t < n; t++) this.texture[t] = i.clone(), this.texture[t].isRenderTargetTexture = !0
            }
            setSize(t, e, n = 1) {
                if (this.width !== t || this.height !== e || this.depth !== n) {
                    this.width = t, this.height = e, this.depth = n;
                    for (let r = 0, i = this.texture.length; r < i; r++) this.texture[r].image.width = t, this.texture[r].image.height = e, this.texture[r].image.depth = n;
                    this.dispose()
                }
                return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this
            }
            copy(t) {
                this.dispose(), this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this.texture.length = 0;
                for (let e = 0, n = t.texture.length; e < n; e++) this.texture[e] = t.texture[e].clone();
                return this
            }
        }.prototype.isWebGLMultipleRenderTargets = !0;
        class Ku {
            constructor(t = 0, e = 0, n = 0, r = 1) {
                this._x = t, this._y = e, this._z = n, this._w = r
            }
            static slerp(t, e, n, r) {
                return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(t, e, r)
            }
            static slerpFlat(t, e, n, r, i, o, s) {
                let a = n[r + 0],
                    l = n[r + 1],
                    u = n[r + 2],
                    h = n[r + 3];
                const c = i[o + 0],
                    d = i[o + 1],
                    p = i[o + 2],
                    f = i[o + 3];
                if (0 === s) return t[e + 0] = a, t[e + 1] = l, t[e + 2] = u, void(t[e + 3] = h);
                if (1 === s) return t[e + 0] = c, t[e + 1] = d, t[e + 2] = p, void(t[e + 3] = f);
                if (h !== f || a !== c || l !== d || u !== p) {
                    let t = 1 - s;
                    const e = a * c + l * d + u * p + h * f,
                        n = e >= 0 ? 1 : -1,
                        r = 1 - e * e;
                    if (r > Number.EPSILON) {
                        const i = Math.sqrt(r),
                            o = Math.atan2(i, e * n);
                        t = Math.sin(t * o) / i, s = Math.sin(s * o) / i
                    }
                    const i = s * n;
                    if (a = a * t + c * i, l = l * t + d * i, u = u * t + p * i, h = h * t + f * i, t === 1 - s) {
                        const t = 1 / Math.sqrt(a * a + l * l + u * u + h * h);
                        a *= t, l *= t, u *= t, h *= t
                    }
                }
                t[e] = a, t[e + 1] = l, t[e + 2] = u, t[e + 3] = h
            }
            static multiplyQuaternionsFlat(t, e, n, r, i, o) {
                const s = n[r],
                    a = n[r + 1],
                    l = n[r + 2],
                    u = n[r + 3],
                    h = i[o],
                    c = i[o + 1],
                    d = i[o + 2],
                    p = i[o + 3];
                return t[e] = s * p + u * h + a * d - l * c, t[e + 1] = a * p + u * c + l * h - s * d, t[e + 2] = l * p + u * d + s * c - a * h, t[e + 3] = u * p - s * h - a * c - l * d, t
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t, this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(t) {
                this._w = t, this._onChangeCallback()
            }
            set(t, e, n, r) {
                return this._x = t, this._y = e, this._z = n, this._w = r, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._w)
            }
            copy(t) {
                return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
            }
            setFromEuler(t, e) {
                if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                const n = t._x,
                    r = t._y,
                    i = t._z,
                    o = t._order,
                    s = Math.cos,
                    a = Math.sin,
                    l = s(n / 2),
                    u = s(r / 2),
                    h = s(i / 2),
                    c = a(n / 2),
                    d = a(r / 2),
                    p = a(i / 2);
                switch (o) {
                    case "XYZ":
                        this._x = c * u * h + l * d * p, this._y = l * d * h - c * u * p, this._z = l * u * p + c * d * h, this._w = l * u * h - c * d * p;
                        break;
                    case "YXZ":
                        this._x = c * u * h + l * d * p, this._y = l * d * h - c * u * p, this._z = l * u * p - c * d * h, this._w = l * u * h + c * d * p;
                        break;
                    case "ZXY":
                        this._x = c * u * h - l * d * p, this._y = l * d * h + c * u * p, this._z = l * u * p + c * d * h, this._w = l * u * h - c * d * p;
                        break;
                    case "ZYX":
                        this._x = c * u * h - l * d * p, this._y = l * d * h + c * u * p, this._z = l * u * p - c * d * h, this._w = l * u * h + c * d * p;
                        break;
                    case "YZX":
                        this._x = c * u * h + l * d * p, this._y = l * d * h + c * u * p, this._z = l * u * p - c * d * h, this._w = l * u * h - c * d * p;
                        break;
                    case "XZY":
                        this._x = c * u * h - l * d * p, this._y = l * d * h - c * u * p, this._z = l * u * p + c * d * h, this._w = l * u * h + c * d * p;
                        break;
                    default:
                        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
                }
                return !1 !== e && this._onChangeCallback(), this
            }
            setFromAxisAngle(t, e) {
                const n = e / 2,
                    r = Math.sin(n);
                return this._x = t.x * r, this._y = t.y * r, this._z = t.z * r, this._w = Math.cos(n), this._onChangeCallback(), this
            }
            setFromRotationMatrix(t) {
                const e = t.elements,
                    n = e[0],
                    r = e[4],
                    i = e[8],
                    o = e[1],
                    s = e[5],
                    a = e[9],
                    l = e[2],
                    u = e[6],
                    h = e[10],
                    c = n + s + h;
                if (c > 0) {
                    const t = .5 / Math.sqrt(c + 1);
                    this._w = .25 / t, this._x = (u - a) * t, this._y = (i - l) * t, this._z = (o - r) * t
                } else if (n > s && n > h) {
                    const t = 2 * Math.sqrt(1 + n - s - h);
                    this._w = (u - a) / t, this._x = .25 * t, this._y = (r + o) / t, this._z = (i + l) / t
                } else if (s > h) {
                    const t = 2 * Math.sqrt(1 + s - n - h);
                    this._w = (i - l) / t, this._x = (r + o) / t, this._y = .25 * t, this._z = (a + u) / t
                } else {
                    const t = 2 * Math.sqrt(1 + h - n - s);
                    this._w = (o - r) / t, this._x = (i + l) / t, this._y = (a + u) / t, this._z = .25 * t
                }
                return this._onChangeCallback(), this
            }
            setFromUnitVectors(t, e) {
                let n = t.dot(e) + 1;
                return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
            }
            angleTo(t) {
                return 2 * Math.acos(Math.abs(yu(this.dot(t), -1, 1)))
            }
            rotateTowards(t, e) {
                const n = this.angleTo(t);
                if (0 === n) return this;
                const r = Math.min(1, e / n);
                return this.slerp(t, r), this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
            }
            dot(t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let t = this.length();
                return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
            }
            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
            }
            premultiply(t) {
                return this.multiplyQuaternions(t, this)
            }
            multiplyQuaternions(t, e) {
                const n = t._x,
                    r = t._y,
                    i = t._z,
                    o = t._w,
                    s = e._x,
                    a = e._y,
                    l = e._z,
                    u = e._w;
                return this._x = n * u + o * s + r * l - i * a, this._y = r * u + o * a + i * s - n * l, this._z = i * u + o * l + n * a - r * s, this._w = o * u - n * s - r * a - i * l, this._onChangeCallback(), this
            }
            slerp(t, e) {
                if (0 === e) return this;
                if (1 === e) return this.copy(t);
                const n = this._x,
                    r = this._y,
                    i = this._z,
                    o = this._w;
                let s = o * t._w + n * t._x + r * t._y + i * t._z;
                if (s < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, s = -s) : this.copy(t), s >= 1) return this._w = o, this._x = n, this._y = r, this._z = i, this;
                const a = 1 - s * s;
                if (a <= Number.EPSILON) {
                    const t = 1 - e;
                    return this._w = t * o + e * this._w, this._x = t * n + e * this._x, this._y = t * r + e * this._y, this._z = t * i + e * this._z, this.normalize(), this._onChangeCallback(), this
                }
                const l = Math.sqrt(a),
                    u = Math.atan2(l, s),
                    h = Math.sin((1 - e) * u) / l,
                    c = Math.sin(e * u) / l;
                return this._w = o * h + this._w * c, this._x = n * h + this._x * c, this._y = r * h + this._y * c, this._z = i * h + this._z * c, this._onChangeCallback(), this
            }
            slerpQuaternions(t, e, n) {
                return this.copy(t).slerp(e, n)
            }
            random() {
                const t = Math.random(),
                    e = Math.sqrt(1 - t),
                    n = Math.sqrt(t),
                    r = 2 * Math.PI * Math.random(),
                    i = 2 * Math.PI * Math.random();
                return this.set(e * Math.cos(r), n * Math.sin(i), n * Math.cos(i), e * Math.sin(r))
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            }
            fromArray(t, e = 0) {
                return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
            }
            toArray(t = [], e = 0) {
                return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
            }
            fromBufferAttribute(t, e) {
                return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
            }
            _onChange(t) {
                return this._onChangeCallback = t, this
            }
            _onChangeCallback() {}
        }
        Ku.prototype.isQuaternion = !0;
        class Ju {
            constructor(t = 0, e = 0, n = 0) {
                this.x = t, this.y = e, this.z = n
            }
            set(t, e, n) {
                return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
            }
            setScalar(t) {
                return this.x = t, this.y = t, this.z = t, this
            }
            setX(t) {
                return this.x = t, this
            }
            setY(t) {
                return this.y = t, this
            }
            setZ(t) {
                return this.z = t, this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z)
            }
            copy(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this
            }
            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
            }
            addScalar(t) {
                return this.x += t, this.y += t, this.z += t, this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
            }
            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
            }
            subScalar(t) {
                return this.x -= t, this.y -= t, this.z -= t, this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
            }
            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
            }
            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this.z *= t, this
            }
            multiplyVectors(t, e) {
                return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
            }
            applyEuler(t) {
                return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion($u.setFromEuler(t))
            }
            applyAxisAngle(t, e) {
                return this.applyQuaternion($u.setFromAxisAngle(t, e))
            }
            applyMatrix3(t) {
                const e = this.x,
                    n = this.y,
                    r = this.z,
                    i = t.elements;
                return this.x = i[0] * e + i[3] * n + i[6] * r, this.y = i[1] * e + i[4] * n + i[7] * r, this.z = i[2] * e + i[5] * n + i[8] * r, this
            }
            applyNormalMatrix(t) {
                return this.applyMatrix3(t).normalize()
            }
            applyMatrix4(t) {
                const e = this.x,
                    n = this.y,
                    r = this.z,
                    i = t.elements,
                    o = 1 / (i[3] * e + i[7] * n + i[11] * r + i[15]);
                return this.x = (i[0] * e + i[4] * n + i[8] * r + i[12]) * o, this.y = (i[1] * e + i[5] * n + i[9] * r + i[13]) * o, this.z = (i[2] * e + i[6] * n + i[10] * r + i[14]) * o, this
            }
            applyQuaternion(t) {
                const e = this.x,
                    n = this.y,
                    r = this.z,
                    i = t.x,
                    o = t.y,
                    s = t.z,
                    a = t.w,
                    l = a * e + o * r - s * n,
                    u = a * n + s * e - i * r,
                    h = a * r + i * n - o * e,
                    c = -i * e - o * n - s * r;
                return this.x = l * a + c * -i + u * -s - h * -o, this.y = u * a + c * -o + h * -i - l * -s, this.z = h * a + c * -s + l * -o - u * -i, this
            }
            project(t) {
                return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
            }
            unproject(t) {
                return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
            }
            transformDirection(t) {
                const e = this.x,
                    n = this.y,
                    r = this.z,
                    i = t.elements;
                return this.x = i[0] * e + i[4] * n + i[8] * r, this.y = i[1] * e + i[5] * n + i[9] * r, this.z = i[2] * e + i[6] * n + i[10] * r, this.normalize()
            }
            divide(t) {
                return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
            }
            cross(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
            }
            crossVectors(t, e) {
                const n = t.x,
                    r = t.y,
                    i = t.z,
                    o = e.x,
                    s = e.y,
                    a = e.z;
                return this.x = r * a - i * s, this.y = i * o - n * a, this.z = n * s - r * o, this
            }
            projectOnVector(t) {
                const e = t.lengthSq();
                if (0 === e) return this.set(0, 0, 0);
                const n = t.dot(this) / e;
                return this.copy(t).multiplyScalar(n)
            }
            projectOnPlane(t) {
                return Qu.copy(this).projectOnVector(t), this.sub(Qu)
            }
            reflect(t) {
                return this.sub(Qu.copy(t).multiplyScalar(2 * this.dot(t)))
            }
            angleTo(t) {
                const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                if (0 === e) return Math.PI / 2;
                const n = this.dot(t) / e;
                return Math.acos(yu(n, -1, 1))
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x,
                    n = this.y - t.y,
                    r = this.z - t.z;
                return e * e + n * n + r * r
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            }
            setFromSpherical(t) {
                return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
            }
            setFromSphericalCoords(t, e, n) {
                const r = Math.sin(e) * t;
                return this.x = r * Math.sin(n), this.y = Math.cos(e) * t, this.z = r * Math.cos(n), this
            }
            setFromCylindrical(t) {
                return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
            }
            setFromCylindricalCoords(t, e, n) {
                return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
            }
            setFromMatrixPosition(t) {
                const e = t.elements;
                return this.x = e[12], this.y = e[13], this.z = e[14], this
            }
            setFromMatrixScale(t) {
                const e = this.setFromMatrixColumn(t, 0).length(),
                    n = this.setFromMatrixColumn(t, 1).length(),
                    r = this.setFromMatrixColumn(t, 2).length();
                return this.x = e, this.y = n, this.z = r, this
            }
            setFromMatrixColumn(t, e) {
                return this.fromArray(t.elements, 4 * e)
            }
            setFromMatrix3Column(t, e) {
                return this.fromArray(t.elements, 3 * e)
            }
            setFromEuler(t) {
                return this.x = t._x, this.y = t._y, this.z = t._z, this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            }
            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
            }
            fromBufferAttribute(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
            }
            randomDirection() {
                const t = 2 * (Math.random() - .5),
                    e = Math.random() * Math.PI * 2,
                    n = Math.sqrt(1 - t ** 2);
                return this.x = n * Math.cos(e), this.y = n * Math.sin(e), this.z = t, this
            }*[Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z
            }
        }
        Ju.prototype.isVector3 = !0;
        const Qu = new Ju,
            $u = new Ku;
        class th {
            constructor(t = new Ju(1 / 0, 1 / 0, 1 / 0), e = new Ju(-1 / 0, -1 / 0, -1 / 0)) {
                this.min = t, this.max = e
            }
            set(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            }
            setFromArray(t) {
                let e = 1 / 0,
                    n = 1 / 0,
                    r = 1 / 0,
                    i = -1 / 0,
                    o = -1 / 0,
                    s = -1 / 0;
                for (let a = 0, l = t.length; a < l; a += 3) {
                    const l = t[a],
                        u = t[a + 1],
                        h = t[a + 2];
                    l < e && (e = l), u < n && (n = u), h < r && (r = h), l > i && (i = l), u > o && (o = u), h > s && (s = h)
                }
                return this.min.set(e, n, r), this.max.set(i, o, s), this
            }
            setFromBufferAttribute(t) {
                let e = 1 / 0,
                    n = 1 / 0,
                    r = 1 / 0,
                    i = -1 / 0,
                    o = -1 / 0,
                    s = -1 / 0;
                for (let a = 0, l = t.count; a < l; a++) {
                    const l = t.getX(a),
                        u = t.getY(a),
                        h = t.getZ(a);
                    l < e && (e = l), u < n && (n = u), h < r && (r = h), l > i && (i = l), u > o && (o = u), h > s && (s = h)
                }
                return this.min.set(e, n, r), this.max.set(i, o, s), this
            }
            setFromPoints(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                return this
            }
            setFromCenterAndSize(t, e) {
                const n = nh.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
            }
            setFromObject(t, e = !1) {
                return this.makeEmpty(), this.expandByObject(t, e)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(t) {
                return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(t) {
                return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            }
            expandByPoint(t) {
                return this.min.min(t), this.max.max(t), this
            }
            expandByVector(t) {
                return this.min.sub(t), this.max.add(t), this
            }
            expandByScalar(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            }
            expandByObject(t, e = !1) {
                t.updateWorldMatrix(!1, !1);
                const n = t.geometry;
                if (void 0 !== n)
                    if (e && null != n.attributes && void 0 !== n.attributes.position) {
                        const e = n.attributes.position;
                        for (let n = 0, r = e.count; n < r; n++) nh.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld), this.expandByPoint(nh)
                    } else null === n.boundingBox && n.computeBoundingBox(), rh.copy(n.boundingBox), rh.applyMatrix4(t.matrixWorld), this.union(rh);
                const r = t.children;
                for (let t = 0, n = r.length; t < n; t++) this.expandByObject(r[t], e);
                return this
            }
            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            }
            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            }
            getParameter(t, e) {
                return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            }
            intersectsSphere(t) {
                return this.clampPoint(t.center, nh), nh.distanceToSquared(t.center) <= t.radius * t.radius
            }
            intersectsPlane(t) {
                let e, n;
                return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
            }
            intersectsTriangle(t) {
                if (this.isEmpty()) return !1;
                this.getCenter(hh), ch.subVectors(this.max, hh), ih.subVectors(t.a, hh), oh.subVectors(t.b, hh), sh.subVectors(t.c, hh), ah.subVectors(oh, ih), lh.subVectors(sh, oh), uh.subVectors(ih, sh);
                let e = [0, -ah.z, ah.y, 0, -lh.z, lh.y, 0, -uh.z, uh.y, ah.z, 0, -ah.x, lh.z, 0, -lh.x, uh.z, 0, -uh.x, -ah.y, ah.x, 0, -lh.y, lh.x, 0, -uh.y, uh.x, 0];
                return !!fh(e, ih, oh, sh, ch) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!fh(e, ih, oh, sh, ch) && (dh.crossVectors(ah, lh), e = [dh.x, dh.y, dh.z], fh(e, ih, oh, sh, ch)))
            }
            clampPoint(t, e) {
                return e.copy(t).clamp(this.min, this.max)
            }
            distanceToPoint(t) {
                return nh.copy(t).clamp(this.min, this.max).sub(t).length()
            }
            getBoundingSphere(t) {
                return this.getCenter(t.center), t.radius = .5 * this.getSize(nh).length(), t
            }
            intersect(t) {
                return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
            }
            union(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            }
            applyMatrix4(t) {
                return this.isEmpty() || (eh[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), eh[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), eh[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), eh[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), eh[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), eh[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), eh[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), eh[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(eh)), this
            }
            translate(t) {
                return this.min.add(t), this.max.add(t), this
            }
            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }
        th.prototype.isBox3 = !0;
        const eh = [new Ju, new Ju, new Ju, new Ju, new Ju, new Ju, new Ju, new Ju],
            nh = new Ju,
            rh = new th,
            ih = new Ju,
            oh = new Ju,
            sh = new Ju,
            ah = new Ju,
            lh = new Ju,
            uh = new Ju,
            hh = new Ju,
            ch = new Ju,
            dh = new Ju,
            ph = new Ju;

        function fh(t, e, n, r, i) {
            for (let o = 0, s = t.length - 3; o <= s; o += 3) {
                ph.fromArray(t, o);
                const s = i.x * Math.abs(ph.x) + i.y * Math.abs(ph.y) + i.z * Math.abs(ph.z),
                    a = e.dot(ph),
                    l = n.dot(ph),
                    u = r.dot(ph);
                if (Math.max(-Math.max(a, l, u), Math.min(a, l, u)) > s) return !1
            }
            return !0
        }
        const mh = new th,
            gh = new Ju,
            vh = new Ju,
            _h = new Ju;
        class yh {
            constructor(t = new Ju, e = -1) {
                this.center = t, this.radius = e
            }
            set(t, e) {
                return this.center.copy(t), this.radius = e, this
            }
            setFromPoints(t, e) {
                const n = this.center;
                void 0 !== e ? n.copy(e) : mh.setFromPoints(t).getCenter(n);
                let r = 0;
                for (let e = 0, i = t.length; e < i; e++) r = Math.max(r, n.distanceToSquared(t[e]));
                return this.radius = Math.sqrt(r), this
            }
            copy(t) {
                return this.center.copy(t.center), this.radius = t.radius, this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0), this.radius = -1, this
            }
            containsPoint(t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(t) {
                return t.distanceTo(this.center) - this.radius
            }
            intersectsSphere(t) {
                const e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            }
            intersectsBox(t) {
                return t.intersectsSphere(this)
            }
            intersectsPlane(t) {
                return Math.abs(t.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(t, e) {
                const n = this.center.distanceToSquared(t);
                return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
            }
            getBoundingBox(t) {
                return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
            }
            applyMatrix4(t) {
                return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
            }
            translate(t) {
                return this.center.add(t), this
            }
            expandByPoint(t) {
                _h.subVectors(t, this.center);
                const e = _h.lengthSq();
                if (e > this.radius * this.radius) {
                    const t = Math.sqrt(e),
                        n = .5 * (t - this.radius);
                    this.center.add(_h.multiplyScalar(n / t)), this.radius += n
                }
                return this
            }
            union(t) {
                return !0 === this.center.equals(t.center) ? vh.set(0, 0, 1).multiplyScalar(t.radius) : vh.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(gh.copy(t.center).add(vh)), this.expandByPoint(gh.copy(t.center).sub(vh)), this
            }
            equals(t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const xh = new Ju,
            bh = new Ju,
            Eh = new Ju,
            Th = new Ju,
            Sh = new Ju,
            wh = new Ju,
            Mh = new Ju;
        class Ah {
            constructor(t = new Ju, e = new Ju(0, 0, -1)) {
                this.origin = t, this.direction = e
            }
            set(t, e) {
                return this.origin.copy(t), this.direction.copy(e), this
            }
            copy(t) {
                return this.origin.copy(t.origin), this.direction.copy(t.direction), this
            }
            at(t, e) {
                return e.copy(this.direction).multiplyScalar(t).add(this.origin)
            }
            lookAt(t) {
                return this.direction.copy(t).sub(this.origin).normalize(), this
            }
            recast(t) {
                return this.origin.copy(this.at(t, xh)), this
            }
            closestPointToPoint(t, e) {
                e.subVectors(t, this.origin);
                const n = e.dot(this.direction);
                return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
            }
            distanceToPoint(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            }
            distanceSqToPoint(t) {
                const e = xh.subVectors(t, this.origin).dot(this.direction);
                return e < 0 ? this.origin.distanceToSquared(t) : (xh.copy(this.direction).multiplyScalar(e).add(this.origin), xh.distanceToSquared(t))
            }
            distanceSqToSegment(t, e, n, r) {
                bh.copy(t).add(e).multiplyScalar(.5), Eh.copy(e).sub(t).normalize(), Th.copy(this.origin).sub(bh);
                const i = .5 * t.distanceTo(e),
                    o = -this.direction.dot(Eh),
                    s = Th.dot(this.direction),
                    a = -Th.dot(Eh),
                    l = Th.lengthSq(),
                    u = Math.abs(1 - o * o);
                let h, c, d, p;
                if (u > 0)
                    if (h = o * a - s, c = o * s - a, p = i * u, h >= 0)
                        if (c >= -p)
                            if (c <= p) {
                                const t = 1 / u;
                                h *= t, c *= t, d = h * (h + o * c + 2 * s) + c * (o * h + c + 2 * a) + l
                            } else c = i, h = Math.max(0, -(o * c + s)), d = -h * h + c * (c + 2 * a) + l;
                else c = -i, h = Math.max(0, -(o * c + s)), d = -h * h + c * (c + 2 * a) + l;
                else c <= -p ? (h = Math.max(0, -(-o * i + s)), c = h > 0 ? -i : Math.min(Math.max(-i, -a), i), d = -h * h + c * (c + 2 * a) + l) : c <= p ? (h = 0, c = Math.min(Math.max(-i, -a), i), d = c * (c + 2 * a) + l) : (h = Math.max(0, -(o * i + s)), c = h > 0 ? i : Math.min(Math.max(-i, -a), i), d = -h * h + c * (c + 2 * a) + l);
                else c = o > 0 ? -i : i, h = Math.max(0, -(o * c + s)), d = -h * h + c * (c + 2 * a) + l;
                return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), r && r.copy(Eh).multiplyScalar(c).add(bh), d
            }
            intersectSphere(t, e) {
                xh.subVectors(t.center, this.origin);
                const n = xh.dot(this.direction),
                    r = xh.dot(xh) - n * n,
                    i = t.radius * t.radius;
                if (r > i) return null;
                const o = Math.sqrt(i - r),
                    s = n - o,
                    a = n + o;
                return s < 0 && a < 0 ? null : s < 0 ? this.at(a, e) : this.at(s, e)
            }
            intersectsSphere(t) {
                return this.distanceSqToPoint(t.center) <= t.radius * t.radius
            }
            distanceToPlane(t) {
                const e = t.normal.dot(this.direction);
                if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                const n = -(this.origin.dot(t.normal) + t.constant) / e;
                return n >= 0 ? n : null
            }
            intersectPlane(t, e) {
                const n = this.distanceToPlane(t);
                return null === n ? null : this.at(n, e)
            }
            intersectsPlane(t) {
                const e = t.distanceToPoint(this.origin);
                return 0 === e || t.normal.dot(this.direction) * e < 0
            }
            intersectBox(t, e) {
                let n, r, i, o, s, a;
                const l = 1 / this.direction.x,
                    u = 1 / this.direction.y,
                    h = 1 / this.direction.z,
                    c = this.origin;
                return l >= 0 ? (n = (t.min.x - c.x) * l, r = (t.max.x - c.x) * l) : (n = (t.max.x - c.x) * l, r = (t.min.x - c.x) * l), u >= 0 ? (i = (t.min.y - c.y) * u, o = (t.max.y - c.y) * u) : (i = (t.max.y - c.y) * u, o = (t.min.y - c.y) * u), n > o || i > r ? null : ((i > n || n != n) && (n = i), (o < r || r != r) && (r = o), h >= 0 ? (s = (t.min.z - c.z) * h, a = (t.max.z - c.z) * h) : (s = (t.max.z - c.z) * h, a = (t.min.z - c.z) * h), n > a || s > r ? null : ((s > n || n != n) && (n = s), (a < r || r != r) && (r = a), r < 0 ? null : this.at(n >= 0 ? n : r, e)))
            }
            intersectsBox(t) {
                return null !== this.intersectBox(t, xh)
            }
            intersectTriangle(t, e, n, r, i) {
                Sh.subVectors(e, t), wh.subVectors(n, t), Mh.crossVectors(Sh, wh);
                let o, s = this.direction.dot(Mh);
                if (s > 0) {
                    if (r) return null;
                    o = 1
                } else {
                    if (!(s < 0)) return null;
                    o = -1, s = -s
                }
                Th.subVectors(this.origin, t);
                const a = o * this.direction.dot(wh.crossVectors(Th, wh));
                if (a < 0) return null;
                const l = o * this.direction.dot(Sh.cross(Th));
                if (l < 0) return null;
                if (a + l > s) return null;
                const u = -o * Th.dot(Mh);
                return u < 0 ? null : this.at(u / s, i)
            }
            applyMatrix4(t) {
                return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
            }
            equals(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class Rh {
            constructor() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }
            set(t, e, n, r, i, o, s, a, l, u, h, c, d, p, f, m) {
                const g = this.elements;
                return g[0] = t, g[4] = e, g[8] = n, g[12] = r, g[1] = i, g[5] = o, g[9] = s, g[13] = a, g[2] = l, g[6] = u, g[10] = h, g[14] = c, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            clone() {
                return (new Rh).fromArray(this.elements)
            }
            copy(t) {
                const e = this.elements,
                    n = t.elements;
                return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
            }
            copyPosition(t) {
                const e = this.elements,
                    n = t.elements;
                return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
            }
            setFromMatrix3(t) {
                const e = t.elements;
                return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
            }
            makeBasis(t, e, n) {
                return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
            }
            extractRotation(t) {
                const e = this.elements,
                    n = t.elements,
                    r = 1 / Ph.setFromMatrixColumn(t, 0).length(),
                    i = 1 / Ph.setFromMatrixColumn(t, 1).length(),
                    o = 1 / Ph.setFromMatrixColumn(t, 2).length();
                return e[0] = n[0] * r, e[1] = n[1] * r, e[2] = n[2] * r, e[3] = 0, e[4] = n[4] * i, e[5] = n[5] * i, e[6] = n[6] * i, e[7] = 0, e[8] = n[8] * o, e[9] = n[9] * o, e[10] = n[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            }
            makeRotationFromEuler(t) {
                t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                const e = this.elements,
                    n = t.x,
                    r = t.y,
                    i = t.z,
                    o = Math.cos(n),
                    s = Math.sin(n),
                    a = Math.cos(r),
                    l = Math.sin(r),
                    u = Math.cos(i),
                    h = Math.sin(i);
                if ("XYZ" === t.order) {
                    const t = o * u,
                        n = o * h,
                        r = s * u,
                        i = s * h;
                    e[0] = a * u, e[4] = -a * h, e[8] = l, e[1] = n + r * l, e[5] = t - i * l, e[9] = -s * a, e[2] = i - t * l, e[6] = r + n * l, e[10] = o * a
                } else if ("YXZ" === t.order) {
                    const t = a * u,
                        n = a * h,
                        r = l * u,
                        i = l * h;
                    e[0] = t + i * s, e[4] = r * s - n, e[8] = o * l, e[1] = o * h, e[5] = o * u, e[9] = -s, e[2] = n * s - r, e[6] = i + t * s, e[10] = o * a
                } else if ("ZXY" === t.order) {
                    const t = a * u,
                        n = a * h,
                        r = l * u,
                        i = l * h;
                    e[0] = t - i * s, e[4] = -o * h, e[8] = r + n * s, e[1] = n + r * s, e[5] = o * u, e[9] = i - t * s, e[2] = -o * l, e[6] = s, e[10] = o * a
                } else if ("ZYX" === t.order) {
                    const t = o * u,
                        n = o * h,
                        r = s * u,
                        i = s * h;
                    e[0] = a * u, e[4] = r * l - n, e[8] = t * l + i, e[1] = a * h, e[5] = i * l + t, e[9] = n * l - r, e[2] = -l, e[6] = s * a, e[10] = o * a
                } else if ("YZX" === t.order) {
                    const t = o * a,
                        n = o * l,
                        r = s * a,
                        i = s * l;
                    e[0] = a * u, e[4] = i - t * h, e[8] = r * h + n, e[1] = h, e[5] = o * u, e[9] = -s * u, e[2] = -l * u, e[6] = n * h + r, e[10] = t - i * h
                } else if ("XZY" === t.order) {
                    const t = o * a,
                        n = o * l,
                        r = s * a,
                        i = s * l;
                    e[0] = a * u, e[4] = -h, e[8] = l * u, e[1] = t * h + i, e[5] = o * u, e[9] = n * h - r, e[2] = r * h - n, e[6] = s * u, e[10] = i * h + t
                }
                return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            }
            makeRotationFromQuaternion(t) {
                return this.compose(Ch, t, Oh)
            }
            lookAt(t, e, n) {
                const r = this.elements;
                return Dh.subVectors(t, e), 0 === Dh.lengthSq() && (Dh.z = 1), Dh.normalize(), Lh.crossVectors(n, Dh), 0 === Lh.lengthSq() && (1 === Math.abs(n.z) ? Dh.x += 1e-4 : Dh.z += 1e-4, Dh.normalize(), Lh.crossVectors(n, Dh)), Lh.normalize(), Nh.crossVectors(Dh, Lh), r[0] = Lh.x, r[4] = Nh.x, r[8] = Dh.x, r[1] = Lh.y, r[5] = Nh.y, r[9] = Dh.y, r[2] = Lh.z, r[6] = Nh.z, r[10] = Dh.z, this
            }
            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements,
                    r = e.elements,
                    i = this.elements,
                    o = n[0],
                    s = n[4],
                    a = n[8],
                    l = n[12],
                    u = n[1],
                    h = n[5],
                    c = n[9],
                    d = n[13],
                    p = n[2],
                    f = n[6],
                    m = n[10],
                    g = n[14],
                    v = n[3],
                    _ = n[7],
                    y = n[11],
                    x = n[15],
                    b = r[0],
                    E = r[4],
                    T = r[8],
                    S = r[12],
                    w = r[1],
                    M = r[5],
                    A = r[9],
                    R = r[13],
                    P = r[2],
                    I = r[6],
                    C = r[10],
                    O = r[14],
                    L = r[3],
                    N = r[7],
                    D = r[11],
                    U = r[15];
                return i[0] = o * b + s * w + a * P + l * L, i[4] = o * E + s * M + a * I + l * N, i[8] = o * T + s * A + a * C + l * D, i[12] = o * S + s * R + a * O + l * U, i[1] = u * b + h * w + c * P + d * L, i[5] = u * E + h * M + c * I + d * N, i[9] = u * T + h * A + c * C + d * D, i[13] = u * S + h * R + c * O + d * U, i[2] = p * b + f * w + m * P + g * L, i[6] = p * E + f * M + m * I + g * N, i[10] = p * T + f * A + m * C + g * D, i[14] = p * S + f * R + m * O + g * U, i[3] = v * b + _ * w + y * P + x * L, i[7] = v * E + _ * M + y * I + x * N, i[11] = v * T + _ * A + y * C + x * D, i[15] = v * S + _ * R + y * O + x * U, this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
            }
            determinant() {
                const t = this.elements,
                    e = t[0],
                    n = t[4],
                    r = t[8],
                    i = t[12],
                    o = t[1],
                    s = t[5],
                    a = t[9],
                    l = t[13],
                    u = t[2],
                    h = t[6],
                    c = t[10],
                    d = t[14];
                return t[3] * (+i * a * h - r * l * h - i * s * c + n * l * c + r * s * d - n * a * d) + t[7] * (+e * a * d - e * l * c + i * o * c - r * o * d + r * l * u - i * a * u) + t[11] * (+e * l * h - e * s * d - i * o * h + n * o * d + i * s * u - n * l * u) + t[15] * (-r * s * u - e * a * h + e * s * c + r * o * h - n * o * c + n * a * u)
            }
            transpose() {
                const t = this.elements;
                let e;
                return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
            }
            setPosition(t, e, n) {
                const r = this.elements;
                return t.isVector3 ? (r[12] = t.x, r[13] = t.y, r[14] = t.z) : (r[12] = t, r[13] = e, r[14] = n), this
            }
            invert() {
                const t = this.elements,
                    e = t[0],
                    n = t[1],
                    r = t[2],
                    i = t[3],
                    o = t[4],
                    s = t[5],
                    a = t[6],
                    l = t[7],
                    u = t[8],
                    h = t[9],
                    c = t[10],
                    d = t[11],
                    p = t[12],
                    f = t[13],
                    m = t[14],
                    g = t[15],
                    v = h * m * l - f * c * l + f * a * d - s * m * d - h * a * g + s * c * g,
                    _ = p * c * l - u * m * l - p * a * d + o * m * d + u * a * g - o * c * g,
                    y = u * f * l - p * h * l + p * s * d - o * f * d - u * s * g + o * h * g,
                    x = p * h * a - u * f * a - p * s * c + o * f * c + u * s * m - o * h * m,
                    b = e * v + n * _ + r * y + i * x;
                if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const E = 1 / b;
                return t[0] = v * E, t[1] = (f * c * i - h * m * i - f * r * d + n * m * d + h * r * g - n * c * g) * E, t[2] = (s * m * i - f * a * i + f * r * l - n * m * l - s * r * g + n * a * g) * E, t[3] = (h * a * i - s * c * i - h * r * l + n * c * l + s * r * d - n * a * d) * E, t[4] = _ * E, t[5] = (u * m * i - p * c * i + p * r * d - e * m * d - u * r * g + e * c * g) * E, t[6] = (p * a * i - o * m * i - p * r * l + e * m * l + o * r * g - e * a * g) * E, t[7] = (o * c * i - u * a * i + u * r * l - e * c * l - o * r * d + e * a * d) * E, t[8] = y * E, t[9] = (p * h * i - u * f * i - p * n * d + e * f * d + u * n * g - e * h * g) * E, t[10] = (o * f * i - p * s * i + p * n * l - e * f * l - o * n * g + e * s * g) * E, t[11] = (u * s * i - o * h * i - u * n * l + e * h * l + o * n * d - e * s * d) * E, t[12] = x * E, t[13] = (u * f * r - p * h * r + p * n * c - e * f * c - u * n * m + e * h * m) * E, t[14] = (p * s * r - o * f * r - p * n * a + e * f * a + o * n * m - e * s * m) * E, t[15] = (o * h * r - u * s * r + u * n * a - e * h * a - o * n * c + e * s * c) * E, this
            }
            scale(t) {
                const e = this.elements,
                    n = t.x,
                    r = t.y,
                    i = t.z;
                return e[0] *= n, e[4] *= r, e[8] *= i, e[1] *= n, e[5] *= r, e[9] *= i, e[2] *= n, e[6] *= r, e[10] *= i, e[3] *= n, e[7] *= r, e[11] *= i, this
            }
            getMaxScaleOnAxis() {
                const t = this.elements,
                    e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                    n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                    r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, n, r))
            }
            makeTranslation(t, e, n) {
                return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
            }
            makeRotationX(t) {
                const e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
            }
            makeRotationY(t) {
                const e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
            }
            makeRotationZ(t) {
                const e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            makeRotationAxis(t, e) {
                const n = Math.cos(e),
                    r = Math.sin(e),
                    i = 1 - n,
                    o = t.x,
                    s = t.y,
                    a = t.z,
                    l = i * o,
                    u = i * s;
                return this.set(l * o + n, l * s - r * a, l * a + r * s, 0, l * s + r * a, u * s + n, u * a - r * o, 0, l * a - r * s, u * a + r * o, i * a * a + n, 0, 0, 0, 0, 1), this
            }
            makeScale(t, e, n) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            }
            makeShear(t, e, n, r, i, o) {
                return this.set(1, n, i, 0, t, 1, o, 0, e, r, 1, 0, 0, 0, 0, 1), this
            }
            compose(t, e, n) {
                const r = this.elements,
                    i = e._x,
                    o = e._y,
                    s = e._z,
                    a = e._w,
                    l = i + i,
                    u = o + o,
                    h = s + s,
                    c = i * l,
                    d = i * u,
                    p = i * h,
                    f = o * u,
                    m = o * h,
                    g = s * h,
                    v = a * l,
                    _ = a * u,
                    y = a * h,
                    x = n.x,
                    b = n.y,
                    E = n.z;
                return r[0] = (1 - (f + g)) * x, r[1] = (d + y) * x, r[2] = (p - _) * x, r[3] = 0, r[4] = (d - y) * b, r[5] = (1 - (c + g)) * b, r[6] = (m + v) * b, r[7] = 0, r[8] = (p + _) * E, r[9] = (m - v) * E, r[10] = (1 - (c + f)) * E, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1, this
            }
            decompose(t, e, n) {
                const r = this.elements;
                let i = Ph.set(r[0], r[1], r[2]).length();
                const o = Ph.set(r[4], r[5], r[6]).length(),
                    s = Ph.set(r[8], r[9], r[10]).length();
                this.determinant() < 0 && (i = -i), t.x = r[12], t.y = r[13], t.z = r[14], Ih.copy(this);
                const a = 1 / i,
                    l = 1 / o,
                    u = 1 / s;
                return Ih.elements[0] *= a, Ih.elements[1] *= a, Ih.elements[2] *= a, Ih.elements[4] *= l, Ih.elements[5] *= l, Ih.elements[6] *= l, Ih.elements[8] *= u, Ih.elements[9] *= u, Ih.elements[10] *= u, e.setFromRotationMatrix(Ih), n.x = i, n.y = o, n.z = s, this
            }
            makePerspective(t, e, n, r, i, o) {
                void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                const s = this.elements,
                    a = 2 * i / (e - t),
                    l = 2 * i / (n - r),
                    u = (e + t) / (e - t),
                    h = (n + r) / (n - r),
                    c = -(o + i) / (o - i),
                    d = -2 * o * i / (o - i);
                return s[0] = a, s[4] = 0, s[8] = u, s[12] = 0, s[1] = 0, s[5] = l, s[9] = h, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = c, s[14] = d, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this
            }
            makeOrthographic(t, e, n, r, i, o) {
                const s = this.elements,
                    a = 1 / (e - t),
                    l = 1 / (n - r),
                    u = 1 / (o - i),
                    h = (e + t) * a,
                    c = (n + r) * l,
                    d = (o + i) * u;
                return s[0] = 2 * a, s[4] = 0, s[8] = 0, s[12] = -h, s[1] = 0, s[5] = 2 * l, s[9] = 0, s[13] = -c, s[2] = 0, s[6] = 0, s[10] = -2 * u, s[14] = -d, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this
            }
            equals(t) {
                const e = this.elements,
                    n = t.elements;
                for (let t = 0; t < 16; t++)
                    if (e[t] !== n[t]) return !1;
                return !0
            }
            fromArray(t, e = 0) {
                for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
                return this
            }
            toArray(t = [], e = 0) {
                const n = this.elements;
                return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
            }
        }
        Rh.prototype.isMatrix4 = !0;
        const Ph = new Ju,
            Ih = new Rh,
            Ch = new Ju(0, 0, 0),
            Oh = new Ju(1, 1, 1),
            Lh = new Ju,
            Nh = new Ju,
            Dh = new Ju,
            Uh = new Rh,
            Fh = new Ku;
        class Bh {
            constructor(t = 0, e = 0, n = 0, r = Bh.DefaultOrder) {
                this._x = t, this._y = e, this._z = n, this._order = r
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t, this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(t) {
                this._order = t, this._onChangeCallback()
            }
            set(t, e, n, r = this._order) {
                return this._x = t, this._y = e, this._z = n, this._order = r, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._order)
            }
            copy(t) {
                return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
            }
            setFromRotationMatrix(t, e = this._order, n = !0) {
                const r = t.elements,
                    i = r[0],
                    o = r[4],
                    s = r[8],
                    a = r[1],
                    l = r[5],
                    u = r[9],
                    h = r[2],
                    c = r[6],
                    d = r[10];
                switch (e) {
                    case "XYZ":
                        this._y = Math.asin(yu(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-u, d), this._z = Math.atan2(-o, i)) : (this._x = Math.atan2(c, l), this._z = 0);
                        break;
                    case "YXZ":
                        this._x = Math.asin(-yu(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(s, d), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-h, i), this._z = 0);
                        break;
                    case "ZXY":
                        this._x = Math.asin(yu(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(a, i));
                        break;
                    case "ZYX":
                        this._y = Math.asin(-yu(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(c, d), this._z = Math.atan2(a, i)) : (this._x = 0, this._z = Math.atan2(-o, l));
                        break;
                    case "YZX":
                        this._z = Math.asin(yu(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-h, i)) : (this._x = 0, this._y = Math.atan2(s, d));
                        break;
                    case "XZY":
                        this._z = Math.asin(-yu(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(c, l), this._y = Math.atan2(s, i)) : (this._x = Math.atan2(-u, d), this._y = 0);
                        break;
                    default:
                        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                }
                return this._order = e, !0 === n && this._onChangeCallback(), this
            }
            setFromQuaternion(t, e, n) {
                return Uh.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Uh, e, n)
            }
            setFromVector3(t, e = this._order) {
                return this.set(t.x, t.y, t.z, e)
            }
            reorder(t) {
                return Fh.setFromEuler(this), this.setFromQuaternion(Fh, t)
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            }
            fromArray(t) {
                return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
            }
            toArray(t = [], e = 0) {
                return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
            }
            _onChange(t) {
                return this._onChangeCallback = t, this
            }
            _onChangeCallback() {}
        }
        Bh.prototype.isEuler = !0, Bh.DefaultOrder = "XYZ", Bh.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
        class kh {
            constructor() {
                this.mask = 1
            }
            set(t) {
                this.mask = (1 << t | 0) >>> 0
            }
            enable(t) {
                this.mask |= 1 << t | 0
            }
            enableAll() {
                this.mask = -1
            }
            toggle(t) {
                this.mask ^= 1 << t | 0
            }
            disable(t) {
                this.mask &= ~(1 << t | 0)
            }
            disableAll() {
                this.mask = 0
            }
            test(t) {
                return 0 != (this.mask & t.mask)
            }
            isEnabled(t) {
                return 0 != (this.mask & (1 << t | 0))
            }
        }
        let Gh = 0;
        const Hh = new Ju,
            zh = new Ku,
            Vh = new Rh,
            Wh = new Ju,
            Xh = new Ju,
            jh = new Ju,
            Yh = new Ku,
            qh = new Ju(1, 0, 0),
            Zh = new Ju(0, 1, 0),
            Kh = new Ju(0, 0, 1),
            Jh = {
                type: "added"
            },
            Qh = {
                type: "removed"
            };
        class $h extends pu {
            constructor() {
                super(), Object.defineProperty(this, "id", {
                    value: Gh++
                }), this.uuid = _u(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = $h.DefaultUp.clone();
                const t = new Ju,
                    e = new Bh,
                    n = new Ku,
                    r = new Ju(1, 1, 1);
                e._onChange((function() {
                    n.setFromEuler(e, !1)
                })), n._onChange((function() {
                    e.setFromQuaternion(n, void 0, !1)
                })), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: r
                    },
                    modelViewMatrix: {
                        value: new Rh
                    },
                    normalMatrix: {
                        value: new Mu
                    }
                }), this.matrix = new Rh, this.matrixWorld = new Rh, this.matrixAutoUpdate = $h.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new kh, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
            }
            onBeforeRender() {}
            onAfterRender() {}
            applyMatrix4(t) {
                this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
            }
            applyQuaternion(t) {
                return this.quaternion.premultiply(t), this
            }
            setRotationFromAxisAngle(t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            }
            setRotationFromEuler(t) {
                this.quaternion.setFromEuler(t, !0)
            }
            setRotationFromMatrix(t) {
                this.quaternion.setFromRotationMatrix(t)
            }
            setRotationFromQuaternion(t) {
                this.quaternion.copy(t)
            }
            rotateOnAxis(t, e) {
                return zh.setFromAxisAngle(t, e), this.quaternion.multiply(zh), this
            }
            rotateOnWorldAxis(t, e) {
                return zh.setFromAxisAngle(t, e), this.quaternion.premultiply(zh), this
            }
            rotateX(t) {
                return this.rotateOnAxis(qh, t)
            }
            rotateY(t) {
                return this.rotateOnAxis(Zh, t)
            }
            rotateZ(t) {
                return this.rotateOnAxis(Kh, t)
            }
            translateOnAxis(t, e) {
                return Hh.copy(t).applyQuaternion(this.quaternion), this.position.add(Hh.multiplyScalar(e)), this
            }
            translateX(t) {
                return this.translateOnAxis(qh, t)
            }
            translateY(t) {
                return this.translateOnAxis(Zh, t)
            }
            translateZ(t) {
                return this.translateOnAxis(Kh, t)
            }
            localToWorld(t) {
                return t.applyMatrix4(this.matrixWorld)
            }
            worldToLocal(t) {
                return t.applyMatrix4(Vh.copy(this.matrixWorld).invert())
            }
            lookAt(t, e, n) {
                t.isVector3 ? Wh.copy(t) : Wh.set(t, e, n);
                const r = this.parent;
                this.updateWorldMatrix(!0, !1), Xh.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Vh.lookAt(Xh, Wh, this.up) : Vh.lookAt(Wh, Xh, this.up), this.quaternion.setFromRotationMatrix(Vh), r && (Vh.extractRotation(r.matrixWorld), zh.setFromRotationMatrix(Vh), this.quaternion.premultiply(zh.invert()))
            }
            add(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                    return this
                }
                return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(Jh)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
            }
            remove(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                    return this
                }
                const e = this.children.indexOf(t);
                return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(Qh)), this
            }
            removeFromParent() {
                const t = this.parent;
                return null !== t && t.remove(this), this
            }
            clear() {
                for (let t = 0; t < this.children.length; t++) {
                    const e = this.children[t];
                    e.parent = null, e.dispatchEvent(Qh)
                }
                return this.children.length = 0, this
            }
            attach(t) {
                return this.updateWorldMatrix(!0, !1), Vh.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Vh.multiply(t.parent.matrixWorld)), t.applyMatrix4(Vh), this.add(t), t.updateWorldMatrix(!1, !0), this
            }
            getObjectById(t) {
                return this.getObjectByProperty("id", t)
            }
            getObjectByName(t) {
                return this.getObjectByProperty("name", t)
            }
            getObjectByProperty(t, e) {
                if (this[t] === e) return this;
                for (let n = 0, r = this.children.length; n < r; n++) {
                    const r = this.children[n].getObjectByProperty(t, e);
                    if (void 0 !== r) return r
                }
            }
            getWorldPosition(t) {
                return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
            }
            getWorldQuaternion(t) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Xh, t, jh), t
            }
            getWorldScale(t) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Xh, Yh, t), t
            }
            getWorldDirection(t) {
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(e[8], e[9], e[10]).normalize()
            }
            raycast() {}
            traverse(t) {
                t(this);
                const e = this.children;
                for (let n = 0, r = e.length; n < r; n++) e[n].traverse(t)
            }
            traverseVisible(t) {
                if (!1 === this.visible) return;
                t(this);
                const e = this.children;
                for (let n = 0, r = e.length; n < r; n++) e[n].traverseVisible(t)
            }
            traverseAncestors(t) {
                const e = this.parent;
                null !== e && (t(e), e.traverseAncestors(t))
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            }
            updateMatrixWorld(t) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                const e = this.children;
                for (let n = 0, r = e.length; n < r; n++) e[n].updateMatrixWorld(t)
            }
            updateWorldMatrix(t, e) {
                const n = this.parent;
                if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
                    const t = this.children;
                    for (let e = 0, n = t.length; e < n; e++) t[e].updateWorldMatrix(!1, !0)
                }
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t,
                    n = {};
                e && (t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {},
                    nodes: {}
                }, n.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const r = {};

                function i(e, n) {
                    return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
                }
                if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && (r.environment = this.environment.toJSON(t).uuid);
                else if (this.isMesh || this.isLine || this.isPoints) {
                    r.geometry = i(t.geometries, this.geometry);
                    const e = this.geometry.parameters;
                    if (void 0 !== e && void 0 !== e.shapes) {
                        const n = e.shapes;
                        if (Array.isArray(n))
                            for (let e = 0, r = n.length; e < r; e++) {
                                const r = n[e];
                                i(t.shapes, r)
                            } else i(t.shapes, n)
                    }
                }
                if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (i(t.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        const e = [];
                        for (let n = 0, r = this.material.length; n < r; n++) e.push(i(t.materials, this.material[n]));
                        r.material = e
                    } else r.material = i(t.materials, this.material);
                if (this.children.length > 0) {
                    r.children = [];
                    for (let e = 0; e < this.children.length; e++) r.children.push(this.children[e].toJSON(t).object)
                }
                if (this.animations.length > 0) {
                    r.animations = [];
                    for (let e = 0; e < this.animations.length; e++) {
                        const n = this.animations[e];
                        r.animations.push(i(t.animations, n))
                    }
                }
                if (e) {
                    const e = o(t.geometries),
                        r = o(t.materials),
                        i = o(t.textures),
                        s = o(t.images),
                        a = o(t.shapes),
                        l = o(t.skeletons),
                        u = o(t.animations),
                        h = o(t.nodes);
                    e.length > 0 && (n.geometries = e), r.length > 0 && (n.materials = r), i.length > 0 && (n.textures = i), s.length > 0 && (n.images = s), a.length > 0 && (n.shapes = a), l.length > 0 && (n.skeletons = l), u.length > 0 && (n.animations = u), h.length > 0 && (n.nodes = h)
                }
                return n.object = r, n;

                function o(t) {
                    const e = [];
                    for (const n in t) {
                        const r = t[n];
                        delete r.metadata, e.push(r)
                    }
                    return e
                }
            }
            clone(t) {
                return (new this.constructor).copy(this, t)
            }
            copy(t, e = !0) {
                if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                    for (let e = 0; e < t.children.length; e++) {
                        const n = t.children[e];
                        this.add(n.clone())
                    }
                return this
            }
        }
        $h.DefaultUp = new Ju(0, 1, 0), $h.DefaultMatrixAutoUpdate = !0, $h.prototype.isObject3D = !0;
        const tc = new Ju,
            ec = new Ju,
            nc = new Ju,
            rc = new Ju,
            ic = new Ju,
            oc = new Ju,
            sc = new Ju,
            ac = new Ju,
            lc = new Ju,
            uc = new Ju;
        class hc {
            constructor(t = new Ju, e = new Ju, n = new Ju) {
                this.a = t, this.b = e, this.c = n
            }
            static getNormal(t, e, n, r) {
                r.subVectors(n, e), tc.subVectors(t, e), r.cross(tc);
                const i = r.lengthSq();
                return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
            }
            static getBarycoord(t, e, n, r, i) {
                tc.subVectors(r, e), ec.subVectors(n, e), nc.subVectors(t, e);
                const o = tc.dot(tc),
                    s = tc.dot(ec),
                    a = tc.dot(nc),
                    l = ec.dot(ec),
                    u = ec.dot(nc),
                    h = o * l - s * s;
                if (0 === h) return i.set(-2, -1, -1);
                const c = 1 / h,
                    d = (l * a - s * u) * c,
                    p = (o * u - s * a) * c;
                return i.set(1 - d - p, p, d)
            }
            static containsPoint(t, e, n, r) {
                return this.getBarycoord(t, e, n, r, rc), rc.x >= 0 && rc.y >= 0 && rc.x + rc.y <= 1
            }
            static getUV(t, e, n, r, i, o, s, a) {
                return this.getBarycoord(t, e, n, r, rc), a.set(0, 0), a.addScaledVector(i, rc.x), a.addScaledVector(o, rc.y), a.addScaledVector(s, rc.z), a
            }
            static isFrontFacing(t, e, n, r) {
                return tc.subVectors(n, e), ec.subVectors(t, e), tc.cross(ec).dot(r) < 0
            }
            set(t, e, n) {
                return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
            }
            setFromPointsAndIndices(t, e, n, r) {
                return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this
            }
            setFromAttributeAndIndices(t, e, n, r) {
                return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, r), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
            }
            getArea() {
                return tc.subVectors(this.c, this.b), ec.subVectors(this.a, this.b), .5 * tc.cross(ec).length()
            }
            getMidpoint(t) {
                return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(t) {
                return hc.getNormal(this.a, this.b, this.c, t)
            }
            getPlane(t) {
                return t.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(t, e) {
                return hc.getBarycoord(t, this.a, this.b, this.c, e)
            }
            getUV(t, e, n, r, i) {
                return hc.getUV(t, this.a, this.b, this.c, e, n, r, i)
            }
            containsPoint(t) {
                return hc.containsPoint(t, this.a, this.b, this.c)
            }
            isFrontFacing(t) {
                return hc.isFrontFacing(this.a, this.b, this.c, t)
            }
            intersectsBox(t) {
                return t.intersectsTriangle(this)
            }
            closestPointToPoint(t, e) {
                const n = this.a,
                    r = this.b,
                    i = this.c;
                let o, s;
                ic.subVectors(r, n), oc.subVectors(i, n), ac.subVectors(t, n);
                const a = ic.dot(ac),
                    l = oc.dot(ac);
                if (a <= 0 && l <= 0) return e.copy(n);
                lc.subVectors(t, r);
                const u = ic.dot(lc),
                    h = oc.dot(lc);
                if (u >= 0 && h <= u) return e.copy(r);
                const c = a * h - u * l;
                if (c <= 0 && a >= 0 && u <= 0) return o = a / (a - u), e.copy(n).addScaledVector(ic, o);
                uc.subVectors(t, i);
                const d = ic.dot(uc),
                    p = oc.dot(uc);
                if (p >= 0 && d <= p) return e.copy(i);
                const f = d * l - a * p;
                if (f <= 0 && l >= 0 && p <= 0) return s = l / (l - p), e.copy(n).addScaledVector(oc, s);
                const m = u * p - d * h;
                if (m <= 0 && h - u >= 0 && d - p >= 0) return sc.subVectors(i, r), s = (h - u) / (h - u + (d - p)), e.copy(r).addScaledVector(sc, s);
                const g = 1 / (m + f + c);
                return o = f * g, s = c * g, e.copy(n).addScaledVector(ic, o).addScaledVector(oc, s)
            }
            equals(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        }
        let cc = 0;
        class dc extends pu {
            constructor() {
                super(), Object.defineProperty(this, "id", {
                    value: cc++
                }), this.uuid = _u(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = Pl, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = lu, this.stencilZFail = lu, this.stencilZPass = lu, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
            }
            get alphaTest() {
                return this._alphaTest
            }
            set alphaTest(t) {
                this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t
            }
            onBuild() {}
            onBeforeRender() {}
            onBeforeCompile() {}
            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }
            setValues(t) {
                if (void 0 !== t)
                    for (const e in t) {
                        const n = t[e];
                        if (void 0 === n) {
                            console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                            continue
                        }
                        if ("shading" === e) {
                            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                            continue
                        }
                        const r = this[e];
                        void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                    }
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                e && (t = {
                    textures: {},
                    images: {}
                });
                const n = {
                    metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };

                function r(t) {
                    const e = [];
                    for (const n in t) {
                        const r = t[n];
                        delete r.metadata, e.push(r)
                    }
                    return e
                }
                if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                    const e = r(t.textures),
                        i = r(t.images);
                    e.length > 0 && (n.textures = e), i.length > 0 && (n.images = i)
                }
                return n
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                const e = t.clippingPlanes;
                let n = null;
                if (null !== e) {
                    const t = e.length;
                    n = new Array(t);
                    for (let r = 0; r !== t; ++r) n[r] = e[r].clone()
                }
                return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
        }
        dc.prototype.isMaterial = !0, dc.fromType = function() {
            return null
        };
        class pc extends dc {
            constructor(t) {
                super(), this.type = "MeshBasicMaterial", this.color = new ku(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
            }
        }
        pc.prototype.isMeshBasicMaterial = !0;
        const fc = new Ju,
            mc = new wu;
        class gc {
            constructor(t, e, n) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = uu, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }
            onUploadCallback() {}
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            setUsage(t) {
                return this.usage = t, this
            }
            copy(t) {
                return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this
            }
            copyAt(t, e, n) {
                t *= this.itemSize, n *= e.itemSize;
                for (let r = 0, i = this.itemSize; r < i; r++) this.array[t + r] = e.array[n + r];
                return this
            }
            copyArray(t) {
                return this.array.set(t), this
            }
            copyColorsArray(t) {
                const e = this.array;
                let n = 0;
                for (let r = 0, i = t.length; r < i; r++) {
                    let i = t[r];
                    void 0 === i && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), i = new ku), e[n++] = i.r, e[n++] = i.g, e[n++] = i.b
                }
                return this
            }
            copyVector2sArray(t) {
                const e = this.array;
                let n = 0;
                for (let r = 0, i = t.length; r < i; r++) {
                    let i = t[r];
                    void 0 === i && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), i = new wu), e[n++] = i.x, e[n++] = i.y
                }
                return this
            }
            copyVector3sArray(t) {
                const e = this.array;
                let n = 0;
                for (let r = 0, i = t.length; r < i; r++) {
                    let i = t[r];
                    void 0 === i && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), i = new Ju), e[n++] = i.x, e[n++] = i.y, e[n++] = i.z
                }
                return this
            }
            copyVector4sArray(t) {
                const e = this.array;
                let n = 0;
                for (let r = 0, i = t.length; r < i; r++) {
                    let i = t[r];
                    void 0 === i && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), i = new ju), e[n++] = i.x, e[n++] = i.y, e[n++] = i.z, e[n++] = i.w
                }
                return this
            }
            applyMatrix3(t) {
                if (2 === this.itemSize)
                    for (let e = 0, n = this.count; e < n; e++) mc.fromBufferAttribute(this, e), mc.applyMatrix3(t), this.setXY(e, mc.x, mc.y);
                else if (3 === this.itemSize)
                    for (let e = 0, n = this.count; e < n; e++) fc.fromBufferAttribute(this, e), fc.applyMatrix3(t), this.setXYZ(e, fc.x, fc.y, fc.z);
                return this
            }
            applyMatrix4(t) {
                for (let e = 0, n = this.count; e < n; e++) fc.fromBufferAttribute(this, e), fc.applyMatrix4(t), this.setXYZ(e, fc.x, fc.y, fc.z);
                return this
            }
            applyNormalMatrix(t) {
                for (let e = 0, n = this.count; e < n; e++) fc.fromBufferAttribute(this, e), fc.applyNormalMatrix(t), this.setXYZ(e, fc.x, fc.y, fc.z);
                return this
            }
            transformDirection(t) {
                for (let e = 0, n = this.count; e < n; e++) fc.fromBufferAttribute(this, e), fc.transformDirection(t), this.setXYZ(e, fc.x, fc.y, fc.z);
                return this
            }
            set(t, e = 0) {
                return this.array.set(t, e), this
            }
            getX(t) {
                return this.array[t * this.itemSize]
            }
            setX(t, e) {
                return this.array[t * this.itemSize] = e, this
            }
            getY(t) {
                return this.array[t * this.itemSize + 1]
            }
            setY(t, e) {
                return this.array[t * this.itemSize + 1] = e, this
            }
            getZ(t) {
                return this.array[t * this.itemSize + 2]
            }
            setZ(t, e) {
                return this.array[t * this.itemSize + 2] = e, this
            }
            getW(t) {
                return this.array[t * this.itemSize + 3]
            }
            setW(t, e) {
                return this.array[t * this.itemSize + 3] = e, this
            }
            setXY(t, e, n) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
            }
            setXYZ(t, e, n, r) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this
            }
            setXYZW(t, e, n, r, i) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this.array[t + 3] = i, this
            }
            onUpload(t) {
                return this.onUploadCallback = t, this
            }
            clone() {
                return new this.constructor(this.array, this.itemSize).copy(this)
            }
            toJSON() {
                const t = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.prototype.slice.call(this.array),
                    normalized: this.normalized
                };
                return "" !== this.name && (t.name = this.name), this.usage !== uu && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t
            }
        }
        gc.prototype.isBufferAttribute = !0;
        class vc extends gc {
            constructor(t, e, n) {
                super(new Uint16Array(t), e, n)
            }
        }
        class _c extends gc {
            constructor(t, e, n) {
                super(new Uint32Array(t), e, n)
            }
        }(class extends gc {
            constructor(t, e, n) {
                super(new Uint16Array(t), e, n)
            }
        }).prototype.isFloat16BufferAttribute = !0;
        class yc extends gc {
            constructor(t, e, n) {
                super(new Float32Array(t), e, n)
            }
        }
        let xc = 0;
        const bc = new Rh,
            Ec = new $h,
            Tc = new Ju,
            Sc = new th,
            wc = new th,
            Mc = new Ju;
        class Ac extends pu {
            constructor() {
                super(), Object.defineProperty(this, "id", {
                    value: xc++
                }), this.uuid = _u(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }
            getIndex() {
                return this.index
            }
            setIndex(t) {
                return Array.isArray(t) ? this.index = new(Au(t) ? _c : vc)(t, 1) : this.index = t, this
            }
            getAttribute(t) {
                return this.attributes[t]
            }
            setAttribute(t, e) {
                return this.attributes[t] = e, this
            }
            deleteAttribute(t) {
                return delete this.attributes[t], this
            }
            hasAttribute(t) {
                return void 0 !== this.attributes[t]
            }
            addGroup(t, e, n = 0) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: n
                })
            }
            clearGroups() {
                this.groups = []
            }
            setDrawRange(t, e) {
                this.drawRange.start = t, this.drawRange.count = e
            }
            applyMatrix4(t) {
                const e = this.attributes.position;
                void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                const n = this.attributes.normal;
                if (void 0 !== n) {
                    const e = (new Mu).getNormalMatrix(t);
                    n.applyNormalMatrix(e), n.needsUpdate = !0
                }
                const r = this.attributes.tangent;
                return void 0 !== r && (r.transformDirection(t), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            }
            applyQuaternion(t) {
                return bc.makeRotationFromQuaternion(t), this.applyMatrix4(bc), this
            }
            rotateX(t) {
                return bc.makeRotationX(t), this.applyMatrix4(bc), this
            }
            rotateY(t) {
                return bc.makeRotationY(t), this.applyMatrix4(bc), this
            }
            rotateZ(t) {
                return bc.makeRotationZ(t), this.applyMatrix4(bc), this
            }
            translate(t, e, n) {
                return bc.makeTranslation(t, e, n), this.applyMatrix4(bc), this
            }
            scale(t, e, n) {
                return bc.makeScale(t, e, n), this.applyMatrix4(bc), this
            }
            lookAt(t) {
                return Ec.lookAt(t), Ec.updateMatrix(), this.applyMatrix4(Ec.matrix), this
            }
            center() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(Tc).negate(), this.translate(Tc.x, Tc.y, Tc.z), this
            }
            setFromPoints(t) {
                const e = [];
                for (let n = 0, r = t.length; n < r; n++) {
                    const r = t[n];
                    e.push(r.x, r.y, r.z || 0)
                }
                return this.setAttribute("position", new yc(e, 3)), this
            }
            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new th);
                const t = this.attributes.position,
                    e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Ju(-1 / 0, -1 / 0, -1 / 0), new Ju(1 / 0, 1 / 0, 1 / 0));
                if (void 0 !== t) {
                    if (this.boundingBox.setFromBufferAttribute(t), e)
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            Sc.setFromBufferAttribute(n), this.morphTargetsRelative ? (Mc.addVectors(this.boundingBox.min, Sc.min), this.boundingBox.expandByPoint(Mc), Mc.addVectors(this.boundingBox.max, Sc.max), this.boundingBox.expandByPoint(Mc)) : (this.boundingBox.expandByPoint(Sc.min), this.boundingBox.expandByPoint(Sc.max))
                        }
                } else this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new yh);
                const t = this.attributes.position,
                    e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Ju, 1 / 0);
                if (t) {
                    const n = this.boundingSphere.center;
                    if (Sc.setFromBufferAttribute(t), e)
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            wc.setFromBufferAttribute(n), this.morphTargetsRelative ? (Mc.addVectors(Sc.min, wc.min), Sc.expandByPoint(Mc), Mc.addVectors(Sc.max, wc.max), Sc.expandByPoint(Mc)) : (Sc.expandByPoint(wc.min), Sc.expandByPoint(wc.max))
                        }
                    Sc.getCenter(n);
                    let r = 0;
                    for (let e = 0, i = t.count; e < i; e++) Mc.fromBufferAttribute(t, e), r = Math.max(r, n.distanceToSquared(Mc));
                    if (e)
                        for (let i = 0, o = e.length; i < o; i++) {
                            const o = e[i],
                                s = this.morphTargetsRelative;
                            for (let e = 0, i = o.count; e < i; e++) Mc.fromBufferAttribute(o, e), s && (Tc.fromBufferAttribute(t, e), Mc.add(Tc)), r = Math.max(r, n.distanceToSquared(Mc))
                        }
                    this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
            computeTangents() {
                const t = this.index,
                    e = this.attributes;
                if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const n = t.array,
                    r = e.position.array,
                    i = e.normal.array,
                    o = e.uv.array,
                    s = r.length / 3;
                !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new gc(new Float32Array(4 * s), 4));
                const a = this.getAttribute("tangent").array,
                    l = [],
                    u = [];
                for (let t = 0; t < s; t++) l[t] = new Ju, u[t] = new Ju;
                const h = new Ju,
                    c = new Ju,
                    d = new Ju,
                    p = new wu,
                    f = new wu,
                    m = new wu,
                    g = new Ju,
                    v = new Ju;

                function _(t, e, n) {
                    h.fromArray(r, 3 * t), c.fromArray(r, 3 * e), d.fromArray(r, 3 * n), p.fromArray(o, 2 * t), f.fromArray(o, 2 * e), m.fromArray(o, 2 * n), c.sub(h), d.sub(h), f.sub(p), m.sub(p);
                    const i = 1 / (f.x * m.y - m.x * f.y);
                    isFinite(i) && (g.copy(c).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(i), v.copy(d).multiplyScalar(f.x).addScaledVector(c, -m.x).multiplyScalar(i), l[t].add(g), l[e].add(g), l[n].add(g), u[t].add(v), u[e].add(v), u[n].add(v))
                }
                let y = this.groups;
                0 === y.length && (y = [{
                    start: 0,
                    count: n.length
                }]);
                for (let t = 0, e = y.length; t < e; ++t) {
                    const e = y[t],
                        r = e.start;
                    for (let t = r, i = r + e.count; t < i; t += 3) _(n[t + 0], n[t + 1], n[t + 2])
                }
                const x = new Ju,
                    b = new Ju,
                    E = new Ju,
                    T = new Ju;

                function S(t) {
                    E.fromArray(i, 3 * t), T.copy(E);
                    const e = l[t];
                    x.copy(e), x.sub(E.multiplyScalar(E.dot(e))).normalize(), b.crossVectors(T, e);
                    const n = b.dot(u[t]) < 0 ? -1 : 1;
                    a[4 * t] = x.x, a[4 * t + 1] = x.y, a[4 * t + 2] = x.z, a[4 * t + 3] = n
                }
                for (let t = 0, e = y.length; t < e; ++t) {
                    const e = y[t],
                        r = e.start;
                    for (let t = r, i = r + e.count; t < i; t += 3) S(n[t + 0]), S(n[t + 1]), S(n[t + 2])
                }
            }
            computeVertexNormals() {
                const t = this.index,
                    e = this.getAttribute("position");
                if (void 0 !== e) {
                    let n = this.getAttribute("normal");
                    if (void 0 === n) n = new gc(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                    else
                        for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
                    const r = new Ju,
                        i = new Ju,
                        o = new Ju,
                        s = new Ju,
                        a = new Ju,
                        l = new Ju,
                        u = new Ju,
                        h = new Ju;
                    if (t)
                        for (let c = 0, d = t.count; c < d; c += 3) {
                            const d = t.getX(c + 0),
                                p = t.getX(c + 1),
                                f = t.getX(c + 2);
                            r.fromBufferAttribute(e, d), i.fromBufferAttribute(e, p), o.fromBufferAttribute(e, f), u.subVectors(o, i), h.subVectors(r, i), u.cross(h), s.fromBufferAttribute(n, d), a.fromBufferAttribute(n, p), l.fromBufferAttribute(n, f), s.add(u), a.add(u), l.add(u), n.setXYZ(d, s.x, s.y, s.z), n.setXYZ(p, a.x, a.y, a.z), n.setXYZ(f, l.x, l.y, l.z)
                        } else
                            for (let t = 0, s = e.count; t < s; t += 3) r.fromBufferAttribute(e, t + 0), i.fromBufferAttribute(e, t + 1), o.fromBufferAttribute(e, t + 2), u.subVectors(o, i), h.subVectors(r, i), u.cross(h), n.setXYZ(t + 0, u.x, u.y, u.z), n.setXYZ(t + 1, u.x, u.y, u.z), n.setXYZ(t + 2, u.x, u.y, u.z);
                    this.normalizeNormals(), n.needsUpdate = !0
                }
            }
            merge(t, e) {
                if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                const n = this.attributes;
                for (const r in n) {
                    if (void 0 === t.attributes[r]) continue;
                    const i = n[r].array,
                        o = t.attributes[r],
                        s = o.array,
                        a = o.itemSize * e,
                        l = Math.min(s.length, i.length - a);
                    for (let t = 0, e = a; t < l; t++, e++) i[e] = s[t]
                }
                return this
            }
            normalizeNormals() {
                const t = this.attributes.normal;
                for (let e = 0, n = t.count; e < n; e++) Mc.fromBufferAttribute(t, e), Mc.normalize(), t.setXYZ(e, Mc.x, Mc.y, Mc.z)
            }
            toNonIndexed() {
                function t(t, e) {
                    const n = t.array,
                        r = t.itemSize,
                        i = t.normalized,
                        o = new n.constructor(e.length * r);
                    let s = 0,
                        a = 0;
                    for (let i = 0, l = e.length; i < l; i++) {
                        s = t.isInterleavedBufferAttribute ? e[i] * t.data.stride + t.offset : e[i] * r;
                        for (let t = 0; t < r; t++) o[a++] = n[s++]
                    }
                    return new gc(o, r, i)
                }
                if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                const e = new Ac,
                    n = this.index.array,
                    r = this.attributes;
                for (const i in r) {
                    const o = t(r[i], n);
                    e.setAttribute(i, o)
                }
                const i = this.morphAttributes;
                for (const r in i) {
                    const o = [],
                        s = i[r];
                    for (let e = 0, r = s.length; e < r; e++) {
                        const r = t(s[e], n);
                        o.push(r)
                    }
                    e.morphAttributes[r] = o
                }
                e.morphTargetsRelative = this.morphTargetsRelative;
                const o = this.groups;
                for (let t = 0, n = o.length; t < n; t++) {
                    const n = o[t];
                    e.addGroup(n.start, n.count, n.materialIndex)
                }
                return e
            }
            toJSON() {
                const t = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                    const e = this.parameters;
                    for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                    return t
                }
                t.data = {
                    attributes: {}
                };
                const e = this.index;
                null !== e && (t.data.index = {
                    type: e.array.constructor.name,
                    array: Array.prototype.slice.call(e.array)
                });
                const n = this.attributes;
                for (const e in n) {
                    const r = n[e];
                    t.data.attributes[e] = r.toJSON(t.data)
                }
                const r = {};
                let i = !1;
                for (const e in this.morphAttributes) {
                    const n = this.morphAttributes[e],
                        o = [];
                    for (let e = 0, r = n.length; e < r; e++) {
                        const r = n[e];
                        o.push(r.toJSON(t.data))
                    }
                    o.length > 0 && (r[e] = o, i = !0)
                }
                i && (t.data.morphAttributes = r, t.data.morphTargetsRelative = this.morphTargetsRelative);
                const o = this.groups;
                o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
                const s = this.boundingSphere;
                return null !== s && (t.data.boundingSphere = {
                    center: s.center.toArray(),
                    radius: s.radius
                }), t
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                const e = {};
                this.name = t.name;
                const n = t.index;
                null !== n && this.setIndex(n.clone(e));
                const r = t.attributes;
                for (const t in r) {
                    const n = r[t];
                    this.setAttribute(t, n.clone(e))
                }
                const i = t.morphAttributes;
                for (const t in i) {
                    const n = [],
                        r = i[t];
                    for (let t = 0, i = r.length; t < i; t++) n.push(r[t].clone(e));
                    this.morphAttributes[t] = n
                }
                this.morphTargetsRelative = t.morphTargetsRelative;
                const o = t.groups;
                for (let t = 0, e = o.length; t < e; t++) {
                    const e = o[t];
                    this.addGroup(e.start, e.count, e.materialIndex)
                }
                const s = t.boundingBox;
                null !== s && (this.boundingBox = s.clone());
                const a = t.boundingSphere;
                return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, void 0 !== t.parameters && (this.parameters = Object.assign({}, t.parameters)), this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        Ac.prototype.isBufferGeometry = !0;
        const Rc = new Rh,
            Pc = new Ah,
            Ic = new yh,
            Cc = new Ju,
            Oc = new Ju,
            Lc = new Ju,
            Nc = new Ju,
            Dc = new Ju,
            Uc = new Ju,
            Fc = new Ju,
            Bc = new Ju,
            kc = new Ju,
            Gc = new wu,
            Hc = new wu,
            zc = new wu,
            Vc = new Ju,
            Wc = new Ju;
        class Xc extends $h {
            constructor(t = new Ac, e = new pc) {
                super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
            }
            copy(t) {
                return super.copy(t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
            }
            updateMorphTargets() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes,
                        n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
            raycast(t, e) {
                const n = this.geometry,
                    r = this.material,
                    i = this.matrixWorld;
                if (void 0 === r) return;
                if (null === n.boundingSphere && n.computeBoundingSphere(), Ic.copy(n.boundingSphere), Ic.applyMatrix4(i), !1 === t.ray.intersectsSphere(Ic)) return;
                if (Rc.copy(i).invert(), Pc.copy(t.ray).applyMatrix4(Rc), null !== n.boundingBox && !1 === Pc.intersectsBox(n.boundingBox)) return;
                let o;
                if (n.isBufferGeometry) {
                    const i = n.index,
                        s = n.attributes.position,
                        a = n.morphAttributes.position,
                        l = n.morphTargetsRelative,
                        u = n.attributes.uv,
                        h = n.attributes.uv2,
                        c = n.groups,
                        d = n.drawRange;
                    if (null !== i)
                        if (Array.isArray(r))
                            for (let n = 0, p = c.length; n < p; n++) {
                                const p = c[n],
                                    f = r[p.materialIndex];
                                for (let n = Math.max(p.start, d.start), r = Math.min(i.count, Math.min(p.start + p.count, d.start + d.count)); n < r; n += 3) {
                                    const r = i.getX(n),
                                        c = i.getX(n + 1),
                                        d = i.getX(n + 2);
                                    o = jc(this, f, t, Pc, s, a, l, u, h, r, c, d), o && (o.faceIndex = Math.floor(n / 3), o.face.materialIndex = p.materialIndex, e.push(o))
                                }
                            } else
                                for (let n = Math.max(0, d.start), c = Math.min(i.count, d.start + d.count); n < c; n += 3) {
                                    const c = i.getX(n),
                                        d = i.getX(n + 1),
                                        p = i.getX(n + 2);
                                    o = jc(this, r, t, Pc, s, a, l, u, h, c, d, p), o && (o.faceIndex = Math.floor(n / 3), e.push(o))
                                } else if (void 0 !== s)
                                    if (Array.isArray(r))
                                        for (let n = 0, i = c.length; n < i; n++) {
                                            const i = c[n],
                                                p = r[i.materialIndex];
                                            for (let n = Math.max(i.start, d.start), r = Math.min(s.count, Math.min(i.start + i.count, d.start + d.count)); n < r; n += 3) o = jc(this, p, t, Pc, s, a, l, u, h, n, n + 1, n + 2), o && (o.faceIndex = Math.floor(n / 3), o.face.materialIndex = i.materialIndex, e.push(o))
                                        } else
                                            for (let n = Math.max(0, d.start), i = Math.min(s.count, d.start + d.count); n < i; n += 3) o = jc(this, r, t, Pc, s, a, l, u, h, n, n + 1, n + 2), o && (o.faceIndex = Math.floor(n / 3), e.push(o))
                } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }

        function jc(t, e, n, r, i, o, s, a, l, u, h, c) {
            Cc.fromBufferAttribute(i, u), Oc.fromBufferAttribute(i, h), Lc.fromBufferAttribute(i, c);
            const d = t.morphTargetInfluences;
            if (o && d) {
                Fc.set(0, 0, 0), Bc.set(0, 0, 0), kc.set(0, 0, 0);
                for (let t = 0, e = o.length; t < e; t++) {
                    const e = d[t],
                        n = o[t];
                    0 !== e && (Nc.fromBufferAttribute(n, u), Dc.fromBufferAttribute(n, h), Uc.fromBufferAttribute(n, c), s ? (Fc.addScaledVector(Nc, e), Bc.addScaledVector(Dc, e), kc.addScaledVector(Uc, e)) : (Fc.addScaledVector(Nc.sub(Cc), e), Bc.addScaledVector(Dc.sub(Oc), e), kc.addScaledVector(Uc.sub(Lc), e)))
                }
                Cc.add(Fc), Oc.add(Bc), Lc.add(kc)
            }
            t.isSkinnedMesh && (t.boneTransform(u, Cc), t.boneTransform(h, Oc), t.boneTransform(c, Lc));
            const p = function(t, e, n, r, i, o, s, a) {
                let l;
                if (l = 1 === e.side ? r.intersectTriangle(s, o, i, !0, a) : r.intersectTriangle(i, o, s, 2 !== e.side, a), null === l) return null;
                Wc.copy(a), Wc.applyMatrix4(t.matrixWorld);
                const u = n.ray.origin.distanceTo(Wc);
                return u < n.near || u > n.far ? null : {
                    distance: u,
                    point: Wc.clone(),
                    object: t
                }
            }(t, e, n, r, Cc, Oc, Lc, Vc);
            if (p) {
                a && (Gc.fromBufferAttribute(a, u), Hc.fromBufferAttribute(a, h), zc.fromBufferAttribute(a, c), p.uv = hc.getUV(Vc, Cc, Oc, Lc, Gc, Hc, zc, new wu)), l && (Gc.fromBufferAttribute(l, u), Hc.fromBufferAttribute(l, h), zc.fromBufferAttribute(l, c), p.uv2 = hc.getUV(Vc, Cc, Oc, Lc, Gc, Hc, zc, new wu));
                const t = {
                    a: u,
                    b: h,
                    c,
                    normal: new Ju,
                    materialIndex: 0
                };
                hc.getNormal(Cc, Oc, Lc, t.normal), p.face = t
            }
            return p
        }
        Xc.prototype.isMesh = !0;
        class Yc extends Ac {
            constructor(t = 1, e = 1, n = 1, r = 1, i = 1, o = 1) {
                super(), this.type = "BoxGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: r,
                    heightSegments: i,
                    depthSegments: o
                };
                const s = this;
                r = Math.floor(r), i = Math.floor(i), o = Math.floor(o);
                const a = [],
                    l = [],
                    u = [],
                    h = [];
                let c = 0,
                    d = 0;

                function p(t, e, n, r, i, o, p, f, m, g, v) {
                    const _ = o / m,
                        y = p / g,
                        x = o / 2,
                        b = p / 2,
                        E = f / 2,
                        T = m + 1,
                        S = g + 1;
                    let w = 0,
                        M = 0;
                    const A = new Ju;
                    for (let o = 0; o < S; o++) {
                        const s = o * y - b;
                        for (let a = 0; a < T; a++) {
                            const c = a * _ - x;
                            A[t] = c * r, A[e] = s * i, A[n] = E, l.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = f > 0 ? 1 : -1, u.push(A.x, A.y, A.z), h.push(a / m), h.push(1 - o / g), w += 1
                        }
                    }
                    for (let t = 0; t < g; t++)
                        for (let e = 0; e < m; e++) {
                            const n = c + e + T * t,
                                r = c + e + T * (t + 1),
                                i = c + (e + 1) + T * (t + 1),
                                o = c + (e + 1) + T * t;
                            a.push(n, r, o), a.push(r, i, o), M += 6
                        }
                    s.addGroup(d, M, v), d += M, c += w
                }
                p("z", "y", "x", -1, -1, n, e, t, o, i, 0), p("z", "y", "x", 1, -1, n, e, -t, o, i, 1), p("x", "z", "y", 1, 1, t, n, e, r, o, 2), p("x", "z", "y", 1, -1, t, n, -e, r, o, 3), p("x", "y", "z", 1, -1, t, e, n, r, i, 4), p("x", "y", "z", -1, -1, t, e, -n, r, i, 5), this.setIndex(a), this.setAttribute("position", new yc(l, 3)), this.setAttribute("normal", new yc(u, 3)), this.setAttribute("uv", new yc(h, 2))
            }
            static fromJSON(t) {
                return new Yc(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
            }
        }

        function qc(t) {
            const e = {};
            for (const n in t) {
                e[n] = {};
                for (const r in t[n]) {
                    const i = t[n][r];
                    i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? e[n][r] = i.clone() : Array.isArray(i) ? e[n][r] = i.slice() : e[n][r] = i
                }
            }
            return e
        }

        function Zc(t) {
            const e = {};
            for (let n = 0; n < t.length; n++) {
                const r = qc(t[n]);
                for (const t in r) e[t] = r[t]
            }
            return e
        }
        const Kc = {
            clone: qc,
            merge: Zc
        };
        class Jc extends dc {
            constructor(t) {
                super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
            }
            copy(t) {
                return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = qc(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                e.glslVersion = this.glslVersion, e.uniforms = {};
                for (const n in this.uniforms) {
                    const r = this.uniforms[n].value;
                    r && r.isTexture ? e.uniforms[n] = {
                        type: "t",
                        value: r.toJSON(t).uuid
                    } : r && r.isColor ? e.uniforms[n] = {
                        type: "c",
                        value: r.getHex()
                    } : r && r.isVector2 ? e.uniforms[n] = {
                        type: "v2",
                        value: r.toArray()
                    } : r && r.isVector3 ? e.uniforms[n] = {
                        type: "v3",
                        value: r.toArray()
                    } : r && r.isVector4 ? e.uniforms[n] = {
                        type: "v4",
                        value: r.toArray()
                    } : r && r.isMatrix3 ? e.uniforms[n] = {
                        type: "m3",
                        value: r.toArray()
                    } : r && r.isMatrix4 ? e.uniforms[n] = {
                        type: "m4",
                        value: r.toArray()
                    } : e.uniforms[n] = {
                        value: r
                    }
                }
                Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
                const n = {};
                for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
                return Object.keys(n).length > 0 && (e.extensions = n), e
            }
        }
        Jc.prototype.isShaderMaterial = !0;
        class Qc extends $h {
            constructor() {
                super(), this.type = "Camera", this.matrixWorldInverse = new Rh, this.projectionMatrix = new Rh, this.projectionMatrixInverse = new Rh
            }
            copy(t, e) {
                return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
            }
            getWorldDirection(t) {
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(-e[8], -e[9], -e[10]).normalize()
            }
            updateMatrixWorld(t) {
                super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            updateWorldMatrix(t, e) {
                super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        Qc.prototype.isCamera = !0;
        class $c extends Qc {
            constructor(t = 50, e = 1, n = .1, r = 2e3) {
                super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }
            copy(t, e) {
                return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
            }
            setFocalLength(t) {
                const e = .5 * this.getFilmHeight() / t;
                this.fov = 2 * vu * Math.atan(e), this.updateProjectionMatrix()
            }
            getFocalLength() {
                const t = Math.tan(.5 * gu * this.fov);
                return .5 * this.getFilmHeight() / t
            }
            getEffectiveFOV() {
                return 2 * vu * Math.atan(Math.tan(.5 * gu * this.fov) / this.zoom)
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }
            setViewOffset(t, e, n, r, i, o) {
                this.aspect = t / e, null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = this.near;
                let e = t * Math.tan(.5 * gu * this.fov) / this.zoom,
                    n = 2 * e,
                    r = this.aspect * n,
                    i = -.5 * r;
                const o = this.view;
                if (null !== this.view && this.view.enabled) {
                    const t = o.fullWidth,
                        s = o.fullHeight;
                    i += o.offsetX * r / t, e -= o.offsetY * n / s, r *= o.width / t, n *= o.height / s
                }
                const s = this.filmOffset;
                0 !== s && (i += t * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
            }
        }
        $c.prototype.isPerspectiveCamera = !0;
        const td = 90;
        class ed extends $h {
            constructor(t, e, n) {
                if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                this.renderTarget = n;
                const r = new $c(td, 1, t, e);
                r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Ju(1, 0, 0)), this.add(r);
                const i = new $c(td, 1, t, e);
                i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new Ju(-1, 0, 0)), this.add(i);
                const o = new $c(td, 1, t, e);
                o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(new Ju(0, 1, 0)), this.add(o);
                const s = new $c(td, 1, t, e);
                s.layers = this.layers, s.up.set(0, 0, -1), s.lookAt(new Ju(0, -1, 0)), this.add(s);
                const a = new $c(td, 1, t, e);
                a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new Ju(0, 0, 1)), this.add(a);
                const l = new $c(td, 1, t, e);
                l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new Ju(0, 0, -1)), this.add(l)
            }
            update(t, e) {
                null === this.parent && this.updateMatrixWorld();
                const n = this.renderTarget,
                    [r, i, o, s, a, l] = this.children,
                    u = t.getRenderTarget(),
                    h = t.outputEncoding,
                    c = t.toneMapping,
                    d = t.xr.enabled;
                t.outputEncoding = iu, t.toneMapping = 0, t.xr.enabled = !1;
                const p = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, r), t.setRenderTarget(n, 1), t.render(e, i), t.setRenderTarget(n, 2), t.render(e, o), t.setRenderTarget(n, 3), t.render(e, s), t.setRenderTarget(n, 4), t.render(e, a), n.texture.generateMipmaps = p, t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(u), t.outputEncoding = h, t.toneMapping = c, t.xr.enabled = d, n.texture.needsPMREMUpdate = !0
            }
        }
        class nd extends Xu {
            constructor(t, e, n, r, i, o, s, a, l, u) {
                super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : Il, n, r, i, o, s, a, l, u), this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(t) {
                this.image = t
            }
        }
        nd.prototype.isCubeTexture = !0;
        class rd extends Yu {
            constructor(t, e = {}) {
                super(t, t, e);
                const n = {
                        width: t,
                        height: t,
                        depth: 1
                    },
                    r = [n, n, n, n, n, n];
                this.texture = new nd(r, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : Fl
            }
            fromEquirectangularTexture(t, e) {
                this.texture.type = e.type, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                const n = {
                        tEquirect: {
                            value: null
                        }
                    },
                    r = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                    i = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                    o = new Yc(5, 5, 5),
                    s = new Jc({
                        name: "CubemapFromEquirect",
                        uniforms: qc(n),
                        vertexShader: r,
                        fragmentShader: i,
                        side: 1,
                        blending: 0
                    });
                s.uniforms.tEquirect.value = e;
                const a = new Xc(o, s),
                    l = e.minFilter;
                return e.minFilter === Bl && (e.minFilter = Fl), new ed(1, 10, this).update(t, a), e.minFilter = l, a.geometry.dispose(), a.material.dispose(), this
            }
            clear(t, e, n, r) {
                const i = t.getRenderTarget();
                for (let i = 0; i < 6; i++) t.setRenderTarget(this, i), t.clear(e, n, r);
                t.setRenderTarget(i)
            }
        }
        rd.prototype.isWebGLCubeRenderTarget = !0;
        const id = new Ju,
            od = new Ju,
            sd = new Mu;
        class ad {
            constructor(t = new Ju(1, 0, 0), e = 0) {
                this.normal = t, this.constant = e
            }
            set(t, e) {
                return this.normal.copy(t), this.constant = e, this
            }
            setComponents(t, e, n, r) {
                return this.normal.set(t, e, n), this.constant = r, this
            }
            setFromNormalAndCoplanarPoint(t, e) {
                return this.normal.copy(t), this.constant = -e.dot(this.normal), this
            }
            setFromCoplanarPoints(t, e, n) {
                const r = id.subVectors(n, e).cross(od.subVectors(t, e)).normalize();
                return this.setFromNormalAndCoplanarPoint(r, t), this
            }
            copy(t) {
                return this.normal.copy(t.normal), this.constant = t.constant, this
            }
            normalize() {
                const t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t), this.constant *= t, this
            }
            negate() {
                return this.constant *= -1, this.normal.negate(), this
            }
            distanceToPoint(t) {
                return this.normal.dot(t) + this.constant
            }
            distanceToSphere(t) {
                return this.distanceToPoint(t.center) - t.radius
            }
            projectPoint(t, e) {
                return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
            }
            intersectLine(t, e) {
                const n = t.delta(id),
                    r = this.normal.dot(n);
                if (0 === r) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                const i = -(t.start.dot(this.normal) + this.constant) / r;
                return i < 0 || i > 1 ? null : e.copy(n).multiplyScalar(i).add(t.start)
            }
            intersectsLine(t) {
                const e = this.distanceToPoint(t.start),
                    n = this.distanceToPoint(t.end);
                return e < 0 && n > 0 || n < 0 && e > 0
            }
            intersectsBox(t) {
                return t.intersectsPlane(this)
            }
            intersectsSphere(t) {
                return t.intersectsPlane(this)
            }
            coplanarPoint(t) {
                return t.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(t, e) {
                const n = e || sd.getNormalMatrix(t),
                    r = this.coplanarPoint(id).applyMatrix4(t),
                    i = this.normal.applyMatrix3(n).normalize();
                return this.constant = -r.dot(i), this
            }
            translate(t) {
                return this.constant -= t.dot(this.normal), this
            }
            equals(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        ad.prototype.isPlane = !0;
        const ld = new yh,
            ud = new Ju;
        class hd {
            constructor(t = new ad, e = new ad, n = new ad, r = new ad, i = new ad, o = new ad) {
                this.planes = [t, e, n, r, i, o]
            }
            set(t, e, n, r, i, o) {
                const s = this.planes;
                return s[0].copy(t), s[1].copy(e), s[2].copy(n), s[3].copy(r), s[4].copy(i), s[5].copy(o), this
            }
            copy(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                return this
            }
            setFromProjectionMatrix(t) {
                const e = this.planes,
                    n = t.elements,
                    r = n[0],
                    i = n[1],
                    o = n[2],
                    s = n[3],
                    a = n[4],
                    l = n[5],
                    u = n[6],
                    h = n[7],
                    c = n[8],
                    d = n[9],
                    p = n[10],
                    f = n[11],
                    m = n[12],
                    g = n[13],
                    v = n[14],
                    _ = n[15];
                return e[0].setComponents(s - r, h - a, f - c, _ - m).normalize(), e[1].setComponents(s + r, h + a, f + c, _ + m).normalize(), e[2].setComponents(s + i, h + l, f + d, _ + g).normalize(), e[3].setComponents(s - i, h - l, f - d, _ - g).normalize(), e[4].setComponents(s - o, h - u, f - p, _ - v).normalize(), e[5].setComponents(s + o, h + u, f + p, _ + v).normalize(), this
            }
            intersectsObject(t) {
                const e = t.geometry;
                return null === e.boundingSphere && e.computeBoundingSphere(), ld.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(ld)
            }
            intersectsSprite(t) {
                return ld.center.set(0, 0, 0), ld.radius = .7071067811865476, ld.applyMatrix4(t.matrixWorld), this.intersectsSphere(ld)
            }
            intersectsSphere(t) {
                const e = this.planes,
                    n = t.center,
                    r = -t.radius;
                for (let t = 0; t < 6; t++)
                    if (e[t].distanceToPoint(n) < r) return !1;
                return !0
            }
            intersectsBox(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++) {
                    const r = e[n];
                    if (ud.x = r.normal.x > 0 ? t.max.x : t.min.x, ud.y = r.normal.y > 0 ? t.max.y : t.min.y, ud.z = r.normal.z > 0 ? t.max.z : t.min.z, r.distanceToPoint(ud) < 0) return !1
                }
                return !0
            }
            containsPoint(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++)
                    if (e[n].distanceToPoint(t) < 0) return !1;
                return !0
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }

        function cd() {
            let t = null,
                e = !1,
                n = null,
                r = null;

            function i(e, o) {
                n(e, o), r = t.requestAnimationFrame(i)
            }
            return {
                start: function() {
                    !0 !== e && null !== n && (r = t.requestAnimationFrame(i), e = !0)
                },
                stop: function() {
                    t.cancelAnimationFrame(r), e = !1
                },
                setAnimationLoop: function(t) {
                    n = t
                },
                setContext: function(e) {
                    t = e
                }
            }
        }

        function dd(t, e) {
            const n = e.isWebGL2,
                r = new WeakMap;
            return {
                get: function(t) {
                    return t.isInterleavedBufferAttribute && (t = t.data), r.get(t)
                },
                remove: function(e) {
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const n = r.get(e);
                    n && (t.deleteBuffer(n.buffer), r.delete(e))
                },
                update: function(e, i) {
                    if (e.isGLBufferAttribute) {
                        const t = r.get(e);
                        return void((!t || t.version < e.version) && r.set(e, {
                            buffer: e.buffer,
                            type: e.type,
                            bytesPerElement: e.elementSize,
                            version: e.version
                        }))
                    }
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const o = r.get(e);
                    void 0 === o ? r.set(e, function(e, r) {
                        const i = e.array,
                            o = e.usage,
                            s = t.createBuffer();
                        let a;
                        if (t.bindBuffer(r, s), t.bufferData(r, i, o), e.onUploadCallback(), i instanceof Float32Array) a = 5126;
                        else if (i instanceof Uint16Array)
                            if (e.isFloat16BufferAttribute) {
                                if (!n) throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                                a = 5131
                            } else a = 5123;
                        else if (i instanceof Int16Array) a = 5122;
                        else if (i instanceof Uint32Array) a = 5125;
                        else if (i instanceof Int32Array) a = 5124;
                        else if (i instanceof Int8Array) a = 5120;
                        else if (i instanceof Uint8Array) a = 5121;
                        else {
                            if (!(i instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + i);
                            a = 5121
                        }
                        return {
                            buffer: s,
                            type: a,
                            bytesPerElement: i.BYTES_PER_ELEMENT,
                            version: e.version
                        }
                    }(e, i)) : o.version < e.version && (function(e, r, i) {
                        const o = r.array,
                            s = r.updateRange;
                        t.bindBuffer(i, e), -1 === s.count ? t.bufferSubData(i, 0, o) : (n ? t.bufferSubData(i, s.offset * o.BYTES_PER_ELEMENT, o, s.offset, s.count) : t.bufferSubData(i, s.offset * o.BYTES_PER_ELEMENT, o.subarray(s.offset, s.offset + s.count)), s.count = -1)
                    }(o.buffer, e, i), o.version = e.version)
                }
            }
        }
        class pd extends Ac {
            constructor(t = 1, e = 1, n = 1, r = 1) {
                super(), this.type = "PlaneGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: r
                };
                const i = t / 2,
                    o = e / 2,
                    s = Math.floor(n),
                    a = Math.floor(r),
                    l = s + 1,
                    u = a + 1,
                    h = t / s,
                    c = e / a,
                    d = [],
                    p = [],
                    f = [],
                    m = [];
                for (let t = 0; t < u; t++) {
                    const e = t * c - o;
                    for (let n = 0; n < l; n++) {
                        const r = n * h - i;
                        p.push(r, -e, 0), f.push(0, 0, 1), m.push(n / s), m.push(1 - t / a)
                    }
                }
                for (let t = 0; t < a; t++)
                    for (let e = 0; e < s; e++) {
                        const n = e + l * t,
                            r = e + l * (t + 1),
                            i = e + 1 + l * (t + 1),
                            o = e + 1 + l * t;
                        d.push(n, r, o), d.push(r, i, o)
                    }
                this.setIndex(d), this.setAttribute("position", new yc(p, 3)), this.setAttribute("normal", new yc(f, 3)), this.setAttribute("uv", new yc(m, 2))
            }
            static fromJSON(t) {
                return new pd(t.width, t.height, t.widthSegments, t.heightSegments)
            }
        }
        const fd = {
                alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
                alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                begin_vertex: "vec3 transformed = vec3( position );",
                beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
                bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
                cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
                envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
                envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
                fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
                fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
                lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
                lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
                lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
                lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
                lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
                lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
                lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
                map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
                morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
                morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
                morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
                normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
                normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
                clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
                clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
                shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
                transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
                uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
                meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
            },
            md = {
                common: {
                    diffuse: {
                        value: new ku(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    uvTransform: {
                        value: new Mu
                    },
                    uv2Transform: {
                        value: new Mu
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaTest: {
                        value: 0
                    }
                },
                specularmap: {
                    specularMap: {
                        value: null
                    }
                },
                envmap: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    ior: {
                        value: 1.5
                    },
                    refractionRatio: {
                        value: .98
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalScale: {
                        value: new wu(1, 1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    }
                },
                gradientmap: {
                    gradientMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new ku(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    lightProbe: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {}
                        }
                    },
                    directionalLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {}
                        }
                    },
                    spotLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotShadowMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {}
                        }
                    },
                    pointLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    },
                    ltc_1: {
                        value: null
                    },
                    ltc_2: {
                        value: null
                    }
                },
                points: {
                    diffuse: {
                        value: new ku(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaTest: {
                        value: 0
                    },
                    uvTransform: {
                        value: new Mu
                    }
                },
                sprite: {
                    diffuse: {
                        value: new ku(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    center: {
                        value: new wu(.5, .5)
                    },
                    rotation: {
                        value: 0
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaTest: {
                        value: 0
                    },
                    uvTransform: {
                        value: new Mu
                    }
                }
            },
            gd = {
                basic: {
                    uniforms: Zc([md.common, md.specularmap, md.envmap, md.aomap, md.lightmap, md.fog]),
                    vertexShader: fd.meshbasic_vert,
                    fragmentShader: fd.meshbasic_frag
                },
                lambert: {
                    uniforms: Zc([md.common, md.specularmap, md.envmap, md.aomap, md.lightmap, md.emissivemap, md.fog, md.lights, {
                        emissive: {
                            value: new ku(0)
                        }
                    }]),
                    vertexShader: fd.meshlambert_vert,
                    fragmentShader: fd.meshlambert_frag
                },
                phong: {
                    uniforms: Zc([md.common, md.specularmap, md.envmap, md.aomap, md.lightmap, md.emissivemap, md.bumpmap, md.normalmap, md.displacementmap, md.fog, md.lights, {
                        emissive: {
                            value: new ku(0)
                        },
                        specular: {
                            value: new ku(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: fd.meshphong_vert,
                    fragmentShader: fd.meshphong_frag
                },
                standard: {
                    uniforms: Zc([md.common, md.envmap, md.aomap, md.lightmap, md.emissivemap, md.bumpmap, md.normalmap, md.displacementmap, md.roughnessmap, md.metalnessmap, md.fog, md.lights, {
                        emissive: {
                            value: new ku(0)
                        },
                        roughness: {
                            value: 1
                        },
                        metalness: {
                            value: 0
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: fd.meshphysical_vert,
                    fragmentShader: fd.meshphysical_frag
                },
                toon: {
                    uniforms: Zc([md.common, md.aomap, md.lightmap, md.emissivemap, md.bumpmap, md.normalmap, md.displacementmap, md.gradientmap, md.fog, md.lights, {
                        emissive: {
                            value: new ku(0)
                        }
                    }]),
                    vertexShader: fd.meshtoon_vert,
                    fragmentShader: fd.meshtoon_frag
                },
                matcap: {
                    uniforms: Zc([md.common, md.bumpmap, md.normalmap, md.displacementmap, md.fog, {
                        matcap: {
                            value: null
                        }
                    }]),
                    vertexShader: fd.meshmatcap_vert,
                    fragmentShader: fd.meshmatcap_frag
                },
                points: {
                    uniforms: Zc([md.points, md.fog]),
                    vertexShader: fd.points_vert,
                    fragmentShader: fd.points_frag
                },
                dashed: {
                    uniforms: Zc([md.common, md.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: fd.linedashed_vert,
                    fragmentShader: fd.linedashed_frag
                },
                depth: {
                    uniforms: Zc([md.common, md.displacementmap]),
                    vertexShader: fd.depth_vert,
                    fragmentShader: fd.depth_frag
                },
                normal: {
                    uniforms: Zc([md.common, md.bumpmap, md.normalmap, md.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: fd.meshnormal_vert,
                    fragmentShader: fd.meshnormal_frag
                },
                sprite: {
                    uniforms: Zc([md.sprite, md.fog]),
                    vertexShader: fd.sprite_vert,
                    fragmentShader: fd.sprite_frag
                },
                background: {
                    uniforms: {
                        uvTransform: {
                            value: new Mu
                        },
                        t2D: {
                            value: null
                        }
                    },
                    vertexShader: fd.background_vert,
                    fragmentShader: fd.background_frag
                },
                cube: {
                    uniforms: Zc([md.envmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: fd.cube_vert,
                    fragmentShader: fd.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: fd.equirect_vert,
                    fragmentShader: fd.equirect_frag
                },
                distanceRGBA: {
                    uniforms: Zc([md.common, md.displacementmap, {
                        referencePosition: {
                            value: new Ju
                        },
                        nearDistance: {
                            value: 1
                        },
                        farDistance: {
                            value: 1e3
                        }
                    }]),
                    vertexShader: fd.distanceRGBA_vert,
                    fragmentShader: fd.distanceRGBA_frag
                },
                shadow: {
                    uniforms: Zc([md.lights, md.fog, {
                        color: {
                            value: new ku(0)
                        },
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: fd.shadow_vert,
                    fragmentShader: fd.shadow_frag
                }
            };

        function vd(t, e, n, r, i, o) {
            const s = new ku(0);
            let a, l, u = !0 === i ? 0 : 1,
                h = null,
                c = 0,
                d = null;

            function p(t, e) {
                n.buffers.color.setClear(t.r, t.g, t.b, e, o)
            }
            return {
                getClearColor: function() {
                    return s
                },
                setClearColor: function(t, e = 1) {
                    s.set(t), u = e, p(s, u)
                },
                getClearAlpha: function() {
                    return u
                },
                setClearAlpha: function(t) {
                    u = t, p(s, u)
                },
                render: function(n, i) {
                    let o = !1,
                        f = !0 === i.isScene ? i.background : null;
                    f && f.isTexture && (f = e.get(f));
                    const m = t.xr,
                        g = m.getSession && m.getSession();
                    g && "additive" === g.environmentBlendMode && (f = null), null === f ? p(s, u) : f && f.isColor && (p(f, 1), o = !0), (t.autoClear || o) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), f && (f.isCubeTexture || f.mapping === Ol) ? (void 0 === l && (l = new Xc(new Yc(1, 1, 1), new Jc({
                        name: "BackgroundCubeMaterial",
                        uniforms: qc(gd.cube.uniforms),
                        vertexShader: gd.cube.vertexShader,
                        fragmentShader: gd.cube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function(t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }, Object.defineProperty(l.material, "envMap", {
                        get: function() {
                            return this.uniforms.envMap.value
                        }
                    }), r.update(l)), l.material.uniforms.envMap.value = f, l.material.uniforms.flipEnvMap.value = f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1, h === f && c === f.version && d === t.toneMapping || (l.material.needsUpdate = !0, h = f, c = f.version, d = t.toneMapping), n.unshift(l, l.geometry, l.material, 0, 0, null)) : f && f.isTexture && (void 0 === a && (a = new Xc(new pd(2, 2), new Jc({
                        name: "BackgroundMaterial",
                        uniforms: qc(gd.background.uniforms),
                        vertexShader: gd.background.vertexShader,
                        fragmentShader: gd.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), a.geometry.deleteAttribute("normal"), Object.defineProperty(a.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }), r.update(a)), a.material.uniforms.t2D.value = f, !0 === f.matrixAutoUpdate && f.updateMatrix(), a.material.uniforms.uvTransform.value.copy(f.matrix), h === f && c === f.version && d === t.toneMapping || (a.material.needsUpdate = !0, h = f, c = f.version, d = t.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null))
                }
            }
        }

        function _d(t, e, n, r) {
            const i = t.getParameter(34921),
                o = r.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                s = r.isWebGL2 || null !== o,
                a = {},
                l = p(null);
            let u = l,
                h = !1;

            function c(e) {
                return r.isWebGL2 ? t.bindVertexArray(e) : o.bindVertexArrayOES(e)
            }

            function d(e) {
                return r.isWebGL2 ? t.deleteVertexArray(e) : o.deleteVertexArrayOES(e)
            }

            function p(t) {
                const e = [],
                    n = [],
                    r = [];
                for (let t = 0; t < i; t++) e[t] = 0, n[t] = 0, r[t] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: e,
                    enabledAttributes: n,
                    attributeDivisors: r,
                    object: t,
                    attributes: {},
                    index: null
                }
            }

            function f() {
                const t = u.newAttributes;
                for (let e = 0, n = t.length; e < n; e++) t[e] = 0
            }

            function m(t) {
                g(t, 0)
            }

            function g(n, i) {
                const o = u.newAttributes,
                    s = u.enabledAttributes,
                    a = u.attributeDivisors;
                o[n] = 1, 0 === s[n] && (t.enableVertexAttribArray(n), s[n] = 1), a[n] !== i && ((r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), a[n] = i)
            }

            function v() {
                const e = u.newAttributes,
                    n = u.enabledAttributes;
                for (let r = 0, i = n.length; r < i; r++) n[r] !== e[r] && (t.disableVertexAttribArray(r), n[r] = 0)
            }

            function _(e, n, i, o, s, a) {
                !0 !== r.isWebGL2 || 5124 !== i && 5125 !== i ? t.vertexAttribPointer(e, n, i, o, s, a) : t.vertexAttribIPointer(e, n, i, s, a)
            }

            function y() {
                x(), h = !0, u !== l && (u = l, c(u.object))
            }

            function x() {
                l.geometry = null, l.program = null, l.wireframe = !1
            }
            return {
                setup: function(i, l, d, y, x) {
                    let b = !1;
                    if (s) {
                        const e = function(e, n, i) {
                            const s = !0 === i.wireframe;
                            let l = a[e.id];
                            void 0 === l && (l = {}, a[e.id] = l);
                            let u = l[n.id];
                            void 0 === u && (u = {}, l[n.id] = u);
                            let h = u[s];
                            return void 0 === h && (h = p(r.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES()), u[s] = h), h
                        }(y, d, l);
                        u !== e && (u = e, c(u.object)), b = function(t, e) {
                            const n = u.attributes,
                                r = t.attributes;
                            let i = 0;
                            for (const t in r) {
                                const e = n[t],
                                    o = r[t];
                                if (void 0 === e) return !0;
                                if (e.attribute !== o) return !0;
                                if (e.data !== o.data) return !0;
                                i++
                            }
                            return u.attributesNum !== i || u.index !== e
                        }(y, x), b && function(t, e) {
                            const n = {},
                                r = t.attributes;
                            let i = 0;
                            for (const t in r) {
                                const e = r[t],
                                    o = {};
                                o.attribute = e, e.data && (o.data = e.data), n[t] = o, i++
                            }
                            u.attributes = n, u.attributesNum = i, u.index = e
                        }(y, x)
                    } else {
                        const t = !0 === l.wireframe;
                        u.geometry === y.id && u.program === d.id && u.wireframe === t || (u.geometry = y.id, u.program = d.id, u.wireframe = t, b = !0)
                    }!0 === i.isInstancedMesh && (b = !0), null !== x && n.update(x, 34963), (b || h) && (h = !1, function(i, o, s, a) {
                        if (!1 === r.isWebGL2 && (i.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                        f();
                        const l = a.attributes,
                            u = s.getAttributes(),
                            h = o.defaultAttributeValues;
                        for (const e in u) {
                            const r = u[e];
                            if (r.location >= 0) {
                                let o = l[e];
                                if (void 0 === o && ("instanceMatrix" === e && i.instanceMatrix && (o = i.instanceMatrix), "instanceColor" === e && i.instanceColor && (o = i.instanceColor)), void 0 !== o) {
                                    const e = o.normalized,
                                        s = o.itemSize,
                                        l = n.get(o);
                                    if (void 0 === l) continue;
                                    const u = l.buffer,
                                        h = l.type,
                                        c = l.bytesPerElement;
                                    if (o.isInterleavedBufferAttribute) {
                                        const n = o.data,
                                            l = n.stride,
                                            d = o.offset;
                                        if (n.isInstancedInterleavedBuffer) {
                                            for (let t = 0; t < r.locationSize; t++) g(r.location + t, n.meshPerAttribute);
                                            !0 !== i.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)
                                        } else
                                            for (let t = 0; t < r.locationSize; t++) m(r.location + t);
                                        t.bindBuffer(34962, u);
                                        for (let t = 0; t < r.locationSize; t++) _(r.location + t, s / r.locationSize, h, e, l * c, (d + s / r.locationSize * t) * c)
                                    } else {
                                        if (o.isInstancedBufferAttribute) {
                                            for (let t = 0; t < r.locationSize; t++) g(r.location + t, o.meshPerAttribute);
                                            !0 !== i.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = o.meshPerAttribute * o.count)
                                        } else
                                            for (let t = 0; t < r.locationSize; t++) m(r.location + t);
                                        t.bindBuffer(34962, u);
                                        for (let t = 0; t < r.locationSize; t++) _(r.location + t, s / r.locationSize, h, e, s * c, s / r.locationSize * t * c)
                                    }
                                } else if (void 0 !== h) {
                                    const n = h[e];
                                    if (void 0 !== n) switch (n.length) {
                                        case 2:
                                            t.vertexAttrib2fv(r.location, n);
                                            break;
                                        case 3:
                                            t.vertexAttrib3fv(r.location, n);
                                            break;
                                        case 4:
                                            t.vertexAttrib4fv(r.location, n);
                                            break;
                                        default:
                                            t.vertexAttrib1fv(r.location, n)
                                    }
                                }
                            }
                        }
                        v()
                    }(i, l, d, y), null !== x && t.bindBuffer(34963, n.get(x).buffer))
                },
                reset: y,
                resetDefaultState: x,
                dispose: function() {
                    y();
                    for (const t in a) {
                        const e = a[t];
                        for (const t in e) {
                            const n = e[t];
                            for (const t in n) d(n[t].object), delete n[t];
                            delete e[t]
                        }
                        delete a[t]
                    }
                },
                releaseStatesOfGeometry: function(t) {
                    if (void 0 === a[t.id]) return;
                    const e = a[t.id];
                    for (const t in e) {
                        const n = e[t];
                        for (const t in n) d(n[t].object), delete n[t];
                        delete e[t]
                    }
                    delete a[t.id]
                },
                releaseStatesOfProgram: function(t) {
                    for (const e in a) {
                        const n = a[e];
                        if (void 0 === n[t.id]) continue;
                        const r = n[t.id];
                        for (const t in r) d(r[t].object), delete r[t];
                        delete n[t.id]
                    }
                },
                initAttributes: f,
                enableAttribute: m,
                disableUnusedAttributes: v
            }
        }

        function yd(t, e, n, r) {
            const i = r.isWebGL2;
            let o;
            this.setMode = function(t) {
                o = t
            }, this.render = function(e, r) {
                t.drawArrays(o, e, r), n.update(r, o, 1)
            }, this.renderInstances = function(r, s, a) {
                if (0 === a) return;
                let l, u;
                if (i) l = t, u = "drawArraysInstanced";
                else if (l = e.get("ANGLE_instanced_arrays"), u = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                l[u](o, r, s, a), n.update(s, o, a)
            }
        }

        function xd(t, e, n) {
            let r;

            function i(e) {
                if ("highp" === e) {
                    if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                    e = "mediump"
                }
                return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
            }
            const o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
            let s = void 0 !== n.precision ? n.precision : "highp";
            const a = i(s);
            a !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", a, "instead."), s = a);
            const l = o || e.has("WEBGL_draw_buffers"),
                u = !0 === n.logarithmicDepthBuffer,
                h = t.getParameter(34930),
                c = t.getParameter(35660),
                d = t.getParameter(3379),
                p = t.getParameter(34076),
                f = t.getParameter(34921),
                m = t.getParameter(36347),
                g = t.getParameter(36348),
                v = t.getParameter(36349),
                _ = c > 0,
                y = o || e.has("OES_texture_float");
            return {
                isWebGL2: o,
                drawBuffers: l,
                getMaxAnisotropy: function() {
                    if (void 0 !== r) return r;
                    if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                        const n = e.get("EXT_texture_filter_anisotropic");
                        r = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else r = 0;
                    return r
                },
                getMaxPrecision: i,
                precision: s,
                logarithmicDepthBuffer: u,
                maxTextures: h,
                maxVertexTextures: c,
                maxTextureSize: d,
                maxCubemapSize: p,
                maxAttributes: f,
                maxVertexUniforms: m,
                maxVaryings: g,
                maxFragmentUniforms: v,
                vertexTextures: _,
                floatFragmentTextures: y,
                floatVertexTextures: _ && y,
                maxSamples: o ? t.getParameter(36183) : 0
            }
        }

        function bd(t) {
            const e = this;
            let n = null,
                r = 0,
                i = !1,
                o = !1;
            const s = new ad,
                a = new Mu,
                l = {
                    value: null,
                    needsUpdate: !1
                };

            function u() {
                l.value !== n && (l.value = n, l.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0
            }

            function h(t, n, r, i) {
                const o = null !== t ? t.length : 0;
                let u = null;
                if (0 !== o) {
                    if (u = l.value, !0 !== i || null === u) {
                        const e = r + 4 * o,
                            i = n.matrixWorldInverse;
                        a.getNormalMatrix(i), (null === u || u.length < e) && (u = new Float32Array(e));
                        for (let e = 0, n = r; e !== o; ++e, n += 4) s.copy(t[e]).applyMatrix4(i, a), s.normal.toArray(u, n), u[n + 3] = s.constant
                    }
                    l.value = u, l.needsUpdate = !0
                }
                return e.numPlanes = o, e.numIntersection = 0, u
            }
            this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, e, o) {
                const s = 0 !== t.length || e || 0 !== r || i;
                return i = e, n = h(t, o, 0), r = t.length, s
            }, this.beginShadows = function() {
                o = !0, h(null)
            }, this.endShadows = function() {
                o = !1, u()
            }, this.setState = function(e, s, a) {
                const c = e.clippingPlanes,
                    d = e.clipIntersection,
                    p = e.clipShadows,
                    f = t.get(e);
                if (!i || null === c || 0 === c.length || o && !p) o ? h(null) : u();
                else {
                    const t = o ? 0 : r,
                        e = 4 * t;
                    let i = f.clippingState || null;
                    l.value = i, i = h(c, s, e, a);
                    for (let t = 0; t !== e; ++t) i[t] = n[t];
                    f.clippingState = i, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t
                }
            }
        }

        function Ed(t) {
            let e = new WeakMap;

            function n(t, e) {
                return 303 === e ? t.mapping = Il : 304 === e && (t.mapping = Cl), t
            }

            function r(t) {
                const n = t.target;
                n.removeEventListener("dispose", r);
                const i = e.get(n);
                void 0 !== i && (e.delete(n), i.dispose())
            }
            return {
                get: function(i) {
                    if (i && i.isTexture && !1 === i.isRenderTargetTexture) {
                        const o = i.mapping;
                        if (303 === o || 304 === o) {
                            if (e.has(i)) return n(e.get(i).texture, i.mapping); {
                                const o = i.image;
                                if (o && o.height > 0) {
                                    const s = new rd(o.height / 2);
                                    return s.fromEquirectangularTexture(t, i), e.set(i, s), i.addEventListener("dispose", r), n(s.texture, i.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return i
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }
        gd.physical = {
            uniforms: Zc([gd.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatNormalScale: {
                    value: new wu(1, 1)
                },
                clearcoatNormalMap: {
                    value: null
                },
                sheen: {
                    value: 0
                },
                sheenColor: {
                    value: new ku(0)
                },
                sheenColorMap: {
                    value: null
                },
                sheenRoughness: {
                    value: 1
                },
                sheenRoughnessMap: {
                    value: null
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionSamplerSize: {
                    value: new wu
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationColor: {
                    value: new ku(0)
                },
                specularIntensity: {
                    value: 1
                },
                specularIntensityMap: {
                    value: null
                },
                specularColor: {
                    value: new ku(1, 1, 1)
                },
                specularColorMap: {
                    value: null
                }
            }]),
            vertexShader: fd.meshphysical_vert,
            fragmentShader: fd.meshphysical_frag
        };
        class Td extends Qc {
            constructor(t = -1, e = 1, n = 1, r = -1, i = .1, o = 2e3) {
                super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = r, this.near = i, this.far = o, this.updateProjectionMatrix()
            }
            copy(t, e) {
                return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
            }
            setViewOffset(t, e, n, r, i, o) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = (this.right - this.left) / (2 * this.zoom),
                    e = (this.top - this.bottom) / (2 * this.zoom),
                    n = (this.right + this.left) / 2,
                    r = (this.top + this.bottom) / 2;
                let i = n - t,
                    o = n + t,
                    s = r + e,
                    a = r - e;
                if (null !== this.view && this.view.enabled) {
                    const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                        e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    i += t * this.view.offsetX, o = i + t * this.view.width, s -= e * this.view.offsetY, a = s - e * this.view.height
                }
                this.projectionMatrix.makeOrthographic(i, o, s, a, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
            }
        }
        Td.prototype.isOrthographicCamera = !0;
        const Sd = [.125, .215, .35, .446, .526, .582],
            wd = new Td,
            Md = new ku;
        let Ad = null;
        const Rd = (1 + Math.sqrt(5)) / 2,
            Pd = 1 / Rd,
            Id = [new Ju(1, 1, 1), new Ju(-1, 1, 1), new Ju(1, 1, -1), new Ju(-1, 1, -1), new Ju(0, Rd, Pd), new Ju(0, Rd, -Pd), new Ju(Pd, 0, Rd), new Ju(-Pd, 0, Rd), new Ju(Rd, Pd, 0), new Ju(-Rd, Pd, 0)];
        class Cd {
            constructor(t) {
                this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
            }
            fromScene(t, e = 0, n = .1, r = 100) {
                Ad = this._renderer.getRenderTarget(), this._setSize(256);
                const i = this._allocateTargets();
                return i.depthBuffer = !0, this._sceneToCubeUV(t, n, r, i), e > 0 && this._blur(i, 0, 0, e), this._applyPMREM(i), this._cleanup(i), i
            }
            fromEquirectangular(t, e = null) {
                return this._fromTexture(t, e)
            }
            fromCubemap(t, e = null) {
                return this._fromTexture(t, e)
            }
            compileCubemapShader() {
                null === this._cubemapMaterial && (this._cubemapMaterial = Dd(), this._compileMaterial(this._cubemapMaterial))
            }
            compileEquirectangularShader() {
                null === this._equirectMaterial && (this._equirectMaterial = Nd(), this._compileMaterial(this._equirectMaterial))
            }
            dispose() {
                this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
            }
            _setSize(t) {
                this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax)
            }
            _dispose() {
                null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                for (let t = 0; t < this._lodPlanes.length; t++) this._lodPlanes[t].dispose()
            }
            _cleanup(t) {
                this._renderer.setRenderTarget(Ad), t.scissorTest = !1, Ld(t, 0, 0, t.width, t.height)
            }
            _fromTexture(t, e) {
                t.mapping === Il || t.mapping === Cl ? this._setSize(0 === t.image.length ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), Ad = this._renderer.getRenderTarget();
                const n = e || this._allocateTargets();
                return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
            }
            _allocateTargets() {
                const t = 3 * Math.max(this._cubeSize, 112),
                    e = 4 * this._cubeSize - 32,
                    n = {
                        magFilter: Fl,
                        minFilter: Fl,
                        generateMipmaps: !1,
                        type: Vl,
                        format: Xl,
                        encoding: iu,
                        depthBuffer: !1
                    },
                    r = Od(t, e, n);
                if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== t) {
                    null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = Od(t, e, n);
                    const {
                        _lodMax: r
                    } = this;
                    ({
                        sizeLods: this._sizeLods,
                        lodPlanes: this._lodPlanes,
                        sigmas: this._sigmas
                    } = function(t) {
                        const e = [],
                            n = [],
                            r = [];
                        let i = t;
                        const o = t - 4 + 1 + Sd.length;
                        for (let s = 0; s < o; s++) {
                            const o = Math.pow(2, i);
                            n.push(o);
                            let a = 1 / o;
                            s > t - 4 ? a = Sd[s - t + 4 - 1] : 0 === s && (a = 0), r.push(a);
                            const l = 1 / (o - 1),
                                u = -l / 2,
                                h = 1 + l / 2,
                                c = [u, u, h, u, h, h, u, u, h, h, u, h],
                                d = 6,
                                p = 6,
                                f = 3,
                                m = 2,
                                g = 1,
                                v = new Float32Array(f * p * d),
                                _ = new Float32Array(m * p * d),
                                y = new Float32Array(g * p * d);
                            for (let t = 0; t < d; t++) {
                                const e = t % 3 * 2 / 3 - 1,
                                    n = t > 2 ? 0 : -1,
                                    r = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                                v.set(r, f * p * t), _.set(c, m * p * t);
                                const i = [t, t, t, t, t, t];
                                y.set(i, g * p * t)
                            }
                            const x = new Ac;
                            x.setAttribute("position", new gc(v, f)), x.setAttribute("uv", new gc(_, m)), x.setAttribute("faceIndex", new gc(y, g)), e.push(x), i > 4 && i--
                        }
                        return {
                            lodPlanes: e,
                            sizeLods: n,
                            sigmas: r
                        }
                    }(r)), this._blurMaterial = function(t, e, n) {
                        const r = new Float32Array(20),
                            i = new Ju(0, 1, 0);
                        return new Jc({
                            name: "SphericalGaussianBlur",
                            defines: {
                                n: 20,
                                CUBEUV_TEXEL_WIDTH: 1 / e,
                                CUBEUV_TEXEL_HEIGHT: 1 / n,
                                CUBEUV_MAX_MIP: `${t}.0`
                            },
                            uniforms: {
                                envMap: {
                                    value: null
                                },
                                samples: {
                                    value: 1
                                },
                                weights: {
                                    value: r
                                },
                                latitudinal: {
                                    value: !1
                                },
                                dTheta: {
                                    value: 0
                                },
                                mipInt: {
                                    value: 0
                                },
                                poleAxis: {
                                    value: i
                                }
                            },
                            vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                            blending: 0,
                            depthTest: !1,
                            depthWrite: !1
                        })
                    }(r, t, e)
                }
                return r
            }
            _compileMaterial(t) {
                const e = new Xc(this._lodPlanes[0], t);
                this._renderer.compile(e, wd)
            }
            _sceneToCubeUV(t, e, n, r) {
                const i = new $c(90, 1, e, n),
                    o = [1, -1, 1, 1, 1, 1],
                    s = [1, 1, 1, -1, -1, -1],
                    a = this._renderer,
                    l = a.autoClear,
                    u = a.toneMapping;
                a.getClearColor(Md), a.toneMapping = 0, a.autoClear = !1;
                const h = new pc({
                        name: "PMREM.Background",
                        side: 1,
                        depthWrite: !1,
                        depthTest: !1
                    }),
                    c = new Xc(new Yc, h);
                let d = !1;
                const p = t.background;
                p ? p.isColor && (h.color.copy(p), t.background = null, d = !0) : (h.color.copy(Md), d = !0);
                for (let e = 0; e < 6; e++) {
                    const n = e % 3;
                    0 === n ? (i.up.set(0, o[e], 0), i.lookAt(s[e], 0, 0)) : 1 === n ? (i.up.set(0, 0, o[e]), i.lookAt(0, s[e], 0)) : (i.up.set(0, o[e], 0), i.lookAt(0, 0, s[e]));
                    const l = this._cubeSize;
                    Ld(r, n * l, e > 2 ? l : 0, l, l), a.setRenderTarget(r), d && a.render(c, i), a.render(t, i)
                }
                c.geometry.dispose(), c.material.dispose(), a.toneMapping = u, a.autoClear = l, t.background = p
            }
            _textureToCubeUV(t, e) {
                const n = this._renderer,
                    r = t.mapping === Il || t.mapping === Cl;
                r ? (null === this._cubemapMaterial && (this._cubemapMaterial = Dd()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = Nd());
                const i = r ? this._cubemapMaterial : this._equirectMaterial,
                    o = new Xc(this._lodPlanes[0], i);
                i.uniforms.envMap.value = t;
                const s = this._cubeSize;
                Ld(e, 0, 0, 3 * s, 2 * s), n.setRenderTarget(e), n.render(o, wd)
            }
            _applyPMREM(t) {
                const e = this._renderer,
                    n = e.autoClear;
                e.autoClear = !1;
                for (let e = 1; e < this._lodPlanes.length; e++) {
                    const n = Math.sqrt(this._sigmas[e] * this._sigmas[e] - this._sigmas[e - 1] * this._sigmas[e - 1]),
                        r = Id[(e - 1) % Id.length];
                    this._blur(t, e - 1, e, n, r)
                }
                e.autoClear = n
            }
            _blur(t, e, n, r, i) {
                const o = this._pingPongRenderTarget;
                this._halfBlur(t, o, e, n, r, "latitudinal", i), this._halfBlur(o, t, n, n, r, "longitudinal", i)
            }
            _halfBlur(t, e, n, r, i, o, s) {
                const a = this._renderer,
                    l = this._blurMaterial;
                "latitudinal" !== o && "longitudinal" !== o && console.error("blur direction must be either latitudinal or longitudinal!");
                const u = new Xc(this._lodPlanes[r], l),
                    h = l.uniforms,
                    c = this._sizeLods[n] - 1,
                    d = isFinite(i) ? Math.PI / (2 * c) : 2 * Math.PI / 39,
                    p = i / d,
                    f = isFinite(i) ? 1 + Math.floor(3 * p) : 20;
                f > 20 && console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
                const m = [];
                let g = 0;
                for (let t = 0; t < 20; ++t) {
                    const e = t / p,
                        n = Math.exp(-e * e / 2);
                    m.push(n), 0 === t ? g += n : t < f && (g += 2 * n)
                }
                for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
                h.envMap.value = t.texture, h.samples.value = f, h.weights.value = m, h.latitudinal.value = "latitudinal" === o, s && (h.poleAxis.value = s);
                const {
                    _lodMax: v
                } = this;
                h.dTheta.value = d, h.mipInt.value = v - n;
                const _ = this._sizeLods[r];
                Ld(e, 3 * _ * (r > v - 4 ? r - v + 4 : 0), 4 * (this._cubeSize - _), 3 * _, 2 * _), a.setRenderTarget(e), a.render(u, wd)
            }
        }

        function Od(t, e, n) {
            const r = new Yu(t, e, n);
            return r.texture.mapping = Ol, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r
        }

        function Ld(t, e, n, r, i) {
            t.viewport.set(e, n, r, i), t.scissor.set(e, n, r, i)
        }

        function Nd() {
            return new Jc({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    }
                },
                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function Dd() {
            return new Jc({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    }
                },
                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function Ud(t) {
            let e = new WeakMap,
                n = null;

            function r(t) {
                const n = t.target;
                n.removeEventListener("dispose", r);
                const i = e.get(n);
                void 0 !== i && (e.delete(n), i.dispose())
            }
            return {
                get: function(i) {
                    if (i && i.isTexture) {
                        const o = i.mapping,
                            s = 303 === o || 304 === o,
                            a = o === Il || o === Cl;
                        if (s || a) {
                            if (i.isRenderTargetTexture && !0 === i.needsPMREMUpdate) {
                                i.needsPMREMUpdate = !1;
                                let r = e.get(i);
                                return null === n && (n = new Cd(t)), r = s ? n.fromEquirectangular(i, r) : n.fromCubemap(i, r), e.set(i, r), r.texture
                            }
                            if (e.has(i)) return e.get(i).texture; {
                                const o = i.image;
                                if (s && o && o.height > 0 || a && o && function(t) {
                                        let e = 0;
                                        for (let n = 0; n < 6; n++) void 0 !== t[n] && e++;
                                        return 6 === e
                                    }(o)) {
                                    null === n && (n = new Cd(t));
                                    const o = s ? n.fromEquirectangular(i) : n.fromCubemap(i);
                                    return e.set(i, o), i.addEventListener("dispose", r), o.texture
                                }
                                return null
                            }
                        }
                    }
                    return i
                },
                dispose: function() {
                    e = new WeakMap, null !== n && (n.dispose(), n = null)
                }
            }
        }

        function Fd(t) {
            const e = {};

            function n(n) {
                if (void 0 !== e[n]) return e[n];
                let r;
                switch (n) {
                    case "WEBGL_depth_texture":
                        r = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        r = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        r = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        r = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        r = t.getExtension(n)
                }
                return e[n] = r, r
            }
            return {
                has: function(t) {
                    return null !== n(t)
                },
                init: function(t) {
                    t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture")
                },
                get: function(t) {
                    const e = n(t);
                    return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e
                }
            }
        }

        function Bd(t, e, n, r) {
            const i = {},
                o = new WeakMap;

            function s(t) {
                const a = t.target;
                null !== a.index && e.remove(a.index);
                for (const t in a.attributes) e.remove(a.attributes[t]);
                a.removeEventListener("dispose", s), delete i[a.id];
                const l = o.get(a);
                l && (e.remove(l), o.delete(a)), r.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries--
            }

            function a(t) {
                const n = [],
                    r = t.index,
                    i = t.attributes.position;
                let s = 0;
                if (null !== r) {
                    const t = r.array;
                    s = r.version;
                    for (let e = 0, r = t.length; e < r; e += 3) {
                        const r = t[e + 0],
                            i = t[e + 1],
                            o = t[e + 2];
                        n.push(r, i, i, o, o, r)
                    }
                } else {
                    const t = i.array;
                    s = i.version;
                    for (let e = 0, r = t.length / 3 - 1; e < r; e += 3) {
                        const t = e + 0,
                            r = e + 1,
                            i = e + 2;
                        n.push(t, r, r, i, i, t)
                    }
                }
                const a = new(Au(n) ? _c : vc)(n, 1);
                a.version = s;
                const l = o.get(t);
                l && e.remove(l), o.set(t, a)
            }
            return {
                get: function(t, e) {
                    return !0 === i[e.id] || (e.addEventListener("dispose", s), i[e.id] = !0, n.memory.geometries++), e
                },
                update: function(t) {
                    const n = t.attributes;
                    for (const t in n) e.update(n[t], 34962);
                    const r = t.morphAttributes;
                    for (const t in r) {
                        const n = r[t];
                        for (let t = 0, r = n.length; t < r; t++) e.update(n[t], 34962)
                    }
                },
                getWireframeAttribute: function(t) {
                    const e = o.get(t);
                    if (e) {
                        const n = t.index;
                        null !== n && e.version < n.version && a(t)
                    } else a(t);
                    return o.get(t)
                }
            }
        }

        function kd(t, e, n, r) {
            const i = r.isWebGL2;
            let o, s, a;
            this.setMode = function(t) {
                o = t
            }, this.setIndex = function(t) {
                s = t.type, a = t.bytesPerElement
            }, this.render = function(e, r) {
                t.drawElements(o, r, s, e * a), n.update(r, o, 1)
            }, this.renderInstances = function(r, l, u) {
                if (0 === u) return;
                let h, c;
                if (i) h = t, c = "drawElementsInstanced";
                else if (h = e.get("ANGLE_instanced_arrays"), c = "drawElementsInstancedANGLE", null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                h[c](o, l, s, r * a, u), n.update(l, o, u)
            }
        }

        function Gd(t) {
            const e = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: e,
                programs: null,
                autoReset: !0,
                reset: function() {
                    e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                },
                update: function(t, n, r) {
                    switch (e.calls++, n) {
                        case 4:
                            e.triangles += r * (t / 3);
                            break;
                        case 1:
                            e.lines += r * (t / 2);
                            break;
                        case 3:
                            e.lines += r * (t - 1);
                            break;
                        case 2:
                            e.lines += r * t;
                            break;
                        case 0:
                            e.points += r * t;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                    }
                }
            }
        }

        function Hd(t, e) {
            return t[0] - e[0]
        }

        function zd(t, e) {
            return Math.abs(e[1]) - Math.abs(t[1])
        }

        function Vd(t, e) {
            let n = 1;
            const r = e.isInterleavedBufferAttribute ? e.data.array : e.array;
            r instanceof Int8Array ? n = 127 : r instanceof Int16Array ? n = 32767 : r instanceof Int32Array ? n = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", r), t.divideScalar(n)
        }

        function Wd(t, e, n) {
            const r = {},
                i = new Float32Array(8),
                o = new WeakMap,
                s = new ju,
                a = [];
            for (let t = 0; t < 8; t++) a[t] = [t, 0];
            return {
                update: function(l, u, h, c) {
                    const d = l.morphTargetInfluences;
                    if (!0 === e.isWebGL2) {
                        const r = u.morphAttributes.position || u.morphAttributes.normal || u.morphAttributes.color,
                            i = void 0 !== r ? r.length : 0;
                        let a = o.get(u);
                        if (void 0 === a || a.count !== i) {
                            void 0 !== a && a.texture.dispose();
                            const t = void 0 !== u.morphAttributes.position,
                                n = void 0 !== u.morphAttributes.normal,
                                r = void 0 !== u.morphAttributes.color,
                                l = u.morphAttributes.position || [],
                                h = u.morphAttributes.normal || [],
                                c = u.morphAttributes.color || [];
                            let d = 0;
                            !0 === t && (d = 1), !0 === n && (d = 2), !0 === r && (d = 3);
                            let p = u.attributes.position.count * d,
                                f = 1;
                            p > e.maxTextureSize && (f = Math.ceil(p / e.maxTextureSize), p = e.maxTextureSize);
                            const m = new Float32Array(p * f * 4 * i),
                                g = new qu(m, p, f, i);
                            g.type = zl, g.needsUpdate = !0;
                            const v = 4 * d;
                            for (let e = 0; e < i; e++) {
                                const i = l[e],
                                    o = h[e],
                                    a = c[e],
                                    u = p * f * 4 * e;
                                for (let e = 0; e < i.count; e++) {
                                    const l = e * v;
                                    !0 === t && (s.fromBufferAttribute(i, e), !0 === i.normalized && Vd(s, i), m[u + l + 0] = s.x, m[u + l + 1] = s.y, m[u + l + 2] = s.z, m[u + l + 3] = 0), !0 === n && (s.fromBufferAttribute(o, e), !0 === o.normalized && Vd(s, o), m[u + l + 4] = s.x, m[u + l + 5] = s.y, m[u + l + 6] = s.z, m[u + l + 7] = 0), !0 === r && (s.fromBufferAttribute(a, e), !0 === a.normalized && Vd(s, a), m[u + l + 8] = s.x, m[u + l + 9] = s.y, m[u + l + 10] = s.z, m[u + l + 11] = 4 === a.itemSize ? s.w : 1)
                                }
                            }
                            a = {
                                count: i,
                                texture: g,
                                size: new wu(p, f)
                            }, o.set(u, a), u.addEventListener("dispose", (function t() {
                                g.dispose(), o.delete(u), u.removeEventListener("dispose", t)
                            }))
                        }
                        let l = 0;
                        for (let t = 0; t < d.length; t++) l += d[t];
                        const h = u.morphTargetsRelative ? 1 : 1 - l;
                        c.getUniforms().setValue(t, "morphTargetBaseInfluence", h), c.getUniforms().setValue(t, "morphTargetInfluences", d), c.getUniforms().setValue(t, "morphTargetsTexture", a.texture, n), c.getUniforms().setValue(t, "morphTargetsTextureSize", a.size)
                    } else {
                        const e = void 0 === d ? 0 : d.length;
                        let n = r[u.id];
                        if (void 0 === n || n.length !== e) {
                            n = [];
                            for (let t = 0; t < e; t++) n[t] = [t, 0];
                            r[u.id] = n
                        }
                        for (let t = 0; t < e; t++) {
                            const e = n[t];
                            e[0] = t, e[1] = d[t]
                        }
                        n.sort(zd);
                        for (let t = 0; t < 8; t++) t < e && n[t][1] ? (a[t][0] = n[t][0], a[t][1] = n[t][1]) : (a[t][0] = Number.MAX_SAFE_INTEGER, a[t][1] = 0);
                        a.sort(Hd);
                        const o = u.morphAttributes.position,
                            s = u.morphAttributes.normal;
                        let l = 0;
                        for (let t = 0; t < 8; t++) {
                            const e = a[t],
                                n = e[0],
                                r = e[1];
                            n !== Number.MAX_SAFE_INTEGER && r ? (o && u.getAttribute("morphTarget" + t) !== o[n] && u.setAttribute("morphTarget" + t, o[n]), s && u.getAttribute("morphNormal" + t) !== s[n] && u.setAttribute("morphNormal" + t, s[n]), i[t] = r, l += r) : (o && !0 === u.hasAttribute("morphTarget" + t) && u.deleteAttribute("morphTarget" + t), s && !0 === u.hasAttribute("morphNormal" + t) && u.deleteAttribute("morphNormal" + t), i[t] = 0)
                        }
                        const h = u.morphTargetsRelative ? 1 : 1 - l;
                        c.getUniforms().setValue(t, "morphTargetBaseInfluence", h), c.getUniforms().setValue(t, "morphTargetInfluences", i)
                    }
                }
            }
        }

        function Xd(t, e, n, r) {
            let i = new WeakMap;

            function o(t) {
                const e = t.target;
                e.removeEventListener("dispose", o), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
            }
            return {
                update: function(t) {
                    const s = r.render.frame,
                        a = t.geometry,
                        l = e.get(t, a);
                    return i.get(l) !== s && (e.update(l), i.set(l, s)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", o) && t.addEventListener("dispose", o), n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), l
                },
                dispose: function() {
                    i = new WeakMap
                }
            }
        }
        const jd = new Xu,
            Yd = new qu,
            qd = new Zu,
            Zd = new nd,
            Kd = [],
            Jd = [],
            Qd = new Float32Array(16),
            $d = new Float32Array(9),
            tp = new Float32Array(4);

        function ep(t, e, n) {
            const r = t[0];
            if (r <= 0 || r > 0) return t;
            const i = e * n;
            let o = Kd[i];
            if (void 0 === o && (o = new Float32Array(i), Kd[i] = o), 0 !== e) {
                r.toArray(o, 0);
                for (let r = 1, i = 0; r !== e; ++r) i += n, t[r].toArray(o, i)
            }
            return o
        }

        function np(t, e) {
            if (t.length !== e.length) return !1;
            for (let n = 0, r = t.length; n < r; n++)
                if (t[n] !== e[n]) return !1;
            return !0
        }

        function rp(t, e) {
            for (let n = 0, r = e.length; n < r; n++) t[n] = e[n]
        }

        function ip(t, e) {
            let n = Jd[e];
            void 0 === n && (n = new Int32Array(e), Jd[e] = n);
            for (let r = 0; r !== e; ++r) n[r] = t.allocateTextureUnit();
            return n
        }

        function op(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
        }

        function sp(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
            else {
                if (np(n, e)) return;
                t.uniform2fv(this.addr, e), rp(n, e)
            }
        }

        function ap(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
            else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
            else {
                if (np(n, e)) return;
                t.uniform3fv(this.addr, e), rp(n, e)
            }
        }

        function lp(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
            else {
                if (np(n, e)) return;
                t.uniform4fv(this.addr, e), rp(n, e)
            }
        }

        function up(t, e) {
            const n = this.cache,
                r = e.elements;
            if (void 0 === r) {
                if (np(n, e)) return;
                t.uniformMatrix2fv(this.addr, !1, e), rp(n, e)
            } else {
                if (np(n, r)) return;
                tp.set(r), t.uniformMatrix2fv(this.addr, !1, tp), rp(n, r)
            }
        }

        function hp(t, e) {
            const n = this.cache,
                r = e.elements;
            if (void 0 === r) {
                if (np(n, e)) return;
                t.uniformMatrix3fv(this.addr, !1, e), rp(n, e)
            } else {
                if (np(n, r)) return;
                $d.set(r), t.uniformMatrix3fv(this.addr, !1, $d), rp(n, r)
            }
        }

        function cp(t, e) {
            const n = this.cache,
                r = e.elements;
            if (void 0 === r) {
                if (np(n, e)) return;
                t.uniformMatrix4fv(this.addr, !1, e), rp(n, e)
            } else {
                if (np(n, r)) return;
                Qd.set(r), t.uniformMatrix4fv(this.addr, !1, Qd), rp(n, r)
            }
        }

        function dp(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
        }

        function pp(t, e) {
            const n = this.cache;
            np(n, e) || (t.uniform2iv(this.addr, e), rp(n, e))
        }

        function fp(t, e) {
            const n = this.cache;
            np(n, e) || (t.uniform3iv(this.addr, e), rp(n, e))
        }

        function mp(t, e) {
            const n = this.cache;
            np(n, e) || (t.uniform4iv(this.addr, e), rp(n, e))
        }

        function gp(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
        }

        function vp(t, e) {
            const n = this.cache;
            np(n, e) || (t.uniform2uiv(this.addr, e), rp(n, e))
        }

        function _p(t, e) {
            const n = this.cache;
            np(n, e) || (t.uniform3uiv(this.addr, e), rp(n, e))
        }

        function yp(t, e) {
            const n = this.cache;
            np(n, e) || (t.uniform4uiv(this.addr, e), rp(n, e))
        }

        function xp(t, e, n) {
            const r = this.cache,
                i = n.allocateTextureUnit();
            r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture2D(e || jd, i)
        }

        function bp(t, e, n) {
            const r = this.cache,
                i = n.allocateTextureUnit();
            r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(e || qd, i)
        }

        function Ep(t, e, n) {
            const r = this.cache,
                i = n.allocateTextureUnit();
            r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTextureCube(e || Zd, i)
        }

        function Tp(t, e, n) {
            const r = this.cache,
                i = n.allocateTextureUnit();
            r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(e || Yd, i)
        }

        function Sp(t, e) {
            t.uniform1fv(this.addr, e)
        }

        function wp(t, e) {
            const n = ep(e, this.size, 2);
            t.uniform2fv(this.addr, n)
        }

        function Mp(t, e) {
            const n = ep(e, this.size, 3);
            t.uniform3fv(this.addr, n)
        }

        function Ap(t, e) {
            const n = ep(e, this.size, 4);
            t.uniform4fv(this.addr, n)
        }

        function Rp(t, e) {
            const n = ep(e, this.size, 4);
            t.uniformMatrix2fv(this.addr, !1, n)
        }

        function Pp(t, e) {
            const n = ep(e, this.size, 9);
            t.uniformMatrix3fv(this.addr, !1, n)
        }

        function Ip(t, e) {
            const n = ep(e, this.size, 16);
            t.uniformMatrix4fv(this.addr, !1, n)
        }

        function Cp(t, e) {
            t.uniform1iv(this.addr, e)
        }

        function Op(t, e) {
            t.uniform2iv(this.addr, e)
        }

        function Lp(t, e) {
            t.uniform3iv(this.addr, e)
        }

        function Np(t, e) {
            t.uniform4iv(this.addr, e)
        }

        function Dp(t, e) {
            t.uniform1uiv(this.addr, e)
        }

        function Up(t, e) {
            t.uniform2uiv(this.addr, e)
        }

        function Fp(t, e) {
            t.uniform3uiv(this.addr, e)
        }

        function Bp(t, e) {
            t.uniform4uiv(this.addr, e)
        }

        function kp(t, e, n) {
            const r = e.length,
                i = ip(n, r);
            t.uniform1iv(this.addr, i);
            for (let t = 0; t !== r; ++t) n.setTexture2D(e[t] || jd, i[t])
        }

        function Gp(t, e, n) {
            const r = e.length,
                i = ip(n, r);
            t.uniform1iv(this.addr, i);
            for (let t = 0; t !== r; ++t) n.setTexture3D(e[t] || qd, i[t])
        }

        function Hp(t, e, n) {
            const r = e.length,
                i = ip(n, r);
            t.uniform1iv(this.addr, i);
            for (let t = 0; t !== r; ++t) n.setTextureCube(e[t] || Zd, i[t])
        }

        function zp(t, e, n) {
            const r = e.length,
                i = ip(n, r);
            t.uniform1iv(this.addr, i);
            for (let t = 0; t !== r; ++t) n.setTexture2DArray(e[t] || Yd, i[t])
        }

        function Vp(t, e, n) {
            this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
                switch (t) {
                    case 5126:
                        return op;
                    case 35664:
                        return sp;
                    case 35665:
                        return ap;
                    case 35666:
                        return lp;
                    case 35674:
                        return up;
                    case 35675:
                        return hp;
                    case 35676:
                        return cp;
                    case 5124:
                    case 35670:
                        return dp;
                    case 35667:
                    case 35671:
                        return pp;
                    case 35668:
                    case 35672:
                        return fp;
                    case 35669:
                    case 35673:
                        return mp;
                    case 5125:
                        return gp;
                    case 36294:
                        return vp;
                    case 36295:
                        return _p;
                    case 36296:
                        return yp;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return xp;
                    case 35679:
                    case 36299:
                    case 36307:
                        return bp;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return Ep;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return Tp
                }
            }(e.type)
        }

        function Wp(t, e, n) {
            this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
                switch (t) {
                    case 5126:
                        return Sp;
                    case 35664:
                        return wp;
                    case 35665:
                        return Mp;
                    case 35666:
                        return Ap;
                    case 35674:
                        return Rp;
                    case 35675:
                        return Pp;
                    case 35676:
                        return Ip;
                    case 5124:
                    case 35670:
                        return Cp;
                    case 35667:
                    case 35671:
                        return Op;
                    case 35668:
                    case 35672:
                        return Lp;
                    case 35669:
                    case 35673:
                        return Np;
                    case 5125:
                        return Dp;
                    case 36294:
                        return Up;
                    case 36295:
                        return Fp;
                    case 36296:
                        return Bp;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return kp;
                    case 35679:
                    case 36299:
                    case 36307:
                        return Gp;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return Hp;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return zp
                }
            }(e.type)
        }

        function Xp(t) {
            this.id = t, this.seq = [], this.map = {}
        }
        Wp.prototype.updateCache = function(t) {
            const e = this.cache;
            t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), rp(e, t)
        }, Xp.prototype.setValue = function(t, e, n) {
            const r = this.seq;
            for (let i = 0, o = r.length; i !== o; ++i) {
                const o = r[i];
                o.setValue(t, e[o.id], n)
            }
        };
        const jp = /(\w+)(\])?(\[|\.)?/g;

        function Yp(t, e) {
            t.seq.push(e), t.map[e.id] = e
        }

        function qp(t, e, n) {
            const r = t.name,
                i = r.length;
            for (jp.lastIndex = 0;;) {
                const o = jp.exec(r),
                    s = jp.lastIndex;
                let a = o[1];
                const l = "]" === o[2],
                    u = o[3];
                if (l && (a |= 0), void 0 === u || "[" === u && s + 2 === i) {
                    Yp(n, void 0 === u ? new Vp(a, t, e) : new Wp(a, t, e));
                    break
                } {
                    let t = n.map[a];
                    void 0 === t && (t = new Xp(a), Yp(n, t)), n = t
                }
            }
        }

        function Zp(t, e) {
            this.seq = [], this.map = {};
            const n = t.getProgramParameter(e, 35718);
            for (let r = 0; r < n; ++r) {
                const n = t.getActiveUniform(e, r);
                qp(n, t.getUniformLocation(e, n.name), this)
            }
        }

        function Kp(t, e, n) {
            const r = t.createShader(e);
            return t.shaderSource(r, n), t.compileShader(r), r
        }
        Zp.prototype.setValue = function(t, e, n, r) {
            const i = this.map[e];
            void 0 !== i && i.setValue(t, n, r)
        }, Zp.prototype.setOptional = function(t, e, n) {
            const r = e[n];
            void 0 !== r && this.setValue(t, n, r)
        }, Zp.upload = function(t, e, n, r) {
            for (let i = 0, o = e.length; i !== o; ++i) {
                const o = e[i],
                    s = n[o.id];
                !1 !== s.needsUpdate && o.setValue(t, s.value, r)
            }
        }, Zp.seqWithValue = function(t, e) {
            const n = [];
            for (let r = 0, i = t.length; r !== i; ++r) {
                const i = t[r];
                i.id in e && n.push(i)
            }
            return n
        };
        let Jp = 0;

        function Qp(t, e, n) {
            const r = t.getShaderParameter(e, 35713),
                i = t.getShaderInfoLog(e).trim();
            if (r && "" === i) return "";
            const o = parseInt(/ERROR: 0:(\d+)/.exec(i)[1]);
            return n.toUpperCase() + "\n\n" + i + "\n\n" + function(t, e) {
                const n = t.split("\n"),
                    r = [],
                    i = Math.max(e - 6, 0),
                    o = Math.min(e + 6, n.length);
                for (let t = i; t < o; t++) r.push(t + 1 + ": " + n[t]);
                return r.join("\n")
            }(t.getShaderSource(e), o)
        }

        function $p(t, e) {
            const n = function(t) {
                switch (t) {
                    case iu:
                        return ["Linear", "( value )"];
                    case ou:
                        return ["sRGB", "( value )"];
                    default:
                        return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
                }
            }(e);
            return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
        }

        function tf(t, e) {
            let n;
            switch (e) {
                case 1:
                    n = "Linear";
                    break;
                case 2:
                    n = "Reinhard";
                    break;
                case 3:
                    n = "OptimizedCineon";
                    break;
                case 4:
                    n = "ACESFilmic";
                    break;
                case 5:
                    n = "Custom";
                    break;
                default:
                    console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
            }
            return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }

        function ef(t) {
            return "" !== t
        }

        function nf(t, e) {
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }

        function rf(t, e) {
            return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }
        const of = /^[ \t]*#include +<([\w\d./]+)>/gm;

        function sf(t) {
            return t.replace(of, af)
        }

        function af(t, e) {
            const n = fd[e];
            if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
            return sf(n)
        }
        const lf = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
            uf = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

        function hf(t) {
            return t.replace(uf, df).replace(lf, cf)
        }

        function cf(t, e, n, r) {
            return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), df(0, e, n, r)
        }

        function df(t, e, n, r) {
            let i = "";
            for (let t = parseInt(e); t < parseInt(n); t++) i += r.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
            return i
        }

        function pf(t) {
            let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
            return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
        }

        function ff(t, e, n, r) {
            const i = t.getContext(),
                o = n.defines;
            let s = n.vertexShader,
                a = n.fragmentShader;
            const l = function(t) {
                    let e = "SHADOWMAP_TYPE_BASIC";
                    return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e
                }(n),
                u = function(t) {
                    let e = "ENVMAP_TYPE_CUBE";
                    if (t.envMap) switch (t.envMapMode) {
                        case Il:
                        case Cl:
                            e = "ENVMAP_TYPE_CUBE";
                            break;
                        case Ol:
                            e = "ENVMAP_TYPE_CUBE_UV"
                    }
                    return e
                }(n),
                h = function(t) {
                    let e = "ENVMAP_MODE_REFLECTION";
                    if (t.envMap) switch (t.envMapMode) {
                        case Cl:
                            e = "ENVMAP_MODE_REFRACTION"
                    }
                    return e
                }(n),
                c = function(t) {
                    let e = "ENVMAP_BLENDING_NONE";
                    if (t.envMap) switch (t.combine) {
                        case 0:
                            e = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case 1:
                            e = "ENVMAP_BLENDING_MIX";
                            break;
                        case 2:
                            e = "ENVMAP_BLENDING_ADD"
                    }
                    return e
                }(n),
                d = function(t) {
                    const e = t.envMapCubeUVHeight;
                    if (null === e) return null;
                    const n = Math.log2(e / 32 + 1) + 3,
                        r = 1 / e;
                    return {
                        texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                        texelHeight: r,
                        maxMip: n
                    }
                }(n),
                p = n.isWebGL2 ? "" : function(t) {
                    return [t.extensionDerivatives || t.envMapCubeUVHeight || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ef).join("\n")
                }(n),
                f = function(t) {
                    const e = [];
                    for (const n in t) {
                        const r = t[n];
                        !1 !== r && e.push("#define " + n + " " + r)
                    }
                    return e.join("\n")
                }(o),
                m = i.createProgram();
            let g, v, _ = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
            n.isRawShaderMaterial ? (g = [f].filter(ef).join("\n"), g.length > 0 && (g += "\n"), v = [p, f].filter(ef).join("\n"), v.length > 0 && (v += "\n")) : (g = [pf(n), "#define SHADER_NAME " + n.shaderName, f, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(ef).join("\n"), v = [p, pf(n), "#define SHADER_NAME " + n.shaderName, f, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + c : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? fd.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? tf("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", fd.encodings_pars_fragment, $p("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(ef).join("\n")), s = sf(s), s = nf(s, n), s = rf(s, n), a = sf(a), a = nf(a, n), a = rf(a, n), s = hf(s), a = hf(a), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (_ = "#version 300 es\n", g = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#define varying in", n.glslVersion === cu ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === cu ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
            const y = _ + v + a,
                x = Kp(i, 35633, _ + g + s),
                b = Kp(i, 35632, y);
            if (i.attachShader(m, x), i.attachShader(m, b), void 0 !== n.index0AttributeName ? i.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && i.bindAttribLocation(m, 0, "position"), i.linkProgram(m), t.debug.checkShaderErrors) {
                const t = i.getProgramInfoLog(m).trim(),
                    e = i.getShaderInfoLog(x).trim(),
                    n = i.getShaderInfoLog(b).trim();
                let r = !0,
                    o = !0;
                if (!1 === i.getProgramParameter(m, 35714)) {
                    r = !1;
                    const e = Qp(i, x, "vertex"),
                        n = Qp(i, b, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(m, 35715) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + n)
                } else "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== e && "" !== n || (o = !1);
                o && (this.diagnostics = {
                    runnable: r,
                    programLog: t,
                    vertexShader: {
                        log: e,
                        prefix: g
                    },
                    fragmentShader: {
                        log: n,
                        prefix: v
                    }
                })
            }
            let E, T;
            return i.deleteShader(x), i.deleteShader(b), this.getUniforms = function() {
                return void 0 === E && (E = new Zp(i, m)), E
            }, this.getAttributes = function() {
                return void 0 === T && (T = function(t, e) {
                    const n = {},
                        r = t.getProgramParameter(e, 35721);
                    for (let i = 0; i < r; i++) {
                        const r = t.getActiveAttrib(e, i),
                            o = r.name;
                        let s = 1;
                        35674 === r.type && (s = 2), 35675 === r.type && (s = 3), 35676 === r.type && (s = 4), n[o] = {
                            type: r.type,
                            location: t.getAttribLocation(e, o),
                            locationSize: s
                        }
                    }
                    return n
                }(i, m)), T
            }, this.destroy = function() {
                r.releaseStatesOfProgram(this), i.deleteProgram(m), this.program = void 0
            }, this.name = n.shaderName, this.id = Jp++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = x, this.fragmentShader = b, this
        }
        let mf = 0;
        class gf {
            constructor() {
                this.shaderCache = new Map, this.materialCache = new Map
            }
            update(t) {
                const e = t.vertexShader,
                    n = t.fragmentShader,
                    r = this._getShaderStage(e),
                    i = this._getShaderStage(n),
                    o = this._getShaderCacheForMaterial(t);
                return !1 === o.has(r) && (o.add(r), r.usedTimes++), !1 === o.has(i) && (o.add(i), i.usedTimes++), this
            }
            remove(t) {
                const e = this.materialCache.get(t);
                for (const t of e) t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t.code);
                return this.materialCache.delete(t), this
            }
            getVertexShaderID(t) {
                return this._getShaderStage(t.vertexShader).id
            }
            getFragmentShaderID(t) {
                return this._getShaderStage(t.fragmentShader).id
            }
            dispose() {
                this.shaderCache.clear(), this.materialCache.clear()
            }
            _getShaderCacheForMaterial(t) {
                const e = this.materialCache;
                return !1 === e.has(t) && e.set(t, new Set), e.get(t)
            }
            _getShaderStage(t) {
                const e = this.shaderCache;
                if (!1 === e.has(t)) {
                    const n = new vf(t);
                    e.set(t, n)
                }
                return e.get(t)
            }
        }
        class vf {
            constructor(t) {
                this.id = mf++, this.code = t, this.usedTimes = 0
            }
        }

        function _f(t, e, n, r, i, o, s) {
            const a = new kh,
                l = new gf,
                u = [],
                h = i.isWebGL2,
                c = i.logarithmicDepthBuffer,
                d = i.floatVertexTextures,
                p = i.maxVertexUniforms,
                f = i.vertexTextures;
            let m = i.precision;
            const g = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            };
            return {
                getParameters: function(o, a, u, v, _) {
                    const y = v.fog,
                        x = _.geometry,
                        b = o.isMeshStandardMaterial ? v.environment : null,
                        E = (o.isMeshStandardMaterial ? n : e).get(o.envMap || b),
                        T = E && E.mapping === Ol ? E.image.height : null,
                        S = g[o.type],
                        w = _.isSkinnedMesh ? function(t) {
                            const e = t.skeleton.bones;
                            if (d) return 1024; {
                                const t = p,
                                    n = Math.floor((t - 20) / 4),
                                    r = Math.min(n, e.length);
                                return r < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + r + "."), 0) : r
                            }
                        }(_) : 0;
                    null !== o.precision && (m = i.getMaxPrecision(o.precision), m !== o.precision && console.warn("THREE.WebGLProgram.getParameters:", o.precision, "not supported, using", m, "instead."));
                    const M = x.morphAttributes.position || x.morphAttributes.normal || x.morphAttributes.color,
                        A = void 0 !== M ? M.length : 0;
                    let R, P, I, C, O = 0;
                    if (void 0 !== x.morphAttributes.position && (O = 1), void 0 !== x.morphAttributes.normal && (O = 2), void 0 !== x.morphAttributes.color && (O = 3), S) {
                        const t = gd[S];
                        R = t.vertexShader, P = t.fragmentShader
                    } else R = o.vertexShader, P = o.fragmentShader, l.update(o), I = l.getVertexShaderID(o), C = l.getFragmentShaderID(o);
                    const L = t.getRenderTarget(),
                        N = o.alphaTest > 0,
                        D = o.clearcoat > 0;
                    return {
                        isWebGL2: h,
                        shaderID: S,
                        shaderName: o.type,
                        vertexShader: R,
                        fragmentShader: P,
                        defines: o.defines,
                        customVertexShaderID: I,
                        customFragmentShaderID: C,
                        isRawShaderMaterial: !0 === o.isRawShaderMaterial,
                        glslVersion: o.glslVersion,
                        precision: m,
                        instancing: !0 === _.isInstancedMesh,
                        instancingColor: !0 === _.isInstancedMesh && null !== _.instanceColor,
                        supportsVertexTextures: f,
                        outputEncoding: null === L ? t.outputEncoding : !0 === L.isXRRenderTarget ? L.texture.encoding : iu,
                        map: !!o.map,
                        matcap: !!o.matcap,
                        envMap: !!E,
                        envMapMode: E && E.mapping,
                        envMapCubeUVHeight: T,
                        lightMap: !!o.lightMap,
                        aoMap: !!o.aoMap,
                        emissiveMap: !!o.emissiveMap,
                        bumpMap: !!o.bumpMap,
                        normalMap: !!o.normalMap,
                        objectSpaceNormalMap: 1 === o.normalMapType,
                        tangentSpaceNormalMap: 0 === o.normalMapType,
                        decodeVideoTexture: !!o.map && !0 === o.map.isVideoTexture && o.map.encoding === ou,
                        clearcoat: D,
                        clearcoatMap: D && !!o.clearcoatMap,
                        clearcoatRoughnessMap: D && !!o.clearcoatRoughnessMap,
                        clearcoatNormalMap: D && !!o.clearcoatNormalMap,
                        displacementMap: !!o.displacementMap,
                        roughnessMap: !!o.roughnessMap,
                        metalnessMap: !!o.metalnessMap,
                        specularMap: !!o.specularMap,
                        specularIntensityMap: !!o.specularIntensityMap,
                        specularColorMap: !!o.specularColorMap,
                        opaque: !1 === o.transparent && 1 === o.blending,
                        alphaMap: !!o.alphaMap,
                        alphaTest: N,
                        gradientMap: !!o.gradientMap,
                        sheen: o.sheen > 0,
                        sheenColorMap: !!o.sheenColorMap,
                        sheenRoughnessMap: !!o.sheenRoughnessMap,
                        transmission: o.transmission > 0,
                        transmissionMap: !!o.transmissionMap,
                        thicknessMap: !!o.thicknessMap,
                        combine: o.combine,
                        vertexTangents: !!o.normalMap && !!x.attributes.tangent,
                        vertexColors: o.vertexColors,
                        vertexAlphas: !0 === o.vertexColors && !!x.attributes.color && 4 === x.attributes.color.itemSize,
                        vertexUvs: !!(o.map || o.bumpMap || o.normalMap || o.specularMap || o.alphaMap || o.emissiveMap || o.roughnessMap || o.metalnessMap || o.clearcoatMap || o.clearcoatRoughnessMap || o.clearcoatNormalMap || o.displacementMap || o.transmissionMap || o.thicknessMap || o.specularIntensityMap || o.specularColorMap || o.sheenColorMap || o.sheenRoughnessMap),
                        uvsVertexOnly: !(o.map || o.bumpMap || o.normalMap || o.specularMap || o.alphaMap || o.emissiveMap || o.roughnessMap || o.metalnessMap || o.clearcoatNormalMap || o.transmission > 0 || o.transmissionMap || o.thicknessMap || o.specularIntensityMap || o.specularColorMap || o.sheen > 0 || o.sheenColorMap || o.sheenRoughnessMap || !o.displacementMap),
                        fog: !!y,
                        useFog: o.fog,
                        fogExp2: y && y.isFogExp2,
                        flatShading: !!o.flatShading,
                        sizeAttenuation: o.sizeAttenuation,
                        logarithmicDepthBuffer: c,
                        skinning: !0 === _.isSkinnedMesh && w > 0,
                        maxBones: w,
                        useVertexTexture: d,
                        morphTargets: void 0 !== x.morphAttributes.position,
                        morphNormals: void 0 !== x.morphAttributes.normal,
                        morphColors: void 0 !== x.morphAttributes.color,
                        morphTargetsCount: A,
                        morphTextureStride: O,
                        numDirLights: a.directional.length,
                        numPointLights: a.point.length,
                        numSpotLights: a.spot.length,
                        numRectAreaLights: a.rectArea.length,
                        numHemiLights: a.hemi.length,
                        numDirLightShadows: a.directionalShadowMap.length,
                        numPointLightShadows: a.pointShadowMap.length,
                        numSpotLightShadows: a.spotShadowMap.length,
                        numClippingPlanes: s.numPlanes,
                        numClipIntersection: s.numIntersection,
                        dithering: o.dithering,
                        shadowMapEnabled: t.shadowMap.enabled && u.length > 0,
                        shadowMapType: t.shadowMap.type,
                        toneMapping: o.toneMapped ? t.toneMapping : 0,
                        physicallyCorrectLights: t.physicallyCorrectLights,
                        premultipliedAlpha: o.premultipliedAlpha,
                        doubleSided: 2 === o.side,
                        flipSided: 1 === o.side,
                        depthPacking: void 0 !== o.depthPacking && o.depthPacking,
                        index0AttributeName: o.index0AttributeName,
                        extensionDerivatives: o.extensions && o.extensions.derivatives,
                        extensionFragDepth: o.extensions && o.extensions.fragDepth,
                        extensionDrawBuffers: o.extensions && o.extensions.drawBuffers,
                        extensionShaderTextureLOD: o.extensions && o.extensions.shaderTextureLOD,
                        rendererExtensionFragDepth: h || r.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: h || r.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: h || r.has("EXT_shader_texture_lod"),
                        customProgramCacheKey: o.customProgramCacheKey()
                    }
                },
                getProgramCacheKey: function(e) {
                    const n = [];
                    if (e.shaderID ? n.push(e.shaderID) : (n.push(e.customVertexShaderID), n.push(e.customFragmentShaderID)), void 0 !== e.defines)
                        for (const t in e.defines) n.push(t), n.push(e.defines[t]);
                    return !1 === e.isRawShaderMaterial && (function(t, e) {
                        t.push(e.precision), t.push(e.outputEncoding), t.push(e.envMapMode), t.push(e.envMapCubeUVHeight), t.push(e.combine), t.push(e.vertexUvs), t.push(e.fogExp2), t.push(e.sizeAttenuation), t.push(e.maxBones), t.push(e.morphTargetsCount), t.push(e.morphAttributeCount), t.push(e.numDirLights), t.push(e.numPointLights), t.push(e.numSpotLights), t.push(e.numHemiLights), t.push(e.numRectAreaLights), t.push(e.numDirLightShadows), t.push(e.numPointLightShadows), t.push(e.numSpotLightShadows), t.push(e.shadowMapType), t.push(e.toneMapping), t.push(e.numClippingPlanes), t.push(e.numClipIntersection)
                    }(n, e), function(t, e) {
                        a.disableAll(), e.isWebGL2 && a.enable(0), e.supportsVertexTextures && a.enable(1), e.instancing && a.enable(2), e.instancingColor && a.enable(3), e.map && a.enable(4), e.matcap && a.enable(5), e.envMap && a.enable(6), e.lightMap && a.enable(7), e.aoMap && a.enable(8), e.emissiveMap && a.enable(9), e.bumpMap && a.enable(10), e.normalMap && a.enable(11), e.objectSpaceNormalMap && a.enable(12), e.tangentSpaceNormalMap && a.enable(13), e.clearcoat && a.enable(14), e.clearcoatMap && a.enable(15), e.clearcoatRoughnessMap && a.enable(16), e.clearcoatNormalMap && a.enable(17), e.displacementMap && a.enable(18), e.specularMap && a.enable(19), e.roughnessMap && a.enable(20), e.metalnessMap && a.enable(21), e.gradientMap && a.enable(22), e.alphaMap && a.enable(23), e.alphaTest && a.enable(24), e.vertexColors && a.enable(25), e.vertexAlphas && a.enable(26), e.vertexUvs && a.enable(27), e.vertexTangents && a.enable(28), e.uvsVertexOnly && a.enable(29), e.fog && a.enable(30), t.push(a.mask), a.disableAll(), e.useFog && a.enable(0), e.flatShading && a.enable(1), e.logarithmicDepthBuffer && a.enable(2), e.skinning && a.enable(3), e.useVertexTexture && a.enable(4), e.morphTargets && a.enable(5), e.morphNormals && a.enable(6), e.morphColors && a.enable(7), e.premultipliedAlpha && a.enable(8), e.shadowMapEnabled && a.enable(9), e.physicallyCorrectLights && a.enable(10), e.doubleSided && a.enable(11), e.flipSided && a.enable(12), e.depthPacking && a.enable(13), e.dithering && a.enable(14), e.specularIntensityMap && a.enable(15), e.specularColorMap && a.enable(16), e.transmission && a.enable(17), e.transmissionMap && a.enable(18), e.thicknessMap && a.enable(19), e.sheen && a.enable(20), e.sheenColorMap && a.enable(21), e.sheenRoughnessMap && a.enable(22), e.decodeVideoTexture && a.enable(23), e.opaque && a.enable(24), t.push(a.mask)
                    }(n, e), n.push(t.outputEncoding)), n.push(e.customProgramCacheKey), n.join()
                },
                getUniforms: function(t) {
                    const e = g[t.type];
                    let n;
                    if (e) {
                        const t = gd[e];
                        n = Kc.clone(t.uniforms)
                    } else n = t.uniforms;
                    return n
                },
                acquireProgram: function(e, n) {
                    let r;
                    for (let t = 0, e = u.length; t < e; t++) {
                        const e = u[t];
                        if (e.cacheKey === n) {
                            r = e, ++r.usedTimes;
                            break
                        }
                    }
                    return void 0 === r && (r = new ff(t, n, e, o), u.push(r)), r
                },
                releaseProgram: function(t) {
                    if (0 == --t.usedTimes) {
                        const e = u.indexOf(t);
                        u[e] = u[u.length - 1], u.pop(), t.destroy()
                    }
                },
                releaseShaderCache: function(t) {
                    l.remove(t)
                },
                programs: u,
                dispose: function() {
                    l.dispose()
                }
            }
        }

        function yf() {
            let t = new WeakMap;
            return {
                get: function(e) {
                    let n = t.get(e);
                    return void 0 === n && (n = {}, t.set(e, n)), n
                },
                remove: function(e) {
                    t.delete(e)
                },
                update: function(e, n, r) {
                    t.get(e)[n] = r
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }

        function xf(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }

        function bf(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }

        function Ef() {
            const t = [];
            let e = 0;
            const n = [],
                r = [],
                i = [];

            function o(n, r, i, o, s, a) {
                let l = t[e];
                return void 0 === l ? (l = {
                    id: n.id,
                    object: n,
                    geometry: r,
                    material: i,
                    groupOrder: o,
                    renderOrder: n.renderOrder,
                    z: s,
                    group: a
                }, t[e] = l) : (l.id = n.id, l.object = n, l.geometry = r, l.material = i, l.groupOrder = o, l.renderOrder = n.renderOrder, l.z = s, l.group = a), e++, l
            }
            return {
                opaque: n,
                transmissive: r,
                transparent: i,
                init: function() {
                    e = 0, n.length = 0, r.length = 0, i.length = 0
                },
                push: function(t, e, s, a, l, u) {
                    const h = o(t, e, s, a, l, u);
                    s.transmission > 0 ? r.push(h) : !0 === s.transparent ? i.push(h) : n.push(h)
                },
                unshift: function(t, e, s, a, l, u) {
                    const h = o(t, e, s, a, l, u);
                    s.transmission > 0 ? r.unshift(h) : !0 === s.transparent ? i.unshift(h) : n.unshift(h)
                },
                finish: function() {
                    for (let n = e, r = t.length; n < r; n++) {
                        const e = t[n];
                        if (null === e.id) break;
                        e.id = null, e.object = null, e.geometry = null, e.material = null, e.group = null
                    }
                },
                sort: function(t, e) {
                    n.length > 1 && n.sort(t || xf), r.length > 1 && r.sort(e || bf), i.length > 1 && i.sort(e || bf)
                }
            }
        }

        function Tf() {
            let t = new WeakMap;
            return {
                get: function(e, n) {
                    let r;
                    return !1 === t.has(e) ? (r = new Ef, t.set(e, [r])) : n >= t.get(e).length ? (r = new Ef, t.get(e).push(r)) : r = t.get(e)[n], r
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }

        function Sf() {
            const t = {};
            return {
                get: function(e) {
                    if (void 0 !== t[e.id]) return t[e.id];
                    let n;
                    switch (e.type) {
                        case "DirectionalLight":
                            n = {
                                direction: new Ju,
                                color: new ku
                            };
                            break;
                        case "SpotLight":
                            n = {
                                position: new Ju,
                                direction: new Ju,
                                color: new ku,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;
                        case "PointLight":
                            n = {
                                position: new Ju,
                                color: new ku,
                                distance: 0,
                                decay: 0
                            };
                            break;
                        case "HemisphereLight":
                            n = {
                                direction: new Ju,
                                skyColor: new ku,
                                groundColor: new ku
                            };
                            break;
                        case "RectAreaLight":
                            n = {
                                color: new ku,
                                position: new Ju,
                                halfWidth: new Ju,
                                halfHeight: new Ju
                            }
                    }
                    return t[e.id] = n, n
                }
            }
        }
        let wf = 0;

        function Mf(t, e) {
            return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
        }

        function Af(t, e) {
            const n = new Sf,
                r = function() {
                    const t = {};
                    return {
                        get: function(e) {
                            if (void 0 !== t[e.id]) return t[e.id];
                            let n;
                            switch (e.type) {
                                case "DirectionalLight":
                                case "SpotLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new wu
                                    };
                                    break;
                                case "PointLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new wu,
                                        shadowCameraNear: 1,
                                        shadowCameraFar: 1e3
                                    }
                            }
                            return t[e.id] = n, n
                        }
                    }
                }(),
                i = {
                    version: 0,
                    hash: {
                        directionalLength: -1,
                        pointLength: -1,
                        spotLength: -1,
                        rectAreaLength: -1,
                        hemiLength: -1,
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1
                    },
                    ambient: [0, 0, 0],
                    probe: [],
                    directional: [],
                    directionalShadow: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotShadow: [],
                    spotShadowMap: [],
                    spotShadowMatrix: [],
                    rectArea: [],
                    rectAreaLTC1: null,
                    rectAreaLTC2: null,
                    point: [],
                    pointShadow: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: []
                };
            for (let t = 0; t < 9; t++) i.probe.push(new Ju);
            const o = new Ju,
                s = new Rh,
                a = new Rh;
            return {
                setup: function(o, s) {
                    let a = 0,
                        l = 0,
                        u = 0;
                    for (let t = 0; t < 9; t++) i.probe[t].set(0, 0, 0);
                    let h = 0,
                        c = 0,
                        d = 0,
                        p = 0,
                        f = 0,
                        m = 0,
                        g = 0,
                        v = 0;
                    o.sort(Mf);
                    const _ = !0 !== s ? Math.PI : 1;
                    for (let t = 0, e = o.length; t < e; t++) {
                        const e = o[t],
                            s = e.color,
                            y = e.intensity,
                            x = e.distance,
                            b = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                        if (e.isAmbientLight) a += s.r * y * _, l += s.g * y * _, u += s.b * y * _;
                        else if (e.isLightProbe)
                            for (let t = 0; t < 9; t++) i.probe[t].addScaledVector(e.sh.coefficients[t], y);
                        else if (e.isDirectionalLight) {
                            const t = n.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity * _), e.castShadow) {
                                const t = e.shadow,
                                    n = r.get(e);
                                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, i.directionalShadow[h] = n, i.directionalShadowMap[h] = b, i.directionalShadowMatrix[h] = e.shadow.matrix, m++
                            }
                            i.directional[h] = t, h++
                        } else if (e.isSpotLight) {
                            const t = n.get(e);
                            if (t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(s).multiplyScalar(y * _), t.distance = x, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, e.castShadow) {
                                const t = e.shadow,
                                    n = r.get(e);
                                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, i.spotShadow[d] = n, i.spotShadowMap[d] = b, i.spotShadowMatrix[d] = e.shadow.matrix, v++
                            }
                            i.spot[d] = t, d++
                        } else if (e.isRectAreaLight) {
                            const t = n.get(e);
                            t.color.copy(s).multiplyScalar(y), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), i.rectArea[p] = t, p++
                        } else if (e.isPointLight) {
                            const t = n.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity * _), t.distance = e.distance, t.decay = e.decay, e.castShadow) {
                                const t = e.shadow,
                                    n = r.get(e);
                                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, i.pointShadow[c] = n, i.pointShadowMap[c] = b, i.pointShadowMatrix[c] = e.shadow.matrix, g++
                            }
                            i.point[c] = t, c++
                        } else if (e.isHemisphereLight) {
                            const t = n.get(e);
                            t.skyColor.copy(e.color).multiplyScalar(y * _), t.groundColor.copy(e.groundColor).multiplyScalar(y * _), i.hemi[f] = t, f++
                        }
                    }
                    p > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = md.LTC_FLOAT_1, i.rectAreaLTC2 = md.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (i.rectAreaLTC1 = md.LTC_HALF_1, i.rectAreaLTC2 = md.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = a, i.ambient[1] = l, i.ambient[2] = u;
                    const y = i.hash;
                    y.directionalLength === h && y.pointLength === c && y.spotLength === d && y.rectAreaLength === p && y.hemiLength === f && y.numDirectionalShadows === m && y.numPointShadows === g && y.numSpotShadows === v || (i.directional.length = h, i.spot.length = d, i.rectArea.length = p, i.point.length = c, i.hemi.length = f, i.directionalShadow.length = m, i.directionalShadowMap.length = m, i.pointShadow.length = g, i.pointShadowMap.length = g, i.spotShadow.length = v, i.spotShadowMap.length = v, i.directionalShadowMatrix.length = m, i.pointShadowMatrix.length = g, i.spotShadowMatrix.length = v, y.directionalLength = h, y.pointLength = c, y.spotLength = d, y.rectAreaLength = p, y.hemiLength = f, y.numDirectionalShadows = m, y.numPointShadows = g, y.numSpotShadows = v, i.version = wf++)
                },
                setupView: function(t, e) {
                    let n = 0,
                        r = 0,
                        l = 0,
                        u = 0,
                        h = 0;
                    const c = e.matrixWorldInverse;
                    for (let e = 0, d = t.length; e < d; e++) {
                        const d = t[e];
                        if (d.isDirectionalLight) {
                            const t = i.directional[n];
                            t.direction.setFromMatrixPosition(d.matrixWorld), o.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(o), t.direction.transformDirection(c), n++
                        } else if (d.isSpotLight) {
                            const t = i.spot[l];
                            t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(c), t.direction.setFromMatrixPosition(d.matrixWorld), o.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(o), t.direction.transformDirection(c), l++
                        } else if (d.isRectAreaLight) {
                            const t = i.rectArea[u];
                            t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(c), a.identity(), s.copy(d.matrixWorld), s.premultiply(c), a.extractRotation(s), t.halfWidth.set(.5 * d.width, 0, 0), t.halfHeight.set(0, .5 * d.height, 0), t.halfWidth.applyMatrix4(a), t.halfHeight.applyMatrix4(a), u++
                        } else if (d.isPointLight) {
                            const t = i.point[r];
                            t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(c), r++
                        } else if (d.isHemisphereLight) {
                            const t = i.hemi[h];
                            t.direction.setFromMatrixPosition(d.matrixWorld), t.direction.transformDirection(c), t.direction.normalize(), h++
                        }
                    }
                },
                state: i
            }
        }

        function Rf(t, e) {
            const n = new Af(t, e),
                r = [],
                i = [];
            return {
                init: function() {
                    r.length = 0, i.length = 0
                },
                state: {
                    lightsArray: r,
                    shadowsArray: i,
                    lights: n
                },
                setupLights: function(t) {
                    n.setup(r, t)
                },
                setupLightsView: function(t) {
                    n.setupView(r, t)
                },
                pushLight: function(t) {
                    r.push(t)
                },
                pushShadow: function(t) {
                    i.push(t)
                }
            }
        }

        function Pf(t, e) {
            let n = new WeakMap;
            return {
                get: function(r, i = 0) {
                    let o;
                    return !1 === n.has(r) ? (o = new Rf(t, e), n.set(r, [o])) : i >= n.get(r).length ? (o = new Rf(t, e), n.get(r).push(o)) : o = n.get(r)[i], o
                },
                dispose: function() {
                    n = new WeakMap
                }
            }
        }
        class If extends dc {
            constructor(t) {
                super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
            }
        }
        If.prototype.isMeshDepthMaterial = !0;
        class Cf extends dc {
            constructor(t) {
                super(), this.type = "MeshDistanceMaterial", this.referencePosition = new Ju, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
            }
        }

        function Of(t, e, n) {
            let r = new hd;
            const i = new wu,
                o = new wu,
                s = new ju,
                a = new If({
                    depthPacking: 3201
                }),
                l = new Cf,
                u = {},
                h = n.maxTextureSize,
                c = {
                    0: 1,
                    1: 0,
                    2: 2
                },
                d = new Jc({
                    defines: {
                        VSM_SAMPLES: 8
                    },
                    uniforms: {
                        shadow_pass: {
                            value: null
                        },
                        resolution: {
                            value: new wu
                        },
                        radius: {
                            value: 4
                        }
                    },
                    vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                    fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                }),
                p = d.clone();
            p.defines.HORIZONTAL_PASS = 1;
            const f = new Ac;
            f.setAttribute("position", new gc(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
            const m = new Xc(f, d),
                g = this;

            function v(n, r) {
                const i = e.update(m);
                d.defines.VSM_SAMPLES !== n.blurSamples && (d.defines.VSM_SAMPLES = n.blurSamples, p.defines.VSM_SAMPLES = n.blurSamples, d.needsUpdate = !0, p.needsUpdate = !0), d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(r, null, i, d, m, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(r, null, i, p, m, null)
            }

            function _(e, n, r, i, o, s) {
                let h = null;
                const d = !0 === r.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
                if (h = void 0 !== d ? d : !0 === r.isPointLight ? l : a, t.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0) {
                    const t = h.uuid,
                        e = n.uuid;
                    let r = u[t];
                    void 0 === r && (r = {}, u[t] = r);
                    let i = r[e];
                    void 0 === i && (i = h.clone(), r[e] = i), h = i
                }
                return h.visible = n.visible, h.wireframe = n.wireframe, h.side = 3 === s ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : c[n.side], h.alphaMap = n.alphaMap, h.alphaTest = n.alphaTest, h.clipShadows = n.clipShadows, h.clippingPlanes = n.clippingPlanes, h.clipIntersection = n.clipIntersection, h.displacementMap = n.displacementMap, h.displacementScale = n.displacementScale, h.displacementBias = n.displacementBias, h.wireframeLinewidth = n.wireframeLinewidth, h.linewidth = n.linewidth, !0 === r.isPointLight && !0 === h.isMeshDistanceMaterial && (h.referencePosition.setFromMatrixPosition(r.matrixWorld), h.nearDistance = i, h.farDistance = o), h
            }

            function y(n, i, o, s, a) {
                if (!1 === n.visible) return;
                if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === a) && (!n.frustumCulled || r.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                    const r = e.update(n),
                        i = n.material;
                    if (Array.isArray(i)) {
                        const e = r.groups;
                        for (let l = 0, u = e.length; l < u; l++) {
                            const u = e[l],
                                h = i[u.materialIndex];
                            if (h && h.visible) {
                                const e = _(n, h, s, o.near, o.far, a);
                                t.renderBufferDirect(o, null, r, e, n, u)
                            }
                        }
                    } else if (i.visible) {
                        const e = _(n, i, s, o.near, o.far, a);
                        t.renderBufferDirect(o, null, r, e, n, null)
                    }
                }
                const l = n.children;
                for (let t = 0, e = l.length; t < e; t++) y(l[t], i, o, s, a)
            }
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(e, n, a) {
                if (!1 === g.enabled) return;
                if (!1 === g.autoUpdate && !1 === g.needsUpdate) return;
                if (0 === e.length) return;
                const l = t.getRenderTarget(),
                    u = t.getActiveCubeFace(),
                    c = t.getActiveMipmapLevel(),
                    d = t.state;
                d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                for (let l = 0, u = e.length; l < u; l++) {
                    const u = e[l],
                        c = u.shadow;
                    if (void 0 === c) {
                        console.warn("THREE.WebGLShadowMap:", u, "has no shadow.");
                        continue
                    }
                    if (!1 === c.autoUpdate && !1 === c.needsUpdate) continue;
                    i.copy(c.mapSize);
                    const p = c.getFrameExtents();
                    if (i.multiply(p), o.copy(c.mapSize), (i.x > h || i.y > h) && (i.x > h && (o.x = Math.floor(h / p.x), i.x = o.x * p.x, c.mapSize.x = o.x), i.y > h && (o.y = Math.floor(h / p.y), i.y = o.y * p.y, c.mapSize.y = o.y)), null !== c.map || c.isPointLightShadow || 3 !== this.type || (c.map = new Yu(i.x, i.y), c.map.texture.name = u.name + ".shadowMap", c.mapPass = new Yu(i.x, i.y), c.camera.updateProjectionMatrix()), null === c.map) {
                        const t = {
                            minFilter: Ul,
                            magFilter: Ul,
                            format: Xl
                        };
                        c.map = new Yu(i.x, i.y, t), c.map.texture.name = u.name + ".shadowMap", c.camera.updateProjectionMatrix()
                    }
                    t.setRenderTarget(c.map), t.clear();
                    const f = c.getViewportCount();
                    for (let t = 0; t < f; t++) {
                        const e = c.getViewport(t);
                        s.set(o.x * e.x, o.y * e.y, o.x * e.z, o.y * e.w), d.viewport(s), c.updateMatrices(u, t), r = c.getFrustum(), y(n, a, c.camera, u, this.type)
                    }
                    c.isPointLightShadow || 3 !== this.type || v(c, a), c.needsUpdate = !1
                }
                g.needsUpdate = !1, t.setRenderTarget(l, u, c)
            }
        }

        function Lf(t, e, n) {
            const r = n.isWebGL2,
                i = new function() {
                    let e = !1;
                    const n = new ju;
                    let r = null;
                    const i = new ju(0, 0, 0, 0);
                    return {
                        setMask: function(n) {
                            r === n || e || (t.colorMask(n, n, n, n), r = n)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e, r, o, s, a) {
                            !0 === a && (e *= s, r *= s, o *= s), n.set(e, r, o, s), !1 === i.equals(n) && (t.clearColor(e, r, o, s), i.copy(n))
                        },
                        reset: function() {
                            e = !1, r = null, i.set(-1, 0, 0, 0)
                        }
                    }
                },
                o = new function() {
                    let e = !1,
                        n = null,
                        r = null,
                        i = null;
                    return {
                        setTest: function(t) {
                            t ? B(2929) : k(2929)
                        },
                        setMask: function(r) {
                            n === r || e || (t.depthMask(r), n = r)
                        },
                        setFunc: function(e) {
                            if (r !== e) {
                                if (e) switch (e) {
                                    case 0:
                                        t.depthFunc(512);
                                        break;
                                    case 1:
                                        t.depthFunc(519);
                                        break;
                                    case 2:
                                        t.depthFunc(513);
                                        break;
                                    case 3:
                                        t.depthFunc(515);
                                        break;
                                    case 4:
                                        t.depthFunc(514);
                                        break;
                                    case 5:
                                        t.depthFunc(518);
                                        break;
                                    case 6:
                                        t.depthFunc(516);
                                        break;
                                    case 7:
                                        t.depthFunc(517);
                                        break;
                                    default:
                                        t.depthFunc(515)
                                } else t.depthFunc(515);
                                r = e
                            }
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e) {
                            i !== e && (t.clearDepth(e), i = e)
                        },
                        reset: function() {
                            e = !1, n = null, r = null, i = null
                        }
                    }
                },
                s = new function() {
                    let e = !1,
                        n = null,
                        r = null,
                        i = null,
                        o = null,
                        s = null,
                        a = null,
                        l = null,
                        u = null;
                    return {
                        setTest: function(t) {
                            e || (t ? B(2960) : k(2960))
                        },
                        setMask: function(r) {
                            n === r || e || (t.stencilMask(r), n = r)
                        },
                        setFunc: function(e, n, s) {
                            r === e && i === n && o === s || (t.stencilFunc(e, n, s), r = e, i = n, o = s)
                        },
                        setOp: function(e, n, r) {
                            s === e && a === n && l === r || (t.stencilOp(e, n, r), s = e, a = n, l = r)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e) {
                            u !== e && (t.clearStencil(e), u = e)
                        },
                        reset: function() {
                            e = !1, n = null, r = null, i = null, o = null, s = null, a = null, l = null, u = null
                        }
                    }
                };
            let a = {},
                l = {},
                u = new WeakMap,
                h = [],
                c = null,
                d = !1,
                p = null,
                f = null,
                m = null,
                g = null,
                v = null,
                _ = null,
                y = null,
                x = !1,
                b = null,
                E = null,
                T = null,
                S = null,
                w = null;
            const M = t.getParameter(35661);
            let A = !1,
                R = 0;
            const P = t.getParameter(7938); - 1 !== P.indexOf("WebGL") ? (R = parseFloat(/^WebGL (\d)/.exec(P)[1]), A = R >= 1) : -1 !== P.indexOf("OpenGL ES") && (R = parseFloat(/^OpenGL ES (\d)/.exec(P)[1]), A = R >= 2);
            let I = null,
                C = {};
            const O = t.getParameter(3088),
                L = t.getParameter(2978),
                N = (new ju).fromArray(O),
                D = (new ju).fromArray(L);

            function U(e, n, r) {
                const i = new Uint8Array(4),
                    o = t.createTexture();
                t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                for (let e = 0; e < r; e++) t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, i);
                return o
            }
            const F = {};

            function B(e) {
                !0 !== a[e] && (t.enable(e), a[e] = !0)
            }

            function k(e) {
                !1 !== a[e] && (t.disable(e), a[e] = !1)
            }
            F[3553] = U(3553, 3553, 1), F[34067] = U(34067, 34069, 6), i.setClear(0, 0, 0, 1), o.setClear(1), s.setClear(0), B(2929), o.setFunc(3), V(!1), W(1), B(2884), z(0);
            const G = {
                [Pl]: 32774,
                101: 32778,
                102: 32779
            };
            if (r) G[103] = 32775, G[104] = 32776;
            else {
                const t = e.get("EXT_blend_minmax");
                null !== t && (G[103] = t.MIN_EXT, G[104] = t.MAX_EXT)
            }
            const H = {
                200: 0,
                201: 1,
                202: 768,
                204: 770,
                210: 776,
                208: 774,
                206: 772,
                203: 769,
                205: 771,
                209: 775,
                207: 773
            };

            function z(e, n, r, i, o, s, a, l) {
                if (0 !== e) {
                    if (!1 === d && (B(3042), d = !0), 5 === e) o = o || n, s = s || r, a = a || i, n === f && o === v || (t.blendEquationSeparate(G[n], G[o]), f = n, v = o), r === m && i === g && s === _ && a === y || (t.blendFuncSeparate(H[r], H[i], H[s], H[a]), m = r, g = i, _ = s, y = a), p = e, x = null;
                    else if (e !== p || l !== x) {
                        if (f === Pl && v === Pl || (t.blendEquation(32774), f = Pl, v = Pl), l) switch (e) {
                            case 1:
                                t.blendFuncSeparate(1, 771, 1, 771);
                                break;
                            case 2:
                                t.blendFunc(1, 1);
                                break;
                            case 3:
                                t.blendFuncSeparate(0, 769, 0, 1);
                                break;
                            case 4:
                                t.blendFuncSeparate(0, 768, 0, 770);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                        } else switch (e) {
                            case 1:
                                t.blendFuncSeparate(770, 771, 1, 771);
                                break;
                            case 2:
                                t.blendFunc(770, 1);
                                break;
                            case 3:
                                t.blendFuncSeparate(0, 769, 0, 1);
                                break;
                            case 4:
                                t.blendFunc(0, 768);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                        }
                        m = null, g = null, _ = null, y = null, p = e, x = l
                    }
                } else !0 === d && (k(3042), d = !1)
            }

            function V(e) {
                b !== e && (e ? t.frontFace(2304) : t.frontFace(2305), b = e)
            }

            function W(e) {
                0 !== e ? (B(2884), e !== E && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : k(2884), E = e
            }

            function X(e, n, r) {
                e ? (B(32823), S === n && w === r || (t.polygonOffset(n, r), S = n, w = r)) : k(32823)
            }

            function j(e) {
                void 0 === e && (e = 33984 + M - 1), I !== e && (t.activeTexture(e), I = e)
            }
            return {
                buffers: {
                    color: i,
                    depth: o,
                    stencil: s
                },
                enable: B,
                disable: k,
                bindFramebuffer: function(e, n) {
                    return l[e] !== n && (t.bindFramebuffer(e, n), l[e] = n, r && (36009 === e && (l[36160] = n), 36160 === e && (l[36009] = n)), !0)
                },
                drawBuffers: function(r, i) {
                    let o = h,
                        s = !1;
                    if (r)
                        if (o = u.get(i), void 0 === o && (o = [], u.set(i, o)), r.isWebGLMultipleRenderTargets) {
                            const t = r.texture;
                            if (o.length !== t.length || 36064 !== o[0]) {
                                for (let e = 0, n = t.length; e < n; e++) o[e] = 36064 + e;
                                o.length = t.length, s = !0
                            }
                        } else 36064 !== o[0] && (o[0] = 36064, s = !0);
                    else 1029 !== o[0] && (o[0] = 1029, s = !0);
                    s && (n.isWebGL2 ? t.drawBuffers(o) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(o))
                },
                useProgram: function(e) {
                    return c !== e && (t.useProgram(e), c = e, !0)
                },
                setBlending: z,
                setMaterial: function(t, e) {
                    2 === t.side ? k(2884) : B(2884);
                    let n = 1 === t.side;
                    e && (n = !n), V(n), 1 === t.blending && !1 === t.transparent ? z(0) : z(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), o.setFunc(t.depthFunc), o.setTest(t.depthTest), o.setMask(t.depthWrite), i.setMask(t.colorWrite);
                    const r = t.stencilWrite;
                    s.setTest(r), r && (s.setMask(t.stencilWriteMask), s.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), s.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), X(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? B(32926) : k(32926)
                },
                setFlipSided: V,
                setCullFace: W,
                setLineWidth: function(e) {
                    e !== T && (A && t.lineWidth(e), T = e)
                },
                setPolygonOffset: X,
                setScissorTest: function(t) {
                    t ? B(3089) : k(3089)
                },
                activeTexture: j,
                bindTexture: function(e, n) {
                    null === I && j();
                    let r = C[I];
                    void 0 === r && (r = {
                        type: void 0,
                        texture: void 0
                    }, C[I] = r), r.type === e && r.texture === n || (t.bindTexture(e, n || F[e]), r.type = e, r.texture = n)
                },
                unbindTexture: function() {
                    const e = C[I];
                    void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                },
                compressedTexImage2D: function() {
                    try {
                        t.compressedTexImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage2D: function() {
                    try {
                        t.texImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage3D: function() {
                    try {
                        t.texImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texStorage2D: function() {
                    try {
                        t.texStorage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texStorage3D: function() {
                    try {
                        t.texStorage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texSubImage2D: function() {
                    try {
                        t.texSubImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texSubImage3D: function() {
                    try {
                        t.texSubImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                compressedTexSubImage2D: function() {
                    try {
                        t.compressedTexSubImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                scissor: function(e) {
                    !1 === N.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), N.copy(e))
                },
                viewport: function(e) {
                    !1 === D.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), D.copy(e))
                },
                reset: function() {
                    t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === r && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), a = {}, I = null, C = {}, l = {}, u = new WeakMap, h = [], c = null, d = !1, p = null, f = null, m = null, g = null, v = null, _ = null, y = null, x = !1, b = null, E = null, T = null, S = null, w = null, N.set(0, 0, t.canvas.width, t.canvas.height), D.set(0, 0, t.canvas.width, t.canvas.height), i.reset(), o.reset(), s.reset()
                }
            }
        }

        function Nf(t, e, n, r, i, o, s) {
            const a = i.isWebGL2,
                l = i.maxTextures,
                u = i.maxCubemapSize,
                h = i.maxTextureSize,
                c = i.maxSamples,
                d = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
                p = /OculusBrowser/g.test(navigator.userAgent),
                f = new WeakMap;
            let m;
            const g = new WeakMap;
            let v = !1;
            try {
                v = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
            } catch (t) {}

            function _(t, e) {
                return v ? new OffscreenCanvas(t, e) : Ru("canvas")
            }

            function y(t, e, n, r) {
                let i = 1;
                if ((t.width > r || t.height > r) && (i = r / Math.max(t.width, t.height)), i < 1 || !0 === e) {
                    if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                        const r = e ? Tu : Math.floor,
                            o = r(i * t.width),
                            s = r(i * t.height);
                        void 0 === m && (m = _(o, s));
                        const a = n ? _(o, s) : m;
                        return a.width = o, a.height = s, a.getContext("2d").drawImage(t, 0, 0, o, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + o + "x" + s + ")."), a
                    }
                    return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
                }
                return t
            }

            function x(t) {
                return Eu(t.width) && Eu(t.height)
            }

            function b(t, e) {
                return t.generateMipmaps && e && t.minFilter !== Ul && t.minFilter !== Fl
            }

            function E(e) {
                t.generateMipmap(e)
            }

            function T(n, r, i, o, s = !1) {
                if (!1 === a) return r;
                if (null !== n) {
                    if (void 0 !== t[n]) return t[n];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                }
                let l = r;
                return 6403 === r && (5126 === i && (l = 33326), 5131 === i && (l = 33325), 5121 === i && (l = 33321)), 33319 === r && (5126 === i && (l = 33328), 5131 === i && (l = 33327), 5121 === i && (l = 33323)), 6408 === r && (5126 === i && (l = 34836), 5131 === i && (l = 34842), 5121 === i && (l = o === ou && !1 === s ? 35907 : 32856), 32819 === i && (l = 32854), 32820 === i && (l = 32855)), 33325 !== l && 33326 !== l && 33327 !== l && 33328 !== l && 34842 !== l && 34836 !== l || e.get("EXT_color_buffer_float"), l
            }

            function S(t, e, n) {
                return !0 === b(t, n) || t.isFramebufferTexture && t.minFilter !== Ul && t.minFilter !== Fl ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1
            }

            function w(t) {
                return t === Ul || 1004 === t || 1005 === t ? 9728 : 9729
            }

            function M(t) {
                const e = t.target;
                e.removeEventListener("dispose", M),
                    function(t) {
                        const e = r.get(t);
                        if (void 0 === e.__webglInit) return;
                        const n = t.source,
                            i = g.get(n);
                        if (i) {
                            const r = i[e.__cacheKey];
                            r.usedTimes--, 0 === r.usedTimes && R(t), 0 === Object.keys(i).length && g.delete(n)
                        }
                        r.remove(t)
                    }(e), e.isVideoTexture && f.delete(e)
            }

            function A(e) {
                const n = e.target;
                n.removeEventListener("dispose", A),
                    function(e) {
                        const n = e.texture,
                            i = r.get(e),
                            o = r.get(n);
                        if (void 0 !== o.__webglTexture && (t.deleteTexture(o.__webglTexture), s.memory.textures--), e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget)
                            for (let e = 0; e < 6; e++) t.deleteFramebuffer(i.__webglFramebuffer[e]), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer[e]);
                        else t.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer), i.__webglMultisampledFramebuffer && t.deleteFramebuffer(i.__webglMultisampledFramebuffer), i.__webglColorRenderbuffer && t.deleteRenderbuffer(i.__webglColorRenderbuffer), i.__webglDepthRenderbuffer && t.deleteRenderbuffer(i.__webglDepthRenderbuffer);
                        if (e.isWebGLMultipleRenderTargets)
                            for (let e = 0, i = n.length; e < i; e++) {
                                const i = r.get(n[e]);
                                i.__webglTexture && (t.deleteTexture(i.__webglTexture), s.memory.textures--), r.remove(n[e])
                            }
                        r.remove(n), r.remove(e)
                    }(n)
            }

            function R(e) {
                const n = r.get(e);
                t.deleteTexture(n.__webglTexture);
                const i = e.source;
                delete g.get(i)[n.__cacheKey], s.memory.textures--
            }
            let P = 0;

            function I(t, e) {
                const i = r.get(t);
                if (t.isVideoTexture && function(t) {
                        const e = s.render.frame;
                        f.get(t) !== e && (f.set(t, e), t.update())
                    }(t), !1 === t.isRenderTargetTexture && t.version > 0 && i.__version !== t.version) {
                    const n = t.image;
                    if (null === n) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                    else {
                        if (!1 !== n.complete) return void D(i, t, e);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                n.activeTexture(33984 + e), n.bindTexture(3553, i.__webglTexture)
            }
            const C = {
                    [Ll]: 10497,
                    [Nl]: 33071,
                    [Dl]: 33648
                },
                O = {
                    [Ul]: 9728,
                    1004: 9984,
                    1005: 9986,
                    [Fl]: 9729,
                    1007: 9985,
                    [Bl]: 9987
                };

            function L(n, o, s) {
                if (s ? (t.texParameteri(n, 10242, C[o.wrapS]), t.texParameteri(n, 10243, C[o.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, C[o.wrapR]), t.texParameteri(n, 10240, O[o.magFilter]), t.texParameteri(n, 10241, O[o.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), o.wrapS === Nl && o.wrapT === Nl || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, w(o.magFilter)), t.texParameteri(n, 10241, w(o.minFilter)), o.minFilter !== Ul && o.minFilter !== Fl && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
                    const s = e.get("EXT_texture_filter_anisotropic");
                    if (o.type === zl && !1 === e.has("OES_texture_float_linear")) return;
                    if (!1 === a && o.type === Vl && !1 === e.has("OES_texture_half_float_linear")) return;
                    (o.anisotropy > 1 || r.get(o).__currentAnisotropy) && (t.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, i.getMaxAnisotropy())), r.get(o).__currentAnisotropy = o.anisotropy)
                }
            }

            function N(e, n) {
                let r = !1;
                void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", M));
                const i = n.source;
                let o = g.get(i);
                void 0 === o && (o = {}, g.set(i, o));
                const a = function(t) {
                    const e = [];
                    return e.push(t.wrapS), e.push(t.wrapT), e.push(t.magFilter), e.push(t.minFilter), e.push(t.anisotropy), e.push(t.internalFormat), e.push(t.format), e.push(t.type), e.push(t.generateMipmaps), e.push(t.premultiplyAlpha), e.push(t.flipY), e.push(t.unpackAlignment), e.push(t.encoding), e.join()
                }(n);
                if (a !== e.__cacheKey) {
                    void 0 === o[a] && (o[a] = {
                        texture: t.createTexture(),
                        usedTimes: 0
                    }, s.memory.textures++, r = !0), o[a].usedTimes++;
                    const i = o[e.__cacheKey];
                    void 0 !== i && (o[e.__cacheKey].usedTimes--, 0 === i.usedTimes && R(n)), e.__cacheKey = a, e.__webglTexture = o[a].texture
                }
                return r
            }

            function D(e, r, i) {
                let s = 3553;
                r.isDataArrayTexture && (s = 35866), r.isData3DTexture && (s = 32879);
                const l = N(e, r),
                    u = r.source;
                if (n.activeTexture(33984 + i), n.bindTexture(s, e.__webglTexture), u.version !== u.__currentVersion || !0 === l) {
                    t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment), t.pixelStorei(37443, 0);
                    const i = function(t) {
                        return !a && (t.wrapS !== Nl || t.wrapT !== Nl || t.minFilter !== Ul && t.minFilter !== Fl)
                    }(r) && !1 === x(r.image);
                    let l = y(r.image, i, !1, h);
                    l = H(r, l);
                    const c = x(l) || a,
                        d = o.convert(r.format, r.encoding);
                    let p, f = o.convert(r.type),
                        m = T(r.internalFormat, d, f, r.encoding, r.isVideoTexture);
                    L(s, r, c);
                    const g = r.mipmaps,
                        v = a && !0 !== r.isVideoTexture,
                        _ = void 0 === e.__version,
                        w = S(r, l, c);
                    if (r.isDepthTexture) m = 6402, a ? m = r.type === zl ? 36012 : r.type === Hl ? 33190 : r.type === Wl ? 35056 : 33189 : r.type === zl && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), r.format === jl && 6402 === m && r.type !== Gl && r.type !== Hl && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = Gl, f = o.convert(r.type)), r.format === Yl && 6402 === m && (m = 34041, r.type !== Wl && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = Wl, f = o.convert(r.type))), v && _ ? n.texStorage2D(3553, 1, m, l.width, l.height) : n.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, null);
                    else if (r.isDataTexture)
                        if (g.length > 0 && c) {
                            v && _ && n.texStorage2D(3553, w, m, g[0].width, g[0].height);
                            for (let t = 0, e = g.length; t < e; t++) p = g[t], v ? n.texSubImage2D(3553, t, 0, 0, p.width, p.height, d, f, p.data) : n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                            r.generateMipmaps = !1
                        } else v ? (_ && n.texStorage2D(3553, w, m, l.width, l.height), n.texSubImage2D(3553, 0, 0, 0, l.width, l.height, d, f, l.data)) : n.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, l.data);
                    else if (r.isCompressedTexture) {
                        v && _ && n.texStorage2D(3553, w, m, g[0].width, g[0].height);
                        for (let t = 0, e = g.length; t < e; t++) p = g[t], r.format !== Xl ? null !== d ? v ? n.compressedTexSubImage2D(3553, t, 0, 0, p.width, p.height, d, p.data) : n.compressedTexImage2D(3553, t, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : v ? n.texSubImage2D(3553, t, 0, 0, p.width, p.height, d, f, p.data) : n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data)
                    } else if (r.isDataArrayTexture) v ? (_ && n.texStorage3D(35866, w, m, l.width, l.height, l.depth), n.texSubImage3D(35866, 0, 0, 0, 0, l.width, l.height, l.depth, d, f, l.data)) : n.texImage3D(35866, 0, m, l.width, l.height, l.depth, 0, d, f, l.data);
                    else if (r.isData3DTexture) v ? (_ && n.texStorage3D(32879, w, m, l.width, l.height, l.depth), n.texSubImage3D(32879, 0, 0, 0, 0, l.width, l.height, l.depth, d, f, l.data)) : n.texImage3D(32879, 0, m, l.width, l.height, l.depth, 0, d, f, l.data);
                    else if (r.isFramebufferTexture) v && _ ? n.texStorage2D(3553, w, m, l.width, l.height) : n.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, null);
                    else if (g.length > 0 && c) {
                        v && _ && n.texStorage2D(3553, w, m, g[0].width, g[0].height);
                        for (let t = 0, e = g.length; t < e; t++) p = g[t], v ? n.texSubImage2D(3553, t, 0, 0, d, f, p) : n.texImage2D(3553, t, m, d, f, p);
                        r.generateMipmaps = !1
                    } else v ? (_ && n.texStorage2D(3553, w, m, l.width, l.height), n.texSubImage2D(3553, 0, 0, 0, d, f, l)) : n.texImage2D(3553, 0, m, d, f, l);
                    b(r, c) && E(s), u.__currentVersion = u.version, r.onUpdate && r.onUpdate(r)
                }
                e.__version = r.version
            }

            function U(e, i, s, a, l) {
                const u = o.convert(s.format, s.encoding),
                    h = o.convert(s.type),
                    c = T(s.internalFormat, u, h, s.encoding);
                r.get(i).__hasExternalTextures || (32879 === l || 35866 === l ? n.texImage3D(l, 0, c, i.width, i.height, i.depth, 0, u, h, null) : n.texImage2D(l, 0, c, i.width, i.height, 0, u, h, null)), n.bindFramebuffer(36160, e), G(i) ? d.framebufferTexture2DMultisampleEXT(36160, a, l, r.get(s).__webglTexture, 0, k(i)) : t.framebufferTexture2D(36160, a, l, r.get(s).__webglTexture, 0), n.bindFramebuffer(36160, null)
            }

            function F(e, n, r) {
                if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
                    let i = 33189;
                    if (r || G(n)) {
                        const e = n.depthTexture;
                        e && e.isDepthTexture && (e.type === zl ? i = 36012 : e.type === Hl && (i = 33190));
                        const r = k(n);
                        G(n) ? d.renderbufferStorageMultisampleEXT(36161, r, i, n.width, n.height) : t.renderbufferStorageMultisample(36161, r, i, n.width, n.height)
                    } else t.renderbufferStorage(36161, i, n.width, n.height);
                    t.framebufferRenderbuffer(36160, 36096, 36161, e)
                } else if (n.depthBuffer && n.stencilBuffer) {
                    const i = k(n);
                    r && !1 === G(n) ? t.renderbufferStorageMultisample(36161, i, 35056, n.width, n.height) : G(n) ? d.renderbufferStorageMultisampleEXT(36161, i, 35056, n.width, n.height) : t.renderbufferStorage(36161, 34041, n.width, n.height), t.framebufferRenderbuffer(36160, 33306, 36161, e)
                } else {
                    const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
                        i = o.convert(e.format, e.encoding),
                        s = o.convert(e.type),
                        a = T(e.internalFormat, i, s, e.encoding),
                        l = k(n);
                    r && !1 === G(n) ? t.renderbufferStorageMultisample(36161, l, a, n.width, n.height) : G(n) ? d.renderbufferStorageMultisampleEXT(36161, l, a, n.width, n.height) : t.renderbufferStorage(36161, a, n.width, n.height)
                }
                t.bindRenderbuffer(36161, null)
            }

            function B(e) {
                const i = r.get(e),
                    o = !0 === e.isWebGLCubeRenderTarget;
                if (e.depthTexture && !i.__autoAllocateDepthBuffer) {
                    if (o) throw new Error("target.depthTexture not supported in Cube render targets");
                    ! function(e, i) {
                        if (i && i.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                        if (n.bindFramebuffer(36160, e), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), I(i.depthTexture, 0);
                        const o = r.get(i.depthTexture).__webglTexture,
                            s = k(i);
                        if (i.depthTexture.format === jl) G(i) ? d.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, o, 0, s) : t.framebufferTexture2D(36160, 36096, 3553, o, 0);
                        else {
                            if (i.depthTexture.format !== Yl) throw new Error("Unknown depthTexture format");
                            G(i) ? d.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, o, 0, s) : t.framebufferTexture2D(36160, 33306, 3553, o, 0)
                        }
                    }(i.__webglFramebuffer, e)
                } else if (o) {
                    i.__webglDepthbuffer = [];
                    for (let r = 0; r < 6; r++) n.bindFramebuffer(36160, i.__webglFramebuffer[r]), i.__webglDepthbuffer[r] = t.createRenderbuffer(), F(i.__webglDepthbuffer[r], e, !1)
                } else n.bindFramebuffer(36160, i.__webglFramebuffer), i.__webglDepthbuffer = t.createRenderbuffer(), F(i.__webglDepthbuffer, e, !1);
                n.bindFramebuffer(36160, null)
            }

            function k(t) {
                return Math.min(c, t.samples)
            }

            function G(t) {
                const n = r.get(t);
                return a && t.samples > 0 && !0 === e.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
            }

            function H(t, n) {
                const r = t.encoding,
                    i = t.format,
                    o = t.type;
                return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || t.format === du || r !== iu && (r === ou ? !1 === a ? !0 === e.has("EXT_sRGB") && i === Xl ? (t.format = du, t.minFilter = Fl, t.generateMipmaps = !1) : n = Hu.sRGBToLinear(n) : i === Xl && o === kl || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", r)), n
            }
            this.allocateTextureUnit = function() {
                const t = P;
                return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), P += 1, t
            }, this.resetTextureUnits = function() {
                P = 0
            }, this.setTexture2D = I, this.setTexture2DArray = function(t, e) {
                const i = r.get(t);
                t.version > 0 && i.__version !== t.version ? D(i, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, i.__webglTexture))
            }, this.setTexture3D = function(t, e) {
                const i = r.get(t);
                t.version > 0 && i.__version !== t.version ? D(i, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, i.__webglTexture))
            }, this.setTextureCube = function(e, i) {
                const s = r.get(e);
                e.version > 0 && s.__version !== e.version ? function(e, r, i) {
                    if (6 !== r.image.length) return;
                    const s = N(e, r),
                        l = r.source;
                    if (n.activeTexture(33984 + i), n.bindTexture(34067, e.__webglTexture), l.version !== l.__currentVersion || !0 === s) {
                        t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment), t.pixelStorei(37443, 0);
                        const i = r.isCompressedTexture || r.image[0].isCompressedTexture,
                            s = r.image[0] && r.image[0].isDataTexture,
                            h = [];
                        for (let t = 0; t < 6; t++) h[t] = i || s ? s ? r.image[t].image : r.image[t] : y(r.image[t], !1, !0, u), h[t] = H(r, h[t]);
                        const c = h[0],
                            d = x(c) || a,
                            p = o.convert(r.format, r.encoding),
                            f = o.convert(r.type),
                            m = T(r.internalFormat, p, f, r.encoding),
                            g = a && !0 !== r.isVideoTexture,
                            v = void 0 === e.__version;
                        let _, w = S(r, c, d);
                        if (L(34067, r, d), i) {
                            g && v && n.texStorage2D(34067, w, m, c.width, c.height);
                            for (let t = 0; t < 6; t++) {
                                _ = h[t].mipmaps;
                                for (let e = 0; e < _.length; e++) {
                                    const i = _[e];
                                    r.format !== Xl ? null !== p ? g ? n.compressedTexSubImage2D(34069 + t, e, 0, 0, i.width, i.height, p, i.data) : n.compressedTexImage2D(34069 + t, e, m, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : g ? n.texSubImage2D(34069 + t, e, 0, 0, i.width, i.height, p, f, i.data) : n.texImage2D(34069 + t, e, m, i.width, i.height, 0, p, f, i.data)
                                }
                            }
                        } else {
                            _ = r.mipmaps, g && v && (_.length > 0 && w++, n.texStorage2D(34067, w, m, h[0].width, h[0].height));
                            for (let t = 0; t < 6; t++)
                                if (s) {
                                    g ? n.texSubImage2D(34069 + t, 0, 0, 0, h[t].width, h[t].height, p, f, h[t].data) : n.texImage2D(34069 + t, 0, m, h[t].width, h[t].height, 0, p, f, h[t].data);
                                    for (let e = 0; e < _.length; e++) {
                                        const r = _[e].image[t].image;
                                        g ? n.texSubImage2D(34069 + t, e + 1, 0, 0, r.width, r.height, p, f, r.data) : n.texImage2D(34069 + t, e + 1, m, r.width, r.height, 0, p, f, r.data)
                                    }
                                } else {
                                    g ? n.texSubImage2D(34069 + t, 0, 0, 0, p, f, h[t]) : n.texImage2D(34069 + t, 0, m, p, f, h[t]);
                                    for (let e = 0; e < _.length; e++) {
                                        const r = _[e];
                                        g ? n.texSubImage2D(34069 + t, e + 1, 0, 0, p, f, r.image[t]) : n.texImage2D(34069 + t, e + 1, m, p, f, r.image[t])
                                    }
                                }
                        }
                        b(r, d) && E(34067), l.__currentVersion = l.version, r.onUpdate && r.onUpdate(r)
                    }
                    e.__version = r.version
                }(s, e, i) : (n.activeTexture(33984 + i), n.bindTexture(34067, s.__webglTexture))
            }, this.rebindTextures = function(t, e, n) {
                const i = r.get(t);
                void 0 !== e && U(i.__webglFramebuffer, t, t.texture, 36064, 3553), void 0 !== n && B(t)
            }, this.setupRenderTarget = function(e) {
                const l = e.texture,
                    u = r.get(e),
                    h = r.get(l);
                e.addEventListener("dispose", A), !0 !== e.isWebGLMultipleRenderTargets && (void 0 === h.__webglTexture && (h.__webglTexture = t.createTexture()), h.__version = l.version, s.memory.textures++);
                const c = !0 === e.isWebGLCubeRenderTarget,
                    d = !0 === e.isWebGLMultipleRenderTargets,
                    p = x(e) || a;
                if (c) {
                    u.__webglFramebuffer = [];
                    for (let e = 0; e < 6; e++) u.__webglFramebuffer[e] = t.createFramebuffer()
                } else if (u.__webglFramebuffer = t.createFramebuffer(), d)
                    if (i.drawBuffers) {
                        const n = e.texture;
                        for (let e = 0, i = n.length; e < i; e++) {
                            const i = r.get(n[e]);
                            void 0 === i.__webglTexture && (i.__webglTexture = t.createTexture(), s.memory.textures++)
                        }
                    } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                else if (a && e.samples > 0 && !1 === G(e)) {
                    u.__webglMultisampledFramebuffer = t.createFramebuffer(), u.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, u.__webglColorRenderbuffer);
                    const r = o.convert(l.format, l.encoding),
                        i = o.convert(l.type),
                        s = T(l.internalFormat, r, i, l.encoding),
                        a = k(e);
                    t.renderbufferStorageMultisample(36161, a, s, e.width, e.height), n.bindFramebuffer(36160, u.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, u.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (u.__webglDepthRenderbuffer = t.createRenderbuffer(), F(u.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(36160, null)
                }
                if (c) {
                    n.bindTexture(34067, h.__webglTexture), L(34067, l, p);
                    for (let t = 0; t < 6; t++) U(u.__webglFramebuffer[t], e, l, 36064, 34069 + t);
                    b(l, p) && E(34067), n.unbindTexture()
                } else if (d) {
                    const t = e.texture;
                    for (let i = 0, o = t.length; i < o; i++) {
                        const o = t[i],
                            s = r.get(o);
                        n.bindTexture(3553, s.__webglTexture), L(3553, o, p), U(u.__webglFramebuffer, e, o, 36064 + i, 3553), b(o, p) && E(3553)
                    }
                    n.unbindTexture()
                } else {
                    let t = 3553;
                    (e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) && (a ? t = e.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n.bindTexture(t, h.__webglTexture), L(t, l, p), U(u.__webglFramebuffer, e, l, 36064, t), b(l, p) && E(t), n.unbindTexture()
                }
                e.depthBuffer && B(e)
            }, this.updateRenderTargetMipmap = function(t) {
                const e = x(t) || a,
                    i = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
                for (let o = 0, s = i.length; o < s; o++) {
                    const s = i[o];
                    if (b(s, e)) {
                        const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                            i = r.get(s).__webglTexture;
                        n.bindTexture(e, i), E(e), n.unbindTexture()
                    }
                }
            }, this.updateMultisampleRenderTarget = function(e) {
                if (a && e.samples > 0 && !1 === G(e)) {
                    const i = e.width,
                        o = e.height;
                    let s = 16384;
                    const a = [36064],
                        l = e.stencilBuffer ? 33306 : 36096;
                    e.depthBuffer && a.push(l);
                    const u = r.get(e),
                        h = void 0 !== u.__ignoreDepthValues && u.__ignoreDepthValues;
                    !1 === h && (e.depthBuffer && (s |= 256), e.stencilBuffer && (s |= 1024)), n.bindFramebuffer(36008, u.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, u.__webglFramebuffer), !0 === h && (t.invalidateFramebuffer(36008, [l]), t.invalidateFramebuffer(36009, [l])), t.blitFramebuffer(0, 0, i, o, 0, 0, i, o, s, 9728), p && t.invalidateFramebuffer(36008, a), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, u.__webglMultisampledFramebuffer)
                }
            }, this.setupDepthRenderbuffer = B, this.setupFrameBufferTexture = U, this.useMultisampledRTT = G
        }

        function Df(t, e, n) {
            const r = n.isWebGL2;
            return {
                convert: function(t, n = null) {
                    let i;
                    if (t === kl) return 5121;
                    if (1017 === t) return 32819;
                    if (1018 === t) return 32820;
                    if (1010 === t) return 5120;
                    if (1011 === t) return 5122;
                    if (t === Gl) return 5123;
                    if (1013 === t) return 5124;
                    if (t === Hl) return 5125;
                    if (t === zl) return 5126;
                    if (t === Vl) return r ? 5131 : (i = e.get("OES_texture_half_float"), null !== i ? i.HALF_FLOAT_OES : null);
                    if (1021 === t) return 6406;
                    if (t === Xl) return 6408;
                    if (1024 === t) return 6409;
                    if (1025 === t) return 6410;
                    if (t === jl) return 6402;
                    if (t === Yl) return 34041;
                    if (1028 === t) return 6403;
                    if (1022 === t) return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
                    if (t === du) return i = e.get("EXT_sRGB"), null !== i ? i.SRGB_ALPHA_EXT : null;
                    if (1029 === t) return 36244;
                    if (1030 === t) return 33319;
                    if (1031 === t) return 33320;
                    if (1033 === t) return 36249;
                    if (t === ql || t === Zl || t === Kl || t === Jl)
                        if (n === ou) {
                            if (i = e.get("WEBGL_compressed_texture_s3tc_srgb"), null === i) return null;
                            if (t === ql) return i.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                            if (t === Zl) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                            if (t === Kl) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                            if (t === Jl) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                        } else {
                            if (i = e.get("WEBGL_compressed_texture_s3tc"), null === i) return null;
                            if (t === ql) return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (t === Zl) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (t === Kl) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (t === Jl) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        } if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
                        if (i = e.get("WEBGL_compressed_texture_pvrtc"), null === i) return null;
                        if (35840 === t) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === t) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (35842 === t) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === t) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (36196 === t) return i = e.get("WEBGL_compressed_texture_etc1"), null !== i ? i.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if (37492 === t || 37496 === t) {
                        if (i = e.get("WEBGL_compressed_texture_etc"), null === i) return null;
                        if (37492 === t) return n === ou ? i.COMPRESSED_SRGB8_ETC2 : i.COMPRESSED_RGB8_ETC2;
                        if (37496 === t) return n === ou ? i.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : i.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    if (37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t) {
                        if (i = e.get("WEBGL_compressed_texture_astc"), null === i) return null;
                        if (37808 === t) return n === ou ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : i.COMPRESSED_RGBA_ASTC_4x4_KHR;
                        if (37809 === t) return n === ou ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : i.COMPRESSED_RGBA_ASTC_5x4_KHR;
                        if (37810 === t) return n === ou ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : i.COMPRESSED_RGBA_ASTC_5x5_KHR;
                        if (37811 === t) return n === ou ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : i.COMPRESSED_RGBA_ASTC_6x5_KHR;
                        if (37812 === t) return n === ou ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : i.COMPRESSED_RGBA_ASTC_6x6_KHR;
                        if (37813 === t) return n === ou ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : i.COMPRESSED_RGBA_ASTC_8x5_KHR;
                        if (37814 === t) return n === ou ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : i.COMPRESSED_RGBA_ASTC_8x6_KHR;
                        if (37815 === t) return n === ou ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : i.COMPRESSED_RGBA_ASTC_8x8_KHR;
                        if (37816 === t) return n === ou ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : i.COMPRESSED_RGBA_ASTC_10x5_KHR;
                        if (37817 === t) return n === ou ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : i.COMPRESSED_RGBA_ASTC_10x6_KHR;
                        if (37818 === t) return n === ou ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : i.COMPRESSED_RGBA_ASTC_10x8_KHR;
                        if (37819 === t) return n === ou ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : i.COMPRESSED_RGBA_ASTC_10x10_KHR;
                        if (37820 === t) return n === ou ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : i.COMPRESSED_RGBA_ASTC_12x10_KHR;
                        if (37821 === t) return n === ou ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : i.COMPRESSED_RGBA_ASTC_12x12_KHR
                    }
                    if (36492 === t) {
                        if (i = e.get("EXT_texture_compression_bptc"), null === i) return null;
                        if (36492 === t) return n === ou ? i.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : i.COMPRESSED_RGBA_BPTC_UNORM_EXT
                    }
                    return t === Wl ? r ? 34042 : (i = e.get("WEBGL_depth_texture"), null !== i ? i.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                }
            }
        }
        Cf.prototype.isMeshDistanceMaterial = !0;
        class Uf extends $c {
            constructor(t = []) {
                super(), this.cameras = t
            }
        }
        Uf.prototype.isArrayCamera = !0;
        class Ff extends $h {
            constructor() {
                super(), this.type = "Group"
            }
        }
        Ff.prototype.isGroup = !0;
        const Bf = {
            type: "move"
        };
        class kf {
            constructor() {
                this._targetRay = null, this._grip = null, this._hand = null
            }
            getHandSpace() {
                return null === this._hand && (this._hand = new Ff, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                    pinching: !1
                }), this._hand
            }
            getTargetRaySpace() {
                return null === this._targetRay && (this._targetRay = new Ff, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Ju, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Ju), this._targetRay
            }
            getGripSpace() {
                return null === this._grip && (this._grip = new Ff, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Ju, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Ju), this._grip
            }
            dispatchEvent(t) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
            }
            disconnect(t) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: t
                }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
            }
            update(t, e, n) {
                let r = null,
                    i = null,
                    o = null;
                const s = this._targetRay,
                    a = this._grip,
                    l = this._hand;
                if (t && "visible-blurred" !== e.session.visibilityState)
                    if (null !== s && (r = e.getPose(t.targetRaySpace, n), null !== r && (s.matrix.fromArray(r.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), r.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(r.linearVelocity)) : s.hasLinearVelocity = !1, r.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(r.angularVelocity)) : s.hasAngularVelocity = !1, this.dispatchEvent(Bf))), l && t.hand) {
                        o = !0;
                        for (const r of t.hand.values()) {
                            const t = e.getJointPose(r, n);
                            if (void 0 === l.joints[r.jointName]) {
                                const t = new Ff;
                                t.matrixAutoUpdate = !1, t.visible = !1, l.joints[r.jointName] = t, l.add(t)
                            }
                            const i = l.joints[r.jointName];
                            null !== t && (i.matrix.fromArray(t.transform.matrix), i.matrix.decompose(i.position, i.rotation, i.scale), i.jointRadius = t.radius), i.visible = null !== t
                        }
                        const r = l.joints["index-finger-tip"],
                            i = l.joints["thumb-tip"],
                            s = r.position.distanceTo(i.position),
                            a = .02,
                            u = .005;
                        l.inputState.pinching && s > a + u ? (l.inputState.pinching = !1, this.dispatchEvent({
                            type: "pinchend",
                            handedness: t.handedness,
                            target: this
                        })) : !l.inputState.pinching && s <= a - u && (l.inputState.pinching = !0, this.dispatchEvent({
                            type: "pinchstart",
                            handedness: t.handedness,
                            target: this
                        }))
                    } else null !== a && t.gripSpace && (i = e.getPose(t.gripSpace, n), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1));
                return null !== s && (s.visible = null !== r), null !== a && (a.visible = null !== i), null !== l && (l.visible = null !== o), this
            }
        }
        class Gf extends Xu {
            constructor(t, e, n, r, i, o, s, a, l, u) {
                if ((u = void 0 !== u ? u : jl) !== jl && u !== Yl) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && u === jl && (n = Gl), void 0 === n && u === Yl && (n = Wl), super(null, r, i, o, s, a, u, n, l), this.image = {
                    width: t,
                    height: e
                }, this.magFilter = void 0 !== s ? s : Ul, this.minFilter = void 0 !== a ? a : Ul, this.flipY = !1, this.generateMipmaps = !1
            }
        }
        Gf.prototype.isDepthTexture = !0;
        class Hf extends pu {
            constructor(t, e) {
                super();
                const n = this;
                let r = null,
                    i = 1,
                    o = null,
                    s = "local-floor",
                    a = null,
                    l = null,
                    u = null,
                    h = null,
                    c = null;
                const d = e.getContextAttributes();
                let p = null,
                    f = null;
                const m = [],
                    g = new Map,
                    v = new $c;
                v.layers.enable(1), v.viewport = new ju;
                const _ = new $c;
                _.layers.enable(2), _.viewport = new ju;
                const y = [v, _],
                    x = new Uf;
                x.layers.enable(1), x.layers.enable(2);
                let b = null,
                    E = null;

                function T(t) {
                    const e = g.get(t.inputSource);
                    e && e.dispatchEvent({
                        type: t.type,
                        data: t.inputSource
                    })
                }

                function S() {
                    g.forEach((function(t, e) {
                        t.disconnect(e)
                    })), g.clear(), b = null, E = null, t.setRenderTarget(p), h = null, u = null, l = null, r = null, f = null, I.stop(), n.isPresenting = !1, n.dispatchEvent({
                        type: "sessionend"
                    })
                }

                function w(t) {
                    const e = r.inputSources;
                    for (let t = 0; t < m.length; t++) g.set(e[t], m[t]);
                    for (let e = 0; e < t.removed.length; e++) {
                        const n = t.removed[e],
                            r = g.get(n);
                        r && (r.dispatchEvent({
                            type: "disconnected",
                            data: n
                        }), g.delete(n))
                    }
                    for (let e = 0; e < t.added.length; e++) {
                        const n = t.added[e],
                            r = g.get(n);
                        r && r.dispatchEvent({
                            type: "connected",
                            data: n
                        })
                    }
                }
                this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
                    let e = m[t];
                    return void 0 === e && (e = new kf, m[t] = e), e.getTargetRaySpace()
                }, this.getControllerGrip = function(t) {
                    let e = m[t];
                    return void 0 === e && (e = new kf, m[t] = e), e.getGripSpace()
                }, this.getHand = function(t) {
                    let e = m[t];
                    return void 0 === e && (e = new kf, m[t] = e), e.getHandSpace()
                }, this.setFramebufferScaleFactor = function(t) {
                    i = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }, this.setReferenceSpaceType = function(t) {
                    s = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }, this.getReferenceSpace = function() {
                    return o
                }, this.getBaseLayer = function() {
                    return null !== u ? u : h
                }, this.getBinding = function() {
                    return l
                }, this.getFrame = function() {
                    return c
                }, this.getSession = function() {
                    return r
                }, this.setSession = async function(a) {
                    if (r = a, null !== r) {
                        if (p = t.getRenderTarget(), r.addEventListener("select", T), r.addEventListener("selectstart", T), r.addEventListener("selectend", T), r.addEventListener("squeeze", T), r.addEventListener("squeezestart", T), r.addEventListener("squeezeend", T), r.addEventListener("end", S), r.addEventListener("inputsourceschange", w), !0 !== d.xrCompatible && await e.makeXRCompatible(), void 0 === r.renderState.layers || !1 === t.capabilities.isWebGL2) {
                            const n = {
                                antialias: void 0 !== r.renderState.layers || d.antialias,
                                alpha: d.alpha,
                                depth: d.depth,
                                stencil: d.stencil,
                                framebufferScaleFactor: i
                            };
                            h = new XRWebGLLayer(r, e, n), r.updateRenderState({
                                baseLayer: h
                            }), f = new Yu(h.framebufferWidth, h.framebufferHeight, {
                                format: Xl,
                                type: kl,
                                encoding: t.outputEncoding
                            })
                        } else {
                            let n = null,
                                o = null,
                                s = null;
                            d.depth && (s = d.stencil ? 35056 : 33190, n = d.stencil ? Yl : jl, o = d.stencil ? Wl : Gl);
                            const a = {
                                colorFormat: t.outputEncoding === ou ? 35907 : 32856,
                                depthFormat: s,
                                scaleFactor: i
                            };
                            l = new XRWebGLBinding(r, e), u = l.createProjectionLayer(a), r.updateRenderState({
                                layers: [u]
                            }), f = new Yu(u.textureWidth, u.textureHeight, {
                                format: Xl,
                                type: kl,
                                depthTexture: new Gf(u.textureWidth, u.textureHeight, o, void 0, void 0, void 0, void 0, void 0, void 0, n),
                                stencilBuffer: d.stencil,
                                encoding: t.outputEncoding,
                                samples: d.antialias ? 4 : 0
                            }), t.properties.get(f).__ignoreDepthValues = u.ignoreDepthValues
                        }
                        f.isXRRenderTarget = !0, this.setFoveation(1), o = await r.requestReferenceSpace(s), I.setContext(r), I.start(), n.isPresenting = !0, n.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                };
                const M = new Ju,
                    A = new Ju;

                function R(t, e) {
                    null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
                }
                this.updateCamera = function(t) {
                    if (null === r) return;
                    x.near = _.near = v.near = t.near, x.far = _.far = v.far = t.far, b === x.near && E === x.far || (r.updateRenderState({
                        depthNear: x.near,
                        depthFar: x.far
                    }), b = x.near, E = x.far);
                    const e = t.parent,
                        n = x.cameras;
                    R(x, e);
                    for (let t = 0; t < n.length; t++) R(n[t], e);
                    x.matrixWorld.decompose(x.position, x.quaternion, x.scale), t.position.copy(x.position), t.quaternion.copy(x.quaternion), t.scale.copy(x.scale), t.matrix.copy(x.matrix), t.matrixWorld.copy(x.matrixWorld);
                    const i = t.children;
                    for (let t = 0, e = i.length; t < e; t++) i[t].updateMatrixWorld(!0);
                    2 === n.length ? function(t, e, n) {
                        M.setFromMatrixPosition(e.matrixWorld), A.setFromMatrixPosition(n.matrixWorld);
                        const r = M.distanceTo(A),
                            i = e.projectionMatrix.elements,
                            o = n.projectionMatrix.elements,
                            s = i[14] / (i[10] - 1),
                            a = i[14] / (i[10] + 1),
                            l = (i[9] + 1) / i[5],
                            u = (i[9] - 1) / i[5],
                            h = (i[8] - 1) / i[0],
                            c = (o[8] + 1) / o[0],
                            d = s * h,
                            p = s * c,
                            f = r / (-h + c),
                            m = f * -h;
                        e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                        const g = s + f,
                            v = a + f,
                            _ = d - m,
                            y = p + (r - m),
                            x = l * a / v * g,
                            b = u * a / v * g;
                        t.projectionMatrix.makePerspective(_, y, x, b, g, v)
                    }(x, v, _) : x.projectionMatrix.copy(v.projectionMatrix)
                }, this.getCamera = function() {
                    return x
                }, this.getFoveation = function() {
                    return null !== u ? u.fixedFoveation : null !== h ? h.fixedFoveation : void 0
                }, this.setFoveation = function(t) {
                    null !== u && (u.fixedFoveation = t), null !== h && void 0 !== h.fixedFoveation && (h.fixedFoveation = t)
                };
                let P = null;
                const I = new cd;
                I.setAnimationLoop((function(e, n) {
                    if (a = n.getViewerPose(o), c = n, null !== a) {
                        const e = a.views;
                        null !== h && (t.setRenderTargetFramebuffer(f, h.framebuffer), t.setRenderTarget(f));
                        let n = !1;
                        e.length !== x.cameras.length && (x.cameras.length = 0, n = !0);
                        for (let r = 0; r < e.length; r++) {
                            const i = e[r];
                            let o = null;
                            if (null !== h) o = h.getViewport(i);
                            else {
                                const e = l.getViewSubImage(u, i);
                                o = e.viewport, 0 === r && (t.setRenderTargetTextures(f, e.colorTexture, u.ignoreDepthValues ? void 0 : e.depthStencilTexture), t.setRenderTarget(f))
                            }
                            const s = y[r];
                            s.matrix.fromArray(i.transform.matrix), s.projectionMatrix.fromArray(i.projectionMatrix), s.viewport.set(o.x, o.y, o.width, o.height), 0 === r && x.matrix.copy(s.matrix), !0 === n && x.cameras.push(s)
                        }
                    }
                    const i = r.inputSources;
                    for (let t = 0; t < m.length; t++) {
                        const e = m[t],
                            r = i[t];
                        e.update(r, n, o)
                    }
                    P && P(e, n), c = null
                })), this.setAnimationLoop = function(t) {
                    P = t
                }, this.dispose = function() {}
            }
        }

        function zf(t, e) {
            function n(n, r) {
                n.opacity.value = r.opacity, r.color && n.diffuse.value.copy(r.color), r.emissive && n.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity), r.map && (n.map.value = r.map), r.alphaMap && (n.alphaMap.value = r.alphaMap), r.bumpMap && (n.bumpMap.value = r.bumpMap, n.bumpScale.value = r.bumpScale, 1 === r.side && (n.bumpScale.value *= -1)), r.displacementMap && (n.displacementMap.value = r.displacementMap, n.displacementScale.value = r.displacementScale, n.displacementBias.value = r.displacementBias), r.emissiveMap && (n.emissiveMap.value = r.emissiveMap), r.normalMap && (n.normalMap.value = r.normalMap, n.normalScale.value.copy(r.normalScale), 1 === r.side && n.normalScale.value.negate()), r.specularMap && (n.specularMap.value = r.specularMap), r.alphaTest > 0 && (n.alphaTest.value = r.alphaTest);
                const i = e.get(r).envMap;
                if (i && (n.envMap.value = i, n.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, n.reflectivity.value = r.reflectivity, n.ior.value = r.ior, n.refractionRatio.value = r.refractionRatio), r.lightMap) {
                    n.lightMap.value = r.lightMap;
                    const e = !0 !== t.physicallyCorrectLights ? Math.PI : 1;
                    n.lightMapIntensity.value = r.lightMapIntensity * e
                }
                let o, s;
                r.aoMap && (n.aoMap.value = r.aoMap, n.aoMapIntensity.value = r.aoMapIntensity), r.map ? o = r.map : r.specularMap ? o = r.specularMap : r.displacementMap ? o = r.displacementMap : r.normalMap ? o = r.normalMap : r.bumpMap ? o = r.bumpMap : r.roughnessMap ? o = r.roughnessMap : r.metalnessMap ? o = r.metalnessMap : r.alphaMap ? o = r.alphaMap : r.emissiveMap ? o = r.emissiveMap : r.clearcoatMap ? o = r.clearcoatMap : r.clearcoatNormalMap ? o = r.clearcoatNormalMap : r.clearcoatRoughnessMap ? o = r.clearcoatRoughnessMap : r.specularIntensityMap ? o = r.specularIntensityMap : r.specularColorMap ? o = r.specularColorMap : r.transmissionMap ? o = r.transmissionMap : r.thicknessMap ? o = r.thicknessMap : r.sheenColorMap ? o = r.sheenColorMap : r.sheenRoughnessMap && (o = r.sheenRoughnessMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), !0 === o.matrixAutoUpdate && o.updateMatrix(), n.uvTransform.value.copy(o.matrix)), r.aoMap ? s = r.aoMap : r.lightMap && (s = r.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), n.uv2Transform.value.copy(s.matrix))
            }
            return {
                refreshFogUniforms: function(t, e) {
                    t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                },
                refreshMaterialUniforms: function(t, r, i, o, s) {
                    r.isMeshBasicMaterial || r.isMeshLambertMaterial ? n(t, r) : r.isMeshToonMaterial ? (n(t, r), function(t, e) {
                        e.gradientMap && (t.gradientMap.value = e.gradientMap)
                    }(t, r)) : r.isMeshPhongMaterial ? (n(t, r), function(t, e) {
                        t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4)
                    }(t, r)) : r.isMeshStandardMaterial ? (n(t, r), function(t, n) {
                        t.roughness.value = n.roughness, t.metalness.value = n.metalness, n.roughnessMap && (t.roughnessMap.value = n.roughnessMap), n.metalnessMap && (t.metalnessMap.value = n.metalnessMap), e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity)
                    }(t, r), r.isMeshPhysicalMaterial && function(t, e, n) {
                        t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap)), e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate())), e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = n.texture, t.transmissionSamplerSize.value.set(n.width, n.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor)), t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap), e.specularColorMap && (t.specularColorMap.value = e.specularColorMap)
                    }(t, r, s)) : r.isMeshMatcapMaterial ? (n(t, r), function(t, e) {
                        e.matcap && (t.matcap.value = e.matcap)
                    }(t, r)) : r.isMeshDepthMaterial ? n(t, r) : r.isMeshDistanceMaterial ? (n(t, r), function(t, e) {
                        t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                    }(t, r)) : r.isMeshNormalMaterial ? n(t, r) : r.isLineBasicMaterial ? (function(t, e) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
                    }(t, r), r.isLineDashedMaterial && function(t, e) {
                        t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                    }(t, r)) : r.isPointsMaterial ? function(t, e, n, r) {
                        let i;
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * r, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest), e.map ? i = e.map : e.alphaMap && (i = e.alphaMap), void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix))
                    }(t, r, i, o) : r.isSpriteMaterial ? function(t, e) {
                        let n;
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest), e.map ? n = e.map : e.alphaMap && (n = e.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                    }(t, r) : r.isShadowMaterial ? (t.color.value.copy(r.color), t.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
                }
            }
        }

        function Vf(t = {}) {
            const e = void 0 !== t.canvas ? t.canvas : function() {
                    const t = Ru("canvas");
                    return t.style.display = "block", t
                }(),
                n = void 0 !== t.context ? t.context : null,
                r = void 0 === t.depth || t.depth,
                i = void 0 === t.stencil || t.stencil,
                o = void 0 !== t.antialias && t.antialias,
                s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                a = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                l = void 0 !== t.powerPreference ? t.powerPreference : "default",
                u = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
            let h;
            h = void 0 !== t.context ? n.getContextAttributes().alpha : void 0 !== t.alpha && t.alpha;
            let c = null,
                d = null;
            const p = [],
                f = [];
            this.domElement = e, this.debug = {
                checkShaderErrors: !0
            }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = iu, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
            const m = this;
            let g = !1,
                v = 0,
                _ = 0,
                y = null,
                x = -1,
                b = null;
            const E = new ju,
                T = new ju;
            let S = null,
                w = e.width,
                M = e.height,
                A = 1,
                R = null,
                P = null;
            const I = new ju(0, 0, w, M),
                C = new ju(0, 0, w, M);
            let O = !1;
            const L = new hd;
            let N = !1,
                D = !1,
                U = null;
            const F = new Rh,
                B = new wu,
                k = new Ju,
                G = {
                    background: null,
                    fog: null,
                    environment: null,
                    overrideMaterial: null,
                    isScene: !0
                };

            function H() {
                return null === y ? A : 1
            }
            let z, V, W, X, j, Y, q, Z, K, J, Q, $, tt, et, nt, rt, it, ot, st, at, lt, ut, ht, ct = n;

            function dt(t, n) {
                for (let r = 0; r < t.length; r++) {
                    const i = t[r],
                        o = e.getContext(i, n);
                    if (null !== o) return o
                }
                return null
            }
            try {
                const t = {
                    alpha: !0,
                    depth: r,
                    stencil: i,
                    antialias: o,
                    premultipliedAlpha: s,
                    preserveDrawingBuffer: a,
                    powerPreference: l,
                    failIfMajorPerformanceCaveat: u
                };
                if ("setAttribute" in e && e.setAttribute("data-engine", "three.js r139"), e.addEventListener("webglcontextlost", mt, !1), e.addEventListener("webglcontextrestored", gt, !1), null === ct) {
                    const e = ["webgl2", "webgl", "experimental-webgl"];
                    if (!0 === m.isWebGL1Renderer && e.shift(), ct = dt(e, t), null === ct) throw dt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                }
                void 0 === ct.getShaderPrecisionFormat && (ct.getShaderPrecisionFormat = function() {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                })
            } catch (t) {
                throw console.error("THREE.WebGLRenderer: " + t.message), t
            }

            function pt() {
                z = new Fd(ct), V = new xd(ct, z, t), z.init(V), ut = new Df(ct, z, V), W = new Lf(ct, z, V), X = new Gd(ct), j = new yf, Y = new Nf(ct, z, W, j, V, ut, X), q = new Ed(m), Z = new Ud(m), K = new dd(ct, V), ht = new _d(ct, z, K, V), J = new Bd(ct, K, X, ht), Q = new Xd(ct, J, K, X), st = new Wd(ct, V, Y), rt = new bd(j), $ = new _f(m, q, Z, z, V, ht, rt), tt = new zf(m, j), et = new Tf, nt = new Pf(z, V), ot = new vd(m, q, W, Q, h, s), it = new Of(m, Q, V), at = new yd(ct, z, X, V), lt = new kd(ct, z, X, V), X.programs = $.programs, m.capabilities = V, m.extensions = z, m.properties = j, m.renderLists = et, m.shadowMap = it, m.state = W, m.info = X
            }
            pt();
            const ft = new Hf(m, ct);

            function mt(t) {
                t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g = !0
            }

            function gt() {
                console.log("THREE.WebGLRenderer: Context Restored."), g = !1;
                const t = X.autoReset,
                    e = it.enabled,
                    n = it.autoUpdate,
                    r = it.needsUpdate,
                    i = it.type;
                pt(), X.autoReset = t, it.enabled = e, it.autoUpdate = n, it.needsUpdate = r, it.type = i
            }

            function vt(t) {
                const e = t.target;
                e.removeEventListener("dispose", vt),
                    function(t) {
                        (function(t) {
                            const e = j.get(t).programs;
                            void 0 !== e && (e.forEach((function(t) {
                                $.releaseProgram(t)
                            })), t.isShaderMaterial && $.releaseShaderCache(t))
                        })(t), j.remove(t)
                    }(e)
            }
            this.xr = ft, this.getContext = function() {
                return ct
            }, this.getContextAttributes = function() {
                return ct.getContextAttributes()
            }, this.forceContextLoss = function() {
                const t = z.get("WEBGL_lose_context");
                t && t.loseContext()
            }, this.forceContextRestore = function() {
                const t = z.get("WEBGL_lose_context");
                t && t.restoreContext()
            }, this.getPixelRatio = function() {
                return A
            }, this.setPixelRatio = function(t) {
                void 0 !== t && (A = t, this.setSize(w, M, !1))
            }, this.getSize = function(t) {
                return t.set(w, M)
            }, this.setSize = function(t, n, r) {
                ft.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (w = t, M = n, e.width = Math.floor(t * A), e.height = Math.floor(n * A), !1 !== r && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
            }, this.getDrawingBufferSize = function(t) {
                return t.set(w * A, M * A).floor()
            }, this.setDrawingBufferSize = function(t, n, r) {
                w = t, M = n, A = r, e.width = Math.floor(t * r), e.height = Math.floor(n * r), this.setViewport(0, 0, t, n)
            }, this.getCurrentViewport = function(t) {
                return t.copy(E)
            }, this.getViewport = function(t) {
                return t.copy(I)
            }, this.setViewport = function(t, e, n, r) {
                t.isVector4 ? I.set(t.x, t.y, t.z, t.w) : I.set(t, e, n, r), W.viewport(E.copy(I).multiplyScalar(A).floor())
            }, this.getScissor = function(t) {
                return t.copy(C)
            }, this.setScissor = function(t, e, n, r) {
                t.isVector4 ? C.set(t.x, t.y, t.z, t.w) : C.set(t, e, n, r), W.scissor(T.copy(C).multiplyScalar(A).floor())
            }, this.getScissorTest = function() {
                return O
            }, this.setScissorTest = function(t) {
                W.setScissorTest(O = t)
            }, this.setOpaqueSort = function(t) {
                R = t
            }, this.setTransparentSort = function(t) {
                P = t
            }, this.getClearColor = function(t) {
                return t.copy(ot.getClearColor())
            }, this.setClearColor = function() {
                ot.setClearColor.apply(ot, arguments)
            }, this.getClearAlpha = function() {
                return ot.getClearAlpha()
            }, this.setClearAlpha = function() {
                ot.setClearAlpha.apply(ot, arguments)
            }, this.clear = function(t = !0, e = !0, n = !0) {
                let r = 0;
                t && (r |= 16384), e && (r |= 256), n && (r |= 1024), ct.clear(r)
            }, this.clearColor = function() {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }, this.dispose = function() {
                e.removeEventListener("webglcontextlost", mt, !1), e.removeEventListener("webglcontextrestored", gt, !1), et.dispose(), nt.dispose(), j.dispose(), q.dispose(), Z.dispose(), Q.dispose(), ht.dispose(), $.dispose(), ft.dispose(), ft.removeEventListener("sessionstart", yt), ft.removeEventListener("sessionend", xt), U && (U.dispose(), U = null), bt.stop()
            }, this.renderBufferDirect = function(t, e, n, r, i, o) {
                null === e && (e = G);
                const s = i.isMesh && i.matrixWorld.determinant() < 0,
                    a = function(t, e, n, r, i) {
                        !0 !== e.isScene && (e = G), Y.resetTextureUnits();
                        const o = e.fog,
                            s = r.isMeshStandardMaterial ? e.environment : null,
                            a = null === y ? m.outputEncoding : !0 === y.isXRRenderTarget ? y.texture.encoding : iu,
                            l = (r.isMeshStandardMaterial ? Z : q).get(r.envMap || s),
                            u = !0 === r.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                            h = !!r.normalMap && !!n.attributes.tangent,
                            c = !!n.morphAttributes.position,
                            p = !!n.morphAttributes.normal,
                            f = !!n.morphAttributes.color,
                            g = r.toneMapped ? m.toneMapping : 0,
                            v = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color,
                            _ = void 0 !== v ? v.length : 0,
                            E = j.get(r),
                            T = d.state.lights;
                        if (!0 === N && (!0 === D || t !== b)) {
                            const e = t === b && r.id === x;
                            rt.setState(r, t, e)
                        }
                        let S = !1;
                        r.version === E.__version ? E.needsLights && E.lightsStateVersion !== T.state.version || E.outputEncoding !== a || i.isInstancedMesh && !1 === E.instancing ? S = !0 : i.isInstancedMesh || !0 !== E.instancing ? i.isSkinnedMesh && !1 === E.skinning ? S = !0 : i.isSkinnedMesh || !0 !== E.skinning ? E.envMap !== l || r.fog && E.fog !== o ? S = !0 : void 0 === E.numClippingPlanes || E.numClippingPlanes === rt.numPlanes && E.numIntersection === rt.numIntersection ? (E.vertexAlphas !== u || E.vertexTangents !== h || E.morphTargets !== c || E.morphNormals !== p || E.morphColors !== f || E.toneMapping !== g || !0 === V.isWebGL2 && E.morphTargetsCount !== _) && (S = !0) : S = !0 : S = !0 : S = !0 : (S = !0, E.__version = r.version);
                        let w = E.currentProgram;
                        !0 === S && (w = Mt(r, e, i));
                        let R = !1,
                            P = !1,
                            I = !1;
                        const C = w.getUniforms(),
                            O = E.uniforms;
                        if (W.useProgram(w.program) && (R = !0, P = !0, I = !0), r.id !== x && (x = r.id, P = !0), R || b !== t) {
                            if (C.setValue(ct, "projectionMatrix", t.projectionMatrix), V.logarithmicDepthBuffer && C.setValue(ct, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), b !== t && (b = t, P = !0, I = !0), r.isShaderMaterial || r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshStandardMaterial || r.envMap) {
                                const e = C.map.cameraPosition;
                                void 0 !== e && e.setValue(ct, k.setFromMatrixPosition(t.matrixWorld))
                            }(r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial) && C.setValue(ct, "isOrthographic", !0 === t.isOrthographicCamera), (r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial || r.isShadowMaterial || i.isSkinnedMesh) && C.setValue(ct, "viewMatrix", t.matrixWorldInverse)
                        }
                        if (i.isSkinnedMesh) {
                            C.setOptional(ct, i, "bindMatrix"), C.setOptional(ct, i, "bindMatrixInverse");
                            const t = i.skeleton;
                            t && (V.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), C.setValue(ct, "boneTexture", t.boneTexture, Y), C.setValue(ct, "boneTextureSize", t.boneTextureSize)) : C.setOptional(ct, t, "boneMatrices"))
                        }
                        const L = n.morphAttributes;
                        var F, B;
                        return (void 0 !== L.position || void 0 !== L.normal || void 0 !== L.color && !0 === V.isWebGL2) && st.update(i, n, r, w), (P || E.receiveShadow !== i.receiveShadow) && (E.receiveShadow = i.receiveShadow, C.setValue(ct, "receiveShadow", i.receiveShadow)), P && (C.setValue(ct, "toneMappingExposure", m.toneMappingExposure), E.needsLights && (B = I, (F = O).ambientLightColor.needsUpdate = B, F.lightProbe.needsUpdate = B, F.directionalLights.needsUpdate = B, F.directionalLightShadows.needsUpdate = B, F.pointLights.needsUpdate = B, F.pointLightShadows.needsUpdate = B, F.spotLights.needsUpdate = B, F.spotLightShadows.needsUpdate = B, F.rectAreaLights.needsUpdate = B, F.hemisphereLights.needsUpdate = B), o && r.fog && tt.refreshFogUniforms(O, o), tt.refreshMaterialUniforms(O, r, A, M, U), Zp.upload(ct, E.uniformsList, O, Y)), r.isShaderMaterial && !0 === r.uniformsNeedUpdate && (Zp.upload(ct, E.uniformsList, O, Y), r.uniformsNeedUpdate = !1), r.isSpriteMaterial && C.setValue(ct, "center", i.center), C.setValue(ct, "modelViewMatrix", i.modelViewMatrix), C.setValue(ct, "normalMatrix", i.normalMatrix), C.setValue(ct, "modelMatrix", i.matrixWorld), w
                    }(t, e, n, r, i);
                W.setMaterial(r, s);
                let l = n.index;
                const u = n.attributes.position;
                if (null === l) {
                    if (void 0 === u || 0 === u.count) return
                } else if (0 === l.count) return;
                let h, c = 1;
                !0 === r.wireframe && (l = J.getWireframeAttribute(n), c = 2), ht.setup(i, r, a, n, l);
                let p = at;
                null !== l && (h = K.get(l), p = lt, p.setIndex(h));
                const f = null !== l ? l.count : u.count,
                    g = n.drawRange.start * c,
                    v = n.drawRange.count * c,
                    _ = null !== o ? o.start * c : 0,
                    E = null !== o ? o.count * c : 1 / 0,
                    T = Math.max(g, _),
                    S = Math.min(f, g + v, _ + E) - 1,
                    w = Math.max(0, S - T + 1);
                if (0 !== w) {
                    if (i.isMesh) !0 === r.wireframe ? (W.setLineWidth(r.wireframeLinewidth * H()), p.setMode(1)) : p.setMode(4);
                    else if (i.isLine) {
                        let t = r.linewidth;
                        void 0 === t && (t = 1), W.setLineWidth(t * H()), i.isLineSegments ? p.setMode(1) : i.isLineLoop ? p.setMode(2) : p.setMode(3)
                    } else i.isPoints ? p.setMode(0) : i.isSprite && p.setMode(4);
                    if (i.isInstancedMesh) p.renderInstances(T, w, i.count);
                    else if (n.isInstancedBufferGeometry) {
                        const t = Math.min(n.instanceCount, n._maxInstanceCount);
                        p.renderInstances(T, w, t)
                    } else p.render(T, w)
                }
            }, this.compile = function(t, e) {
                d = nt.get(t), d.init(), f.push(d), t.traverseVisible((function(t) {
                    t.isLight && t.layers.test(e.layers) && (d.pushLight(t), t.castShadow && d.pushShadow(t))
                })), d.setupLights(m.physicallyCorrectLights), t.traverse((function(e) {
                    const n = e.material;
                    if (n)
                        if (Array.isArray(n))
                            for (let r = 0; r < n.length; r++) Mt(n[r], t, e);
                        else Mt(n, t, e)
                })), f.pop(), d = null
            };
            let _t = null;

            function yt() {
                bt.stop()
            }

            function xt() {
                bt.start()
            }
            const bt = new cd;

            function Et(t, e, n, r) {
                if (!1 === t.visible) return;
                if (t.layers.test(e.layers))
                    if (t.isGroup) n = t.renderOrder;
                    else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t);
                else if (t.isSprite) {
                    if (!t.frustumCulled || L.intersectsSprite(t)) {
                        r && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(F);
                        const e = Q.update(t),
                            i = t.material;
                        i.visible && c.push(t, e, i, n, k.z, null)
                    }
                } else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== X.render.frame && (t.skeleton.update(), t.skeleton.frame = X.render.frame), !t.frustumCulled || L.intersectsObject(t))) {
                    r && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(F);
                    const e = Q.update(t),
                        i = t.material;
                    if (Array.isArray(i)) {
                        const r = e.groups;
                        for (let o = 0, s = r.length; o < s; o++) {
                            const s = r[o],
                                a = i[s.materialIndex];
                            a && a.visible && c.push(t, e, a, n, k.z, s)
                        }
                    } else i.visible && c.push(t, e, i, n, k.z, null)
                }
                const i = t.children;
                for (let t = 0, o = i.length; t < o; t++) Et(i[t], e, n, r)
            }

            function Tt(t, e, n, r) {
                const i = t.opaque,
                    s = t.transmissive,
                    a = t.transparent;
                d.setupLightsView(n), s.length > 0 && function(t, e, n) {
                    const r = V.isWebGL2;
                    null === U && (U = new Yu(1, 1, {
                        generateMipmaps: !0,
                        type: null !== ut.convert(Vl) ? Vl : kl,
                        minFilter: Bl,
                        samples: r && !0 === o ? 4 : 0
                    })), m.getDrawingBufferSize(B), r ? U.setSize(B.x, B.y) : U.setSize(Tu(B.x), Tu(B.y));
                    const i = m.getRenderTarget();
                    m.setRenderTarget(U), m.clear();
                    const s = m.toneMapping;
                    m.toneMapping = 0, St(t, e, n), m.toneMapping = s, Y.updateMultisampleRenderTarget(U), Y.updateRenderTargetMipmap(U), m.setRenderTarget(i)
                }(i, e, n), r && W.viewport(E.copy(r)), i.length > 0 && St(i, e, n), s.length > 0 && St(s, e, n), a.length > 0 && St(a, e, n), W.buffers.depth.setTest(!0), W.buffers.depth.setMask(!0), W.buffers.color.setMask(!0), W.setPolygonOffset(!1)
            }

            function St(t, e, n) {
                const r = !0 === e.isScene ? e.overrideMaterial : null;
                for (let i = 0, o = t.length; i < o; i++) {
                    const o = t[i],
                        s = o.object,
                        a = o.geometry,
                        l = null === r ? o.material : r,
                        u = o.group;
                    s.layers.test(n.layers) && wt(s, e, n, a, l, u)
                }
            }

            function wt(t, e, n, r, i, o) {
                t.onBeforeRender(m, e, n, r, i, o), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), i.onBeforeRender(m, e, n, r, t, o), !0 === i.transparent && 2 === i.side ? (i.side = 1, i.needsUpdate = !0, m.renderBufferDirect(n, e, r, i, t, o), i.side = 0, i.needsUpdate = !0, m.renderBufferDirect(n, e, r, i, t, o), i.side = 2) : m.renderBufferDirect(n, e, r, i, t, o), t.onAfterRender(m, e, n, r, i, o)
            }

            function Mt(t, e, n) {
                !0 !== e.isScene && (e = G);
                const r = j.get(t),
                    i = d.state.lights,
                    o = d.state.shadowsArray,
                    s = i.state.version,
                    a = $.getParameters(t, i.state, o, e, n),
                    l = $.getProgramCacheKey(a);
                let u = r.programs;
                r.environment = t.isMeshStandardMaterial ? e.environment : null, r.fog = e.fog, r.envMap = (t.isMeshStandardMaterial ? Z : q).get(t.envMap || r.environment), void 0 === u && (t.addEventListener("dispose", vt), u = new Map, r.programs = u);
                let h = u.get(l);
                if (void 0 !== h) {
                    if (r.currentProgram === h && r.lightsStateVersion === s) return At(t, a), h
                } else a.uniforms = $.getUniforms(t), t.onBuild(n, a, m), t.onBeforeCompile(a, m), h = $.acquireProgram(a, l), u.set(l, h), r.uniforms = a.uniforms;
                const c = r.uniforms;
                (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (c.clippingPlanes = rt.uniform), At(t, a), r.needsLights = function(t) {
                    return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                }(t), r.lightsStateVersion = s, r.needsLights && (c.ambientLightColor.value = i.state.ambient, c.lightProbe.value = i.state.probe, c.directionalLights.value = i.state.directional, c.directionalLightShadows.value = i.state.directionalShadow, c.spotLights.value = i.state.spot, c.spotLightShadows.value = i.state.spotShadow, c.rectAreaLights.value = i.state.rectArea, c.ltc_1.value = i.state.rectAreaLTC1, c.ltc_2.value = i.state.rectAreaLTC2, c.pointLights.value = i.state.point, c.pointLightShadows.value = i.state.pointShadow, c.hemisphereLights.value = i.state.hemi, c.directionalShadowMap.value = i.state.directionalShadowMap, c.directionalShadowMatrix.value = i.state.directionalShadowMatrix, c.spotShadowMap.value = i.state.spotShadowMap, c.spotShadowMatrix.value = i.state.spotShadowMatrix, c.pointShadowMap.value = i.state.pointShadowMap, c.pointShadowMatrix.value = i.state.pointShadowMatrix);
                const p = h.getUniforms(),
                    f = Zp.seqWithValue(p.seq, c);
                return r.currentProgram = h, r.uniformsList = f, h
            }

            function At(t, e) {
                const n = j.get(t);
                n.outputEncoding = e.outputEncoding, n.instancing = e.instancing, n.skinning = e.skinning, n.morphTargets = e.morphTargets, n.morphNormals = e.morphNormals, n.morphColors = e.morphColors, n.morphTargetsCount = e.morphTargetsCount, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas, n.vertexTangents = e.vertexTangents, n.toneMapping = e.toneMapping
            }
            bt.setAnimationLoop((function(t) {
                _t && _t(t)
            })), "undefined" != typeof self && bt.setContext(self), this.setAnimationLoop = function(t) {
                _t = t, ft.setAnimationLoop(t), null === t ? bt.stop() : bt.start()
            }, ft.addEventListener("sessionstart", yt), ft.addEventListener("sessionend", xt), this.render = function(t, e) {
                if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                if (!0 === g) return;
                !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === ft.enabled && !0 === ft.isPresenting && (!0 === ft.cameraAutoUpdate && ft.updateCamera(e), e = ft.getCamera()), !0 === t.isScene && t.onBeforeRender(m, t, e, y), d = nt.get(t, f.length), d.init(), f.push(d), F.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), L.setFromProjectionMatrix(F), D = this.localClippingEnabled, N = rt.init(this.clippingPlanes, D, e), c = et.get(t, p.length), c.init(), p.push(c), Et(t, e, 0, m.sortObjects), c.finish(), !0 === m.sortObjects && c.sort(R, P), !0 === N && rt.beginShadows();
                const n = d.state.shadowsArray;
                if (it.render(n, t, e), !0 === N && rt.endShadows(), !0 === this.info.autoReset && this.info.reset(), ot.render(c, t), d.setupLights(m.physicallyCorrectLights), e.isArrayCamera) {
                    const n = e.cameras;
                    for (let e = 0, r = n.length; e < r; e++) {
                        const r = n[e];
                        Tt(c, t, r, r.viewport)
                    }
                } else Tt(c, t, e);
                null !== y && (Y.updateMultisampleRenderTarget(y), Y.updateRenderTargetMipmap(y)), !0 === t.isScene && t.onAfterRender(m, t, e), ht.resetDefaultState(), x = -1, b = null, f.pop(), d = f.length > 0 ? f[f.length - 1] : null, p.pop(), c = p.length > 0 ? p[p.length - 1] : null
            }, this.getActiveCubeFace = function() {
                return v
            }, this.getActiveMipmapLevel = function() {
                return _
            }, this.getRenderTarget = function() {
                return y
            }, this.setRenderTargetTextures = function(t, e, n) {
                j.get(t.texture).__webglTexture = e, j.get(t.depthTexture).__webglTexture = n;
                const r = j.get(t);
                r.__hasExternalTextures = !0, r.__hasExternalTextures && (r.__autoAllocateDepthBuffer = void 0 === n, r.__autoAllocateDepthBuffer || !0 === z.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), r.__useRenderToTexture = !1))
            }, this.setRenderTargetFramebuffer = function(t, e) {
                const n = j.get(t);
                n.__webglFramebuffer = e, n.__useDefaultFramebuffer = void 0 === e
            }, this.setRenderTarget = function(t, e = 0, n = 0) {
                y = t, v = e, _ = n;
                let r = !0;
                if (t) {
                    const e = j.get(t);
                    void 0 !== e.__useDefaultFramebuffer ? (W.bindFramebuffer(36160, null), r = !1) : void 0 === e.__webglFramebuffer ? Y.setupRenderTarget(t) : e.__hasExternalTextures && Y.rebindTextures(t, j.get(t.texture).__webglTexture, j.get(t.depthTexture).__webglTexture)
                }
                let i = null,
                    o = !1,
                    s = !1;
                if (t) {
                    const n = t.texture;
                    (n.isData3DTexture || n.isDataArrayTexture) && (s = !0);
                    const r = j.get(t).__webglFramebuffer;
                    t.isWebGLCubeRenderTarget ? (i = r[e], o = !0) : i = V.isWebGL2 && t.samples > 0 && !1 === Y.useMultisampledRTT(t) ? j.get(t).__webglMultisampledFramebuffer : r, E.copy(t.viewport), T.copy(t.scissor), S = t.scissorTest
                } else E.copy(I).multiplyScalar(A).floor(), T.copy(C).multiplyScalar(A).floor(), S = O;
                if (W.bindFramebuffer(36160, i) && V.drawBuffers && r && W.drawBuffers(t, i), W.viewport(E), W.scissor(T), W.setScissorTest(S), o) {
                    const r = j.get(t.texture);
                    ct.framebufferTexture2D(36160, 36064, 34069 + e, r.__webglTexture, n)
                } else if (s) {
                    const r = j.get(t.texture),
                        i = e || 0;
                    ct.framebufferTextureLayer(36160, 36064, r.__webglTexture, n || 0, i)
                }
                x = -1
            }, this.readRenderTargetPixels = function(t, e, n, r, i, o, s) {
                if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                let a = j.get(t).__webglFramebuffer;
                if (t.isWebGLCubeRenderTarget && void 0 !== s && (a = a[s]), a) {
                    W.bindFramebuffer(36160, a);
                    try {
                        const s = t.texture,
                            a = s.format,
                            l = s.type;
                        if (a !== Xl && ut.convert(a) !== ct.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        const u = l === Vl && (z.has("EXT_color_buffer_half_float") || V.isWebGL2 && z.has("EXT_color_buffer_float"));
                        if (!(l === kl || ut.convert(l) === ct.getParameter(35738) || l === zl && (V.isWebGL2 || z.has("OES_texture_float") || z.has("WEBGL_color_buffer_float")) || u)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        e >= 0 && e <= t.width - r && n >= 0 && n <= t.height - i && ct.readPixels(e, n, r, i, ut.convert(a), ut.convert(l), o)
                    } finally {
                        const t = null !== y ? j.get(y).__webglFramebuffer : null;
                        W.bindFramebuffer(36160, t)
                    }
                }
            }, this.copyFramebufferToTexture = function(t, e, n = 0) {
                if (!0 !== e.isFramebufferTexture) return void console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
                const r = Math.pow(2, -n),
                    i = Math.floor(e.image.width * r),
                    o = Math.floor(e.image.height * r);
                Y.setTexture2D(e, 0), ct.copyTexSubImage2D(3553, n, 0, 0, t.x, t.y, i, o), W.unbindTexture()
            }, this.copyTextureToTexture = function(t, e, n, r = 0) {
                const i = e.image.width,
                    o = e.image.height,
                    s = ut.convert(n.format),
                    a = ut.convert(n.type);
                Y.setTexture2D(n, 0), ct.pixelStorei(37440, n.flipY), ct.pixelStorei(37441, n.premultiplyAlpha), ct.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? ct.texSubImage2D(3553, r, t.x, t.y, i, o, s, a, e.image.data) : e.isCompressedTexture ? ct.compressedTexSubImage2D(3553, r, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, s, e.mipmaps[0].data) : ct.texSubImage2D(3553, r, t.x, t.y, s, a, e.image), 0 === r && n.generateMipmaps && ct.generateMipmap(3553), W.unbindTexture()
            }, this.copyTextureToTexture3D = function(t, e, n, r, i = 0) {
                if (m.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                const o = t.max.x - t.min.x + 1,
                    s = t.max.y - t.min.y + 1,
                    a = t.max.z - t.min.z + 1,
                    l = ut.convert(r.format),
                    u = ut.convert(r.type);
                let h;
                if (r.isData3DTexture) Y.setTexture3D(r, 0), h = 32879;
                else {
                    if (!r.isDataArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                    Y.setTexture2DArray(r, 0), h = 35866
                }
                ct.pixelStorei(37440, r.flipY), ct.pixelStorei(37441, r.premultiplyAlpha), ct.pixelStorei(3317, r.unpackAlignment);
                const c = ct.getParameter(3314),
                    d = ct.getParameter(32878),
                    p = ct.getParameter(3316),
                    f = ct.getParameter(3315),
                    g = ct.getParameter(32877),
                    v = n.isCompressedTexture ? n.mipmaps[0] : n.image;
                ct.pixelStorei(3314, v.width), ct.pixelStorei(32878, v.height), ct.pixelStorei(3316, t.min.x), ct.pixelStorei(3315, t.min.y), ct.pixelStorei(32877, t.min.z), n.isDataTexture || n.isData3DTexture ? ct.texSubImage3D(h, i, e.x, e.y, e.z, o, s, a, l, u, v.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), ct.compressedTexSubImage3D(h, i, e.x, e.y, e.z, o, s, a, l, v.data)) : ct.texSubImage3D(h, i, e.x, e.y, e.z, o, s, a, l, u, v), ct.pixelStorei(3314, c), ct.pixelStorei(32878, d), ct.pixelStorei(3316, p), ct.pixelStorei(3315, f), ct.pixelStorei(32877, g), 0 === i && r.generateMipmaps && ct.generateMipmap(h), W.unbindTexture()
            }, this.initTexture = function(t) {
                Y.setTexture2D(t, 0), W.unbindTexture()
            }, this.resetState = function() {
                v = 0, _ = 0, y = null, W.reset(), ht.reset()
            }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }
        Vf.prototype.isWebGLRenderer = !0, class extends Vf {}.prototype.isWebGL1Renderer = !0;
        class Wf {
            constructor(t, e = 25e-5) {
                this.name = "", this.color = new ku(t), this.density = e
            }
            clone() {
                return new Wf(this.color, this.density)
            }
            toJSON() {
                return {
                    type: "FogExp2",
                    color: this.color.getHex(),
                    density: this.density
                }
            }
        }
        Wf.prototype.isFogExp2 = !0;
        class Xf {
            constructor(t, e = 1, n = 1e3) {
                this.name = "", this.color = new ku(t), this.near = e, this.far = n
            }
            clone() {
                return new Xf(this.color, this.near, this.far)
            }
            toJSON() {
                return {
                    type: "Fog",
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }
        }
        Xf.prototype.isFog = !0;
        class jf extends $h {
            constructor() {
                super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            copy(t, e) {
                return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return null !== this.fog && (e.object.fog = this.fog.toJSON()), e
            }
        }
        jf.prototype.isScene = !0;
        class Yf {
            constructor(t, e) {
                this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = uu, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0, this.uuid = _u()
            }
            onUploadCallback() {}
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            setUsage(t) {
                return this.usage = t, this
            }
            copy(t) {
                return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
            }
            copyAt(t, e, n) {
                t *= this.stride, n *= e.stride;
                for (let r = 0, i = this.stride; r < i; r++) this.array[t + r] = e.array[n + r];
                return this
            }
            set(t, e = 0) {
                return this.array.set(t, e), this
            }
            clone(t) {
                void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = _u()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
                    n = new this.constructor(e, this.stride);
                return n.setUsage(this.usage), n
            }
            onUpload(t) {
                return this.onUploadCallback = t, this
            }
            toJSON(t) {
                return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = _u()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        }
        Yf.prototype.isInterleavedBuffer = !0;
        const qf = new Ju;
        class Zf {
            constructor(t, e, n, r = !1) {
                this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === r
            }
            get count() {
                return this.data.count
            }
            get array() {
                return this.data.array
            }
            set needsUpdate(t) {
                this.data.needsUpdate = t
            }
            applyMatrix4(t) {
                for (let e = 0, n = this.data.count; e < n; e++) qf.fromBufferAttribute(this, e), qf.applyMatrix4(t), this.setXYZ(e, qf.x, qf.y, qf.z);
                return this
            }
            applyNormalMatrix(t) {
                for (let e = 0, n = this.count; e < n; e++) qf.fromBufferAttribute(this, e), qf.applyNormalMatrix(t), this.setXYZ(e, qf.x, qf.y, qf.z);
                return this
            }
            transformDirection(t) {
                for (let e = 0, n = this.count; e < n; e++) qf.fromBufferAttribute(this, e), qf.transformDirection(t), this.setXYZ(e, qf.x, qf.y, qf.z);
                return this
            }
            setX(t, e) {
                return this.data.array[t * this.data.stride + this.offset] = e, this
            }
            setY(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 1] = e, this
            }
            setZ(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 2] = e, this
            }
            setW(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 3] = e, this
            }
            getX(t) {
                return this.data.array[t * this.data.stride + this.offset]
            }
            getY(t) {
                return this.data.array[t * this.data.stride + this.offset + 1]
            }
            getZ(t) {
                return this.data.array[t * this.data.stride + this.offset + 2]
            }
            getW(t) {
                return this.data.array[t * this.data.stride + this.offset + 3]
            }
            setXY(t, e, n) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
            }
            setXYZ(t, e, n, r) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this
            }
            setXYZW(t, e, n, r, i) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this.data.array[t + 3] = i, this
            }
            clone(t) {
                if (void 0 === t) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                    const t = [];
                    for (let e = 0; e < this.count; e++) {
                        const n = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                    }
                    return new gc(new this.array.constructor(t), this.itemSize, this.normalized)
                }
                return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new Zf(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
            }
            toJSON(t) {
                if (void 0 === t) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                    const t = [];
                    for (let e = 0; e < this.count; e++) {
                        const n = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: t,
                        normalized: this.normalized
                    }
                }
                return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        }
        Zf.prototype.isInterleavedBufferAttribute = !0;
        class Kf extends dc {
            constructor(t) {
                super(), this.type = "SpriteMaterial", this.color = new ku(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
            }
        }
        let Jf;
        Kf.prototype.isSpriteMaterial = !0;
        const Qf = new Ju,
            $f = new Ju,
            tm = new Ju,
            em = new wu,
            nm = new wu,
            rm = new Rh,
            im = new Ju,
            om = new Ju,
            sm = new Ju,
            am = new wu,
            lm = new wu,
            um = new wu;
        class hm extends $h {
            constructor(t) {
                if (super(), this.type = "Sprite", void 0 === Jf) {
                    Jf = new Ac;
                    const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                        e = new Yf(t, 5);
                    Jf.setIndex([0, 1, 2, 0, 2, 3]), Jf.setAttribute("position", new Zf(e, 3, 0, !1)), Jf.setAttribute("uv", new Zf(e, 2, 3, !1))
                }
                this.geometry = Jf, this.material = void 0 !== t ? t : new Kf, this.center = new wu(.5, .5)
            }
            raycast(t, e) {
                null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), $f.setFromMatrixScale(this.matrixWorld), rm.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), tm.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && $f.multiplyScalar(-tm.z);
                const n = this.material.rotation;
                let r, i;
                0 !== n && (i = Math.cos(n), r = Math.sin(n));
                const o = this.center;
                cm(im.set(-.5, -.5, 0), tm, o, $f, r, i), cm(om.set(.5, -.5, 0), tm, o, $f, r, i), cm(sm.set(.5, .5, 0), tm, o, $f, r, i), am.set(0, 0), lm.set(1, 0), um.set(1, 1);
                let s = t.ray.intersectTriangle(im, om, sm, !1, Qf);
                if (null === s && (cm(om.set(-.5, .5, 0), tm, o, $f, r, i), lm.set(0, 1), s = t.ray.intersectTriangle(im, sm, om, !1, Qf), null === s)) return;
                const a = t.ray.origin.distanceTo(Qf);
                a < t.near || a > t.far || e.push({
                    distance: a,
                    point: Qf.clone(),
                    uv: hc.getUV(Qf, im, om, sm, am, lm, um, new wu),
                    face: null,
                    object: this
                })
            }
            copy(t) {
                return super.copy(t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this
            }
        }

        function cm(t, e, n, r, i, o) {
            em.subVectors(t, n).addScalar(.5).multiply(r), void 0 !== i ? (nm.x = o * em.x - i * em.y, nm.y = i * em.x + o * em.y) : nm.copy(em), t.copy(e), t.x += nm.x, t.y += nm.y, t.applyMatrix4(rm)
        }
        hm.prototype.isSprite = !0;
        const dm = new Ju,
            pm = new ju,
            fm = new ju,
            mm = new Ju,
            gm = new Rh;
        class vm extends Xc {
            constructor(t, e) {
                super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Rh, this.bindMatrixInverse = new Rh
            }
            copy(t) {
                return super.copy(t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this
            }
            bind(t, e) {
                this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
            }
            pose() {
                this.skeleton.pose()
            }
            normalizeSkinWeights() {
                const t = new ju,
                    e = this.geometry.attributes.skinWeight;
                for (let n = 0, r = e.count; n < r; n++) {
                    t.fromBufferAttribute(e, n);
                    const r = 1 / t.manhattanLength();
                    r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
                }
            }
            updateMatrixWorld(t) {
                super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            }
            boneTransform(t, e) {
                const n = this.skeleton,
                    r = this.geometry;
                pm.fromBufferAttribute(r.attributes.skinIndex, t), fm.fromBufferAttribute(r.attributes.skinWeight, t), dm.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                for (let t = 0; t < 4; t++) {
                    const r = fm.getComponent(t);
                    if (0 !== r) {
                        const i = pm.getComponent(t);
                        gm.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]), e.addScaledVector(mm.copy(dm).applyMatrix4(gm), r)
                    }
                }
                return e.applyMatrix4(this.bindMatrixInverse)
            }
        }
        vm.prototype.isSkinnedMesh = !0;
        (class extends $h {
            constructor() {
                super(), this.type = "Bone"
            }
        }).prototype.isBone = !0;
        (class extends Xu {
            constructor(t = null, e = 1, n = 1, r, i, o, s, a, l = 1003, u = 1003, h, c) {
                super(null, o, s, a, l, u, r, i, h, c), this.image = {
                    data: t,
                    width: e,
                    height: n
                }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }).prototype.isDataTexture = !0;
        class _m extends gc {
            constructor(t, e, n, r = 1) {
                "number" == typeof n && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, n), this.meshPerAttribute = r
            }
            copy(t) {
                return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
            }
            toJSON() {
                const t = super.toJSON();
                return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
            }
        }
        _m.prototype.isInstancedBufferAttribute = !0;
        const ym = new Rh,
            xm = new Rh,
            bm = [],
            Em = new Xc;
        (class extends Xc {
            constructor(t, e, n) {
                super(t, e), this.instanceMatrix = new _m(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
            }
            copy(t) {
                return super.copy(t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this
            }
            getColorAt(t, e) {
                e.fromArray(this.instanceColor.array, 3 * t)
            }
            getMatrixAt(t, e) {
                e.fromArray(this.instanceMatrix.array, 16 * t)
            }
            raycast(t, e) {
                const n = this.matrixWorld,
                    r = this.count;
                if (Em.geometry = this.geometry, Em.material = this.material, void 0 !== Em.material)
                    for (let i = 0; i < r; i++) {
                        this.getMatrixAt(i, ym), xm.multiplyMatrices(n, ym), Em.matrixWorld = xm, Em.raycast(t, bm);
                        for (let t = 0, n = bm.length; t < n; t++) {
                            const n = bm[t];
                            n.instanceId = i, n.object = this, e.push(n)
                        }
                        bm.length = 0
                    }
            }
            setColorAt(t, e) {
                null === this.instanceColor && (this.instanceColor = new _m(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
            }
            setMatrixAt(t, e) {
                e.toArray(this.instanceMatrix.array, 16 * t)
            }
            updateMorphTargets() {}
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }).prototype.isInstancedMesh = !0;
        class Tm extends dc {
            constructor(t) {
                super(), this.type = "LineBasicMaterial", this.color = new ku(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
            }
        }
        Tm.prototype.isLineBasicMaterial = !0;
        const Sm = new Ju,
            wm = new Ju,
            Mm = new Rh,
            Am = new Ah,
            Rm = new yh;
        class Pm extends $h {
            constructor(t = new Ac, e = new Tm) {
                super(), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
            }
            copy(t) {
                return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
            }
            computeLineDistances() {
                const t = this.geometry;
                if (t.isBufferGeometry)
                    if (null === t.index) {
                        const e = t.attributes.position,
                            n = [0];
                        for (let t = 1, r = e.count; t < r; t++) Sm.fromBufferAttribute(e, t - 1), wm.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += Sm.distanceTo(wm);
                        t.setAttribute("lineDistance", new yc(n, 1))
                    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                return this
            }
            raycast(t, e) {
                const n = this.geometry,
                    r = this.matrixWorld,
                    i = t.params.Line.threshold,
                    o = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(), Rm.copy(n.boundingSphere), Rm.applyMatrix4(r), Rm.radius += i, !1 === t.ray.intersectsSphere(Rm)) return;
                Mm.copy(r).invert(), Am.copy(t.ray).applyMatrix4(Mm);
                const s = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    a = s * s,
                    l = new Ju,
                    u = new Ju,
                    h = new Ju,
                    c = new Ju,
                    d = this.isLineSegments ? 2 : 1;
                if (n.isBufferGeometry) {
                    const r = n.index,
                        i = n.attributes.position;
                    if (null !== r)
                        for (let n = Math.max(0, o.start), s = Math.min(r.count, o.start + o.count) - 1; n < s; n += d) {
                            const o = r.getX(n),
                                s = r.getX(n + 1);
                            if (l.fromBufferAttribute(i, o), u.fromBufferAttribute(i, s), Am.distanceSqToSegment(l, u, c, h) > a) continue;
                            c.applyMatrix4(this.matrixWorld);
                            const d = t.ray.origin.distanceTo(c);
                            d < t.near || d > t.far || e.push({
                                distance: d,
                                point: h.clone().applyMatrix4(this.matrixWorld),
                                index: n,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        } else
                            for (let n = Math.max(0, o.start), r = Math.min(i.count, o.start + o.count) - 1; n < r; n += d) {
                                if (l.fromBufferAttribute(i, n), u.fromBufferAttribute(i, n + 1), Am.distanceSqToSegment(l, u, c, h) > a) continue;
                                c.applyMatrix4(this.matrixWorld);
                                const r = t.ray.origin.distanceTo(c);
                                r < t.near || r > t.far || e.push({
                                    distance: r,
                                    point: h.clone().applyMatrix4(this.matrixWorld),
                                    index: n,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
            updateMorphTargets() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes,
                        n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
        }
        Pm.prototype.isLine = !0;
        const Im = new Ju,
            Cm = new Ju;
        class Om extends Pm {
            constructor(t, e) {
                super(t, e), this.type = "LineSegments"
            }
            computeLineDistances() {
                const t = this.geometry;
                if (t.isBufferGeometry)
                    if (null === t.index) {
                        const e = t.attributes.position,
                            n = [];
                        for (let t = 0, r = e.count; t < r; t += 2) Im.fromBufferAttribute(e, t), Cm.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + Im.distanceTo(Cm);
                        t.setAttribute("lineDistance", new yc(n, 1))
                    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                return this
            }
        }
        Om.prototype.isLineSegments = !0;
        (class extends Pm {
            constructor(t, e) {
                super(t, e), this.type = "LineLoop"
            }
        }).prototype.isLineLoop = !0;
        class Lm extends dc {
            constructor(t) {
                super(), this.type = "PointsMaterial", this.color = new ku(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this
            }
        }
        Lm.prototype.isPointsMaterial = !0;
        const Nm = new Rh,
            Dm = new Ah,
            Um = new yh,
            Fm = new Ju;

        function Bm(t, e, n, r, i, o, s) {
            const a = Dm.distanceSqToPoint(t);
            if (a < n) {
                const n = new Ju;
                Dm.closestPointToPoint(t, n), n.applyMatrix4(r);
                const l = i.ray.origin.distanceTo(n);
                if (l < i.near || l > i.far) return;
                o.push({
                    distance: l,
                    distanceToRay: Math.sqrt(a),
                    point: n,
                    index: e,
                    face: null,
                    object: s
                })
            }
        }(class extends $h {
            constructor(t = new Ac, e = new Lm) {
                super(), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
            }
            copy(t) {
                return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
            }
            raycast(t, e) {
                const n = this.geometry,
                    r = this.matrixWorld,
                    i = t.params.Points.threshold,
                    o = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(), Um.copy(n.boundingSphere), Um.applyMatrix4(r), Um.radius += i, !1 === t.ray.intersectsSphere(Um)) return;
                Nm.copy(r).invert(), Dm.copy(t.ray).applyMatrix4(Nm);
                const s = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    a = s * s;
                if (n.isBufferGeometry) {
                    const i = n.index,
                        s = n.attributes.position;
                    if (null !== i)
                        for (let n = Math.max(0, o.start), l = Math.min(i.count, o.start + o.count); n < l; n++) {
                            const o = i.getX(n);
                            Fm.fromBufferAttribute(s, o), Bm(Fm, o, a, r, t, e, this)
                        } else
                            for (let n = Math.max(0, o.start), i = Math.min(s.count, o.start + o.count); n < i; n++) Fm.fromBufferAttribute(s, n), Bm(Fm, n, a, r, t, e, this)
                } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
            updateMorphTargets() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes,
                        n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
        }).prototype.isPoints = !0, class extends Xu {
            constructor(t, e, n, r, i, o, s, a, l) {
                super(t, e, n, r, i, o, s, a, l), this.minFilter = void 0 !== o ? o : Fl, this.magFilter = void 0 !== i ? i : Fl, this.generateMipmaps = !1;
                const u = this;
                "requestVideoFrameCallback" in t && t.requestVideoFrameCallback((function e() {
                    u.needsUpdate = !0, t.requestVideoFrameCallback(e)
                }))
            }
            clone() {
                return new this.constructor(this.image).copy(this)
            }
            update() {
                const t = this.image;
                !1 == "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }.prototype.isVideoTexture = !0, class extends Xu {
            constructor(t, e, n) {
                super({
                    width: t,
                    height: e
                }), this.format = n, this.magFilter = Ul, this.minFilter = Ul, this.generateMipmaps = !1, this.needsUpdate = !0
            }
        }.prototype.isFramebufferTexture = !0;
        (class extends Xu {
            constructor(t, e, n, r, i, o, s, a, l, u, h, c) {
                super(null, o, s, a, l, u, r, i, h, c), this.image = {
                    width: e,
                    height: n
                }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
            }
        }).prototype.isCompressedTexture = !0, class extends Xu {
            constructor(t, e, n, r, i, o, s, a, l) {
                super(t, e, n, r, i, o, s, a, l), this.needsUpdate = !0
            }
        }.prototype.isCanvasTexture = !0;
        class km {
            constructor() {
                this.type = "Curve", this.arcLengthDivisions = 200
            }
            getPoint() {
                return console.warn("THREE.Curve: .getPoint() not implemented."), null
            }
            getPointAt(t, e) {
                const n = this.getUtoTmapping(t);
                return this.getPoint(n, e)
            }
            getPoints(t = 5) {
                const e = [];
                for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                return e
            }
            getSpacedPoints(t = 5) {
                const e = [];
                for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
                return e
            }
            getLength() {
                const t = this.getLengths();
                return t[t.length - 1]
            }
            getLengths(t = this.arcLengthDivisions) {
                if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                this.needsUpdate = !1;
                const e = [];
                let n, r = this.getPoint(0),
                    i = 0;
                e.push(0);
                for (let o = 1; o <= t; o++) n = this.getPoint(o / t), i += n.distanceTo(r), e.push(i), r = n;
                return this.cacheArcLengths = e, e
            }
            updateArcLengths() {
                this.needsUpdate = !0, this.getLengths()
            }
            getUtoTmapping(t, e) {
                const n = this.getLengths();
                let r = 0;
                const i = n.length;
                let o;
                o = e || t * n[i - 1];
                let s, a = 0,
                    l = i - 1;
                for (; a <= l;)
                    if (r = Math.floor(a + (l - a) / 2), s = n[r] - o, s < 0) a = r + 1;
                    else {
                        if (!(s > 0)) {
                            l = r;
                            break
                        }
                        l = r - 1
                    } if (r = l, n[r] === o) return r / (i - 1);
                const u = n[r];
                return (r + (o - u) / (n[r + 1] - u)) / (i - 1)
            }
            getTangent(t, e) {
                const n = 1e-4;
                let r = t - n,
                    i = t + n;
                r < 0 && (r = 0), i > 1 && (i = 1);
                const o = this.getPoint(r),
                    s = this.getPoint(i),
                    a = e || (o.isVector2 ? new wu : new Ju);
                return a.copy(s).sub(o).normalize(), a
            }
            getTangentAt(t, e) {
                const n = this.getUtoTmapping(t);
                return this.getTangent(n, e)
            }
            computeFrenetFrames(t, e) {
                const n = new Ju,
                    r = [],
                    i = [],
                    o = [],
                    s = new Ju,
                    a = new Rh;
                for (let e = 0; e <= t; e++) {
                    const n = e / t;
                    r[e] = this.getTangentAt(n, new Ju)
                }
                i[0] = new Ju, o[0] = new Ju;
                let l = Number.MAX_VALUE;
                const u = Math.abs(r[0].x),
                    h = Math.abs(r[0].y),
                    c = Math.abs(r[0].z);
                u <= l && (l = u, n.set(1, 0, 0)), h <= l && (l = h, n.set(0, 1, 0)), c <= l && n.set(0, 0, 1), s.crossVectors(r[0], n).normalize(), i[0].crossVectors(r[0], s), o[0].crossVectors(r[0], i[0]);
                for (let e = 1; e <= t; e++) {
                    if (i[e] = i[e - 1].clone(), o[e] = o[e - 1].clone(), s.crossVectors(r[e - 1], r[e]), s.length() > Number.EPSILON) {
                        s.normalize();
                        const t = Math.acos(yu(r[e - 1].dot(r[e]), -1, 1));
                        i[e].applyMatrix4(a.makeRotationAxis(s, t))
                    }
                    o[e].crossVectors(r[e], i[e])
                }
                if (!0 === e) {
                    let e = Math.acos(yu(i[0].dot(i[t]), -1, 1));
                    e /= t, r[0].dot(s.crossVectors(i[0], i[t])) > 0 && (e = -e);
                    for (let n = 1; n <= t; n++) i[n].applyMatrix4(a.makeRotationAxis(r[n], e * n)), o[n].crossVectors(r[n], i[n])
                }
                return {
                    tangents: r,
                    normals: i,
                    binormals: o
                }
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.arcLengthDivisions = t.arcLengthDivisions, this
            }
            toJSON() {
                const t = {
                    metadata: {
                        version: 4.5,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
            }
            fromJSON(t) {
                return this.arcLengthDivisions = t.arcLengthDivisions, this
            }
        }
        class Gm extends km {
            constructor(t = 0, e = 0, n = 1, r = 1, i = 0, o = 2 * Math.PI, s = !1, a = 0) {
                super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = r, this.aStartAngle = i, this.aEndAngle = o, this.aClockwise = s, this.aRotation = a
            }
            getPoint(t, e) {
                const n = e || new wu,
                    r = 2 * Math.PI;
                let i = this.aEndAngle - this.aStartAngle;
                const o = Math.abs(i) < Number.EPSILON;
                for (; i < 0;) i += r;
                for (; i > r;) i -= r;
                i < Number.EPSILON && (i = o ? 0 : r), !0 !== this.aClockwise || o || (i === r ? i = -r : i -= r);
                const s = this.aStartAngle + t * i;
                let a = this.aX + this.xRadius * Math.cos(s),
                    l = this.aY + this.yRadius * Math.sin(s);
                if (0 !== this.aRotation) {
                    const t = Math.cos(this.aRotation),
                        e = Math.sin(this.aRotation),
                        n = a - this.aX,
                        r = l - this.aY;
                    a = n * t - r * e + this.aX, l = n * e + r * t + this.aY
                }
                return n.set(a, l)
            }
            copy(t) {
                return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }
            toJSON() {
                const t = super.toJSON();
                return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
            }
            fromJSON(t) {
                return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }
        }
        Gm.prototype.isEllipseCurve = !0;
        class Hm extends Gm {
            constructor(t, e, n, r, i, o) {
                super(t, e, n, n, r, i, o), this.type = "ArcCurve"
            }
        }

        function zm() {
            let t = 0,
                e = 0,
                n = 0,
                r = 0;

            function i(i, o, s, a) {
                t = i, e = s, n = -3 * i + 3 * o - 2 * s - a, r = 2 * i - 2 * o + s + a
            }
            return {
                initCatmullRom: function(t, e, n, r, o) {
                    i(e, n, o * (n - t), o * (r - e))
                },
                initNonuniformCatmullRom: function(t, e, n, r, o, s, a) {
                    let l = (e - t) / o - (n - t) / (o + s) + (n - e) / s,
                        u = (n - e) / s - (r - e) / (s + a) + (r - n) / a;
                    l *= s, u *= s, i(e, n, l, u)
                },
                calc: function(i) {
                    const o = i * i;
                    return t + e * i + n * o + r * (o * i)
                }
            }
        }
        Hm.prototype.isArcCurve = !0;
        const Vm = new Ju,
            Wm = new zm,
            Xm = new zm,
            jm = new zm;
        class Ym extends km {
            constructor(t = [], e = !1, n = "centripetal", r = .5) {
                super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = r
            }
            getPoint(t, e = new Ju) {
                const n = e,
                    r = this.points,
                    i = r.length,
                    o = (i - (this.closed ? 0 : 1)) * t;
                let s, a, l = Math.floor(o),
                    u = o - l;
                this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / i) + 1) * i : 0 === u && l === i - 1 && (l = i - 2, u = 1), this.closed || l > 0 ? s = r[(l - 1) % i] : (Vm.subVectors(r[0], r[1]).add(r[0]), s = Vm);
                const h = r[l % i],
                    c = r[(l + 1) % i];
                if (this.closed || l + 2 < i ? a = r[(l + 2) % i] : (Vm.subVectors(r[i - 1], r[i - 2]).add(r[i - 1]), a = Vm), "centripetal" === this.curveType || "chordal" === this.curveType) {
                    const t = "chordal" === this.curveType ? .5 : .25;
                    let e = Math.pow(s.distanceToSquared(h), t),
                        n = Math.pow(h.distanceToSquared(c), t),
                        r = Math.pow(c.distanceToSquared(a), t);
                    n < 1e-4 && (n = 1), e < 1e-4 && (e = n), r < 1e-4 && (r = n), Wm.initNonuniformCatmullRom(s.x, h.x, c.x, a.x, e, n, r), Xm.initNonuniformCatmullRom(s.y, h.y, c.y, a.y, e, n, r), jm.initNonuniformCatmullRom(s.z, h.z, c.z, a.z, e, n, r)
                } else "catmullrom" === this.curveType && (Wm.initCatmullRom(s.x, h.x, c.x, a.x, this.tension), Xm.initCatmullRom(s.y, h.y, c.y, a.y, this.tension), jm.initCatmullRom(s.z, h.z, c.z, a.z, this.tension));
                return n.set(Wm.calc(u), Xm.calc(u), jm.calc(u)), n
            }
            copy(t) {
                super.copy(t), this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push(n.clone())
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }
            toJSON() {
                const t = super.toJSON();
                t.points = [];
                for (let e = 0, n = this.points.length; e < n; e++) {
                    const n = this.points[e];
                    t.points.push(n.toArray())
                }
                return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
            }
            fromJSON(t) {
                super.fromJSON(t), this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push((new Ju).fromArray(n))
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }
        }

        function qm(t, e, n, r, i) {
            const o = .5 * (r - e),
                s = .5 * (i - n),
                a = t * t;
            return (2 * n - 2 * r + o + s) * (t * a) + (-3 * n + 3 * r - 2 * o - s) * a + o * t + n
        }

        function Zm(t, e, n, r) {
            return function(t, e) {
                const n = 1 - t;
                return n * n * e
            }(t, e) + function(t, e) {
                return 2 * (1 - t) * t * e
            }(t, n) + function(t, e) {
                return t * t * e
            }(t, r)
        }

        function Km(t, e, n, r, i) {
            return function(t, e) {
                const n = 1 - t;
                return n * n * n * e
            }(t, e) + function(t, e) {
                const n = 1 - t;
                return 3 * n * n * t * e
            }(t, n) + function(t, e) {
                return 3 * (1 - t) * t * t * e
            }(t, r) + function(t, e) {
                return t * t * t * e
            }(t, i)
        }
        Ym.prototype.isCatmullRomCurve3 = !0;
        class Jm extends km {
            constructor(t = new wu, e = new wu, n = new wu, r = new wu) {
                super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r
            }
            getPoint(t, e = new wu) {
                const n = e,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2,
                    s = this.v3;
                return n.set(Km(t, r.x, i.x, o.x, s.x), Km(t, r.y, i.y, o.y, s.y)), n
            }
            copy(t) {
                return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }
            fromJSON(t) {
                return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }
        }
        Jm.prototype.isCubicBezierCurve = !0;
        class Qm extends km {
            constructor(t = new Ju, e = new Ju, n = new Ju, r = new Ju) {
                super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r
            }
            getPoint(t, e = new Ju) {
                const n = e,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2,
                    s = this.v3;
                return n.set(Km(t, r.x, i.x, o.x, s.x), Km(t, r.y, i.y, o.y, s.y), Km(t, r.z, i.z, o.z, s.z)), n
            }
            copy(t) {
                return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }
            fromJSON(t) {
                return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }
        }
        Qm.prototype.isCubicBezierCurve3 = !0;
        class $m extends km {
            constructor(t = new wu, e = new wu) {
                super(), this.type = "LineCurve", this.v1 = t, this.v2 = e
            }
            getPoint(t, e = new wu) {
                const n = e;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
            }
            getPointAt(t, e) {
                return this.getPoint(t, e)
            }
            getTangent(t, e) {
                const n = e || new wu;
                return n.copy(this.v2).sub(this.v1).normalize(), n
            }
            copy(t) {
                return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }
            fromJSON(t) {
                return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }
        }
        $m.prototype.isLineCurve = !0;
        class tg extends km {
            constructor(t = new wu, e = new wu, n = new wu) {
                super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n
            }
            getPoint(t, e = new wu) {
                const n = e,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2;
                return n.set(Zm(t, r.x, i.x, o.x), Zm(t, r.y, i.y, o.y)), n
            }
            copy(t) {
                return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }
            fromJSON(t) {
                return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }
        }
        tg.prototype.isQuadraticBezierCurve = !0;
        class eg extends km {
            constructor(t = new Ju, e = new Ju, n = new Ju) {
                super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n
            }
            getPoint(t, e = new Ju) {
                const n = e,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2;
                return n.set(Zm(t, r.x, i.x, o.x), Zm(t, r.y, i.y, o.y), Zm(t, r.z, i.z, o.z)), n
            }
            copy(t) {
                return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }
            fromJSON(t) {
                return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }
        }
        eg.prototype.isQuadraticBezierCurve3 = !0;
        class ng extends km {
            constructor(t = []) {
                super(), this.type = "SplineCurve", this.points = t
            }
            getPoint(t, e = new wu) {
                const n = e,
                    r = this.points,
                    i = (r.length - 1) * t,
                    o = Math.floor(i),
                    s = i - o,
                    a = r[0 === o ? o : o - 1],
                    l = r[o],
                    u = r[o > r.length - 2 ? r.length - 1 : o + 1],
                    h = r[o > r.length - 3 ? r.length - 1 : o + 2];
                return n.set(qm(s, a.x, l.x, u.x, h.x), qm(s, a.y, l.y, u.y, h.y)), n
            }
            copy(t) {
                super.copy(t), this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push(n.clone())
                }
                return this
            }
            toJSON() {
                const t = super.toJSON();
                t.points = [];
                for (let e = 0, n = this.points.length; e < n; e++) {
                    const n = this.points[e];
                    t.points.push(n.toArray())
                }
                return t
            }
            fromJSON(t) {
                super.fromJSON(t), this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push((new wu).fromArray(n))
                }
                return this
            }
        }
        ng.prototype.isSplineCurve = !0;
        var rg = Object.freeze({
            __proto__: null,
            ArcCurve: Hm,
            CatmullRomCurve3: Ym,
            CubicBezierCurve: Jm,
            CubicBezierCurve3: Qm,
            EllipseCurve: Gm,
            LineCurve: $m,
            LineCurve3: class extends km {
                constructor(t = new Ju, e = new Ju) {
                    super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = t, this.v2 = e
                }
                getPoint(t, e = new Ju) {
                    const n = e;
                    return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
                }
                getPointAt(t, e) {
                    return this.getPoint(t, e)
                }
                copy(t) {
                    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                }
            },
            QuadraticBezierCurve: tg,
            QuadraticBezierCurve3: eg,
            SplineCurve: ng
        });
        class ig extends km {
            constructor() {
                super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
            }
            add(t) {
                this.curves.push(t)
            }
            closePath() {
                const t = this.curves[0].getPoint(0),
                    e = this.curves[this.curves.length - 1].getPoint(1);
                t.equals(e) || this.curves.push(new $m(e, t))
            }
            getPoint(t, e) {
                const n = t * this.getLength(),
                    r = this.getCurveLengths();
                let i = 0;
                for (; i < r.length;) {
                    if (r[i] >= n) {
                        const t = r[i] - n,
                            o = this.curves[i],
                            s = o.getLength(),
                            a = 0 === s ? 0 : 1 - t / s;
                        return o.getPointAt(a, e)
                    }
                    i++
                }
                return null
            }
            getLength() {
                const t = this.getCurveLengths();
                return t[t.length - 1]
            }
            updateArcLengths() {
                this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
            }
            getCurveLengths() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                const t = [];
                let e = 0;
                for (let n = 0, r = this.curves.length; n < r; n++) e += this.curves[n].getLength(), t.push(e);
                return this.cacheLengths = t, t
            }
            getSpacedPoints(t = 40) {
                const e = [];
                for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                return this.autoClose && e.push(e[0]), e
            }
            getPoints(t = 12) {
                const e = [];
                let n;
                for (let r = 0, i = this.curves; r < i.length; r++) {
                    const o = i[r],
                        s = o.isEllipseCurve ? 2 * t : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? t * o.points.length : t,
                        a = o.getPoints(s);
                    for (let t = 0; t < a.length; t++) {
                        const r = a[t];
                        n && n.equals(r) || (e.push(r), n = r)
                    }
                }
                return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
            }
            copy(t) {
                super.copy(t), this.curves = [];
                for (let e = 0, n = t.curves.length; e < n; e++) {
                    const n = t.curves[e];
                    this.curves.push(n.clone())
                }
                return this.autoClose = t.autoClose, this
            }
            toJSON() {
                const t = super.toJSON();
                t.autoClose = this.autoClose, t.curves = [];
                for (let e = 0, n = this.curves.length; e < n; e++) {
                    const n = this.curves[e];
                    t.curves.push(n.toJSON())
                }
                return t
            }
            fromJSON(t) {
                super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
                for (let e = 0, n = t.curves.length; e < n; e++) {
                    const n = t.curves[e];
                    this.curves.push((new rg[n.type]).fromJSON(n))
                }
                return this
            }
        }
        class og extends ig {
            constructor(t) {
                super(), this.type = "Path", this.currentPoint = new wu, t && this.setFromPoints(t)
            }
            setFromPoints(t) {
                this.moveTo(t[0].x, t[0].y);
                for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
                return this
            }
            moveTo(t, e) {
                return this.currentPoint.set(t, e), this
            }
            lineTo(t, e) {
                const n = new $m(this.currentPoint.clone(), new wu(t, e));
                return this.curves.push(n), this.currentPoint.set(t, e), this
            }
            quadraticCurveTo(t, e, n, r) {
                const i = new tg(this.currentPoint.clone(), new wu(t, e), new wu(n, r));
                return this.curves.push(i), this.currentPoint.set(n, r), this
            }
            bezierCurveTo(t, e, n, r, i, o) {
                const s = new Jm(this.currentPoint.clone(), new wu(t, e), new wu(n, r), new wu(i, o));
                return this.curves.push(s), this.currentPoint.set(i, o), this
            }
            splineThru(t) {
                const e = [this.currentPoint.clone()].concat(t),
                    n = new ng(e);
                return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
            }
            arc(t, e, n, r, i, o) {
                const s = this.currentPoint.x,
                    a = this.currentPoint.y;
                return this.absarc(t + s, e + a, n, r, i, o), this
            }
            absarc(t, e, n, r, i, o) {
                return this.absellipse(t, e, n, n, r, i, o), this
            }
            ellipse(t, e, n, r, i, o, s, a) {
                const l = this.currentPoint.x,
                    u = this.currentPoint.y;
                return this.absellipse(t + l, e + u, n, r, i, o, s, a), this
            }
            absellipse(t, e, n, r, i, o, s, a) {
                const l = new Gm(t, e, n, r, i, o, s, a);
                if (this.curves.length > 0) {
                    const t = l.getPoint(0);
                    t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                }
                this.curves.push(l);
                const u = l.getPoint(1);
                return this.currentPoint.copy(u), this
            }
            copy(t) {
                return super.copy(t), this.currentPoint.copy(t.currentPoint), this
            }
            toJSON() {
                const t = super.toJSON();
                return t.currentPoint = this.currentPoint.toArray(), t
            }
            fromJSON(t) {
                return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
            }
        }
        class sg extends Ac {
            constructor(t = 1, e = 8, n = 0, r = 2 * Math.PI) {
                super(), this.type = "CircleGeometry", this.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: n,
                    thetaLength: r
                }, e = Math.max(3, e);
                const i = [],
                    o = [],
                    s = [],
                    a = [],
                    l = new Ju,
                    u = new wu;
                o.push(0, 0, 0), s.push(0, 0, 1), a.push(.5, .5);
                for (let i = 0, h = 3; i <= e; i++, h += 3) {
                    const c = n + i / e * r;
                    l.x = t * Math.cos(c), l.y = t * Math.sin(c), o.push(l.x, l.y, l.z), s.push(0, 0, 1), u.x = (o[h] / t + 1) / 2, u.y = (o[h + 1] / t + 1) / 2, a.push(u.x, u.y)
                }
                for (let t = 1; t <= e; t++) i.push(t, t + 1, 0);
                this.setIndex(i), this.setAttribute("position", new yc(o, 3)), this.setAttribute("normal", new yc(s, 3)), this.setAttribute("uv", new yc(a, 2))
            }
            static fromJSON(t) {
                return new sg(t.radius, t.segments, t.thetaStart, t.thetaLength)
            }
        }
        new Ju, new Ju, new Ju, new hc;
        class ag extends og {
            constructor(t) {
                super(t), this.uuid = _u(), this.type = "Shape", this.holes = []
            }
            getPointsHoles(t) {
                const e = [];
                for (let n = 0, r = this.holes.length; n < r; n++) e[n] = this.holes[n].getPoints(t);
                return e
            }
            extractPoints(t) {
                return {
                    shape: this.getPoints(t),
                    holes: this.getPointsHoles(t)
                }
            }
            copy(t) {
                super.copy(t), this.holes = [];
                for (let e = 0, n = t.holes.length; e < n; e++) {
                    const n = t.holes[e];
                    this.holes.push(n.clone())
                }
                return this
            }
            toJSON() {
                const t = super.toJSON();
                t.uuid = this.uuid, t.holes = [];
                for (let e = 0, n = this.holes.length; e < n; e++) {
                    const n = this.holes[e];
                    t.holes.push(n.toJSON())
                }
                return t
            }
            fromJSON(t) {
                super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
                for (let e = 0, n = t.holes.length; e < n; e++) {
                    const n = t.holes[e];
                    this.holes.push((new og).fromJSON(n))
                }
                return this
            }
        }

        function lg(t, e, n, r, i) {
            let o, s;
            if (i === function(t, e, n, r) {
                    let i = 0;
                    for (let o = e, s = n - r; o < n; o += r) i += (t[s] - t[o]) * (t[o + 1] + t[s + 1]), s = o;
                    return i
                }(t, e, n, r) > 0)
                for (o = e; o < n; o += r) s = Pg(o, t[o], t[o + 1], s);
            else
                for (o = n - r; o >= e; o -= r) s = Pg(o, t[o], t[o + 1], s);
            return s && Tg(s, s.next) && (Ig(s), s = s.next), s
        }

        function ug(t, e) {
            if (!t) return t;
            e || (e = t);
            let n, r = t;
            do {
                if (n = !1, r.steiner || !Tg(r, r.next) && 0 !== Eg(r.prev, r, r.next)) r = r.next;
                else {
                    if (Ig(r), r = e = r.prev, r === r.next) break;
                    n = !0
                }
            } while (n || r !== e);
            return e
        }

        function hg(t, e, n, r, i, o, s) {
            if (!t) return;
            !s && o && function(t, e, n, r) {
                let i = t;
                do {
                    null === i.z && (i.z = _g(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next
                } while (i !== t);
                i.prevZ.nextZ = null, i.prevZ = null,
                    function(t) {
                        let e, n, r, i, o, s, a, l, u = 1;
                        do {
                            for (n = t, t = null, o = null, s = 0; n;) {
                                for (s++, r = n, a = 0, e = 0; e < u && (a++, r = r.nextZ, r); e++);
                                for (l = u; a > 0 || l > 0 && r;) 0 !== a && (0 === l || !r || n.z <= r.z) ? (i = n, n = n.nextZ, a--) : (i = r, r = r.nextZ, l--), o ? o.nextZ = i : t = i, i.prevZ = o, o = i;
                                n = r
                            }
                            o.nextZ = null, u *= 2
                        } while (s > 1)
                    }(i)
            }(t, r, i, o);
            let a, l, u = t;
            for (; t.prev !== t.next;)
                if (a = t.prev, l = t.next, o ? dg(t, r, i, o) : cg(t)) e.push(a.i / n), e.push(t.i / n), e.push(l.i / n), Ig(t), t = l.next, u = l.next;
                else if ((t = l) === u) {
                s ? 1 === s ? hg(t = pg(ug(t), e, n), e, n, r, i, o, 2) : 2 === s && fg(t, e, n, r, i, o) : hg(ug(t), e, n, r, i, o, 1);
                break
            }
        }

        function cg(t) {
            const e = t.prev,
                n = t,
                r = t.next;
            if (Eg(e, n, r) >= 0) return !1;
            let i = t.next.next;
            for (; i !== t.prev;) {
                if (xg(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) && Eg(i.prev, i, i.next) >= 0) return !1;
                i = i.next
            }
            return !0
        }

        function dg(t, e, n, r) {
            const i = t.prev,
                o = t,
                s = t.next;
            if (Eg(i, o, s) >= 0) return !1;
            const a = i.x < o.x ? i.x < s.x ? i.x : s.x : o.x < s.x ? o.x : s.x,
                l = i.y < o.y ? i.y < s.y ? i.y : s.y : o.y < s.y ? o.y : s.y,
                u = i.x > o.x ? i.x > s.x ? i.x : s.x : o.x > s.x ? o.x : s.x,
                h = i.y > o.y ? i.y > s.y ? i.y : s.y : o.y > s.y ? o.y : s.y,
                c = _g(a, l, e, n, r),
                d = _g(u, h, e, n, r);
            let p = t.prevZ,
                f = t.nextZ;
            for (; p && p.z >= c && f && f.z <= d;) {
                if (p !== t.prev && p !== t.next && xg(i.x, i.y, o.x, o.y, s.x, s.y, p.x, p.y) && Eg(p.prev, p, p.next) >= 0) return !1;
                if (p = p.prevZ, f !== t.prev && f !== t.next && xg(i.x, i.y, o.x, o.y, s.x, s.y, f.x, f.y) && Eg(f.prev, f, f.next) >= 0) return !1;
                f = f.nextZ
            }
            for (; p && p.z >= c;) {
                if (p !== t.prev && p !== t.next && xg(i.x, i.y, o.x, o.y, s.x, s.y, p.x, p.y) && Eg(p.prev, p, p.next) >= 0) return !1;
                p = p.prevZ
            }
            for (; f && f.z <= d;) {
                if (f !== t.prev && f !== t.next && xg(i.x, i.y, o.x, o.y, s.x, s.y, f.x, f.y) && Eg(f.prev, f, f.next) >= 0) return !1;
                f = f.nextZ
            }
            return !0
        }

        function pg(t, e, n) {
            let r = t;
            do {
                const i = r.prev,
                    o = r.next.next;
                !Tg(i, o) && Sg(i, r, r.next, o) && Ag(i, o) && Ag(o, i) && (e.push(i.i / n), e.push(r.i / n), e.push(o.i / n), Ig(r), Ig(r.next), r = t = o), r = r.next
            } while (r !== t);
            return ug(r)
        }

        function fg(t, e, n, r, i, o) {
            let s = t;
            do {
                let t = s.next.next;
                for (; t !== s.prev;) {
                    if (s.i !== t.i && bg(s, t)) {
                        let a = Rg(s, t);
                        return s = ug(s, s.next), a = ug(a, a.next), hg(s, e, n, r, i, o), void hg(a, e, n, r, i, o)
                    }
                    t = t.next
                }
                s = s.next
            } while (s !== t)
        }

        function mg(t, e) {
            return t.x - e.x
        }

        function gg(t, e) {
            if (e = function(t, e) {
                    let n = e;
                    const r = t.x,
                        i = t.y;
                    let o, s = -1 / 0;
                    do {
                        if (i <= n.y && i >= n.next.y && n.next.y !== n.y) {
                            const t = n.x + (i - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                            if (t <= r && t > s) {
                                if (s = t, t === r) {
                                    if (i === n.y) return n;
                                    if (i === n.next.y) return n.next
                                }
                                o = n.x < n.next.x ? n : n.next
                            }
                        }
                        n = n.next
                    } while (n !== e);
                    if (!o) return null;
                    if (r === s) return o;
                    const a = o,
                        l = o.x,
                        u = o.y;
                    let h, c = 1 / 0;
                    n = o;
                    do {
                        r >= n.x && n.x >= l && r !== n.x && xg(i < u ? r : s, i, l, u, i < u ? s : r, i, n.x, n.y) && (h = Math.abs(i - n.y) / (r - n.x), Ag(n, t) && (h < c || h === c && (n.x > o.x || n.x === o.x && vg(o, n))) && (o = n, c = h)), n = n.next
                    } while (n !== a);
                    return o
                }(t, e)) {
                const n = Rg(e, t);
                ug(e, e.next), ug(n, n.next)
            }
        }

        function vg(t, e) {
            return Eg(t.prev, t, e.prev) < 0 && Eg(e.next, t, t.next) < 0
        }

        function _g(t, e, n, r, i) {
            return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
        }

        function yg(t) {
            let e = t,
                n = t;
            do {
                (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
            } while (e !== t);
            return n
        }

        function xg(t, e, n, r, i, o, s, a) {
            return (i - s) * (e - a) - (t - s) * (o - a) >= 0 && (t - s) * (r - a) - (n - s) * (e - a) >= 0 && (n - s) * (o - a) - (i - s) * (r - a) >= 0
        }

        function bg(t, e) {
            return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                let n = t;
                do {
                    if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Sg(n, n.next, t, e)) return !0;
                    n = n.next
                } while (n !== t);
                return !1
            }(t, e) && (Ag(t, e) && Ag(e, t) && function(t, e) {
                let n = t,
                    r = !1;
                const i = (t.x + e.x) / 2,
                    o = (t.y + e.y) / 2;
                do {
                    n.y > o != n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next
                } while (n !== t);
                return r
            }(t, e) && (Eg(t.prev, t, e.prev) || Eg(t, e.prev, e)) || Tg(t, e) && Eg(t.prev, t, t.next) > 0 && Eg(e.prev, e, e.next) > 0)
        }

        function Eg(t, e, n) {
            return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
        }

        function Tg(t, e) {
            return t.x === e.x && t.y === e.y
        }

        function Sg(t, e, n, r) {
            const i = Mg(Eg(t, e, n)),
                o = Mg(Eg(t, e, r)),
                s = Mg(Eg(n, r, t)),
                a = Mg(Eg(n, r, e));
            return i !== o && s !== a || !(0 !== i || !wg(t, n, e)) || !(0 !== o || !wg(t, r, e)) || !(0 !== s || !wg(n, t, r)) || !(0 !== a || !wg(n, e, r))
        }

        function wg(t, e, n) {
            return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
        }

        function Mg(t) {
            return t > 0 ? 1 : t < 0 ? -1 : 0
        }

        function Ag(t, e) {
            return Eg(t.prev, t, t.next) < 0 ? Eg(t, e, t.next) >= 0 && Eg(t, t.prev, e) >= 0 : Eg(t, e, t.prev) < 0 || Eg(t, t.next, e) < 0
        }

        function Rg(t, e) {
            const n = new Cg(t.i, t.x, t.y),
                r = new Cg(e.i, e.x, e.y),
                i = t.next,
                o = e.prev;
            return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r
        }

        function Pg(t, e, n, r) {
            const i = new Cg(t, e, n);
            return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
        }

        function Ig(t) {
            t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }

        function Cg(t, e, n) {
            this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
        }
        class Og {
            static area(t) {
                const e = t.length;
                let n = 0;
                for (let r = e - 1, i = 0; i < e; r = i++) n += t[r].x * t[i].y - t[i].x * t[r].y;
                return .5 * n
            }
            static isClockWise(t) {
                return Og.area(t) < 0
            }
            static triangulateShape(t, e) {
                const n = [],
                    r = [],
                    i = [];
                Lg(t), Ng(n, t);
                let o = t.length;
                e.forEach(Lg);
                for (let t = 0; t < e.length; t++) r.push(o), o += e[t].length, Ng(n, e[t]);
                const s = function(t, e, n = 2) {
                    const r = e && e.length,
                        i = r ? e[0] * n : t.length;
                    let o = lg(t, 0, i, n, !0);
                    const s = [];
                    if (!o || o.next === o.prev) return s;
                    let a, l, u, h, c, d, p;
                    if (r && (o = function(t, e, n, r) {
                            const i = [];
                            let o, s, a, l, u;
                            for (o = 0, s = e.length; o < s; o++) a = e[o] * r, l = o < s - 1 ? e[o + 1] * r : t.length, u = lg(t, a, l, r, !1), u === u.next && (u.steiner = !0), i.push(yg(u));
                            for (i.sort(mg), o = 0; o < i.length; o++) gg(i[o], n), n = ug(n, n.next);
                            return n
                        }(t, e, o, n)), t.length > 80 * n) {
                        a = u = t[0], l = h = t[1];
                        for (let e = n; e < i; e += n) c = t[e], d = t[e + 1], c < a && (a = c), d < l && (l = d), c > u && (u = c), d > h && (h = d);
                        p = Math.max(u - a, h - l), p = 0 !== p ? 1 / p : 0
                    }
                    return hg(o, s, n, a, l, p), s
                }(n, r);
                for (let t = 0; t < s.length; t += 3) i.push(s.slice(t, t + 3));
                return i
            }
        }

        function Lg(t) {
            const e = t.length;
            e > 2 && t[e - 1].equals(t[0]) && t.pop()
        }

        function Ng(t, e) {
            for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
        }
        class Dg extends Ac {
            constructor(t = new ag([new wu(.5, .5), new wu(-.5, .5), new wu(-.5, -.5), new wu(.5, -.5)]), e = {}) {
                super(), this.type = "ExtrudeGeometry", this.parameters = {
                    shapes: t,
                    options: e
                }, t = Array.isArray(t) ? t : [t];
                const n = this,
                    r = [],
                    i = [];
                for (let e = 0, n = t.length; e < n; e++) o(t[e]);

                function o(t) {
                    const o = [],
                        s = void 0 !== e.curveSegments ? e.curveSegments : 12,
                        a = void 0 !== e.steps ? e.steps : 1;
                    let l = void 0 !== e.depth ? e.depth : 1,
                        u = void 0 === e.bevelEnabled || e.bevelEnabled,
                        h = void 0 !== e.bevelThickness ? e.bevelThickness : .2,
                        c = void 0 !== e.bevelSize ? e.bevelSize : h - .1,
                        d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                        p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                    const f = e.extrudePath,
                        m = void 0 !== e.UVGenerator ? e.UVGenerator : Ug;
                    void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = e.amount);
                    let g, v, _, y, x, b = !1;
                    f && (g = f.getSpacedPoints(a), b = !0, u = !1, v = f.computeFrenetFrames(a, !1), _ = new Ju, y = new Ju, x = new Ju), u || (p = 0, h = 0, c = 0, d = 0);
                    const E = t.extractPoints(s);
                    let T = E.shape;
                    const S = E.holes;
                    if (!Og.isClockWise(T)) {
                        T = T.reverse();
                        for (let t = 0, e = S.length; t < e; t++) {
                            const e = S[t];
                            Og.isClockWise(e) && (S[t] = e.reverse())
                        }
                    }
                    const w = Og.triangulateShape(T, S),
                        M = T;
                    for (let t = 0, e = S.length; t < e; t++) {
                        const e = S[t];
                        T = T.concat(e)
                    }

                    function A(t, e, n) {
                        return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t)
                    }
                    const R = T.length,
                        P = w.length;

                    function I(t, e, n) {
                        let r, i, o;
                        const s = t.x - e.x,
                            a = t.y - e.y,
                            l = n.x - t.x,
                            u = n.y - t.y,
                            h = s * s + a * a,
                            c = s * u - a * l;
                        if (Math.abs(c) > Number.EPSILON) {
                            const c = Math.sqrt(h),
                                d = Math.sqrt(l * l + u * u),
                                p = e.x - a / c,
                                f = e.y + s / c,
                                m = ((n.x - u / d - p) * u - (n.y + l / d - f) * l) / (s * u - a * l);
                            r = p + s * m - t.x, i = f + a * m - t.y;
                            const g = r * r + i * i;
                            if (g <= 2) return new wu(r, i);
                            o = Math.sqrt(g / 2)
                        } else {
                            let t = !1;
                            s > Number.EPSILON ? l > Number.EPSILON && (t = !0) : s < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(u) && (t = !0), t ? (r = -a, i = s, o = Math.sqrt(h)) : (r = s, i = a, o = Math.sqrt(h / 2))
                        }
                        return new wu(r / o, i / o)
                    }
                    const C = [];
                    for (let t = 0, e = M.length, n = e - 1, r = t + 1; t < e; t++, n++, r++) n === e && (n = 0), r === e && (r = 0), C[t] = I(M[t], M[n], M[r]);
                    const O = [];
                    let L, N = C.concat();
                    for (let t = 0, e = S.length; t < e; t++) {
                        const e = S[t];
                        L = [];
                        for (let t = 0, n = e.length, r = n - 1, i = t + 1; t < n; t++, r++, i++) r === n && (r = 0), i === n && (i = 0), L[t] = I(e[t], e[r], e[i]);
                        O.push(L), N = N.concat(L)
                    }
                    for (let t = 0; t < p; t++) {
                        const e = t / p,
                            n = h * Math.cos(e * Math.PI / 2),
                            r = c * Math.sin(e * Math.PI / 2) + d;
                        for (let t = 0, e = M.length; t < e; t++) {
                            const e = A(M[t], C[t], r);
                            F(e.x, e.y, -n)
                        }
                        for (let t = 0, e = S.length; t < e; t++) {
                            const e = S[t];
                            L = O[t];
                            for (let t = 0, i = e.length; t < i; t++) {
                                const i = A(e[t], L[t], r);
                                F(i.x, i.y, -n)
                            }
                        }
                    }
                    const D = c + d;
                    for (let t = 0; t < R; t++) {
                        const e = u ? A(T[t], N[t], D) : T[t];
                        b ? (y.copy(v.normals[0]).multiplyScalar(e.x), _.copy(v.binormals[0]).multiplyScalar(e.y), x.copy(g[0]).add(y).add(_), F(x.x, x.y, x.z)) : F(e.x, e.y, 0)
                    }
                    for (let t = 1; t <= a; t++)
                        for (let e = 0; e < R; e++) {
                            const n = u ? A(T[e], N[e], D) : T[e];
                            b ? (y.copy(v.normals[t]).multiplyScalar(n.x), _.copy(v.binormals[t]).multiplyScalar(n.y), x.copy(g[t]).add(y).add(_), F(x.x, x.y, x.z)) : F(n.x, n.y, l / a * t)
                        }
                    for (let t = p - 1; t >= 0; t--) {
                        const e = t / p,
                            n = h * Math.cos(e * Math.PI / 2),
                            r = c * Math.sin(e * Math.PI / 2) + d;
                        for (let t = 0, e = M.length; t < e; t++) {
                            const e = A(M[t], C[t], r);
                            F(e.x, e.y, l + n)
                        }
                        for (let t = 0, e = S.length; t < e; t++) {
                            const e = S[t];
                            L = O[t];
                            for (let t = 0, i = e.length; t < i; t++) {
                                const i = A(e[t], L[t], r);
                                b ? F(i.x, i.y + g[a - 1].y, g[a - 1].x + n) : F(i.x, i.y, l + n)
                            }
                        }
                    }

                    function U(t, e) {
                        let n = t.length;
                        for (; --n >= 0;) {
                            const r = n;
                            let i = n - 1;
                            i < 0 && (i = t.length - 1);
                            for (let t = 0, n = a + 2 * p; t < n; t++) {
                                const n = R * t,
                                    o = R * (t + 1);
                                k(e + r + n, e + i + n, e + i + o, e + r + o)
                            }
                        }
                    }

                    function F(t, e, n) {
                        o.push(t), o.push(e), o.push(n)
                    }

                    function B(t, e, i) {
                        G(t), G(e), G(i);
                        const o = r.length / 3,
                            s = m.generateTopUV(n, r, o - 3, o - 2, o - 1);
                        H(s[0]), H(s[1]), H(s[2])
                    }

                    function k(t, e, i, o) {
                        G(t), G(e), G(o), G(e), G(i), G(o);
                        const s = r.length / 3,
                            a = m.generateSideWallUV(n, r, s - 6, s - 3, s - 2, s - 1);
                        H(a[0]), H(a[1]), H(a[3]), H(a[1]), H(a[2]), H(a[3])
                    }

                    function G(t) {
                        r.push(o[3 * t + 0]), r.push(o[3 * t + 1]), r.push(o[3 * t + 2])
                    }

                    function H(t) {
                        i.push(t.x), i.push(t.y)
                    }! function() {
                        const t = r.length / 3;
                        if (u) {
                            let t = 0,
                                e = R * t;
                            for (let t = 0; t < P; t++) {
                                const n = w[t];
                                B(n[2] + e, n[1] + e, n[0] + e)
                            }
                            t = a + 2 * p, e = R * t;
                            for (let t = 0; t < P; t++) {
                                const n = w[t];
                                B(n[0] + e, n[1] + e, n[2] + e)
                            }
                        } else {
                            for (let t = 0; t < P; t++) {
                                const e = w[t];
                                B(e[2], e[1], e[0])
                            }
                            for (let t = 0; t < P; t++) {
                                const e = w[t];
                                B(e[0] + R * a, e[1] + R * a, e[2] + R * a)
                            }
                        }
                        n.addGroup(t, r.length / 3 - t, 0)
                    }(),
                    function() {
                        const t = r.length / 3;
                        let e = 0;
                        U(M, e), e += M.length;
                        for (let t = 0, n = S.length; t < n; t++) {
                            const n = S[t];
                            U(n, e), e += n.length
                        }
                        n.addGroup(t, r.length / 3 - t, 1)
                    }()
                }
                this.setAttribute("position", new yc(r, 3)), this.setAttribute("uv", new yc(i, 2)), this.computeVertexNormals()
            }
            toJSON() {
                const t = super.toJSON();
                return function(t, e, n) {
                    if (n.shapes = [], Array.isArray(t))
                        for (let e = 0, r = t.length; e < r; e++) {
                            const r = t[e];
                            n.shapes.push(r.uuid)
                        } else n.shapes.push(t.uuid);
                    return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n
                }(this.parameters.shapes, this.parameters.options, t)
            }
            static fromJSON(t, e) {
                const n = [];
                for (let r = 0, i = t.shapes.length; r < i; r++) {
                    const i = e[t.shapes[r]];
                    n.push(i)
                }
                const r = t.options.extrudePath;
                return void 0 !== r && (t.options.extrudePath = (new rg[r.type]).fromJSON(r)), new Dg(n, t.options)
            }
        }
        const Ug = {
            generateTopUV: function(t, e, n, r, i) {
                const o = e[3 * n],
                    s = e[3 * n + 1],
                    a = e[3 * r],
                    l = e[3 * r + 1],
                    u = e[3 * i],
                    h = e[3 * i + 1];
                return [new wu(o, s), new wu(a, l), new wu(u, h)]
            },
            generateSideWallUV: function(t, e, n, r, i, o) {
                const s = e[3 * n],
                    a = e[3 * n + 1],
                    l = e[3 * n + 2],
                    u = e[3 * r],
                    h = e[3 * r + 1],
                    c = e[3 * r + 2],
                    d = e[3 * i],
                    p = e[3 * i + 1],
                    f = e[3 * i + 2],
                    m = e[3 * o],
                    g = e[3 * o + 1],
                    v = e[3 * o + 2];
                return Math.abs(a - h) < Math.abs(s - u) ? [new wu(s, 1 - l), new wu(u, 1 - c), new wu(d, 1 - f), new wu(m, 1 - v)] : [new wu(a, 1 - l), new wu(h, 1 - c), new wu(p, 1 - f), new wu(g, 1 - v)]
            }
        };
        class Fg extends Ac {
            constructor(t = new ag([new wu(0, .5), new wu(-.5, -.5), new wu(.5, -.5)]), e = 12) {
                super(), this.type = "ShapeGeometry", this.parameters = {
                    shapes: t,
                    curveSegments: e
                };
                const n = [],
                    r = [],
                    i = [],
                    o = [];
                let s = 0,
                    a = 0;
                if (!1 === Array.isArray(t)) l(t);
                else
                    for (let e = 0; e < t.length; e++) l(t[e]), this.addGroup(s, a, e), s += a, a = 0;

                function l(t) {
                    const s = r.length / 3,
                        l = t.extractPoints(e);
                    let u = l.shape;
                    const h = l.holes;
                    !1 === Og.isClockWise(u) && (u = u.reverse());
                    for (let t = 0, e = h.length; t < e; t++) {
                        const e = h[t];
                        !0 === Og.isClockWise(e) && (h[t] = e.reverse())
                    }
                    const c = Og.triangulateShape(u, h);
                    for (let t = 0, e = h.length; t < e; t++) {
                        const e = h[t];
                        u = u.concat(e)
                    }
                    for (let t = 0, e = u.length; t < e; t++) {
                        const e = u[t];
                        r.push(e.x, e.y, 0), i.push(0, 0, 1), o.push(e.x, e.y)
                    }
                    for (let t = 0, e = c.length; t < e; t++) {
                        const e = c[t],
                            r = e[0] + s,
                            i = e[1] + s,
                            o = e[2] + s;
                        n.push(r, i, o), a += 3
                    }
                }
                this.setIndex(n), this.setAttribute("position", new yc(r, 3)), this.setAttribute("normal", new yc(i, 3)), this.setAttribute("uv", new yc(o, 2))
            }
            toJSON() {
                const t = super.toJSON();
                return function(t, e) {
                    if (e.shapes = [], Array.isArray(t))
                        for (let n = 0, r = t.length; n < r; n++) {
                            const r = t[n];
                            e.shapes.push(r.uuid)
                        } else e.shapes.push(t.uuid);
                    return e
                }(this.parameters.shapes, t)
            }
            static fromJSON(t, e) {
                const n = [];
                for (let r = 0, i = t.shapes.length; r < i; r++) {
                    const i = e[t.shapes[r]];
                    n.push(i)
                }
                return new Fg(n, t.curveSegments)
            }
        }
        class Bg extends Ac {
            constructor(t = 1, e = 32, n = 16, r = 0, i = 2 * Math.PI, o = 0, s = Math.PI) {
                super(), this.type = "SphereGeometry", this.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: n,
                    phiStart: r,
                    phiLength: i,
                    thetaStart: o,
                    thetaLength: s
                }, e = Math.max(3, Math.floor(e)), n = Math.max(2, Math.floor(n));
                const a = Math.min(o + s, Math.PI);
                let l = 0;
                const u = [],
                    h = new Ju,
                    c = new Ju,
                    d = [],
                    p = [],
                    f = [],
                    m = [];
                for (let d = 0; d <= n; d++) {
                    const g = [],
                        v = d / n;
                    let _ = 0;
                    0 == d && 0 == o ? _ = .5 / e : d == n && a == Math.PI && (_ = -.5 / e);
                    for (let n = 0; n <= e; n++) {
                        const a = n / e;
                        h.x = -t * Math.cos(r + a * i) * Math.sin(o + v * s), h.y = t * Math.cos(o + v * s), h.z = t * Math.sin(r + a * i) * Math.sin(o + v * s), p.push(h.x, h.y, h.z), c.copy(h).normalize(), f.push(c.x, c.y, c.z), m.push(a + _, 1 - v), g.push(l++)
                    }
                    u.push(g)
                }
                for (let t = 0; t < n; t++)
                    for (let r = 0; r < e; r++) {
                        const e = u[t][r + 1],
                            i = u[t][r],
                            s = u[t + 1][r],
                            l = u[t + 1][r + 1];
                        (0 !== t || o > 0) && d.push(e, i, l), (t !== n - 1 || a < Math.PI) && d.push(i, s, l)
                    }
                this.setIndex(d), this.setAttribute("position", new yc(p, 3)), this.setAttribute("normal", new yc(f, 3)), this.setAttribute("uv", new yc(m, 2))
            }
            static fromJSON(t) {
                return new Bg(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength)
            }
        }
        class kg extends Ac {
            constructor(t = 1, e = .4, n = 8, r = 6, i = 2 * Math.PI) {
                super(), this.type = "TorusGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: n,
                    tubularSegments: r,
                    arc: i
                }, n = Math.floor(n), r = Math.floor(r);
                const o = [],
                    s = [],
                    a = [],
                    l = [],
                    u = new Ju,
                    h = new Ju,
                    c = new Ju;
                for (let o = 0; o <= n; o++)
                    for (let d = 0; d <= r; d++) {
                        const p = d / r * i,
                            f = o / n * Math.PI * 2;
                        h.x = (t + e * Math.cos(f)) * Math.cos(p), h.y = (t + e * Math.cos(f)) * Math.sin(p), h.z = e * Math.sin(f), s.push(h.x, h.y, h.z), u.x = t * Math.cos(p), u.y = t * Math.sin(p), c.subVectors(h, u).normalize(), a.push(c.x, c.y, c.z), l.push(d / r), l.push(o / n)
                    }
                for (let t = 1; t <= n; t++)
                    for (let e = 1; e <= r; e++) {
                        const n = (r + 1) * t + e - 1,
                            i = (r + 1) * (t - 1) + e - 1,
                            s = (r + 1) * (t - 1) + e,
                            a = (r + 1) * t + e;
                        o.push(n, i, a), o.push(i, s, a)
                    }
                this.setIndex(o), this.setAttribute("position", new yc(s, 3)), this.setAttribute("normal", new yc(a, 3)), this.setAttribute("uv", new yc(l, 2))
            }
            static fromJSON(t) {
                return new kg(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.arc)
            }
        }
        class Gg extends dc {
            constructor(t) {
                super(), this.type = "ShadowMaterial", this.color = new ku(0), this.transparent = !0, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.color.copy(t.color), this
            }
        }
        Gg.prototype.isShadowMaterial = !0;
        class Hg extends Jc {
            constructor(t) {
                super(t), this.type = "RawShaderMaterial"
            }
        }
        Hg.prototype.isRawShaderMaterial = !0;
        class zg extends dc {
            constructor(t) {
                super(), this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new ku(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ku(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new wu(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.defines = {
                    STANDARD: ""
                }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this
            }
        }
        zg.prototype.isMeshStandardMaterial = !0;
        class Vg extends zg {
            constructor(t) {
                super(), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new wu(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                    get: function() {
                        return yu(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                    },
                    set: function(t) {
                        this.ior = (1 + .4 * t) / (1 - .4 * t)
                    }
                }), this.sheenColor = new ku(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new ku(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new ku(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(t)
            }
            get sheen() {
                return this._sheen
            }
            set sheen(t) {
                this._sheen > 0 != t > 0 && this.version++, this._sheen = t
            }
            get clearcoat() {
                return this._clearcoat
            }
            set clearcoat(t) {
                this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t
            }
            get transmission() {
                return this._transmission
            }
            set transmission(t) {
                this._transmission > 0 != t > 0 && this.version++, this._transmission = t
            }
            copy(t) {
                return super.copy(t), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this
            }
        }
        Vg.prototype.isMeshPhysicalMaterial = !0;
        class Wg extends dc {
            constructor(t) {
                super(), this.type = "MeshPhongMaterial", this.color = new ku(16777215), this.specular = new ku(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ku(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new wu(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this
            }
        }
        Wg.prototype.isMeshPhongMaterial = !0;
        class Xg extends dc {
            constructor(t) {
                super(), this.defines = {
                    TOON: ""
                }, this.type = "MeshToonMaterial", this.color = new ku(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ku(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new wu(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
            }
        }
        Xg.prototype.isMeshToonMaterial = !0;
        class jg extends dc {
            constructor(t) {
                super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new wu(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.flatShading = t.flatShading, this
            }
        }
        jg.prototype.isMeshNormalMaterial = !0;
        class Yg extends dc {
            constructor(t) {
                super(), this.type = "MeshLambertMaterial", this.color = new ku(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ku(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
            }
        }
        Yg.prototype.isMeshLambertMaterial = !0;
        class qg extends dc {
            constructor(t) {
                super(), this.defines = {
                    MATCAP: ""
                }, this.type = "MeshMatcapMaterial", this.color = new ku(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new wu(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.defines = {
                    MATCAP: ""
                }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.flatShading = t.flatShading, this
            }
        }
        qg.prototype.isMeshMatcapMaterial = !0;
        class Zg extends Tm {
            constructor(t) {
                super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
            }
        }
        Zg.prototype.isLineDashedMaterial = !0;
        const Kg = {
            ShadowMaterial: Gg,
            SpriteMaterial: Kf,
            RawShaderMaterial: Hg,
            ShaderMaterial: Jc,
            PointsMaterial: Lm,
            MeshPhysicalMaterial: Vg,
            MeshStandardMaterial: zg,
            MeshPhongMaterial: Wg,
            MeshToonMaterial: Xg,
            MeshNormalMaterial: jg,
            MeshLambertMaterial: Yg,
            MeshDepthMaterial: If,
            MeshDistanceMaterial: Cf,
            MeshBasicMaterial: pc,
            MeshMatcapMaterial: qg,
            LineDashedMaterial: Zg,
            LineBasicMaterial: Tm,
            Material: dc
        };
        dc.fromType = function(t) {
            return new Kg[t]
        };
        const Jg = {
            arraySlice: function(t, e, n) {
                return Jg.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
            },
            convertArray: function(t, e, n) {
                return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
            },
            isTypedArray: function(t) {
                return ArrayBuffer.isView(t) && !(t instanceof DataView)
            },
            getKeyframeOrder: function(t) {
                const e = t.length,
                    n = new Array(e);
                for (let t = 0; t !== e; ++t) n[t] = t;
                return n.sort((function(e, n) {
                    return t[e] - t[n]
                })), n
            },
            sortedArray: function(t, e, n) {
                const r = t.length,
                    i = new t.constructor(r);
                for (let o = 0, s = 0; s !== r; ++o) {
                    const r = n[o] * e;
                    for (let n = 0; n !== e; ++n) i[s++] = t[r + n]
                }
                return i
            },
            flattenJSON: function(t, e, n, r) {
                let i = 1,
                    o = t[0];
                for (; void 0 !== o && void 0 === o[r];) o = t[i++];
                if (void 0 === o) return;
                let s = o[r];
                if (void 0 !== s)
                    if (Array.isArray(s))
                        do {
                            s = o[r], void 0 !== s && (e.push(o.time), n.push.apply(n, s)), o = t[i++]
                        } while (void 0 !== o);
                    else if (void 0 !== s.toArray)
                    do {
                        s = o[r], void 0 !== s && (e.push(o.time), s.toArray(n, n.length)), o = t[i++]
                    } while (void 0 !== o);
                else
                    do {
                        s = o[r], void 0 !== s && (e.push(o.time), n.push(s)), o = t[i++]
                    } while (void 0 !== o)
            },
            subclip: function(t, e, n, r, i = 30) {
                const o = t.clone();
                o.name = e;
                const s = [];
                for (let t = 0; t < o.tracks.length; ++t) {
                    const e = o.tracks[t],
                        a = e.getValueSize(),
                        l = [],
                        u = [];
                    for (let t = 0; t < e.times.length; ++t) {
                        const o = e.times[t] * i;
                        if (!(o < n || o >= r)) {
                            l.push(e.times[t]);
                            for (let n = 0; n < a; ++n) u.push(e.values[t * a + n])
                        }
                    }
                    0 !== l.length && (e.times = Jg.convertArray(l, e.times.constructor), e.values = Jg.convertArray(u, e.values.constructor), s.push(e))
                }
                o.tracks = s;
                let a = 1 / 0;
                for (let t = 0; t < o.tracks.length; ++t) a > o.tracks[t].times[0] && (a = o.tracks[t].times[0]);
                for (let t = 0; t < o.tracks.length; ++t) o.tracks[t].shift(-1 * a);
                return o.resetDuration(), o
            },
            makeClipAdditive: function(t, e = 0, n = t, r = 30) {
                r <= 0 && (r = 30);
                const i = n.tracks.length,
                    o = e / r;
                for (let e = 0; e < i; ++e) {
                    const r = n.tracks[e],
                        i = r.ValueTypeName;
                    if ("bool" === i || "string" === i) continue;
                    const s = t.tracks.find((function(t) {
                        return t.name === r.name && t.ValueTypeName === i
                    }));
                    if (void 0 === s) continue;
                    let a = 0;
                    const l = r.getValueSize();
                    r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3);
                    let u = 0;
                    const h = s.getValueSize();
                    s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (u = h / 3);
                    const c = r.times.length - 1;
                    let d;
                    if (o <= r.times[0]) {
                        const t = a,
                            e = l - a;
                        d = Jg.arraySlice(r.values, t, e)
                    } else if (o >= r.times[c]) {
                        const t = c * l + a,
                            e = t + l - a;
                        d = Jg.arraySlice(r.values, t, e)
                    } else {
                        const t = r.createInterpolant(),
                            e = a,
                            n = l - a;
                        t.evaluate(o), d = Jg.arraySlice(t.resultBuffer, e, n)
                    }
                    "quaternion" === i && (new Ku).fromArray(d).normalize().conjugate().toArray(d);
                    const p = s.times.length;
                    for (let t = 0; t < p; ++t) {
                        const e = t * h + u;
                        if ("quaternion" === i) Ku.multiplyQuaternionsFlat(s.values, e, d, 0, s.values, e);
                        else {
                            const t = h - 2 * u;
                            for (let n = 0; n < t; ++n) s.values[e + n] -= d[n]
                        }
                    }
                }
                return t.blendMode = 2501, t
            }
        };
        class Qg {
            constructor(t, e, n, r) {
                this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
            }
            evaluate(t) {
                const e = this.parameterPositions;
                let n = this._cachedIndex,
                    r = e[n],
                    i = e[n - 1];
                t: {
                    e: {
                        let o;n: {
                            r: if (!(t < r)) {
                                for (let o = n + 2;;) {
                                    if (void 0 === r) {
                                        if (t < i) break r;
                                        return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, i)
                                    }
                                    if (n === o) break;
                                    if (i = r, r = e[++n], t < r) break e
                                }
                                o = e.length;
                                break n
                            }if (t >= i) break t; {
                                const s = e[1];
                                t < s && (n = 2, i = s);
                                for (let o = n - 2;;) {
                                    if (void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
                                    if (n === o) break;
                                    if (r = i, i = e[--n - 1], t >= i) break e
                                }
                                o = n, n = 0
                            }
                        }
                        for (; n < o;) {
                            const r = n + o >>> 1;
                            t < e[r] ? o = r : n = r + 1
                        }
                        if (r = e[n], i = e[n - 1], void 0 === i) return this._cachedIndex = 0,
                        this.beforeStart_(0, t, r);
                        if (void 0 === r) return n = e.length,
                        this._cachedIndex = n,
                        this.afterEnd_(n - 1, i, t)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, i, r)
                }
                return this.interpolate_(n, i, t, r)
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_
            }
            copySampleValue_(t) {
                const e = this.resultBuffer,
                    n = this.sampleValues,
                    r = this.valueSize,
                    i = t * r;
                for (let t = 0; t !== r; ++t) e[t] = n[i + t];
                return e
            }
            interpolate_() {
                throw new Error("call to abstract method")
            }
            intervalChanged_() {}
        }
        Qg.prototype.beforeStart_ = Qg.prototype.copySampleValue_, Qg.prototype.afterEnd_ = Qg.prototype.copySampleValue_;
        class $g extends Qg {
            constructor(t, e, n, r) {
                super(t, e, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                    endingStart: eu,
                    endingEnd: eu
                }
            }
            intervalChanged_(t, e, n) {
                const r = this.parameterPositions;
                let i = t - 2,
                    o = t + 1,
                    s = r[i],
                    a = r[o];
                if (void 0 === s) switch (this.getSettings_().endingStart) {
                    case nu:
                        i = t, s = 2 * e - n;
                        break;
                    case ru:
                        i = r.length - 2, s = e + r[i] - r[i + 1];
                        break;
                    default:
                        i = t, s = n
                }
                if (void 0 === a) switch (this.getSettings_().endingEnd) {
                    case nu:
                        o = t, a = 2 * n - e;
                        break;
                    case ru:
                        o = 1, a = n + r[1] - r[0];
                        break;
                    default:
                        o = t - 1, a = e
                }
                const l = .5 * (n - e),
                    u = this.valueSize;
                this._weightPrev = l / (e - s), this._weightNext = l / (a - n), this._offsetPrev = i * u, this._offsetNext = o * u
            }
            interpolate_(t, e, n, r) {
                const i = this.resultBuffer,
                    o = this.sampleValues,
                    s = this.valueSize,
                    a = t * s,
                    l = a - s,
                    u = this._offsetPrev,
                    h = this._offsetNext,
                    c = this._weightPrev,
                    d = this._weightNext,
                    p = (n - e) / (r - e),
                    f = p * p,
                    m = f * p,
                    g = -c * m + 2 * c * f - c * p,
                    v = (1 + c) * m + (-1.5 - 2 * c) * f + (-.5 + c) * p + 1,
                    _ = (-1 - d) * m + (1.5 + d) * f + .5 * p,
                    y = d * m - d * f;
                for (let t = 0; t !== s; ++t) i[t] = g * o[u + t] + v * o[l + t] + _ * o[a + t] + y * o[h + t];
                return i
            }
        }
        class tv extends Qg {
            constructor(t, e, n, r) {
                super(t, e, n, r)
            }
            interpolate_(t, e, n, r) {
                const i = this.resultBuffer,
                    o = this.sampleValues,
                    s = this.valueSize,
                    a = t * s,
                    l = a - s,
                    u = (n - e) / (r - e),
                    h = 1 - u;
                for (let t = 0; t !== s; ++t) i[t] = o[l + t] * h + o[a + t] * u;
                return i
            }
        }
        class ev extends Qg {
            constructor(t, e, n, r) {
                super(t, e, n, r)
            }
            interpolate_(t) {
                return this.copySampleValue_(t - 1)
            }
        }
        class nv {
            constructor(t, e, n, r) {
                if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t, this.times = Jg.convertArray(e, this.TimeBufferType), this.values = Jg.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
            }
            static toJSON(t) {
                const e = t.constructor;
                let n;
                if (e.toJSON !== this.toJSON) n = e.toJSON(t);
                else {
                    n = {
                        name: t.name,
                        times: Jg.convertArray(t.times, Array),
                        values: Jg.convertArray(t.values, Array)
                    };
                    const e = t.getInterpolation();
                    e !== t.DefaultInterpolation && (n.interpolation = e)
                }
                return n.type = t.ValueTypeName, n
            }
            InterpolantFactoryMethodDiscrete(t) {
                return new ev(this.times, this.values, this.getValueSize(), t)
            }
            InterpolantFactoryMethodLinear(t) {
                return new tv(this.times, this.values, this.getValueSize(), t)
            }
            InterpolantFactoryMethodSmooth(t) {
                return new $g(this.times, this.values, this.getValueSize(), t)
            }
            setInterpolation(t) {
                let e;
                switch (t) {
                    case Ql:
                        e = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case $l:
                        e = this.InterpolantFactoryMethodLinear;
                        break;
                    case tu:
                        e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === e) {
                    const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation) throw new Error(e);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", e), this
                }
                return this.createInterpolant = e, this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return Ql;
                    case this.InterpolantFactoryMethodLinear:
                        return $l;
                    case this.InterpolantFactoryMethodSmooth:
                        return tu
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(t) {
                if (0 !== t) {
                    const e = this.times;
                    for (let n = 0, r = e.length; n !== r; ++n) e[n] += t
                }
                return this
            }
            scale(t) {
                if (1 !== t) {
                    const e = this.times;
                    for (let n = 0, r = e.length; n !== r; ++n) e[n] *= t
                }
                return this
            }
            trim(t, e) {
                const n = this.times,
                    r = n.length;
                let i = 0,
                    o = r - 1;
                for (; i !== r && n[i] < t;) ++i;
                for (; - 1 !== o && n[o] > e;) --o;
                if (++o, 0 !== i || o !== r) {
                    i >= o && (o = Math.max(o, 1), i = o - 1);
                    const t = this.getValueSize();
                    this.times = Jg.arraySlice(n, i, o), this.values = Jg.arraySlice(this.values, i * t, o * t)
                }
                return this
            }
            validate() {
                let t = !0;
                const e = this.getValueSize();
                e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                const n = this.times,
                    r = this.values,
                    i = n.length;
                0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                let o = null;
                for (let e = 0; e !== i; e++) {
                    const r = n[e];
                    if ("number" == typeof r && isNaN(r)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, r), t = !1;
                        break
                    }
                    if (null !== o && o > r) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, e, r, o), t = !1;
                        break
                    }
                    o = r
                }
                if (void 0 !== r && Jg.isTypedArray(r))
                    for (let e = 0, n = r.length; e !== n; ++e) {
                        const n = r[e];
                        if (isNaN(n)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1;
                            break
                        }
                    }
                return t
            }
            optimize() {
                const t = Jg.arraySlice(this.times),
                    e = Jg.arraySlice(this.values),
                    n = this.getValueSize(),
                    r = this.getInterpolation() === tu,
                    i = t.length - 1;
                let o = 1;
                for (let s = 1; s < i; ++s) {
                    let i = !1;
                    const a = t[s];
                    if (a !== t[s + 1] && (1 !== s || a !== t[0]))
                        if (r) i = !0;
                        else {
                            const t = s * n,
                                r = t - n,
                                o = t + n;
                            for (let s = 0; s !== n; ++s) {
                                const n = e[t + s];
                                if (n !== e[r + s] || n !== e[o + s]) {
                                    i = !0;
                                    break
                                }
                            }
                        } if (i) {
                        if (s !== o) {
                            t[o] = t[s];
                            const r = s * n,
                                i = o * n;
                            for (let t = 0; t !== n; ++t) e[i + t] = e[r + t]
                        }++o
                    }
                }
                if (i > 0) {
                    t[o] = t[i];
                    for (let t = i * n, r = o * n, s = 0; s !== n; ++s) e[r + s] = e[t + s];
                    ++o
                }
                return o !== t.length ? (this.times = Jg.arraySlice(t, 0, o), this.values = Jg.arraySlice(e, 0, o * n)) : (this.times = t, this.values = e), this
            }
            clone() {
                const t = Jg.arraySlice(this.times, 0),
                    e = Jg.arraySlice(this.values, 0),
                    n = new(0, this.constructor)(this.name, t, e);
                return n.createInterpolant = this.createInterpolant, n
            }
        }
        nv.prototype.TimeBufferType = Float32Array, nv.prototype.ValueBufferType = Float32Array, nv.prototype.DefaultInterpolation = $l;
        class rv extends nv {}
        rv.prototype.ValueTypeName = "bool", rv.prototype.ValueBufferType = Array, rv.prototype.DefaultInterpolation = Ql, rv.prototype.InterpolantFactoryMethodLinear = void 0, rv.prototype.InterpolantFactoryMethodSmooth = void 0;
        class iv extends nv {}
        iv.prototype.ValueTypeName = "color";
        class ov extends nv {}
        ov.prototype.ValueTypeName = "number";
        class sv extends Qg {
            constructor(t, e, n, r) {
                super(t, e, n, r)
            }
            interpolate_(t, e, n, r) {
                const i = this.resultBuffer,
                    o = this.sampleValues,
                    s = this.valueSize,
                    a = (n - e) / (r - e);
                let l = t * s;
                for (let t = l + s; l !== t; l += 4) Ku.slerpFlat(i, 0, o, l - s, o, l, a);
                return i
            }
        }
        class av extends nv {
            InterpolantFactoryMethodLinear(t) {
                return new sv(this.times, this.values, this.getValueSize(), t)
            }
        }
        av.prototype.ValueTypeName = "quaternion", av.prototype.DefaultInterpolation = $l, av.prototype.InterpolantFactoryMethodSmooth = void 0;
        class lv extends nv {}
        lv.prototype.ValueTypeName = "string", lv.prototype.ValueBufferType = Array, lv.prototype.DefaultInterpolation = Ql, lv.prototype.InterpolantFactoryMethodLinear = void 0, lv.prototype.InterpolantFactoryMethodSmooth = void 0;
        class uv extends nv {}
        uv.prototype.ValueTypeName = "vector";
        class hv {
            constructor(t, e = -1, n, r = 2500) {
                this.name = t, this.tracks = n, this.duration = e, this.blendMode = r, this.uuid = _u(), this.duration < 0 && this.resetDuration()
            }
            static parse(t) {
                const e = [],
                    n = t.tracks,
                    r = 1 / (t.fps || 1);
                for (let t = 0, i = n.length; t !== i; ++t) e.push(cv(n[t]).scale(r));
                const i = new this(t.name, t.duration, e, t.blendMode);
                return i.uuid = t.uuid, i
            }
            static toJSON(t) {
                const e = [],
                    n = t.tracks,
                    r = {
                        name: t.name,
                        duration: t.duration,
                        tracks: e,
                        uuid: t.uuid,
                        blendMode: t.blendMode
                    };
                for (let t = 0, r = n.length; t !== r; ++t) e.push(nv.toJSON(n[t]));
                return r
            }
            static CreateFromMorphTargetSequence(t, e, n, r) {
                const i = e.length,
                    o = [];
                for (let t = 0; t < i; t++) {
                    let s = [],
                        a = [];
                    s.push((t + i - 1) % i, t, (t + 1) % i), a.push(0, 1, 0);
                    const l = Jg.getKeyframeOrder(s);
                    s = Jg.sortedArray(s, 1, l), a = Jg.sortedArray(a, 1, l), r || 0 !== s[0] || (s.push(i), a.push(a[0])), o.push(new ov(".morphTargetInfluences[" + e[t].name + "]", s, a).scale(1 / n))
                }
                return new this(t, -1, o)
            }
            static findByName(t, e) {
                let n = t;
                if (!Array.isArray(t)) {
                    const e = t;
                    n = e.geometry && e.geometry.animations || e.animations
                }
                for (let t = 0; t < n.length; t++)
                    if (n[t].name === e) return n[t];
                return null
            }
            static CreateClipsFromMorphTargetSequences(t, e, n) {
                const r = {},
                    i = /^([\w-]*?)([\d]+)$/;
                for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e],
                        o = n.name.match(i);
                    if (o && o.length > 1) {
                        const t = o[1];
                        let e = r[t];
                        e || (r[t] = e = []), e.push(n)
                    }
                }
                const o = [];
                for (const t in r) o.push(this.CreateFromMorphTargetSequence(t, r[t], e, n));
                return o
            }
            static parseAnimation(t, e) {
                if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                const n = function(t, e, n, r, i) {
                        if (0 !== n.length) {
                            const o = [],
                                s = [];
                            Jg.flattenJSON(n, o, s, r), 0 !== o.length && i.push(new t(e, o, s))
                        }
                    },
                    r = [],
                    i = t.name || "default",
                    o = t.fps || 30,
                    s = t.blendMode;
                let a = t.length || -1;
                const l = t.hierarchy || [];
                for (let t = 0; t < l.length; t++) {
                    const i = l[t].keys;
                    if (i && 0 !== i.length)
                        if (i[0].morphTargets) {
                            const t = {};
                            let e;
                            for (e = 0; e < i.length; e++)
                                if (i[e].morphTargets)
                                    for (let n = 0; n < i[e].morphTargets.length; n++) t[i[e].morphTargets[n]] = -1;
                            for (const n in t) {
                                const t = [],
                                    o = [];
                                for (let r = 0; r !== i[e].morphTargets.length; ++r) {
                                    const r = i[e];
                                    t.push(r.time), o.push(r.morphTarget === n ? 1 : 0)
                                }
                                r.push(new ov(".morphTargetInfluence[" + n + "]", t, o))
                            }
                            a = t.length * o
                        } else {
                            const o = ".bones[" + e[t].name + "]";
                            n(uv, o + ".position", i, "pos", r), n(av, o + ".quaternion", i, "rot", r), n(uv, o + ".scale", i, "scl", r)
                        }
                }
                return 0 === r.length ? null : new this(i, a, r, s)
            }
            resetDuration() {
                let t = 0;
                for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                    const n = this.tracks[e];
                    t = Math.max(t, n.times[n.times.length - 1])
                }
                return this.duration = t, this
            }
            trim() {
                for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                return this
            }
            validate() {
                let t = !0;
                for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                return t
            }
            optimize() {
                for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                return this
            }
            clone() {
                const t = [];
                for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                return new this.constructor(this.name, this.duration, t, this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }

        function cv(t) {
            if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const e = function(t) {
                switch (t.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return ov;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return uv;
                    case "color":
                        return iv;
                    case "quaternion":
                        return av;
                    case "bool":
                    case "boolean":
                        return rv;
                    case "string":
                        return lv
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
            }(t.type);
            if (void 0 === t.times) {
                const e = [],
                    n = [];
                Jg.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
            }
            return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
        }
        const dv = {
            enabled: !1,
            files: {},
            add: function(t, e) {
                !1 !== this.enabled && (this.files[t] = e)
            },
            get: function(t) {
                if (!1 !== this.enabled) return this.files[t]
            },
            remove: function(t) {
                delete this.files[t]
            },
            clear: function() {
                this.files = {}
            }
        };
        const pv = new class {
            constructor(t, e, n) {
                const r = this;
                let i, o = !1,
                    s = 0,
                    a = 0;
                const l = [];
                this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
                    a++, !1 === o && void 0 !== r.onStart && r.onStart(t, s, a), o = !0
                }, this.itemEnd = function(t) {
                    s++, void 0 !== r.onProgress && r.onProgress(t, s, a), s === a && (o = !1, void 0 !== r.onLoad && r.onLoad())
                }, this.itemError = function(t) {
                    void 0 !== r.onError && r.onError(t)
                }, this.resolveURL = function(t) {
                    return i ? i(t) : t
                }, this.setURLModifier = function(t) {
                    return i = t, this
                }, this.addHandler = function(t, e) {
                    return l.push(t, e), this
                }, this.removeHandler = function(t) {
                    const e = l.indexOf(t);
                    return -1 !== e && l.splice(e, 2), this
                }, this.getHandler = function(t) {
                    for (let e = 0, n = l.length; e < n; e += 2) {
                        const n = l[e],
                            r = l[e + 1];
                        if (n.global && (n.lastIndex = 0), n.test(t)) return r
                    }
                    return null
                }
            }
        };
        class fv {
            constructor(t) {
                this.manager = void 0 !== t ? t : pv, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
            }
            load() {}
            loadAsync(t, e) {
                const n = this;
                return new Promise((function(r, i) {
                    n.load(t, r, e, i)
                }))
            }
            parse() {}
            setCrossOrigin(t) {
                return this.crossOrigin = t, this
            }
            setWithCredentials(t) {
                return this.withCredentials = t, this
            }
            setPath(t) {
                return this.path = t, this
            }
            setResourcePath(t) {
                return this.resourcePath = t, this
            }
            setRequestHeader(t) {
                return this.requestHeader = t, this
            }
        }
        const mv = {};
        class gv extends fv {
            constructor(t) {
                super(t)
            }
            load(t, e, n, r) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                const i = dv.get(t);
                if (void 0 !== i) return this.manager.itemStart(t), setTimeout((() => {
                    e && e(i), this.manager.itemEnd(t)
                }), 0), i;
                if (void 0 !== mv[t]) return void mv[t].push({
                    onLoad: e,
                    onProgress: n,
                    onError: r
                });
                mv[t] = [], mv[t].push({
                    onLoad: e,
                    onProgress: n,
                    onError: r
                });
                const o = new Request(t, {
                        headers: new Headers(this.requestHeader),
                        credentials: this.withCredentials ? "include" : "same-origin"
                    }),
                    s = this.mimeType,
                    a = this.responseType;
                fetch(o).then((e => {
                    if (200 === e.status || 0 === e.status) {
                        if (0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === e.body || void 0 === e.body.getReader) return e;
                        const n = mv[t],
                            r = e.body.getReader(),
                            i = e.headers.get("Content-Length"),
                            o = i ? parseInt(i) : 0,
                            s = 0 !== o;
                        let a = 0;
                        const l = new ReadableStream({
                            start(t) {
                                ! function e() {
                                    r.read().then((({
                                        done: r,
                                        value: i
                                    }) => {
                                        if (r) t.close();
                                        else {
                                            a += i.byteLength;
                                            const r = new ProgressEvent("progress", {
                                                lengthComputable: s,
                                                loaded: a,
                                                total: o
                                            });
                                            for (let t = 0, e = n.length; t < e; t++) {
                                                const e = n[t];
                                                e.onProgress && e.onProgress(r)
                                            }
                                            t.enqueue(i), e()
                                        }
                                    }))
                                }()
                            }
                        });
                        return new Response(l)
                    }
                    throw Error(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`)
                })).then((t => {
                    switch (a) {
                        case "arraybuffer":
                            return t.arrayBuffer();
                        case "blob":
                            return t.blob();
                        case "document":
                            return t.text().then((t => (new DOMParser).parseFromString(t, s)));
                        case "json":
                            return t.json();
                        default:
                            if (void 0 === s) return t.text(); {
                                const e = /charset="?([^;"\s]*)"?/i.exec(s),
                                    n = e && e[1] ? e[1].toLowerCase() : void 0,
                                    r = new TextDecoder(n);
                                return t.arrayBuffer().then((t => r.decode(t)))
                            }
                    }
                })).then((e => {
                    dv.add(t, e);
                    const n = mv[t];
                    delete mv[t];
                    for (let t = 0, r = n.length; t < r; t++) {
                        const r = n[t];
                        r.onLoad && r.onLoad(e)
                    }
                })).catch((e => {
                    const n = mv[t];
                    if (void 0 === n) throw this.manager.itemError(t), e;
                    delete mv[t];
                    for (let t = 0, r = n.length; t < r; t++) {
                        const r = n[t];
                        r.onError && r.onError(e)
                    }
                    this.manager.itemError(t)
                })).finally((() => {
                    this.manager.itemEnd(t)
                })), this.manager.itemStart(t)
            }
            setResponseType(t) {
                return this.responseType = t, this
            }
            setMimeType(t) {
                return this.mimeType = t, this
            }
        }
        class vv extends fv {
            constructor(t) {
                super(t)
            }
            load(t, e, n, r) {
                void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                const i = this,
                    o = dv.get(t);
                if (void 0 !== o) return i.manager.itemStart(t), setTimeout((function() {
                    e && e(o), i.manager.itemEnd(t)
                }), 0), o;
                const s = Ru("img");

                function a() {
                    u(), dv.add(t, this), e && e(this), i.manager.itemEnd(t)
                }

                function l(e) {
                    u(), r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
                }

                function u() {
                    s.removeEventListener("load", a, !1), s.removeEventListener("error", l, !1)
                }
                return s.addEventListener("load", a, !1), s.addEventListener("error", l, !1), "data:" !== t.slice(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), i.manager.itemStart(t), s.src = t, s
            }
        }
        class _v extends fv {
            constructor(t) {
                super(t)
            }
            load(t, e, n, r) {
                const i = new nd,
                    o = new vv(this.manager);
                o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
                let s = 0;

                function a(n) {
                    o.load(t[n], (function(t) {
                        i.images[n] = t, s++, 6 === s && (i.needsUpdate = !0, e && e(i))
                    }), void 0, r)
                }
                for (let e = 0; e < t.length; ++e) a(e);
                return i
            }
        }
        class yv extends fv {
            constructor(t) {
                super(t)
            }
            load(t, e, n, r) {
                const i = new Xu,
                    o = new vv(this.manager);
                return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, (function(t) {
                    i.image = t, i.needsUpdate = !0, void 0 !== e && e(i)
                }), n, r), i
            }
        }
        class xv extends $h {
            constructor(t, e = 1) {
                super(), this.type = "Light", this.color = new ku(t), this.intensity = e
            }
            dispose() {}
            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.intensity = t.intensity, this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
            }
        }
        xv.prototype.isLight = !0;
        (class extends xv {
            constructor(t, e, n) {
                super(t, n), this.type = "HemisphereLight", this.position.copy($h.DefaultUp), this.updateMatrix(), this.groundColor = new ku(e)
            }
            copy(t) {
                return xv.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
            }
        }).prototype.isHemisphereLight = !0;
        const bv = new Rh,
            Ev = new Ju,
            Tv = new Ju;
        class Sv {
            constructor(t) {
                this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new wu(512, 512), this.map = null, this.mapPass = null, this.matrix = new Rh, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new hd, this._frameExtents = new wu(1, 1), this._viewportCount = 1, this._viewports = [new ju(0, 0, 1, 1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(t) {
                const e = this.camera,
                    n = this.matrix;
                Ev.setFromMatrixPosition(t.matrixWorld), e.position.copy(Ev), Tv.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Tv), e.updateMatrixWorld(), bv.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(bv), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
            }
            getViewport(t) {
                return this._viewports[t]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            dispose() {
                this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
            }
            copy(t) {
                return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const t = {};
                return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
            }
        }
        class wv extends Sv {
            constructor() {
                super(new $c(50, 1, .5, 500)), this.focus = 1
            }
            updateMatrices(t) {
                const e = this.camera,
                    n = 2 * vu * t.angle * this.focus,
                    r = this.mapSize.width / this.mapSize.height,
                    i = t.distance || e.far;
                n === e.fov && r === e.aspect && i === e.far || (e.fov = n, e.aspect = r, e.far = i, e.updateProjectionMatrix()), super.updateMatrices(t)
            }
            copy(t) {
                return super.copy(t), this.focus = t.focus, this
            }
        }
        wv.prototype.isSpotLightShadow = !0;
        (class extends xv {
            constructor(t, e, n = 0, r = Math.PI / 3, i = 0, o = 1) {
                super(t, e), this.type = "SpotLight", this.position.copy($h.DefaultUp), this.updateMatrix(), this.target = new $h, this.distance = n, this.angle = r, this.penumbra = i, this.decay = o, this.shadow = new wv
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(t) {
                this.intensity = t / Math.PI
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t) {
                return super.copy(t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }).prototype.isSpotLight = !0;
        const Mv = new Rh,
            Av = new Ju,
            Rv = new Ju;
        class Pv extends Sv {
            constructor() {
                super(new $c(90, 1, .5, 500)), this._frameExtents = new wu(4, 2), this._viewportCount = 6, this._viewports = [new ju(2, 1, 1, 1), new ju(0, 1, 1, 1), new ju(3, 1, 1, 1), new ju(1, 1, 1, 1), new ju(3, 0, 1, 1), new ju(1, 0, 1, 1)], this._cubeDirections = [new Ju(1, 0, 0), new Ju(-1, 0, 0), new Ju(0, 0, 1), new Ju(0, 0, -1), new Ju(0, 1, 0), new Ju(0, -1, 0)], this._cubeUps = [new Ju(0, 1, 0), new Ju(0, 1, 0), new Ju(0, 1, 0), new Ju(0, 1, 0), new Ju(0, 0, 1), new Ju(0, 0, -1)]
            }
            updateMatrices(t, e = 0) {
                const n = this.camera,
                    r = this.matrix,
                    i = t.distance || n.far;
                i !== n.far && (n.far = i, n.updateProjectionMatrix()), Av.setFromMatrixPosition(t.matrixWorld), n.position.copy(Av), Rv.copy(n.position), Rv.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(Rv), n.updateMatrixWorld(), r.makeTranslation(-Av.x, -Av.y, -Av.z), Mv.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Mv)
            }
        }
        Pv.prototype.isPointLightShadow = !0;
        (class extends xv {
            constructor(t, e, n = 0, r = 1) {
                super(t, e), this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new Pv
            }
            get power() {
                return 4 * this.intensity * Math.PI
            }
            set power(t) {
                this.intensity = t / (4 * Math.PI)
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t) {
                return super.copy(t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
            }
        }).prototype.isPointLight = !0;
        class Iv extends Sv {
            constructor() {
                super(new Td(-5, 5, 5, -5, .5, 500))
            }
        }
        Iv.prototype.isDirectionalLightShadow = !0;
        (class extends xv {
            constructor(t, e) {
                super(t, e), this.type = "DirectionalLight", this.position.copy($h.DefaultUp), this.updateMatrix(), this.target = new $h, this.shadow = new Iv
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t) {
                return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }).prototype.isDirectionalLight = !0;
        (class extends xv {
            constructor(t, e) {
                super(t, e), this.type = "AmbientLight"
            }
        }).prototype.isAmbientLight = !0;
        (class extends xv {
            constructor(t, e, n = 10, r = 10) {
                super(t, e), this.type = "RectAreaLight", this.width = n, this.height = r
            }
            get power() {
                return this.intensity * this.width * this.height * Math.PI
            }
            set power(t) {
                this.intensity = t / (this.width * this.height * Math.PI)
            }
            copy(t) {
                return super.copy(t), this.width = t.width, this.height = t.height, this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.width = this.width, e.object.height = this.height, e
            }
        }).prototype.isRectAreaLight = !0;
        class Cv {
            constructor() {
                this.coefficients = [];
                for (let t = 0; t < 9; t++) this.coefficients.push(new Ju)
            }
            set(t) {
                for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                return this
            }
            zero() {
                for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
                return this
            }
            getAt(t, e) {
                const n = t.x,
                    r = t.y,
                    i = t.z,
                    o = this.coefficients;
                return e.copy(o[0]).multiplyScalar(.282095), e.addScaledVector(o[1], .488603 * r), e.addScaledVector(o[2], .488603 * i), e.addScaledVector(o[3], .488603 * n), e.addScaledVector(o[4], n * r * 1.092548), e.addScaledVector(o[5], r * i * 1.092548), e.addScaledVector(o[6], .315392 * (3 * i * i - 1)), e.addScaledVector(o[7], n * i * 1.092548), e.addScaledVector(o[8], .546274 * (n * n - r * r)), e
            }
            getIrradianceAt(t, e) {
                const n = t.x,
                    r = t.y,
                    i = t.z,
                    o = this.coefficients;
                return e.copy(o[0]).multiplyScalar(.886227), e.addScaledVector(o[1], 1.023328 * r), e.addScaledVector(o[2], 1.023328 * i), e.addScaledVector(o[3], 1.023328 * n), e.addScaledVector(o[4], .858086 * n * r), e.addScaledVector(o[5], .858086 * r * i), e.addScaledVector(o[6], .743125 * i * i - .247708), e.addScaledVector(o[7], .858086 * n * i), e.addScaledVector(o[8], .429043 * (n * n - r * r)), e
            }
            add(t) {
                for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
                return this
            }
            addScaledSH(t, e) {
                for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e);
                return this
            }
            scale(t) {
                for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
                return this
            }
            lerp(t, e) {
                for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
                return this
            }
            equals(t) {
                for (let e = 0; e < 9; e++)
                    if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
                return !0
            }
            copy(t) {
                return this.set(t.coefficients)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            fromArray(t, e = 0) {
                const n = this.coefficients;
                for (let r = 0; r < 9; r++) n[r].fromArray(t, e + 3 * r);
                return this
            }
            toArray(t = [], e = 0) {
                const n = this.coefficients;
                for (let r = 0; r < 9; r++) n[r].toArray(t, e + 3 * r);
                return t
            }
            static getBasisAt(t, e) {
                const n = t.x,
                    r = t.y,
                    i = t.z;
                e[0] = .282095, e[1] = .488603 * r, e[2] = .488603 * i, e[3] = .488603 * n, e[4] = 1.092548 * n * r, e[5] = 1.092548 * r * i, e[6] = .315392 * (3 * i * i - 1), e[7] = 1.092548 * n * i, e[8] = .546274 * (n * n - r * r)
            }
        }
        Cv.prototype.isSphericalHarmonics3 = !0;
        class Ov extends xv {
            constructor(t = new Cv, e = 1) {
                super(void 0, e), this.sh = t
            }
            copy(t) {
                return super.copy(t), this.sh.copy(t.sh), this
            }
            fromJSON(t) {
                return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.sh = this.sh.toArray(), e
            }
        }
        Ov.prototype.isLightProbe = !0;
        let Lv;
        (class extends Ac {
            constructor() {
                super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
            }
            copy(t) {
                return super.copy(t), this.instanceCount = t.instanceCount, this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const t = super.toJSON(this);
                return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
            }
        }).prototype.isInstancedBufferGeometry = !0, class extends fv {
            constructor(t) {
                super(t), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                    premultiplyAlpha: "none"
                }
            }
            setOptions(t) {
                return this.options = t, this
            }
            load(t, e, n, r) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                const i = this,
                    o = dv.get(t);
                if (void 0 !== o) return i.manager.itemStart(t), setTimeout((function() {
                    e && e(o), i.manager.itemEnd(t)
                }), 0), o;
                const s = {};
                s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", s.headers = this.requestHeader, fetch(t, s).then((function(t) {
                    return t.blob()
                })).then((function(t) {
                    return createImageBitmap(t, Object.assign(i.options, {
                        colorSpaceConversion: "none"
                    }))
                })).then((function(n) {
                    dv.add(t, n), e && e(n), i.manager.itemEnd(t)
                })).catch((function(e) {
                    r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
                })), i.manager.itemStart(t)
            }
        }.prototype.isImageBitmapLoader = !0;
        class Nv extends fv {
            constructor(t) {
                super(t)
            }
            load(t, e, n, r) {
                const i = this,
                    o = new gv(this.manager);
                o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(t, (function(n) {
                    try {
                        const t = n.slice(0);
                        (void 0 === Lv && (Lv = new(window.AudioContext || window.webkitAudioContext)), Lv).decodeAudioData(t, (function(t) {
                            e(t)
                        }))
                    } catch (e) {
                        r ? r(e) : console.error(e), i.manager.itemError(t)
                    }
                }), n, r)
            }
        }(class extends Ov {
            constructor(t, e, n = 1) {
                super(void 0, n);
                const r = (new ku).set(t),
                    i = (new ku).set(e),
                    o = new Ju(r.r, r.g, r.b),
                    s = new Ju(i.r, i.g, i.b),
                    a = Math.sqrt(Math.PI),
                    l = a * Math.sqrt(.75);
                this.sh.coefficients[0].copy(o).add(s).multiplyScalar(a), this.sh.coefficients[1].copy(o).sub(s).multiplyScalar(l)
            }
        }).prototype.isHemisphereLightProbe = !0, class extends Ov {
            constructor(t, e = 1) {
                super(void 0, e);
                const n = (new ku).set(t);
                this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
            }
        }.prototype.isAmbientLightProbe = !0;
        class Dv {
            constructor(t = !0) {
                this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }
            start() {
                this.startTime = Uv(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
            }
            stop() {
                this.getElapsedTime(), this.running = !1, this.autoStart = !1
            }
            getElapsedTime() {
                return this.getDelta(), this.elapsedTime
            }
            getDelta() {
                let t = 0;
                if (this.autoStart && !this.running) return this.start(), 0;
                if (this.running) {
                    const e = Uv();
                    t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                }
                return t
            }
        }

        function Uv() {
            return ("undefined" == typeof performance ? Date : performance).now()
        }
        class Fv {
            constructor(t, e, n) {
                let r, i, o;
                switch (this.binding = t, this.valueSize = n, e) {
                    case "quaternion":
                        r = this._slerp, i = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                        break;
                    case "string":
                    case "bool":
                        r = this._select, i = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
                        break;
                    default:
                        r = this._lerp, i = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
                }
                this._mixBufferRegion = r, this._mixBufferRegionAdditive = i, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
            }
            accumulate(t, e) {
                const n = this.buffer,
                    r = this.valueSize,
                    i = t * r + r;
                let o = this.cumulativeWeight;
                if (0 === o) {
                    for (let t = 0; t !== r; ++t) n[i + t] = n[t];
                    o = e
                } else {
                    o += e;
                    const t = e / o;
                    this._mixBufferRegion(n, i, 0, t, r)
                }
                this.cumulativeWeight = o
            }
            accumulateAdditive(t) {
                const e = this.buffer,
                    n = this.valueSize,
                    r = n * this._addIndex;
                0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, r, 0, t, n), this.cumulativeWeightAdditive += t
            }
            apply(t) {
                const e = this.valueSize,
                    n = this.buffer,
                    r = t * e + e,
                    i = this.cumulativeWeight,
                    o = this.cumulativeWeightAdditive,
                    s = this.binding;
                if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1) {
                    const t = e * this._origIndex;
                    this._mixBufferRegion(n, r, t, 1 - i, e)
                }
                o > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * e, 1, e);
                for (let t = e, i = e + e; t !== i; ++t)
                    if (n[t] !== n[t + e]) {
                        s.setValue(n, r);
                        break
                    }
            }
            saveOriginalState() {
                const t = this.binding,
                    e = this.buffer,
                    n = this.valueSize,
                    r = n * this._origIndex;
                t.getValue(e, r);
                for (let t = n, i = r; t !== i; ++t) e[t] = e[r + t % n];
                this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
            }
            restoreOriginalState() {
                const t = 3 * this.valueSize;
                this.binding.setValue(this.buffer, t)
            }
            _setAdditiveIdentityNumeric() {
                const t = this._addIndex * this.valueSize,
                    e = t + this.valueSize;
                for (let n = t; n < e; n++) this.buffer[n] = 0
            }
            _setAdditiveIdentityQuaternion() {
                this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
            }
            _setAdditiveIdentityOther() {
                const t = this._origIndex * this.valueSize,
                    e = this._addIndex * this.valueSize;
                for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n]
            }
            _select(t, e, n, r, i) {
                if (r >= .5)
                    for (let r = 0; r !== i; ++r) t[e + r] = t[n + r]
            }
            _slerp(t, e, n, r) {
                Ku.slerpFlat(t, e, t, e, t, n, r)
            }
            _slerpAdditive(t, e, n, r, i) {
                const o = this._workIndex * i;
                Ku.multiplyQuaternionsFlat(t, o, t, e, t, n), Ku.slerpFlat(t, e, t, e, t, o, r)
            }
            _lerp(t, e, n, r, i) {
                const o = 1 - r;
                for (let s = 0; s !== i; ++s) {
                    const i = e + s;
                    t[i] = t[i] * o + t[n + s] * r
                }
            }
            _lerpAdditive(t, e, n, r, i) {
                for (let o = 0; o !== i; ++o) {
                    const i = e + o;
                    t[i] = t[i] + t[n + o] * r
                }
            }
        }
        const Bv = new RegExp("[\\[\\]\\.:\\/]", "g"),
            kv = "[^\\[\\]\\.:\\/]",
            Gv = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
            Hv = /((?:WC+[\/:])*)/.source.replace("WC", kv),
            zv = /(WCOD+)?/.source.replace("WCOD", Gv),
            Vv = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", kv),
            Wv = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", kv),
            Xv = new RegExp("^" + Hv + zv + Vv + Wv + "$"),
            jv = ["material", "materials", "bones"];
        class Yv {
            constructor(t, e, n) {
                this.path = e, this.parsedPath = n || Yv.parseTrackName(e), this.node = Yv.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
            static create(t, e, n) {
                return t && t.isAnimationObjectGroup ? new Yv.Composite(t, e, n) : new Yv(t, e, n)
            }
            static sanitizeNodeName(t) {
                return t.replace(/\s/g, "_").replace(Bv, "")
            }
            static parseTrackName(t) {
                const e = Xv.exec(t);
                if (null === e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                const n = {
                        nodeName: e[2],
                        objectName: e[3],
                        objectIndex: e[4],
                        propertyName: e[5],
                        propertyIndex: e[6]
                    },
                    r = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== r && -1 !== r) {
                    const t = n.nodeName.substring(r + 1); - 1 !== jv.indexOf(t) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = t)
                }
                if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                return n
            }
            static findNode(t, e) {
                if (void 0 === e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                if (t.skeleton) {
                    const n = t.skeleton.getBoneByName(e);
                    if (void 0 !== n) return n
                }
                if (t.children) {
                    const n = function(t) {
                            for (let r = 0; r < t.length; r++) {
                                const i = t[r];
                                if (i.name === e || i.uuid === e) return i;
                                const o = n(i.children);
                                if (o) return o
                            }
                            return null
                        },
                        r = n(t.children);
                    if (r) return r
                }
                return null
            }
            _getValue_unavailable() {}
            _setValue_unavailable() {}
            _getValue_direct(t, e) {
                t[e] = this.targetObject[this.propertyName]
            }
            _getValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let r = 0, i = n.length; r !== i; ++r) t[e++] = n[r]
            }
            _getValue_arrayElement(t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }
            _getValue_toArray(t, e) {
                this.resolvedProperty.toArray(t, e)
            }
            _setValue_direct(t, e) {
                this.targetObject[this.propertyName] = t[e]
            }
            _setValue_direct_setNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++]
            }
            _setValue_array_setNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
                this.targetObject.needsUpdate = !0
            }
            _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_arrayElement(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e]
            }
            _setValue_arrayElement_setNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_fromArray(t, e) {
                this.resolvedProperty.fromArray(t, e)
            }
            _setValue_fromArray_setNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _getValue_unbound(t, e) {
                this.bind(), this.getValue(t, e)
            }
            _setValue_unbound(t, e) {
                this.bind(), this.setValue(t, e)
            }
            bind() {
                let t = this.node;
                const e = this.parsedPath,
                    n = e.objectName,
                    r = e.propertyName;
                let i = e.propertyIndex;
                if (t || (t = Yv.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                if (n) {
                    let r = e.objectIndex;
                    switch (n) {
                        case "materials":
                            if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            t = t.material.materials;
                            break;
                        case "bones":
                            if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            t = t.skeleton.bones;
                            for (let e = 0; e < t.length; e++)
                                if (t[e].name === r) {
                                    r = e;
                                    break
                                } break;
                        default:
                            if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            t = t[n]
                    }
                    if (void 0 !== r) {
                        if (void 0 === t[r]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        t = t[r]
                    }
                }
                const o = t[r];
                if (void 0 === o) {
                    const n = e.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + r + " but it wasn't found.", t)
                }
                let s = this.Versioning.None;
                this.targetObject = t, void 0 !== t.needsUpdate ? s = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate);
                let a = this.BindingType.Direct;
                if (void 0 !== i) {
                    if ("morphTargetInfluences" === r) {
                        if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                        if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        void 0 !== t.morphTargetDictionary[i] && (i = t.morphTargetDictionary[i])
                    }
                    a = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = i
                } else void 0 !== o.fromArray && void 0 !== o.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (a = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = r;
                this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][s]
            }
            unbind() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }
        Yv.Composite = class {
            constructor(t, e, n) {
                const r = n || Yv.parseTrackName(e);
                this._targetGroup = t, this._bindings = t.subscribe_(e, r)
            }
            getValue(t, e) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_,
                    r = this._bindings[n];
                void 0 !== r && r.getValue(t, e)
            }
            setValue(t, e) {
                const n = this._bindings;
                for (let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(t, e)
            }
            bind() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
            }
            unbind() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
            }
        }, Yv.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        }, Yv.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        }, Yv.prototype.GetterByBindingType = [Yv.prototype._getValue_direct, Yv.prototype._getValue_array, Yv.prototype._getValue_arrayElement, Yv.prototype._getValue_toArray], Yv.prototype.SetterByBindingTypeAndVersioning = [
            [Yv.prototype._setValue_direct, Yv.prototype._setValue_direct_setNeedsUpdate, Yv.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
            [Yv.prototype._setValue_array, Yv.prototype._setValue_array_setNeedsUpdate, Yv.prototype._setValue_array_setMatrixWorldNeedsUpdate],
            [Yv.prototype._setValue_arrayElement, Yv.prototype._setValue_arrayElement_setNeedsUpdate, Yv.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
            [Yv.prototype._setValue_fromArray, Yv.prototype._setValue_fromArray_setNeedsUpdate, Yv.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
        ];
        class qv {
            constructor(t, e, n = null, r = e.blendMode) {
                this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = r;
                const i = e.tracks,
                    o = i.length,
                    s = new Array(o),
                    a = {
                        endingStart: eu,
                        endingEnd: eu
                    };
                for (let t = 0; t !== o; ++t) {
                    const e = i[t].createInterpolant(null);
                    s[t] = e, e.settings = a
                }
                this._interpolantSettings = a, this._interpolants = s, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }
            play() {
                return this._mixer._activateAction(this), this
            }
            stop() {
                return this._mixer._deactivateAction(this), this.reset()
            }
            reset() {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            }
            isRunning() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            }
            isScheduled() {
                return this._mixer._isActiveAction(this)
            }
            startAt(t) {
                return this._startTime = t, this
            }
            setLoop(t, e) {
                return this.loop = t, this.repetitions = e, this
            }
            setEffectiveWeight(t) {
                return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
            }
            getEffectiveWeight() {
                return this._effectiveWeight
            }
            fadeIn(t) {
                return this._scheduleFading(t, 0, 1)
            }
            fadeOut(t) {
                return this._scheduleFading(t, 1, 0)
            }
            crossFadeFrom(t, e, n) {
                if (t.fadeOut(e), this.fadeIn(e), n) {
                    const n = this._clip.duration,
                        r = t._clip.duration,
                        i = r / n,
                        o = n / r;
                    t.warp(1, i, e), this.warp(o, 1, e)
                }
                return this
            }
            crossFadeTo(t, e, n) {
                return t.crossFadeFrom(this, e, n)
            }
            stopFading() {
                const t = this._weightInterpolant;
                return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            }
            setEffectiveTimeScale(t) {
                return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
            }
            getEffectiveTimeScale() {
                return this._effectiveTimeScale
            }
            setDuration(t) {
                return this.timeScale = this._clip.duration / t, this.stopWarping()
            }
            syncWith(t) {
                return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
            }
            halt(t) {
                return this.warp(this._effectiveTimeScale, 0, t)
            }
            warp(t, e, n) {
                const r = this._mixer,
                    i = r.time,
                    o = this.timeScale;
                let s = this._timeScaleInterpolant;
                null === s && (s = r._lendControlInterpolant(), this._timeScaleInterpolant = s);
                const a = s.parameterPositions,
                    l = s.sampleValues;
                return a[0] = i, a[1] = i + n, l[0] = t / o, l[1] = e / o, this
            }
            stopWarping() {
                const t = this._timeScaleInterpolant;
                return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            }
            getMixer() {
                return this._mixer
            }
            getClip() {
                return this._clip
            }
            getRoot() {
                return this._localRoot || this._mixer._root
            }
            _update(t, e, n, r) {
                if (!this.enabled) return void this._updateWeight(t);
                const i = this._startTime;
                if (null !== i) {
                    const r = (t - i) * n;
                    if (r < 0 || 0 === n) return;
                    this._startTime = null, e = n * r
                }
                e *= this._updateTimeScale(t);
                const o = this._updateTime(e),
                    s = this._updateWeight(t);
                if (s > 0) {
                    const t = this._interpolants,
                        e = this._propertyBindings;
                    switch (this.blendMode) {
                        case 2501:
                            for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(o), e[n].accumulateAdditive(s);
                            break;
                        case 2500:
                        default:
                            for (let n = 0, i = t.length; n !== i; ++n) t[n].evaluate(o), e[n].accumulate(r, s)
                    }
                }
            }
            _updateWeight(t) {
                let e = 0;
                if (this.enabled) {
                    e = this.weight;
                    const n = this._weightInterpolant;
                    if (null !== n) {
                        const r = n.evaluate(t)[0];
                        e *= r, t > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = e, e
            }
            _updateTimeScale(t) {
                let e = 0;
                if (!this.paused) {
                    e = this.timeScale;
                    const n = this._timeScaleInterpolant;
                    null !== n && (e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e))
                }
                return this._effectiveTimeScale = e, e
            }
            _updateTime(t) {
                const e = this._clip.duration,
                    n = this.loop;
                let r = this.time + t,
                    i = this._loopCount;
                const o = 2202 === n;
                if (0 === t) return -1 === i ? r : o && 1 == (1 & i) ? e - r : r;
                if (2200 === n) {
                    -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                    t: {
                        if (r >= e) r = e;
                        else {
                            if (!(r < 0)) {
                                this.time = r;
                                break t
                            }
                            r = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this.time = r,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (-1 === i && (t >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), r >= e || r < 0) {
                        const n = Math.floor(r / e);
                        r -= e * n, i += Math.abs(n);
                        const s = this.repetitions - i;
                        if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = t > 0 ? e : 0, this.time = r, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t > 0 ? 1 : -1
                        });
                        else {
                            if (1 === s) {
                                const e = t < 0;
                                this._setEndings(e, !e, o)
                            } else this._setEndings(!1, !1, o);
                            this._loopCount = i, this.time = r, this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: n
                            })
                        }
                    } else this.time = r;
                    if (o && 1 == (1 & i)) return e - r
                }
                return r
            }
            _setEndings(t, e, n) {
                const r = this._interpolantSettings;
                n ? (r.endingStart = nu, r.endingEnd = nu) : (r.endingStart = t ? this.zeroSlopeAtStart ? nu : eu : ru, r.endingEnd = e ? this.zeroSlopeAtEnd ? nu : eu : ru)
            }
            _scheduleFading(t, e, n) {
                const r = this._mixer,
                    i = r.time;
                let o = this._weightInterpolant;
                null === o && (o = r._lendControlInterpolant(), this._weightInterpolant = o);
                const s = o.parameterPositions,
                    a = o.sampleValues;
                return s[0] = i, a[0] = e, s[1] = i + t, a[1] = n, this
            }
        }(class extends pu {
            constructor(t) {
                super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }
            _bindAction(t, e) {
                const n = t._localRoot || this._root,
                    r = t._clip.tracks,
                    i = r.length,
                    o = t._propertyBindings,
                    s = t._interpolants,
                    a = n.uuid,
                    l = this._bindingsByRootAndName;
                let u = l[a];
                void 0 === u && (u = {}, l[a] = u);
                for (let t = 0; t !== i; ++t) {
                    const i = r[t],
                        l = i.name;
                    let h = u[l];
                    if (void 0 !== h) ++h.referenceCount, o[t] = h;
                    else {
                        if (h = o[t], void 0 !== h) {
                            null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, a, l));
                            continue
                        }
                        const r = e && e._propertyBindings[t].binding.parsedPath;
                        h = new Fv(Yv.create(n, l, r), i.ValueTypeName, i.getValueSize()), ++h.referenceCount, this._addInactiveBinding(h, a, l), o[t] = h
                    }
                    s[t].resultBuffer = h.buffer
                }
            }
            _activateAction(t) {
                if (!this._isActiveAction(t)) {
                    if (null === t._cacheIndex) {
                        const e = (t._localRoot || this._root).uuid,
                            n = t._clip.uuid,
                            r = this._actionsByClip[n];
                        this._bindAction(t, r && r.knownActions[0]), this._addInactiveAction(t, n, e)
                    }
                    const e = t._propertyBindings;
                    for (let t = 0, n = e.length; t !== n; ++t) {
                        const n = e[t];
                        0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
                    }
                    this._lendAction(t)
                }
            }
            _deactivateAction(t) {
                if (this._isActiveAction(t)) {
                    const e = t._propertyBindings;
                    for (let t = 0, n = e.length; t !== n; ++t) {
                        const n = e[t];
                        0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                    }
                    this._takeBackAction(t)
                }
            }
            _initMemoryManager() {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                const t = this;
                this.stats = {
                    actions: {
                        get total() {
                            return t._actions.length
                        },
                        get inUse() {
                            return t._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return t._bindings.length
                        },
                        get inUse() {
                            return t._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return t._controlInterpolants.length
                        },
                        get inUse() {
                            return t._nActiveControlInterpolants
                        }
                    }
                }
            }
            _isActiveAction(t) {
                const e = t._cacheIndex;
                return null !== e && e < this._nActiveActions
            }
            _addInactiveAction(t, e, n) {
                const r = this._actions,
                    i = this._actionsByClip;
                let o = i[e];
                if (void 0 === o) o = {
                    knownActions: [t],
                    actionByRoot: {}
                }, t._byClipCacheIndex = 0, i[e] = o;
                else {
                    const e = o.knownActions;
                    t._byClipCacheIndex = e.length, e.push(t)
                }
                t._cacheIndex = r.length, r.push(t), o.actionByRoot[n] = t
            }
            _removeInactiveAction(t) {
                const e = this._actions,
                    n = e[e.length - 1],
                    r = t._cacheIndex;
                n._cacheIndex = r, e[r] = n, e.pop(), t._cacheIndex = null;
                const i = t._clip.uuid,
                    o = this._actionsByClip,
                    s = o[i],
                    a = s.knownActions,
                    l = a[a.length - 1],
                    u = t._byClipCacheIndex;
                l._byClipCacheIndex = u, a[u] = l, a.pop(), t._byClipCacheIndex = null, delete s.actionByRoot[(t._localRoot || this._root).uuid], 0 === a.length && delete o[i], this._removeInactiveBindingsForAction(t)
            }
            _removeInactiveBindingsForAction(t) {
                const e = t._propertyBindings;
                for (let t = 0, n = e.length; t !== n; ++t) {
                    const n = e[t];
                    0 == --n.referenceCount && this._removeInactiveBinding(n)
                }
            }
            _lendAction(t) {
                const e = this._actions,
                    n = t._cacheIndex,
                    r = this._nActiveActions++,
                    i = e[r];
                t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
            }
            _takeBackAction(t) {
                const e = this._actions,
                    n = t._cacheIndex,
                    r = --this._nActiveActions,
                    i = e[r];
                t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
            }
            _addInactiveBinding(t, e, n) {
                const r = this._bindingsByRootAndName,
                    i = this._bindings;
                let o = r[e];
                void 0 === o && (o = {}, r[e] = o), o[n] = t, t._cacheIndex = i.length, i.push(t)
            }
            _removeInactiveBinding(t) {
                const e = this._bindings,
                    n = t.binding,
                    r = n.rootNode.uuid,
                    i = n.path,
                    o = this._bindingsByRootAndName,
                    s = o[r],
                    a = e[e.length - 1],
                    l = t._cacheIndex;
                a._cacheIndex = l, e[l] = a, e.pop(), delete s[i], 0 === Object.keys(s).length && delete o[r]
            }
            _lendBinding(t) {
                const e = this._bindings,
                    n = t._cacheIndex,
                    r = this._nActiveBindings++,
                    i = e[r];
                t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
            }
            _takeBackBinding(t) {
                const e = this._bindings,
                    n = t._cacheIndex,
                    r = --this._nActiveBindings,
                    i = e[r];
                t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
            }
            _lendControlInterpolant() {
                const t = this._controlInterpolants,
                    e = this._nActiveControlInterpolants++;
                let n = t[e];
                return void 0 === n && (n = new tv(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
            }
            _takeBackControlInterpolant(t) {
                const e = this._controlInterpolants,
                    n = t.__cacheIndex,
                    r = --this._nActiveControlInterpolants,
                    i = e[r];
                t.__cacheIndex = r, e[r] = t, i.__cacheIndex = n, e[n] = i
            }
            clipAction(t, e, n) {
                const r = e || this._root,
                    i = r.uuid;
                let o = "string" == typeof t ? hv.findByName(r, t) : t;
                const s = null !== o ? o.uuid : t,
                    a = this._actionsByClip[s];
                let l = null;
                if (void 0 === n && (n = null !== o ? o.blendMode : 2500), void 0 !== a) {
                    const t = a.actionByRoot[i];
                    if (void 0 !== t && t.blendMode === n) return t;
                    l = a.knownActions[0], null === o && (o = l._clip)
                }
                if (null === o) return null;
                const u = new qv(this, o, e, n);
                return this._bindAction(u, l), this._addInactiveAction(u, s, i), u
            }
            existingAction(t, e) {
                const n = e || this._root,
                    r = n.uuid,
                    i = "string" == typeof t ? hv.findByName(n, t) : t,
                    o = i ? i.uuid : t,
                    s = this._actionsByClip[o];
                return void 0 !== s && s.actionByRoot[r] || null
            }
            stopAllAction() {
                const t = this._actions;
                for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
                return this
            }
            update(t) {
                t *= this.timeScale;
                const e = this._actions,
                    n = this._nActiveActions,
                    r = this.time += t,
                    i = Math.sign(t),
                    o = this._accuIndex ^= 1;
                for (let s = 0; s !== n; ++s) e[s]._update(r, t, i, o);
                const s = this._bindings,
                    a = this._nActiveBindings;
                for (let t = 0; t !== a; ++t) s[t].apply(o);
                return this
            }
            setTime(t) {
                this.time = 0;
                for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
                return this.update(t)
            }
            getRoot() {
                return this._root
            }
            uncacheClip(t) {
                const e = this._actions,
                    n = t.uuid,
                    r = this._actionsByClip,
                    i = r[n];
                if (void 0 !== i) {
                    const t = i.knownActions;
                    for (let n = 0, r = t.length; n !== r; ++n) {
                        const r = t[n];
                        this._deactivateAction(r);
                        const i = r._cacheIndex,
                            o = e[e.length - 1];
                        r._cacheIndex = null, r._byClipCacheIndex = null, o._cacheIndex = i, e[i] = o, e.pop(), this._removeInactiveBindingsForAction(r)
                    }
                    delete r[n]
                }
            }
            uncacheRoot(t) {
                const e = t.uuid,
                    n = this._actionsByClip;
                for (const t in n) {
                    const r = n[t].actionByRoot[e];
                    void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
                }
                const r = this._bindingsByRootAndName[e];
                if (void 0 !== r)
                    for (const t in r) {
                        const e = r[t];
                        e.restoreOriginalState(), this._removeInactiveBinding(e)
                    }
            }
            uncacheAction(t, e) {
                const n = this.existingAction(t, e);
                null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
            }
        }).prototype._controlInterpolantsResultBuffer = new Float32Array(1);
        class Zv {
            constructor(t) {
                "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
            }
            clone() {
                return new Zv(void 0 === this.value.clone ? this.value : this.value.clone())
            }
        }(class extends Yf {
            constructor(t, e, n = 1) {
                super(t, e), this.meshPerAttribute = n
            }
            copy(t) {
                return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
            }
            clone(t) {
                const e = super.clone(t);
                return e.meshPerAttribute = this.meshPerAttribute, e
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
            }
        }).prototype.isInstancedInterleavedBuffer = !0;
        class Kv {
            constructor(t, e, n = 0, r = 1 / 0) {
                this.ray = new Ah(t, e), this.near = n, this.far = r, this.camera = null, this.layers = new kh, this.params = {
                    Mesh: {},
                    Line: {
                        threshold: 1
                    },
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }
            }
            set(t, e) {
                this.ray.set(t, e)
            }
            setFromCamera(t, e) {
                e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type)
            }
            intersectObject(t, e = !0, n = []) {
                return Qv(t, this, n, e), n.sort(Jv), n
            }
            intersectObjects(t, e = !0, n = []) {
                for (let r = 0, i = t.length; r < i; r++) Qv(t[r], this, n, e);
                return n.sort(Jv), n
            }
        }

        function Jv(t, e) {
            return t.distance - e.distance
        }

        function Qv(t, e, n, r) {
            if (t.layers.test(e.layers) && t.raycast(e, n), !0 === r) {
                const r = t.children;
                for (let t = 0, i = r.length; t < i; t++) Qv(r[t], e, n, !0)
            }
        }
        class $v {
            constructor(t = 1, e = 0, n = 0) {
                return this.radius = t, this.phi = e, this.theta = n, this
            }
            set(t, e, n) {
                return this.radius = t, this.phi = e, this.theta = n, this
            }
            copy(t) {
                return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
            }
            makeSafe() {
                const t = 1e-6;
                return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this
            }
            setFromVector3(t) {
                return this.setFromCartesianCoords(t.x, t.y, t.z)
            }
            setFromCartesianCoords(t, e, n) {
                return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(yu(e / this.radius, -1, 1))), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const t_ = new wu;
        class e_ {
            constructor(t = new wu(1 / 0, 1 / 0), e = new wu(-1 / 0, -1 / 0)) {
                this.min = t, this.max = e
            }
            set(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            }
            setFromPoints(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                return this
            }
            setFromCenterAndSize(t, e) {
                const n = t_.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            }
            makeEmpty() {
                return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            }
            getCenter(t) {
                return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(t) {
                return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
            }
            expandByPoint(t) {
                return this.min.min(t), this.max.max(t), this
            }
            expandByVector(t) {
                return this.min.sub(t), this.max.add(t), this
            }
            expandByScalar(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            }
            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
            }
            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
            }
            getParameter(t, e) {
                return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
            }
            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
            }
            clampPoint(t, e) {
                return e.copy(t).clamp(this.min, this.max)
            }
            distanceToPoint(t) {
                return t_.copy(t).clamp(this.min, this.max).sub(t).length()
            }
            intersect(t) {
                return this.min.max(t.min), this.max.min(t.max), this
            }
            union(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            }
            translate(t) {
                return this.min.add(t), this.max.add(t), this
            }
            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }
        e_.prototype.isBox2 = !0;
        const n_ = new Ju,
            r_ = new Rh,
            i_ = new Rh;

        function o_(t) {
            const e = [];
            !0 === t.isBone && e.push(t);
            for (let n = 0; n < t.children.length; n++) e.push.apply(e, o_(t.children[n]));
            return e
        }
        const s_ = new ArrayBuffer(4),
            a_ = (new Float32Array(s_), new Uint32Array(s_), new Uint32Array(512)),
            l_ = new Uint32Array(512);
        for (let t = 0; t < 256; ++t) {
            const e = t - 127;
            e < -27 ? (a_[t] = 0, a_[256 | t] = 32768, l_[t] = 24, l_[256 | t] = 24) : e < -14 ? (a_[t] = 1024 >> -e - 14, a_[256 | t] = 1024 >> -e - 14 | 32768, l_[t] = -e - 1, l_[256 | t] = -e - 1) : e <= 15 ? (a_[t] = e + 15 << 10, a_[256 | t] = e + 15 << 10 | 32768, l_[t] = 13, l_[256 | t] = 13) : e < 128 ? (a_[t] = 31744, a_[256 | t] = 64512, l_[t] = 24, l_[256 | t] = 24) : (a_[t] = 31744, a_[256 | t] = 64512, l_[t] = 13, l_[256 | t] = 13)
        }
        const u_ = new Uint32Array(2048),
            h_ = new Uint32Array(64),
            c_ = new Uint32Array(64);
        for (let t = 1; t < 1024; ++t) {
            let e = t << 13,
                n = 0;
            for (; 0 == (8388608 & e);) e <<= 1, n -= 8388608;
            e &= -8388609, n += 947912704, u_[t] = e | n
        }
        for (let t = 1024; t < 2048; ++t) u_[t] = 939524096 + (t - 1024 << 13);
        for (let t = 1; t < 31; ++t) h_[t] = t << 23;
        h_[31] = 1199570944, h_[32] = 2147483648;
        for (let t = 33; t < 63; ++t) h_[t] = 2147483648 + (t - 32 << 23);
        h_[63] = 3347054592;
        for (let t = 1; t < 64; ++t) 32 !== t && (c_[t] = 1024);
        km.create = function(t, e) {
            return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(km.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
        }, og.prototype.fromPoints = function(t) {
            return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
        }, class extends Om {
            constructor(t = 10, e = 10, n = 4473924, r = 8947848) {
                n = new ku(n), r = new ku(r);
                const i = e / 2,
                    o = t / e,
                    s = t / 2,
                    a = [],
                    l = [];
                for (let t = 0, u = 0, h = -s; t <= e; t++, h += o) {
                    a.push(-s, 0, h, s, 0, h), a.push(h, 0, -s, h, 0, s);
                    const e = t === i ? n : r;
                    e.toArray(l, u), u += 3, e.toArray(l, u), u += 3, e.toArray(l, u), u += 3, e.toArray(l, u), u += 3
                }
                const u = new Ac;
                u.setAttribute("position", new yc(a, 3)), u.setAttribute("color", new yc(l, 3)), super(u, new Tm({
                    vertexColors: !0,
                    toneMapped: !1
                })), this.type = "GridHelper"
            }
        }.prototype.setColors = function() {
            console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
        }, class extends Om {
            constructor(t) {
                const e = o_(t),
                    n = new Ac,
                    r = [],
                    i = [],
                    o = new ku(0, 0, 1),
                    s = new ku(0, 1, 0);
                for (let t = 0; t < e.length; t++) {
                    const n = e[t];
                    n.parent && n.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(o.r, o.g, o.b), i.push(s.r, s.g, s.b))
                }
                n.setAttribute("position", new yc(r, 3)), n.setAttribute("color", new yc(i, 3)), super(n, new Tm({
                    vertexColors: !0,
                    depthTest: !1,
                    depthWrite: !1,
                    toneMapped: !1,
                    transparent: !0
                })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
            }
            updateMatrixWorld(t) {
                const e = this.bones,
                    n = this.geometry,
                    r = n.getAttribute("position");
                i_.copy(this.root.matrixWorld).invert();
                for (let t = 0, n = 0; t < e.length; t++) {
                    const i = e[t];
                    i.parent && i.parent.isBone && (r_.multiplyMatrices(i_, i.matrixWorld), n_.setFromMatrixPosition(r_), r.setXYZ(n, n_.x, n_.y, n_.z), r_.multiplyMatrices(i_, i.parent.matrixWorld), n_.setFromMatrixPosition(r_), r.setXYZ(n + 1, n_.x, n_.y, n_.z), n += 2)
                }
                n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
            }
        }.prototype.update = function() {
            console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
        }, fv.prototype.extractUrlBase = function(t) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), class {
                static decodeText(t) {
                    if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                    let e = "";
                    for (let n = 0, r = t.length; n < r; n++) e += String.fromCharCode(t[n]);
                    try {
                        return decodeURIComponent(escape(e))
                    } catch (t) {
                        return e
                    }
                }
                static extractUrlBase(t) {
                    const e = t.lastIndexOf("/");
                    return -1 === e ? "./" : t.slice(0, e + 1)
                }
                static resolveURL(t, e) {
                    return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
                }
            }.extractUrlBase(t)
        }, fv.Handlers = {
            add: function() {
                console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
            },
            get: function() {
                console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
            }
        }, e_.prototype.center = function(t) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
        }, e_.prototype.empty = function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        }, e_.prototype.isIntersectionBox = function(t) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        }, e_.prototype.size = function(t) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
        }, th.prototype.center = function(t) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
        }, th.prototype.empty = function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        }, th.prototype.isIntersectionBox = function(t) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        }, th.prototype.isIntersectionSphere = function(t) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
        }, th.prototype.size = function(t) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
        }, Bh.prototype.toVector3 = function() {
            console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")
        }, yh.prototype.empty = function() {
            return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        }, hd.prototype.setFromMatrix = function(t) {
            return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t)
        }, Mu.prototype.flattenToArrayOffset = function(t, e) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
        }, Mu.prototype.multiplyVector3 = function(t) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
        }, Mu.prototype.multiplyVector3Array = function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        }, Mu.prototype.applyToBufferAttribute = function(t) {
            return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
        }, Mu.prototype.applyToVector3Array = function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }, Mu.prototype.getInverse = function(t) {
            return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
        }, Rh.prototype.extractPosition = function(t) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
        }, Rh.prototype.flattenToArrayOffset = function(t, e) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
        }, Rh.prototype.getPosition = function() {
            return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Ju).setFromMatrixColumn(this, 3)
        }, Rh.prototype.setRotationFromQuaternion = function(t) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
        }, Rh.prototype.multiplyToArray = function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        }, Rh.prototype.multiplyVector3 = function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        }, Rh.prototype.multiplyVector4 = function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        }, Rh.prototype.multiplyVector3Array = function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        }, Rh.prototype.rotateAxis = function(t) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
        }, Rh.prototype.crossVector = function(t) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        }, Rh.prototype.translate = function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        }, Rh.prototype.rotateX = function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        }, Rh.prototype.rotateY = function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        }, Rh.prototype.rotateZ = function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        }, Rh.prototype.rotateByAxis = function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        }, Rh.prototype.applyToBufferAttribute = function(t) {
            return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        }, Rh.prototype.applyToVector3Array = function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        }, Rh.prototype.makeFrustum = function(t, e, n, r, i, o) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, r, n, i, o)
        }, Rh.prototype.getInverse = function(t) {
            return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
        }, ad.prototype.isIntersectionLine = function(t) {
            return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
        }, Ku.prototype.multiplyVector3 = function(t) {
            return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
        }, Ku.prototype.inverse = function() {
            return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
        }, Ah.prototype.isIntersectionBox = function(t) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        }, Ah.prototype.isIntersectionPlane = function(t) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
        }, Ah.prototype.isIntersectionSphere = function(t) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
        }, hc.prototype.area = function() {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
        }, hc.prototype.barycoordFromPoint = function(t, e) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
        }, hc.prototype.midpoint = function(t) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
        }, hc.prototypenormal = function(t) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
        }, hc.prototype.plane = function(t) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
        }, hc.barycoordFromPoint = function(t, e, n, r, i) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), hc.getBarycoord(t, e, n, r, i)
        }, hc.normal = function(t, e, n, r) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), hc.getNormal(t, e, n, r)
        }, ag.prototype.extractAllPoints = function(t) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
        }, ag.prototype.extrude = function(t) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Dg(this, t)
        }, ag.prototype.makeGeometry = function(t) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Fg(this, t)
        }, wu.prototype.fromAttribute = function(t, e, n) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
        }, wu.prototype.distanceToManhattan = function(t) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
        }, wu.prototype.lengthManhattan = function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }, Ju.prototype.setEulerFromRotationMatrix = function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        }, Ju.prototype.setEulerFromQuaternion = function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        }, Ju.prototype.getPositionFromMatrix = function(t) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
        }, Ju.prototype.getScaleFromMatrix = function(t) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
        }, Ju.prototype.getColumnFromMatrix = function(t, e) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
        }, Ju.prototype.applyProjection = function(t) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
        }, Ju.prototype.fromAttribute = function(t, e, n) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
        }, Ju.prototype.distanceToManhattan = function(t) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
        }, Ju.prototype.lengthManhattan = function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }, ju.prototype.fromAttribute = function(t, e, n) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
        }, ju.prototype.lengthManhattan = function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }, $h.prototype.getChildByName = function(t) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
        }, $h.prototype.renderDepth = function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        }, $h.prototype.translate = function(t, e) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
        }, $h.prototype.getWorldRotation = function() {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        }, $h.prototype.applyMatrix = function(t) {
            return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
        }, Object.defineProperties($h.prototype, {
            eulerOrder: {
                get: function() {
                    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                },
                set: function(t) {
                    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                }
            },
            useQuaternion: {
                get: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                },
                set: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                }
            }
        }), Xc.prototype.setDrawMode = function() {
            console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
        }, Object.defineProperties(Xc.prototype, {
            drawMode: {
                get: function() {
                    return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
                },
                set: function() {
                    console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                }
            }
        }), vm.prototype.initBones = function() {
            console.error("THREE.SkinnedMesh: initBones() has been removed.")
        }, $c.prototype.setLens = function(t, e) {
            console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
        }, Object.defineProperties(xv.prototype, {
            onlyShadow: {
                set: function() {
                    console.warn("THREE.Light: .onlyShadow has been removed.")
                }
            },
            shadowCameraFov: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                }
            },
            shadowCameraLeft: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                }
            },
            shadowCameraRight: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                }
            },
            shadowCameraTop: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                }
            },
            shadowCameraBottom: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                }
            },
            shadowCameraNear: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                }
            },
            shadowCameraFar: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                }
            },
            shadowCameraVisible: {
                set: function() {
                    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                }
            },
            shadowBias: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                }
            },
            shadowDarkness: {
                set: function() {
                    console.warn("THREE.Light: .shadowDarkness has been removed.")
                }
            },
            shadowMapWidth: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                }
            },
            shadowMapHeight: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                }
            }
        }), Object.defineProperties(gc.prototype, {
            length: {
                get: function() {
                    return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                }
            },
            dynamic: {
                get: function() {
                    return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === hu
                },
                set: function() {
                    console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(hu)
                }
            }
        }), gc.prototype.setDynamic = function(t) {
            return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? hu : uu), this
        }, gc.prototype.copyIndicesArray = function() {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        }, gc.prototype.setArray = function() {
            console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }, Ac.prototype.addIndex = function(t) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
        }, Ac.prototype.addAttribute = function(t, e) {
            return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new gc(arguments[1], arguments[2])))
        }, Ac.prototype.addDrawCall = function(t, e, n) {
            void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
        }, Ac.prototype.clearDrawCalls = function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
        }, Ac.prototype.computeOffsets = function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }, Ac.prototype.removeAttribute = function(t) {
            return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t)
        }, Ac.prototype.applyMatrix = function(t) {
            return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
        }, Object.defineProperties(Ac.prototype, {
            drawcalls: {
                get: function() {
                    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                }
            },
            offsets: {
                get: function() {
                    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                }
            }
        }), Yf.prototype.setDynamic = function(t) {
            return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? hu : uu), this
        }, Yf.prototype.setArray = function() {
            console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }, Dg.prototype.getArrays = function() {
            console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
        }, Dg.prototype.addShapeList = function() {
            console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
        }, Dg.prototype.addShape = function() {
            console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
        }, jf.prototype.dispose = function() {
            console.error("THREE.Scene: .dispose() has been removed.")
        }, Zv.prototype.onUpdate = function() {
            return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
        }, Object.defineProperties(dc.prototype, {
            wrapAround: {
                get: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                },
                set: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                }
            },
            overdraw: {
                get: function() {
                    console.warn("THREE.Material: .overdraw has been removed.")
                },
                set: function() {
                    console.warn("THREE.Material: .overdraw has been removed.")
                }
            },
            wrapRGB: {
                get: function() {
                    return console.warn("THREE.Material: .wrapRGB has been removed."), new ku
                }
            },
            shading: {
                get: function() {
                    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                },
                set: function(t) {
                    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
                }
            },
            stencilMask: {
                get: function() {
                    return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
                },
                set: function(t) {
                    console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t
                }
            },
            vertexTangents: {
                get: function() {
                    console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                },
                set: function() {
                    console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                }
            }
        }), Object.defineProperties(Jc.prototype, {
            derivatives: {
                get: function() {
                    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                },
                set: function(t) {
                    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                }
            }
        }), Vf.prototype.clearTarget = function(t, e, n, r) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, r)
        }, Vf.prototype.animate = function(t) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
        }, Vf.prototype.getCurrentRenderTarget = function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
        }, Vf.prototype.getMaxAnisotropy = function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
        }, Vf.prototype.getPrecision = function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
        }, Vf.prototype.resetGLState = function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
        }, Vf.prototype.supportsFloatTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
        }, Vf.prototype.supportsHalfFloatTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
        }, Vf.prototype.supportsStandardDerivatives = function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
        }, Vf.prototype.supportsCompressedTextureS3TC = function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
        }, Vf.prototype.supportsCompressedTexturePVRTC = function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
        }, Vf.prototype.supportsBlendMinMax = function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
        }, Vf.prototype.supportsVertexTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
        }, Vf.prototype.supportsInstancedArrays = function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
        }, Vf.prototype.enableScissorTest = function(t) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
        }, Vf.prototype.initMaterial = function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        }, Vf.prototype.addPrePlugin = function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        }, Vf.prototype.addPostPlugin = function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        }, Vf.prototype.updateShadowMap = function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        }, Vf.prototype.setFaceCulling = function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        }, Vf.prototype.allocTextureUnit = function() {
            console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
        }, Vf.prototype.setTexture = function() {
            console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
        }, Vf.prototype.setTexture2D = function() {
            console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
        }, Vf.prototype.setTextureCube = function() {
            console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
        }, Vf.prototype.getActiveMipMapLevel = function() {
            return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
        }, Object.defineProperties(Vf.prototype, {
            shadowMapEnabled: {
                get: function() {
                    return this.shadowMap.enabled
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                }
            },
            shadowMapType: {
                get: function() {
                    return this.shadowMap.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                }
            },
            shadowMapCullFace: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            context: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
                }
            },
            vr: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
                }
            },
            gammaInput: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                }
            },
            gammaOutput: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? ou : iu
                }
            },
            toneMappingWhitePoint: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
                }
            },
            gammaFactor: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
                }
            }
        }), Object.defineProperties(Of.prototype, {
            cullFace: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            renderReverseSided: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                }
            },
            renderSingleSided: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                }
            }
        }), Object.defineProperties(Yu.prototype, {
            wrapS: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                }
            },
            wrapT: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                }
            },
            magFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                }
            },
            minFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                }
            },
            anisotropy: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                }
            },
            offset: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                }
            },
            repeat: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                }
            },
            format: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                }
            },
            type: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                }
            },
            generateMipmaps: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                }
            }
        }), class extends $h {
            constructor(t) {
                super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
            }
            getOutput() {
                return this.gain
            }
            setNodeSource(t) {
                return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
            }
            setMediaElementSource(t) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
            }
            setMediaStreamSource(t) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
            }
            setBuffer(t) {
                return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
            }
            play(t = 0) {
                if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                this._startedAt = this.context.currentTime + t;
                const e = this.context.createBufferSource();
                return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
            }
            pause() {
                if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            stop() {
                if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            connect() {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this._connected = !0, this
            }
            disconnect() {
                if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else this.source.disconnect(this.getOutput());
                return this._connected = !1, this
            }
            getFilters() {
                return this.filters
            }
            setFilters(t) {
                return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this
            }
            setDetune(t) {
                if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
            }
            getDetune() {
                return this.detune
            }
            getFilter() {
                return this.getFilters()[0]
            }
            setFilter(t) {
                return this.setFilters(t ? [t] : [])
            }
            setPlaybackRate(t) {
                if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            getPlaybackRate() {
                return this.playbackRate
            }
            onEnded() {
                this.isPlaying = !1
            }
            getLoop() {
                return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
            }
            setLoop(t) {
                if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            setLoopStart(t) {
                return this.loopStart = t, this
            }
            setLoopEnd(t) {
                return this.loopEnd = t, this
            }
            getVolume() {
                return this.gain.gain.value
            }
            setVolume(t) {
                return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
            }
        }.prototype.load = function(t) {
            console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
            const e = this;
            return (new Nv).load(t, (function(t) {
                e.setBuffer(t)
            })), this
        }, ed.prototype.updateCubeMap = function(t, e) {
            return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
        }, ed.prototype.clear = function(t, e, n, r) {
            return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, r)
        }, Hu.crossOrigin = void 0, Hu.loadTexture = function(t, e, n, r) {
            console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
            const i = new yv;
            i.setCrossOrigin(this.crossOrigin);
            const o = i.load(t, n, void 0, r);
            return e && (o.mapping = e), o
        }, Hu.loadTextureCube = function(t, e, n, r) {
            console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
            const i = new _v;
            i.setCrossOrigin(this.crossOrigin);
            const o = i.load(t, n, void 0, r);
            return e && (o.mapping = e), o
        }, Hu.loadCompressedTexture = function() {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
        }, Hu.loadCompressedTextureCube = function() {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
        }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
            detail: {
                revision: "139"
            }
        })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "139");
        const d_ = {
                type: "change"
            },
            p_ = {
                type: "start"
            },
            f_ = {
                type: "end"
            };
        class m_ extends pu {
            constructor(t, e) {
                super(), void 0 === e && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), e === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = t, this.domElement = e, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new Ju, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = {
                    LEFT: "ArrowLeft",
                    UP: "ArrowUp",
                    RIGHT: "ArrowRight",
                    BOTTOM: "ArrowDown"
                }, this.mouseButtons = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2
                }, this.touches = {
                    ONE: 0,
                    TWO: 2
                }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function() {
                    return s.phi
                }, this.getAzimuthalAngle = function() {
                    return s.theta
                }, this.getDistance = function() {
                    return this.object.position.distanceTo(this.target)
                }, this.listenToKeyEvents = function(t) {
                    t.addEventListener("keydown", V), this._domElementKeyEvents = t
                }, this.saveState = function() {
                    n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom
                }, this.reset = function() {
                    n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(d_), n.update(), i = r.NONE
                }, this.update = function() {
                    const e = new Ju,
                        c = (new Ku).setFromUnitVectors(t.up, new Ju(0, 1, 0)),
                        d = c.clone().invert(),
                        p = new Ju,
                        f = new Ku,
                        m = 2 * Math.PI;
                    return function() {
                        const t = n.object.position;
                        e.copy(t).sub(n.target), e.applyQuaternion(c), s.setFromVector3(e), n.autoRotate && i === r.NONE && T(2 * Math.PI / 60 / 60 * n.autoRotateSpeed), n.enableDamping ? (s.theta += a.theta * n.dampingFactor, s.phi += a.phi * n.dampingFactor) : (s.theta += a.theta, s.phi += a.phi);
                        let g = n.minAzimuthAngle,
                            v = n.maxAzimuthAngle;
                        return isFinite(g) && isFinite(v) && (g < -Math.PI ? g += m : g > Math.PI && (g -= m), v < -Math.PI ? v += m : v > Math.PI && (v -= m), s.theta = g <= v ? Math.max(g, Math.min(v, s.theta)) : s.theta > (g + v) / 2 ? Math.max(g, s.theta) : Math.min(v, s.theta)), s.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, s.phi)), s.makeSafe(), s.radius *= l, s.radius = Math.max(n.minDistance, Math.min(n.maxDistance, s.radius)), !0 === n.enableDamping ? n.target.addScaledVector(u, n.dampingFactor) : n.target.add(u), e.setFromSpherical(s), e.applyQuaternion(d), t.copy(n.target).add(e), n.object.lookAt(n.target), !0 === n.enableDamping ? (a.theta *= 1 - n.dampingFactor, a.phi *= 1 - n.dampingFactor, u.multiplyScalar(1 - n.dampingFactor)) : (a.set(0, 0, 0), u.set(0, 0, 0)), l = 1, !!(h || p.distanceToSquared(n.object.position) > o || 8 * (1 - f.dot(n.object.quaternion)) > o) && (n.dispatchEvent(d_), p.copy(n.object.position), f.copy(n.object.quaternion), h = !1, !0)
                    }
                }(), this.dispose = function() {
                    n.domElement.removeEventListener("contextmenu", W), n.domElement.removeEventListener("pointerdown", B), n.domElement.removeEventListener("pointercancel", H), n.domElement.removeEventListener("wheel", z), n.domElement.removeEventListener("pointermove", k), n.domElement.removeEventListener("pointerup", G), null !== n._domElementKeyEvents && n._domElementKeyEvents.removeEventListener("keydown", V)
                };
                const n = this,
                    r = {
                        NONE: -1,
                        ROTATE: 0,
                        DOLLY: 1,
                        PAN: 2,
                        TOUCH_ROTATE: 3,
                        TOUCH_PAN: 4,
                        TOUCH_DOLLY_PAN: 5,
                        TOUCH_DOLLY_ROTATE: 6
                    };
                let i = r.NONE;
                const o = 1e-6,
                    s = new $v,
                    a = new $v;
                let l = 1;
                const u = new Ju;
                let h = !1;
                const c = new wu,
                    d = new wu,
                    p = new wu,
                    f = new wu,
                    m = new wu,
                    g = new wu,
                    v = new wu,
                    _ = new wu,
                    y = new wu,
                    x = [],
                    b = {};

                function E() {
                    return Math.pow(.95, n.zoomSpeed)
                }

                function T(t) {
                    a.theta -= t
                }

                function S(t) {
                    a.phi -= t
                }
                const w = function() {
                        const t = new Ju;
                        return function(e, n) {
                            t.setFromMatrixColumn(n, 0), t.multiplyScalar(-e), u.add(t)
                        }
                    }(),
                    M = function() {
                        const t = new Ju;
                        return function(e, r) {
                            !0 === n.screenSpacePanning ? t.setFromMatrixColumn(r, 1) : (t.setFromMatrixColumn(r, 0), t.crossVectors(n.object.up, t)), t.multiplyScalar(e), u.add(t)
                        }
                    }(),
                    A = function() {
                        const t = new Ju;
                        return function(e, r) {
                            const i = n.domElement;
                            if (n.object.isPerspectiveCamera) {
                                const o = n.object.position;
                                t.copy(o).sub(n.target);
                                let s = t.length();
                                s *= Math.tan(n.object.fov / 2 * Math.PI / 180), w(2 * e * s / i.clientHeight, n.object.matrix), M(2 * r * s / i.clientHeight, n.object.matrix)
                            } else n.object.isOrthographicCamera ? (w(e * (n.object.right - n.object.left) / n.object.zoom / i.clientWidth, n.object.matrix), M(r * (n.object.top - n.object.bottom) / n.object.zoom / i.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1)
                        }
                    }();

                function R(t) {
                    n.object.isPerspectiveCamera ? l /= t : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom * t)), n.object.updateProjectionMatrix(), h = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
                }

                function P(t) {
                    n.object.isPerspectiveCamera ? l *= t : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / t)), n.object.updateProjectionMatrix(), h = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
                }

                function I(t) {
                    c.set(t.clientX, t.clientY)
                }

                function C(t) {
                    f.set(t.clientX, t.clientY)
                }

                function O() {
                    if (1 === x.length) c.set(x[0].pageX, x[0].pageY);
                    else {
                        const t = .5 * (x[0].pageX + x[1].pageX),
                            e = .5 * (x[0].pageY + x[1].pageY);
                        c.set(t, e)
                    }
                }

                function L() {
                    if (1 === x.length) f.set(x[0].pageX, x[0].pageY);
                    else {
                        const t = .5 * (x[0].pageX + x[1].pageX),
                            e = .5 * (x[0].pageY + x[1].pageY);
                        f.set(t, e)
                    }
                }

                function N() {
                    const t = x[0].pageX - x[1].pageX,
                        e = x[0].pageY - x[1].pageY,
                        n = Math.sqrt(t * t + e * e);
                    v.set(0, n)
                }

                function D(t) {
                    if (1 == x.length) d.set(t.pageX, t.pageY);
                    else {
                        const e = Y(t),
                            n = .5 * (t.pageX + e.x),
                            r = .5 * (t.pageY + e.y);
                        d.set(n, r)
                    }
                    p.subVectors(d, c).multiplyScalar(n.rotateSpeed);
                    const e = n.domElement;
                    T(2 * Math.PI * p.x / e.clientHeight), S(2 * Math.PI * p.y / e.clientHeight), c.copy(d)
                }

                function U(t) {
                    if (1 === x.length) m.set(t.pageX, t.pageY);
                    else {
                        const e = Y(t),
                            n = .5 * (t.pageX + e.x),
                            r = .5 * (t.pageY + e.y);
                        m.set(n, r)
                    }
                    g.subVectors(m, f).multiplyScalar(n.panSpeed), A(g.x, g.y), f.copy(m)
                }

                function F(t) {
                    const e = Y(t),
                        r = t.pageX - e.x,
                        i = t.pageY - e.y,
                        o = Math.sqrt(r * r + i * i);
                    _.set(0, o), y.set(0, Math.pow(_.y / v.y, n.zoomSpeed)), R(y.y), v.copy(_)
                }

                function B(t) {
                    !1 !== n.enabled && (0 === x.length && (n.domElement.setPointerCapture(t.pointerId), n.domElement.addEventListener("pointermove", k), n.domElement.addEventListener("pointerup", G)), function(t) {
                        x.push(t)
                    }(t), "touch" === t.pointerType ? function(t) {
                        switch (j(t), x.length) {
                            case 1:
                                switch (n.touches.ONE) {
                                    case 0:
                                        if (!1 === n.enableRotate) return;
                                        O(), i = r.TOUCH_ROTATE;
                                        break;
                                    case 1:
                                        if (!1 === n.enablePan) return;
                                        L(), i = r.TOUCH_PAN;
                                        break;
                                    default:
                                        i = r.NONE
                                }
                                break;
                            case 2:
                                switch (n.touches.TWO) {
                                    case 2:
                                        if (!1 === n.enableZoom && !1 === n.enablePan) return;
                                        n.enableZoom && N(), n.enablePan && L(), i = r.TOUCH_DOLLY_PAN;
                                        break;
                                    case 3:
                                        if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                                        n.enableZoom && N(), n.enableRotate && O(), i = r.TOUCH_DOLLY_ROTATE;
                                        break;
                                    default:
                                        i = r.NONE
                                }
                                break;
                            default:
                                i = r.NONE
                        }
                        i !== r.NONE && n.dispatchEvent(p_)
                    }(t) : function(t) {
                        let e;
                        switch (t.button) {
                            case 0:
                                e = n.mouseButtons.LEFT;
                                break;
                            case 1:
                                e = n.mouseButtons.MIDDLE;
                                break;
                            case 2:
                                e = n.mouseButtons.RIGHT;
                                break;
                            default:
                                e = -1
                        }
                        switch (e) {
                            case 1:
                                if (!1 === n.enableZoom) return;
                                ! function(t) {
                                    v.set(t.clientX, t.clientY)
                                }(t), i = r.DOLLY;
                                break;
                            case 0:
                                if (t.ctrlKey || t.metaKey || t.shiftKey) {
                                    if (!1 === n.enablePan) return;
                                    C(t), i = r.PAN
                                } else {
                                    if (!1 === n.enableRotate) return;
                                    I(t), i = r.ROTATE
                                }
                                break;
                            case 2:
                                if (t.ctrlKey || t.metaKey || t.shiftKey) {
                                    if (!1 === n.enableRotate) return;
                                    I(t), i = r.ROTATE
                                } else {
                                    if (!1 === n.enablePan) return;
                                    C(t), i = r.PAN
                                }
                                break;
                            default:
                                i = r.NONE
                        }
                        i !== r.NONE && n.dispatchEvent(p_)
                    }(t))
                }

                function k(t) {
                    !1 !== n.enabled && ("touch" === t.pointerType ? function(t) {
                        switch (j(t), i) {
                            case r.TOUCH_ROTATE:
                                if (!1 === n.enableRotate) return;
                                D(t), n.update();
                                break;
                            case r.TOUCH_PAN:
                                if (!1 === n.enablePan) return;
                                U(t), n.update();
                                break;
                            case r.TOUCH_DOLLY_PAN:
                                if (!1 === n.enableZoom && !1 === n.enablePan) return;
                                ! function(t) {
                                    n.enableZoom && F(t), n.enablePan && U(t)
                                }(t), n.update();
                                break;
                            case r.TOUCH_DOLLY_ROTATE:
                                if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                                ! function(t) {
                                    n.enableZoom && F(t), n.enableRotate && D(t)
                                }(t), n.update();
                                break;
                            default:
                                i = r.NONE
                        }
                    }(t) : function(t) {
                        if (!1 !== n.enabled) switch (i) {
                            case r.ROTATE:
                                if (!1 === n.enableRotate) return;
                                ! function(t) {
                                    d.set(t.clientX, t.clientY), p.subVectors(d, c).multiplyScalar(n.rotateSpeed);
                                    const e = n.domElement;
                                    T(2 * Math.PI * p.x / e.clientHeight), S(2 * Math.PI * p.y / e.clientHeight), c.copy(d), n.update()
                                }(t);
                                break;
                            case r.DOLLY:
                                if (!1 === n.enableZoom) return;
                                ! function(t) {
                                    _.set(t.clientX, t.clientY), y.subVectors(_, v), y.y > 0 ? R(E()) : y.y < 0 && P(E()), v.copy(_), n.update()
                                }(t);
                                break;
                            case r.PAN:
                                if (!1 === n.enablePan) return;
                                ! function(t) {
                                    m.set(t.clientX, t.clientY), g.subVectors(m, f).multiplyScalar(n.panSpeed), A(g.x, g.y), f.copy(m), n.update()
                                }(t)
                        }
                    }(t))
                }

                function G(t) {
                    X(t), 0 === x.length && (n.domElement.releasePointerCapture(t.pointerId), n.domElement.removeEventListener("pointermove", k), n.domElement.removeEventListener("pointerup", G)), n.dispatchEvent(f_), i = r.NONE
                }

                function H(t) {
                    X(t)
                }

                function z(t) {
                    !1 !== n.enabled && !1 !== n.enableZoom && i === r.NONE && (t.preventDefault(), n.dispatchEvent(p_), function(t) {
                        t.deltaY < 0 ? P(E()) : t.deltaY > 0 && R(E()), n.update()
                    }(t), n.dispatchEvent(f_))
                }

                function V(t) {
                    !1 !== n.enabled && !1 !== n.enablePan && function(t) {
                        let e = !1;
                        switch (t.code) {
                            case n.keys.UP:
                                A(0, n.keyPanSpeed), e = !0;
                                break;
                            case n.keys.BOTTOM:
                                A(0, -n.keyPanSpeed), e = !0;
                                break;
                            case n.keys.LEFT:
                                A(n.keyPanSpeed, 0), e = !0;
                                break;
                            case n.keys.RIGHT:
                                A(-n.keyPanSpeed, 0), e = !0
                        }
                        e && (t.preventDefault(), n.update())
                    }(t)
                }

                function W(t) {
                    !1 !== n.enabled && t.preventDefault()
                }

                function X(t) {
                    delete b[t.pointerId];
                    for (let e = 0; e < x.length; e++)
                        if (x[e].pointerId == t.pointerId) return void x.splice(e, 1)
                }

                function j(t) {
                    let e = b[t.pointerId];
                    void 0 === e && (e = new wu, b[t.pointerId] = e), e.set(t.pageX, t.pageY)
                }

                function Y(t) {
                    const e = t.pointerId === x[0].pointerId ? x[1] : x[0];
                    return b[e.pointerId]
                }
                n.domElement.addEventListener("contextmenu", W), n.domElement.addEventListener("pointerdown", B), n.domElement.addEventListener("pointercancel", H), n.domElement.addEventListener("wheel", z, {
                    passive: !1
                }), this.update()
            }
        }
        const g_ = {
                uniforms: {
                    tDiffuse: {
                        value: null
                    },
                    resolution: {
                        value: new wu(1 / 1024, 1 / 512)
                    }
                },
                vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
                fragmentShader: "\n\tprecision highp float;\n\n\tuniform sampler2D tDiffuse;\n\n\tuniform vec2 resolution;\n\n\tvarying vec2 vUv;\n\n\t// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n\t//----------------------------------------------------------------------------------\n\t// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag\n\t// SDK Version: v3.00\n\t// Email:       gameworks@nvidia.com\n\t// Site:        http://developer.nvidia.com/\n\t//\n\t// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n\t//\n\t// Redistribution and use in source and binary forms, with or without\n\t// modification, are permitted provided that the following conditions\n\t// are met:\n\t//  * Redistributions of source code must retain the above copyright\n\t//    notice, this list of conditions and the following disclaimer.\n\t//  * Redistributions in binary form must reproduce the above copyright\n\t//    notice, this list of conditions and the following disclaimer in the\n\t//    documentation and/or other materials provided with the distribution.\n\t//  * Neither the name of NVIDIA CORPORATION nor the names of its\n\t//    contributors may be used to endorse or promote products derived\n\t//    from this software without specific prior written permission.\n\t//\n\t// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY\n\t// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\t// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n\t// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n\t// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n\t// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n\t// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n\t// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n\t// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t//\n\t//----------------------------------------------------------------------------------\n\n\t#ifndef FXAA_DISCARD\n\t\t\t//\n\t\t\t// Only valid for PC OpenGL currently.\n\t\t\t// Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n\t\t\t//\n\t\t\t// 1 = Use discard on pixels which don't need AA.\n\t\t\t//     For APIs which enable concurrent TEX+ROP from same surface.\n\t\t\t// 0 = Return unchanged color on pixels which don't need AA.\n\t\t\t//\n\t\t\t#define FXAA_DISCARD 0\n\t#endif\n\n\t/*--------------------------------------------------------------------------*/\n\t#define FxaaTexTop(t, p) texture2D(t, p, -100.0)\n\t#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), -100.0)\n\t/*--------------------------------------------------------------------------*/\n\n\t#define NUM_SAMPLES 5\n\n\t// assumes colors have premultipliedAlpha, so that the calculated color contrast is scaled by alpha\n\tfloat contrast( vec4 a, vec4 b ) {\n\t\t\tvec4 diff = abs( a - b );\n\t\t\treturn max( max( max( diff.r, diff.g ), diff.b ), diff.a );\n\t}\n\n\t/*============================================================================\n\n\t\t\t\t\t\t\t\t\tFXAA3 QUALITY - PC\n\n\t============================================================================*/\n\n\t/*--------------------------------------------------------------------------*/\n\tvec4 FxaaPixelShader(\n\t\t\tvec2 posM,\n\t\t\tsampler2D tex,\n\t\t\tvec2 fxaaQualityRcpFrame,\n\t\t\tfloat fxaaQualityEdgeThreshold,\n\t\t\tfloat fxaaQualityinvEdgeThreshold\n\t) {\n\t\t\tvec4 rgbaM = FxaaTexTop(tex, posM);\n\t\t\tvec4 rgbaS = FxaaTexOff(tex, posM, vec2( 0.0, 1.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaE = FxaaTexOff(tex, posM, vec2( 1.0, 0.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaN = FxaaTexOff(tex, posM, vec2( 0.0,-1.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaW = FxaaTexOff(tex, posM, vec2(-1.0, 0.0), fxaaQualityRcpFrame.xy);\n\t\t\t// . S .\n\t\t\t// W M E\n\t\t\t// . N .\n\n\t\t\tbool earlyExit = max( max( max(\n\t\t\t\t\tcontrast( rgbaM, rgbaN ),\n\t\t\t\t\tcontrast( rgbaM, rgbaS ) ),\n\t\t\t\t\tcontrast( rgbaM, rgbaE ) ),\n\t\t\t\t\tcontrast( rgbaM, rgbaW ) )\n\t\t\t\t\t< fxaaQualityEdgeThreshold;\n\t\t\t// . 0 .\n\t\t\t// 0 0 0\n\t\t\t// . 0 .\n\n\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\tif(earlyExit) FxaaDiscard;\n\t\t\t#else\n\t\t\t\t\tif(earlyExit) return rgbaM;\n\t\t\t#endif\n\n\t\t\tfloat contrastN = contrast( rgbaM, rgbaN );\n\t\t\tfloat contrastS = contrast( rgbaM, rgbaS );\n\t\t\tfloat contrastE = contrast( rgbaM, rgbaE );\n\t\t\tfloat contrastW = contrast( rgbaM, rgbaW );\n\n\t\t\tfloat relativeVContrast = ( contrastN + contrastS ) - ( contrastE + contrastW );\n\t\t\trelativeVContrast *= fxaaQualityinvEdgeThreshold;\n\n\t\t\tbool horzSpan = relativeVContrast > 0.;\n\t\t\t// . 1 .\n\t\t\t// 0 0 0\n\t\t\t// . 1 .\n\n\t\t\t// 45 deg edge detection and corners of objects, aka V/H contrast is too similar\n\t\t\tif( abs( relativeVContrast ) < .3 ) {\n\t\t\t\t\t// locate the edge\n\t\t\t\t\tvec2 dirToEdge;\n\t\t\t\t\tdirToEdge.x = contrastE > contrastW ? 1. : -1.;\n\t\t\t\t\tdirToEdge.y = contrastS > contrastN ? 1. : -1.;\n\t\t\t\t\t// . 2 .      . 1 .\n\t\t\t\t\t// 1 0 2  ~=  0 0 1\n\t\t\t\t\t// . 1 .      . 0 .\n\n\t\t\t\t\t// tap 2 pixels and see which ones are \"outside\" the edge, to\n\t\t\t\t\t// determine if the edge is vertical or horizontal\n\n\t\t\t\t\tvec4 rgbaAlongH = FxaaTexOff(tex, posM, vec2( dirToEdge.x, -dirToEdge.y ), fxaaQualityRcpFrame.xy);\n\t\t\t\t\tfloat matchAlongH = contrast( rgbaM, rgbaAlongH );\n\t\t\t\t\t// . 1 .\n\t\t\t\t\t// 0 0 1\n\t\t\t\t\t// . 0 H\n\n\t\t\t\t\tvec4 rgbaAlongV = FxaaTexOff(tex, posM, vec2( -dirToEdge.x, dirToEdge.y ), fxaaQualityRcpFrame.xy);\n\t\t\t\t\tfloat matchAlongV = contrast( rgbaM, rgbaAlongV );\n\t\t\t\t\t// V 1 .\n\t\t\t\t\t// 0 0 1\n\t\t\t\t\t// . 0 .\n\n\t\t\t\t\trelativeVContrast = matchAlongV - matchAlongH;\n\t\t\t\t\trelativeVContrast *= fxaaQualityinvEdgeThreshold;\n\n\t\t\t\t\tif( abs( relativeVContrast ) < .3 ) { // 45 deg edge\n\t\t\t\t\t\t\t// 1 1 .\n\t\t\t\t\t\t\t// 0 0 1\n\t\t\t\t\t\t\t// . 0 1\n\n\t\t\t\t\t\t\t// do a simple blur\n\t\t\t\t\t\t\treturn mix(\n\t\t\t\t\t\t\t\t\trgbaM,\n\t\t\t\t\t\t\t\t\t(rgbaN + rgbaS + rgbaE + rgbaW) * .25,\n\t\t\t\t\t\t\t\t\t.4\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\thorzSpan = relativeVContrast > 0.;\n\t\t\t}\n\n\t\t\tif(!horzSpan) rgbaN = rgbaW;\n\t\t\tif(!horzSpan) rgbaS = rgbaE;\n\t\t\t// . 0 .      1\n\t\t\t// 1 0 1  ->  0\n\t\t\t// . 0 .      1\n\n\t\t\tbool pairN = contrast( rgbaM, rgbaN ) > contrast( rgbaM, rgbaS );\n\t\t\tif(!pairN) rgbaN = rgbaS;\n\n\t\t\tvec2 offNP;\n\t\t\toffNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n\t\t\toffNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n\n\t\t\tbool doneN = false;\n\t\t\tbool doneP = false;\n\n\t\t\tfloat nDist = 0.;\n\t\t\tfloat pDist = 0.;\n\n\t\t\tvec2 posN = posM;\n\t\t\tvec2 posP = posM;\n\n\t\t\tint iterationsUsed = 0;\n\t\t\tint iterationsUsedN = 0;\n\t\t\tint iterationsUsedP = 0;\n\t\t\tfor( int i = 0; i < NUM_SAMPLES; i++ ) {\n\t\t\t\t\titerationsUsed = i;\n\n\t\t\t\t\tfloat increment = float(i + 1);\n\n\t\t\t\t\tif(!doneN) {\n\t\t\t\t\t\t\tnDist += increment;\n\t\t\t\t\t\t\tposN = posM + offNP * nDist;\n\t\t\t\t\t\t\tvec4 rgbaEndN = FxaaTexTop(tex, posN.xy);\n\t\t\t\t\t\t\tdoneN = contrast( rgbaEndN, rgbaM ) > contrast( rgbaEndN, rgbaN );\n\t\t\t\t\t\t\titerationsUsedN = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!doneP) {\n\t\t\t\t\t\t\tpDist += increment;\n\t\t\t\t\t\t\tposP = posM - offNP * pDist;\n\t\t\t\t\t\t\tvec4 rgbaEndP = FxaaTexTop(tex, posP.xy);\n\t\t\t\t\t\t\tdoneP = contrast( rgbaEndP, rgbaM ) > contrast( rgbaEndP, rgbaN );\n\t\t\t\t\t\t\titerationsUsedP = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(doneN || doneP) break;\n\t\t\t}\n\n\n\t\t\tif ( !doneP && !doneN ) return rgbaM; // failed to find end of edge\n\n\t\t\tfloat dist = min(\n\t\t\t\t\tdoneN ? float( iterationsUsedN ) / float( NUM_SAMPLES - 1 ) : 1.,\n\t\t\t\t\tdoneP ? float( iterationsUsedP ) / float( NUM_SAMPLES - 1 ) : 1.\n\t\t\t);\n\n\t\t\t// hacky way of reduces blurriness of mostly diagonal edges\n\t\t\t// but reduces AA quality\n\t\t\tdist = pow(dist, .5);\n\n\t\t\tdist = 1. - dist;\n\n\t\t\treturn mix(\n\t\t\t\t\trgbaM,\n\t\t\t\t\trgbaN,\n\t\t\t\t\tdist * .5\n\t\t\t);\n\t}\n\n\tvoid main() {\n\t\t\tconst float edgeDetectionQuality = .2;\n\t\t\tconst float invEdgeDetectionQuality = 1. / edgeDetectionQuality;\n\n\t\t\tgl_FragColor = FxaaPixelShader(\n\t\t\t\t\tvUv,\n\t\t\t\t\ttDiffuse,\n\t\t\t\t\tresolution,\n\t\t\t\t\tedgeDetectionQuality, // [0,1] contrast needed, otherwise early discard\n\t\t\t\t\tinvEdgeDetectionQuality\n\t\t\t);\n\n\t}\n\t"
            },
            v_ = {
                uniforms: {
                    tDiffuse: {
                        value: null
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
                fragmentShader: "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor.a *= opacity;\n\n\n\t\t}"
            };
        class __ {
            constructor() {
                this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
            }
            setSize() {}
            render() {
                console.error("THREE.Pass: .render() must be implemented in derived pass.")
            }
        }
        const y_ = new Td(-1, 1, 1, -1, 0, 1),
            x_ = new Ac;
        x_.setAttribute("position", new yc([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), x_.setAttribute("uv", new yc([0, 2, 0, 0, 2, 0], 2));
        class b_ {
            constructor(t) {
                this._mesh = new Xc(x_, t)
            }
            dispose() {
                this._mesh.geometry.dispose()
            }
            render(t) {
                t.render(this._mesh, y_)
            }
            get material() {
                return this._mesh.material
            }
            set material(t) {
                this._mesh.material = t
            }
        }
        class E_ extends __ {
            constructor(t, e) {
                super(), this.textureID = void 0 !== e ? e : "tDiffuse", t instanceof Jc ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = Kc.clone(t.uniforms), this.material = new Jc({
                    defines: Object.assign({}, t.defines),
                    uniforms: this.uniforms,
                    vertexShader: t.vertexShader,
                    fragmentShader: t.fragmentShader
                })), this.fsQuad = new b_(this.material)
            }
            render(t, e, n) {
                this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t))
            }
        }
        class T_ extends __ {
            constructor(t, e) {
                super(), this.scene = t, this.camera = e, this.clear = !0, this.needsSwap = !1, this.inverse = !1
            }
            render(t, e, n) {
                const r = t.getContext(),
                    i = t.state;
                let o, s;
                i.buffers.color.setMask(!1), i.buffers.depth.setMask(!1), i.buffers.color.setLocked(!0), i.buffers.depth.setLocked(!0), this.inverse ? (o = 0, s = 1) : (o = 1, s = 0), i.buffers.stencil.setTest(!0), i.buffers.stencil.setOp(r.REPLACE, r.REPLACE, r.REPLACE), i.buffers.stencil.setFunc(r.ALWAYS, o, 4294967295), i.buffers.stencil.setClear(s), i.buffers.stencil.setLocked(!0), t.setRenderTarget(n), this.clear && t.clear(), t.render(this.scene, this.camera), t.setRenderTarget(e), this.clear && t.clear(), t.render(this.scene, this.camera), i.buffers.color.setLocked(!1), i.buffers.depth.setLocked(!1), i.buffers.stencil.setLocked(!1), i.buffers.stencil.setFunc(r.EQUAL, 1, 4294967295), i.buffers.stencil.setOp(r.KEEP, r.KEEP, r.KEEP), i.buffers.stencil.setLocked(!0)
            }
        }
        class S_ extends __ {
            constructor() {
                super(), this.needsSwap = !1
            }
            render(t) {
                t.state.buffers.stencil.setLocked(!1), t.state.buffers.stencil.setTest(!1)
            }
        }
        class w_ {
            constructor(t, e) {
                if (this.renderer = t, void 0 === e) {
                    const n = t.getSize(new wu);
                    this._pixelRatio = t.getPixelRatio(), this._width = n.width, this._height = n.height, (e = new Yu(this._width * this._pixelRatio, this._height * this._pixelRatio)).texture.name = "EffectComposer.rt1"
                } else this._pixelRatio = 1, this._width = e.width, this._height = e.height;
                this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], void 0 === v_ && console.error("THREE.EffectComposer relies on CopyShader"), void 0 === E_ && console.error("THREE.EffectComposer relies on ShaderPass"), this.copyPass = new E_(v_), this.clock = new Dv
            }
            swapBuffers() {
                const t = this.readBuffer;
                this.readBuffer = this.writeBuffer, this.writeBuffer = t
            }
            addPass(t) {
                this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
            }
            insertPass(t, e) {
                this.passes.splice(e, 0, t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
            }
            removePass(t) {
                const e = this.passes.indexOf(t); - 1 !== e && this.passes.splice(e, 1)
            }
            isLastEnabledPass(t) {
                for (let e = t + 1; e < this.passes.length; e++)
                    if (this.passes[e].enabled) return !1;
                return !0
            }
            render(t) {
                void 0 === t && (t = this.clock.getDelta());
                const e = this.renderer.getRenderTarget();
                let n = !1;
                for (let e = 0, r = this.passes.length; e < r; e++) {
                    const r = this.passes[e];
                    if (!1 !== r.enabled) {
                        if (r.renderToScreen = this.renderToScreen && this.isLastEnabledPass(e), r.render(this.renderer, this.writeBuffer, this.readBuffer, t, n), r.needsSwap) {
                            if (n) {
                                const e = this.renderer.getContext(),
                                    n = this.renderer.state.buffers.stencil;
                                n.setFunc(e.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), n.setFunc(e.EQUAL, 1, 4294967295)
                            }
                            this.swapBuffers()
                        }
                        void 0 !== T_ && (r instanceof T_ ? n = !0 : r instanceof S_ && (n = !1))
                    }
                }
                this.renderer.setRenderTarget(e)
            }
            reset(t) {
                if (void 0 === t) {
                    const e = this.renderer.getSize(new wu);
                    this._pixelRatio = this.renderer.getPixelRatio(), this._width = e.width, this._height = e.height, (t = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
                }
                this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
            }
            setSize(t, e) {
                this._width = t, this._height = e;
                const n = this._width * this._pixelRatio,
                    r = this._height * this._pixelRatio;
                this.renderTarget1.setSize(n, r), this.renderTarget2.setSize(n, r);
                for (let t = 0; t < this.passes.length; t++) this.passes[t].setSize(n, r)
            }
            setPixelRatio(t) {
                this._pixelRatio = t, this.setSize(this._width, this._height)
            }
        }
        new Td(-1, 1, 1, -1, 0, 1);
        const M_ = new Ac;
        M_.setAttribute("position", new yc([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), M_.setAttribute("uv", new yc([0, 2, 0, 0, 2, 0], 2));
        class A_ extends __ {
            constructor(t, e, n, r, i) {
                super(), this.scene = t, this.camera = e, this.overrideMaterial = n, this.clearColor = r, this.clearAlpha = void 0 !== i ? i : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new ku
            }
            render(t, e, n) {
                const r = t.autoClear;
                let i, o;
                t.autoClear = !1, void 0 !== this.overrideMaterial && (o = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (t.getClearColor(this._oldClearColor), i = t.getClearAlpha(), t.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && t.clearDepth(), t.setRenderTarget(this.renderToScreen ? null : n), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), t.render(this.scene, this.camera), this.clearColor && t.setClearColor(this._oldClearColor, i), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = o), t.autoClear = r
            }
        }

        function R_(t) {
            return (R_ = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function P_(t, e) {
            for (var n = 0; n < e.length; n++) {
                var r = e[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function I_(t, e) {
            return (I_ = Object.setPrototypeOf || function(t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function C_(t, e) {
            if (e && ("object" === R_(e) || "function" == typeof e)) return e;
            if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            return O_(t)
        }

        function O_(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }

        function L_(t) {
            return (L_ = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            })(t)
        }
        var N_ = function(e) {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), Object.defineProperty(t, "prototype", {
                    writable: !1
                }), e && I_(t, e)
            }(a, e);
            var n, r, i, o, s = (i = a, o = function() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                } catch (t) {
                    return !1
                }
            }(), function() {
                var t, e = L_(i);
                if (o) {
                    var n = L_(this).constructor;
                    t = Reflect.construct(e, arguments, n)
                } else t = e.apply(this, arguments);
                return C_(this, t)
            });

            function a(t) {
                var e;
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, a), (e = s.call(this, t)).initialState = {
                    isDragging: !1,
                    isDraggingSun: !1,
                    isDraggingMoon: !1,
                    mouseoverSun: !1,
                    mouseoverMoon: !1
                }, e.state = e.initialState, e.dayColor = 9486591, e.id = "CelestialSphere", e.start = e.start.bind(O_(e)), e.stop = e.stop.bind(O_(e)), e.animate = e.animate.bind(O_(e)), e.raycaster = new Kv, e.mouse = new wu, e.onMouseMove = e.onMouseMove.bind(O_(e)), e.onMouseDown = e.onMouseDown.bind(O_(e)), e.onMouseUp = e.onMouseUp.bind(O_(e)), e
            }
            return n = a, (r = [{
                key: "componentDidMount",
                value: function() {
                    var t = this.mount.clientWidth,
                        e = this.mount.clientHeight,
                        n = t / e,
                        r = new jf,
                        i = new Td(100 * n / -2, 100 * n / 2, 50, -50, 1, 1e3);
                    i.position.set(-60, 20, 0);
                    var o = new m_(i, this.mount);
                    o.enableKeys = !1, o.enablePan = !1, o.enableZoom = !1, o.minPolarAngle = Su.degToRad(0), o.maxPolarAngle = Su.degToRad(70);
                    var s = new Vf({
                        antialias: !0,
                        canvas: document.getElementById(this.id + "Canvas")
                    });
                    s.setPixelRatio(window.devicePixelRatio), s.setClearColor(16777215);
                    var a = window.devicePixelRatio,
                        l = new w_(s);
                    l.addPass(new A_(r, i));
                    var u = new E_(g_);
                    u.uniforms.resolution.value = new wu(1 / (2 * t * a), 1 / (2 * e * a)), u.renderToScreen = !0, l.setSize(4 * t * a, 4 * e * a), l.addPass(u), o.update(), this.controls = o, this.plane = this.drawPlane(r), this.drawStickFigure(r), this.drawGlobe(r), this.moon = this.drawMoon(r), this.sun = this.drawSun(r), this.angle = this.drawAngle(r), this.orbitGroup = new Ff, this.orbitGroup.add(this.sun), this.orbitGroup.add(this.moon), this.orbitGroup.add(this.celestialEquator), this.orbitGroup.add(this.angle), this.orbitGroup.rotation.x = Su.degToRad(-50), r.add(this.orbitGroup), this.orbitPlane = new ad(new Ju(0, Su.degToRad(50), -1), 0), this.scene = r, this.camera = i, this.renderer = s, this.renderer.domElement.addEventListener("pointermove", this.onMouseMove, !1), this.renderer.domElement.addEventListener("pointerdown", this.onMouseDown, !1), this.renderer.domElement.addEventListener("pointerup", this.onMouseUp, !1), this.composer = l, this.mount.appendChild(this.renderer.domElement), this.start()
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    this.stop(), this.mount.removeChild(this.renderer.domElement)
                }
            }, {
                key: "componentDidUpdate",
                value: function(t, e) {
                    if (!this.props.showAngle || t.observerAngle === this.props.observerAngle && t.moonAngle === this.props.moonAngle || (this.angle.visible = !0, this.updateAngleGeometry(this.angle, this.props.observerAngle, this.props.moonAngle)), t.showAngle !== this.props.showAngle && (this.props.showAngle && this.updateAngleGeometry(this.angle, this.props.observerAngle, this.props.moonAngle), this.angle.visible = this.props.showAngle), t.observerAngle !== this.props.observerAngle && (this.updateSunPos(this.sun, this.props.observerAngle), this.updateMoonPos(this.moon, this.props.observerAngle, this.props.moonAngle), this.skyMaterial.color = this.getSkyColor()), t.moonAngle !== this.props.moonAngle && this.updateMoonPos(this.moon, this.props.observerAngle, this.props.moonAngle), e.mouseoverSun !== this.state.mouseoverSun) {
                        var n = this.sun.children[1];
                        n.verticesNeedUpdate = !0, this.state.mouseoverSun ? n.geometry = new kg(5, .35, 16, 32) : n.geometry = new kg(5, .2, 16, 32)
                    }
                    if (e.mouseoverMoon !== this.state.mouseoverMoon) {
                        var r = this.moon.children[1];
                        r.verticesNeedUpdate = !0, this.state.mouseoverMoon ? r.geometry = new kg(5, .35, 16, 32) : r.geometry = new kg(5, .2, 16, 32)
                    }
                }
            }, {
                key: "updateSunPos",
                value: function(t, e) {
                    t.position.x = 50.25 * Math.cos(e), t.position.z = 50.25 * Math.sin(e), t.rotation.y = -e + Math.PI / 2
                }
            }, {
                key: "updateMoonPos",
                value: function(t, e, n) {
                    t.position.x = 50.25 * Math.cos(-n + e - Math.PI), t.position.z = 50.25 * Math.sin(-n + e - Math.PI), t.rotation.y = -(-n + e) + Su.degToRad(90) - Math.PI
                }
            }, {
                key: "drawPlane",
                value: function(t) {
                    var e = (new yv).load("img/plane.svg"),
                        n = new pc({
                            map: e
                        });
                    n.map.minFilter = Fl;
                    var r = new sg(50, 64),
                        i = new Xc(r, n);
                    return i.name = "Plane", i.rotation.x = Su.degToRad(-90), t.add(i), i
                }
            }, {
                key: "drawGlobe",
                value: function(t) {
                    var e = new Bg(50, 64, 64, 0, 2 * Math.PI, 0, Math.PI / 2),
                        n = new pc({
                            transparent: !0,
                            opacity: .8,
                            color: 0,
                            side: 1
                        }),
                        r = new Xc(e, n);
                    r.rotation.x = Math.PI, t.add(r), this.skyMaterial = new pc({
                        transparent: !0,
                        opacity: .8,
                        color: this.dayColor,
                        side: 1
                    });
                    var i = new Xc(e, this.skyMaterial);
                    t.add(i);
                    var o = new pc({
                            transparent: !0,
                            opacity: .5,
                            color: 16777215
                        }),
                        s = new kg(50, .1, 16, 64),
                        a = new Xc(s, o);
                    a.rotation.y = Su.degToRad(90), t.add(a);
                    var l = new Xc(s, o);
                    l.rotation.z = Su.degToRad(90), t.add(l);
                    var u = new pc({
                            color: 16777215
                        }),
                        h = new kg(50, .3, 16, 64);
                    this.celestialEquator = new Xc(h, u), this.celestialEquator.rotation.x = Su.degToRad(90)
                }
            }, {
                key: "drawStickFigure",
                value: function(t) {
                    var e = (new yv).load("img/stickfigure.svg"),
                        n = new Kf({
                            map: e
                        }),
                        r = new hm(n);
                    r.scale.set(5, 10, 5), r.position.y = 4.5, t.add(r)
                }
            }, {
                key: "drawSun",
                value: function() {
                    var t = new kg(5, .2, 16, 32),
                        e = new pc({
                            color: 0
                        }),
                        n = new pc({
                            color: 16768256,
                            side: 2
                        }),
                        r = new sg(5, 32),
                        i = new Xc(t, e),
                        o = new Xc(r, n);
                    o.name = "Sun";
                    var s = new Ff;
                    return s.add(o), s.add(i), this.updateSunPos(s, this.props.observerAngle), s
                }
            }, {
                key: "drawMoon",
                value: function() {
                    var t = new kg(5, .2, 16, 32),
                        e = new pc({
                            color: 0
                        }),
                        n = new pc({
                            color: 12303291,
                            side: 2
                        }),
                        r = new sg(5, 32),
                        i = new Xc(t, e),
                        o = new Xc(r, n);
                    o.name = "Moon";
                    var s = new Ff;
                    return s.add(o), s.add(i), this.updateMoonPos(s, this.props.observerAngle, this.props.moonAngle), s
                }
            }, {
                key: "updateAngleGeometry",
                value: function(t, e, n) {
                    var r = t.children.find((function(t) {
                            return "angleOutline" === t.name
                        })),
                        i = t.children.find((function(t) {
                            return "angleSlice" === t.name
                        })),
                        o = new kg(50, .4, 16, 100, n - Math.PI);
                    r.geometry = o;
                    var s = new sg(50, 32, Math.PI, n > 0 ? n - Math.PI : n + Math.PI);
                    i.geometry = s, t.rotation.y = -e - Math.PI
                }
            }, {
                key: "drawAngle",
                value: function() {
                    var t = new kg(50, .4, 16, 100, 0),
                        e = new pc({
                            color: 16776960
                        }),
                        n = new Xc(t, e);
                    n.name = "angleOutline", n.rotation.x = Math.PI / 2;
                    var r = new sg(50, 32, 0),
                        i = new pc({
                            color: 16776960,
                            transparent: !0,
                            opacity: .4,
                            side: 2
                        }),
                        o = new Xc(r, i);
                    o.name = "angleSlice", o.rotation.x = -Math.PI / 2;
                    var s = new Ff;
                    return s.add(n), s.add(o), s.visible = !1, s.rotation.y = Math.PI / 2, this.updateAngleGeometry(s, this.props.observerAngle, this.props.moonAngle), s
                }
            }, {
                key: "start",
                value: function() {
                    this.frameId || (this.frameId = requestAnimationFrame(this.animate))
                }
            }, {
                key: "stop",
                value: function() {
                    cancelAnimationFrame(this.frameId)
                }
            }, {
                key: "animate",
                value: function() {
                    this.sun.position.x = 50.25 * Math.cos(this.props.observerAngle), this.sun.position.z = 50.25 * Math.sin(this.props.observerAngle), this.sun.rotation.y = -this.props.observerAngle + Su.degToRad(90), this.renderScene(), this.frameId = window.requestAnimationFrame(this.animate)
                }
            }, {
                key: "renderScene",
                value: function() {
                    this.composer.render()
                }
            }, {
                key: "getTime",
                value: function(t) {
                    var e = Su.radToDeg(t) / 15 * 3600,
                        n = new Date("1/1/2018 6:00 AM");
                    return new Date(n.getTime() + 1e3 * e)
                }
            }, {
                key: "getSkyColor",
                value: function() {
                    var t = new Ju;
                    this.sun.getWorldPosition(t);
                    var e = t.y;
                    if (e < 0 || e > 180) return new ku(137280);
                    var n = new ku(this.dayColor);
                    return n.lerp(new ku(137280), 1 - e / 40), n
                }
            }, {
                key: "render",
                value: function() {
                    var e = this,
                        n = this.getTime(this.props.observerAngle).toLocaleTimeString([], {
                            hour: "2-digit",
                            minute: "2-digit"
                        });
                    return t.createElement(t.Fragment, null, t.createElement("div", {
                        id: this.id,
                        style: {
                            width: "228px",
                            height: "228px",
                            visibility: this.props.isHidden ? "hidden" : "visible"
                        },
                        ref: function(t) {
                            e.mount = t
                        }
                    }, t.createElement("canvas", {
                        id: this.id + "Canvas",
                        width: 456,
                        height: 456
                    })), t.createElement("div", {
                        style: {
                            visibility: this.props.isHidden ? "hidden" : "visible"
                        }
                    }, "Observer's local time: ", n), t.createElement("div", {
                        className: "text-right"
                    }, t.createElement("button", {
                        type: "button",
                        onClick: this.props.onHideShowToggle,
                        className: "btn btn-primary btn-sm"
                    }, this.props.isHidden ? "Show" : "Hide")))
                }
            }, {
                key: "findMouseIntersects",
                value: function(t, e, n, r) {
                    r.setFromCamera(e, n);
                    var i = [this.plane].concat(this.sun.children).concat(this.moon.children);
                    return this.raycaster.intersectObjects(i)
                }
            }, {
                key: "onMouseMove",
                value: function(t) {
                    if (t.preventDefault(), void 0 !== t.offsetX && void 0 !== t.offsetY && !this.state.isDragging) {
                        if (this.mouse.x = t.offsetX / this.renderer.domElement.clientWidth * 2 - 1, this.mouse.y = -t.offsetY / this.renderer.domElement.clientHeight * 2 + 1, this.state.isDraggingSun || this.state.isDraggingMoon) {
                            var e = new Ju,
                                n = new Ju,
                                r = new Ju;
                            this.raycaster.setFromCamera(this.mouse, this.camera), this.raycaster.ray.intersectPlane(this.orbitPlane, e);
                            for (var i = this.celestialEquator.geometry, o = i.index, s = i.attributes.position, a = 1 / 0, l = new hc, u = 0, h = o.count; u < h; u += 3) {
                                var c = o.getX(u),
                                    d = o.getX(u + 1),
                                    p = o.getX(u + 2);
                                l.a.fromBufferAttribute(s, c), l.b.fromBufferAttribute(s, d), l.c.fromBufferAttribute(s, p), l.closestPointToPoint(e, r);
                                var f = e.distanceToSquared(r);
                                f < a && (n.copy(r), a = f)
                            }
                            var m = Math.atan2(n.y, n.x);
                            if (this.state.isDraggingSun) {
                                var g = this.props.observerAngle - m;
                                return this.props.onMoonAngleUpdate((this.props.moonAngle - g) % (2 * Math.PI)), this.props.onObserverAngleUpdate(m)
                            }
                            if (this.state.isDraggingMoon) {
                                var v = -m + this.props.observerAngle + Math.PI;
                                return v < -Math.PI ? v += 2 * Math.PI : v > Math.PI && (v -= 2 * Math.PI), this.props.onMoonAngleUpdate(v)
                            }
                        }
                        this.setState(this.initialState);
                        var _ = this.findMouseIntersects(t, this.mouse, this.camera, this.raycaster);
                        if (_.length > 0 && _[0].object) {
                            var y = "pointerover" + _[0].object.name;
                            this.setState(function(t, e, n) {
                                return e in t ? Object.defineProperty(t, e, {
                                    value: true,
                                    enumerable: !0,
                                    configurable: !0,
                                    writable: !0
                                }) : t[e] = true, t
                            }({}, y))
                        }
                    }
                }
            }, {
                key: "onMouseDown",
                value: function(t) {
                    t.preventDefault();
                    var e = this.findMouseIntersects(t, this.mouse, this.camera, this.raycaster, this.renderer);
                    if (e.length > 0) {
                        if (e[0].object) {
                            var n = e[0].object;
                            "Plane" !== n.name ? (this.controls.enabled = !1, "Sun" === n.name && this.setState({
                                isDraggingSun: !0
                            }), "Moon" === n.name && this.setState({
                                isDraggingMoon: !0
                            })) : this.setState({
                                isDragging: !0
                            })
                        }
                    } else this.setState({
                        isDragging: !0
                    })
                }
            }, {
                key: "onMouseUp",
                value: function(t) {
                    t.preventDefault(), this.controls.enabled = !0, this.setState({
                        isDragging: !1,
                        isDraggingSun: !1,
                        isDraggingMoon: !1
                    })
                }
            }, {
                key: "onResetClicked",
                value: function() {
                    this.controls.reset()
                }
            }]) && P_(n.prototype, r), Object.defineProperty(n, "prototype", {
                writable: !1
            }), a
        }(t.Component);
        N_.propTypes = {
            observerAngle: i().number.isRequired,
            onObserverAngleUpdate: i().func.isRequired,
            moonAngle: i().number.isRequired,
            onMoonAngleUpdate: i().func.isRequired,
            showAngle: i().bool.isRequired,
            isHidden: i().bool.isRequired,
            onHideShowToggle: i().func.isRequired
        };
        var D_ = n(87);

        function U_(t) {
            return (U_ = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function F_(t, e) {
            for (var n = 0; n < e.length; n++) {
                var r = e[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function B_(t, e) {
            return (B_ = Object.setPrototypeOf || function(t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function k_(t, e) {
            if (e && ("object" === U_(e) || "function" == typeof e)) return e;
            if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            return G_(t)
        }

        function G_(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }

        function H_(t) {
            return (H_ = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            })(t)
        }
        var z_ = function(e) {
                ! function(t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            writable: !0,
                            configurable: !0
                        }
                    }), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), e && B_(t, e)
                }(a, e);
                var n, r, i, o, s = (i = a, o = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                    } catch (t) {
                        return !1
                    }
                }(), function() {
                    var t, e = H_(i);
                    if (o) {
                        var n = H_(this).constructor;
                        t = Reflect.construct(e, arguments, n)
                    } else t = e.apply(this, arguments);
                    return k_(this, t)
                });

                function a(e) {
                    var n;
                    return function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, a), (n = s.call(this, e)).initialState = {
                        observerAngle: Math.PI / 2,
                        moonAngle: -Math.PI,
                        isPlaying: !1,
                        animationRate: 1,
                        showAngle: !1,
                        showLunarLandmark: !1,
                        showTimeTickmarks: !1,
                        celestialSphereIsHidden: !1,
                        moonPhaseViewIsHidden: !1
                    }, n.state = n.initialState, n.raf = null, n.synodicPeriod = 29.530589, n.handleInputChange = n.handleInputChange.bind(G_(n)), n.onHideShowMoonPhaseToggle = n.onHideShowMoonPhaseToggle.bind(G_(n)), n.onHideShowCelestialSphereToggle = n.onHideShowCelestialSphereToggle.bind(G_(n)), n.stopAnimation = n.stopAnimation.bind(G_(n)), n.celestialSphereRef = t.createRef(), n
                }
                return n = a, (r = [{
                    key: "render",
                    value: function() {
                        var e = "Start Animation";
                        return this.state.isPlaying && (e = "Pause Animation"), t.createElement(t.Fragment, null, t.createElement("nav", {
                            className: "navbar navbar-expand-md navbar-light bg-light d-flex justify-content-between"
                        }, t.createElement("span", {
                            className: "navbar-brand mb-0 h1"
                        }, "Lunar Phase Simulator"), t.createElement("ul", {
                            className: "navbar-nav"
                        }, t.createElement("li", {
                            className: "nav-item"
                        }, t.createElement("a", {
                            className: "nav-link",
                            href: "#",
                            onClick: this.onResetClick.bind(this)
                        }, "Reset")), t.createElement("li", {
                            className: "nav-item"
                        }, t.createElement("a", {
                            className: "nav-link",
                            href: "#",
                            "data-toggle": "modal",
                            "data-target": "#helpModal"
                        }, "Help")), t.createElement("li", {
                            className: "nav-item"
                        }, t.createElement("a", {
                            className: "nav-link",
                            href: "#",
                            "data-toggle": "modal",
                            "data-target": "#aboutModal"
                        }, "About")))), t.createElement("div", {
                            className: "row mt-2"
                        }, t.createElement("div", {
                            className: "col-8"
                        }, t.createElement(El, {
                            observerAngle: this.state.observerAngle,
                            moonAngle: this.state.moonAngle,
                            showAngle: this.state.showAngle,
                            showLunarLandmark: this.state.showLunarLandmark,
                            showTimeTickmarks: this.state.showTimeTickmarks,
                            onObserverAngleUpdate: this.onObserverAngleUpdate.bind(this),
                            onMoonAngleUpdate: this.onMoonAngleUpdate.bind(this),
                            stopAnimation: this.stopAnimation
                        }), t.createElement("div", {
                            className: "row"
                        }, t.createElement("div", {
                            className: "col"
                        }, t.createElement("h4", null, "Animation and Time Controls"), t.createElement("button", {
                            type: "button",
                            className: "btn btn-primary btn-sm",
                            onClick: this.onStartClick.bind(this)
                        }, e), t.createElement("form", {
                            className: "form-inline"
                        }, t.createElement("label", {
                            htmlFor: "diamRange"
                        }, "Animation rate:"), t.createElement(D_.RangeStepInput, {
                            name: "animationRate",
                            className: "form-control-range ml-2",
                            value: this.state.animationRate,
                            onChange: this.onAnimationRateChange.bind(this),
                            step: .1,
                            min: .1,
                            max: 5
                        }))), t.createElement("div", {
                            className: "col"
                        }, "Increment animation:", t.createElement("form", {
                            className: "form container increment-area"
                        }, t.createElement("div", {
                            className: "row"
                        }, t.createElement("div", {
                            className: "col"
                        }, t.createElement("div", {
                            className: "form-group text-right"
                        }, t.createElement("label", null, "Day:")), t.createElement("div", {
                            className: "form-group text-right"
                        }, t.createElement("label", null, "Hour:")), t.createElement("div", {
                            className: "form-group text-right"
                        }, t.createElement("label", null, "Minute:"))), t.createElement("div", {
                            className: "col"
                        }, t.createElement("div", {
                            className: "form-group"
                        }, t.createElement("button", {
                            type: "button",
                            onClick: this.onDecrementDay.bind(this),
                            className: "btn btn-outline-primary btn-sm"
                        }, "-"), t.createElement("button", {
                            type: "button",
                            onClick: this.onIncrementDay.bind(this),
                            className: "btn btn-outline-primary btn-sm ml-1"
                        }, "+")), t.createElement("div", {
                            className: "form-group"
                        }, t.createElement("button", {
                            type: "button",
                            onClick: this.onDecrementHour.bind(this),
                            className: "btn btn-outline-primary btn-sm"
                        }, "-"), t.createElement("button", {
                            type: "button",
                            onClick: this.onIncrementHour.bind(this),
                            className: "btn btn-outline-primary btn-sm ml-1"
                        }, "+")), t.createElement("div", {
                            className: "form-group"
                        }, t.createElement("button", {
                            type: "button",
                            onClick: this.onDecrementMinute.bind(this),
                            className: "btn btn-outline-primary btn-sm"
                        }, "-"), t.createElement("button", {
                            type: "button",
                            onClick: this.onIncrementMinute.bind(this),
                            className: "btn btn-outline-primary btn-sm ml-1"
                        }, "+")))))), t.createElement("div", {
                            className: "col"
                        }, t.createElement("h4", null, "Diagram Options"), t.createElement("div", {
                            className: "custom-control custom-checkbox"
                        }, t.createElement("input", {
                            type: "checkbox",
                            className: "custom-control-input",
                            name: "showAngle",
                            onChange: this.handleInputChange,
                            checked: this.state.showAngle,
                            id: "showAngleToggle"
                        }), t.createElement("label", {
                            className: "custom-control-label",
                            htmlFor: "showAngleToggle"
                        }, "Show angle")), t.createElement("div", {
                            className: "custom-control custom-checkbox"
                        }, t.createElement("input", {
                            type: "checkbox",
                            className: "custom-control-input",
                            name: "showLunarLandmark",
                            onChange: this.handleInputChange,
                            checked: this.state.showLunarLandmark,
                            id: "showLunarLandmarkToggle"
                        }), t.createElement("label", {
                            className: "custom-control-label",
                            htmlFor: "showLunarLandmarkToggle"
                        }, "Show lunar landmark")), t.createElement("div", {
                            className: "custom-control custom-checkbox"
                        }, t.createElement("input", {
                            type: "checkbox",
                            className: "custom-control-input",
                            name: "showTimeTickmarks",
                            onChange: this.handleInputChange,
                            checked: this.state.showTimeTickmarks,
                            id: "showTimeTickmarksToggle"
                        }), t.createElement("label", {
                            className: "custom-control-label",
                            htmlFor: "showTimeTickmarksToggle"
                        }, "Show time tickmarks"))))), t.createElement("div", {
                            className: "col-4"
                        }, t.createElement("div", null, t.createElement("h4", null, "Moon Phase"), t.createElement(Rl, {
                            isHidden: this.state.moonPhaseViewIsHidden,
                            onHideShowToggle: this.onHideShowMoonPhaseToggle,
                            showLunarLandmark: this.state.showLunarLandmark,
                            moonAngle: this.state.moonAngle,
                            onMoonAngleUpdate: this.onMoonAngleUpdate.bind(this)
                        })), t.createElement("div", null, t.createElement("h4", null, "Horizon Diagram"), t.createElement(N_, {
                            ref: this.celestialSphereRef,
                            isHidden: this.state.celestialSphereIsHidden,
                            onHideShowToggle: this.onHideShowCelestialSphereToggle,
                            observerAngle: this.state.observerAngle,
                            onObserverAngleUpdate: this.onObserverAngleUpdate.bind(this),
                            moonAngle: this.state.moonAngle,
                            onMoonAngleUpdate: this.onMoonAngleUpdate.bind(this),
                            showAngle: this.state.showAngle
                        })))))
                    }
                }, {
                    key: "incrementAngle",
                    value: function(t, e) {
                        var n = t + e;
                        return n > 2 * Math.PI ? n - 2 * Math.PI : n
                    }
                }, {
                    key: "decrementAngle",
                    value: function(t, e) {
                        var n = t - e;
                        return n < 0 ? n + 2 * Math.PI : n
                    }
                }, {
                    key: "incrementMoonAngle",
                    value: function(t, e) {
                        var n = t + e;
                        return n > Math.PI ? n - 2 * Math.PI : n
                    }
                }, {
                    key: "decrementMoonAngle",
                    value: function(t, e) {
                        var n = t - e;
                        return n < -Math.PI ? n + 2 * Math.PI : n
                    }
                }, {
                    key: "animate",
                    value: function() {
                        var t = this,
                            e = this;
                        this.setState((function(n) {
                            return {
                                observerAngle: e.incrementAngle(n.observerAngle, .03 * t.state.animationRate),
                                moonAngle: e.incrementMoonAngle(n.moonAngle, .001 * t.state.animationRate)
                            }
                        })), this.raf = requestAnimationFrame(this.animate.bind(this))
                    }
                }, {
                    key: "onStartClick",
                    value: function() {
                        this.state.isPlaying ? (this.stopAnimation(), this.setState({
                            isPlaying: !1
                        })) : (this.raf = requestAnimationFrame(this.animate.bind(this)), this.setState({
                            isPlaying: !0
                        }))
                    }
                }, {
                    key: "onObserverAngleUpdate",
                    value: function(t) {
                        this.stopAnimation(), this.setState({
                            isPlaying: !1,
                            observerAngle: t
                        })
                    }
                }, {
                    key: "onMoonAngleUpdate",
                    value: function(t) {
                        this.stopAnimation(), this.setState({
                            isPlaying: !1,
                            moonAngle: t
                        })
                    }
                }, {
                    key: "onAnimationRateChange",
                    value: function(t) {
                        this.setState({
                            animationRate: cl(t.target.value)
                        })
                    }
                }, {
                    key: "getMoonObserverPos",
                    value: function(t, e) {
                        return t + Math.PI - e
                    }
                }, {
                    key: "onDecrementDay",
                    value: function() {
                        var t = this.decrementAngle(this.state.observerAngle, dl(360)),
                            e = this.decrementMoonAngle(this.state.moonAngle, 2 * Math.PI / this.synodicPeriod);
                        this.setState({
                            observerAngle: t,
                            moonAngle: e
                        })
                    }
                }, {
                    key: "onIncrementDay",
                    value: function() {
                        var t = this.incrementAngle(this.state.observerAngle, dl(360)),
                            e = this.incrementMoonAngle(this.state.moonAngle, 2 * Math.PI / this.synodicPeriod);
                        this.setState({
                            observerAngle: t,
                            moonAngle: e
                        })
                    }
                }, {
                    key: "onDecrementHour",
                    value: function() {
                        var t = this.decrementAngle(this.state.observerAngle, dl(15)),
                            e = this.decrementMoonAngle(this.state.moonAngle, 2 * Math.PI / this.synodicPeriod / 24);
                        this.setState({
                            observerAngle: t,
                            moonAngle: e
                        })
                    }
                }, {
                    key: "onIncrementHour",
                    value: function() {
                        var t = this.incrementAngle(this.state.observerAngle, dl(15)),
                            e = this.incrementMoonAngle(this.state.moonAngle, 2 * Math.PI / this.synodicPeriod / 24);
                        this.setState({
                            observerAngle: t,
                            moonAngle: e
                        })
                    }
                }, {
                    key: "onDecrementMinute",
                    value: function() {
                        var t = this.decrementAngle(this.state.observerAngle, dl(.25)),
                            e = this.decrementMoonAngle(this.state.moonAngle, 2 * Math.PI / (24 * this.synodicPeriod) / 60);
                        this.setState({
                            observerAngle: t,
                            moonAngle: e
                        })
                    }
                }, {
                    key: "onIncrementMinute",
                    value: function() {
                        var t = this.incrementAngle(this.state.observerAngle, dl(.25)),
                            e = this.incrementMoonAngle(this.state.moonAngle, 2 * Math.PI / (24 * this.synodicPeriod) / 60);
                        this.setState({
                            observerAngle: t,
                            moonAngle: e
                        })
                    }
                }, {
                    key: "handleInputChange",
                    value: function(t) {
                        var e = t.target,
                            n = "checkbox" === e.type ? e.checked : e.value,
                            r = e.name;
                        this.setState(function(t, e, n) {
                            return e in t ? Object.defineProperty(t, e, {
                                value: n,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : t[e] = n, t
                        }({}, r, n))
                    }
                }, {
                    key: "stopAnimation",
                    value: function() {
                        cancelAnimationFrame(this.raf)
                    }
                }, {
                    key: "onResetClick",
                    value: function(t) {
                        t.preventDefault(), this.stopAnimation(), this.setState(this.initialState), this.celestialSphereRef && this.celestialSphereRef.current && this.celestialSphereRef.current.onResetClicked()
                    }
                }, {
                    key: "onHideShowMoonPhaseToggle",
                    value: function() {
                        this.setState({
                            moonPhaseViewIsHidden: !this.state.moonPhaseViewIsHidden
                        })
                    }
                }, {
                    key: "onHideShowCelestialSphereToggle",
                    value: function() {
                        this.setState({
                            celestialSphereIsHidden: !this.state.celestialSphereIsHidden
                        })
                    }
                }]) && F_(n.prototype, r), Object.defineProperty(n, "prototype", {
                    writable: !1
                }), a
            }(t.Component),
            V_ = document.querySelector("#sim-container");
        e.render(t.createElement(z_, null), V_)
    })()
})();